<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IIR滤波器设计</title>
      <link href="/Blog_ButterFly/2024/06/13/IIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/Blog_ButterFly/2024/06/13/IIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IIR（Infinite Impulse Response）数字滤波器是指无限长冲激响应数字滤波器，因其具有良好的幅频响应特性，被广泛应用于通信、控制、生物医学、振动分析、雷达和声呐等领域</p><p>IIR滤波器的设计可以通过设计一个模拟滤波器，进而利用脉冲响应不变法或者双线性变换法来进行数字滤波器的设计。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>通常利用模拟滤波器的理论和设计方法来设计 IIR 数字滤波器。设计过程是：先根据技术指标要求设计出一个相应的模拟低通滤波器，得到模拟低通滤波器的传递函数 $H(s)$ ，然后再按照一定的转换关系将设计好的模拟滤波器的传递函数转换为数字滤波器的系统函数 $H(z)$ 。转换方法有两种：脉冲响应不变法和双线性映射法</p><p>利用模拟滤波器设计数字滤波器，就是从已知的模拟滤波器传递函数 $H(s)$ 设计数字滤波器传递函数 $H(z)$ ，这是一个由 s 平面到 z 平面的映射变换，这种映射变换应该遵循两个基本原则</p><ul><li>$H(z)$ 的频响要能模仿 $H(s)$ 的频响，即 s 平面的虚轴应该能映射到 z 平面的单位圆 $e^{j\omega}$ 上</li><li>$H(s)$ 的因果稳定性映射到 $H(z)$ 之后保持不变，即 s 平面从左半平面 $Re(s)&lt;0$ 映射到 z 平面的单位圆内 $|z|&lt;1$</li></ul><h2 id="脉冲响应不变法"><a href="#脉冲响应不变法" class="headerlink" title="脉冲响应不变法"></a>脉冲响应不变法</h2><p>利用模拟滤波器理论设计数字滤波器，也就是使得数字滤波器能模仿模拟滤波器的特性，这种模仿可以从不同的角度出发。脉冲响应不变法就是从滤波器的脉冲响应出发，使数字滤波器的单位脉冲响应序列 $h(n)$ 模仿模拟滤波器的冲击响应 $h_c(t)$ ，使 $h(n)$ 正好等于 $h_c(t)$ 的采样值，也就是</p><script type="math/tex; mode=display">h[n]=h_c(nT_s)</script><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>时域信号： $h_c(t)$</p><p>脉冲信号： $s(t)=\sum_{n=-\infty}^{\infty}\delta(t-nT_s)$</p><p>采样时的时域信号： $h_s(t)=h_c(t)s(t)$</p><p>采样得到的信号： $h[n]=h_c(t)|_{t=nT_s}=h_c(nT_s)$</p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><script type="math/tex; mode=display">h_s(t)=h_c(t)s(t)=h_c(t)\sum_{n=-\infty}^{+\infty}\delta(t-nT_s)</script><p>对上式做 $laplace$ 变换</p><script type="math/tex; mode=display">H_s(s)=\int_{-\infty}^{+\infty}h_c(t)\sum_{n=-\infty}^{+\infty}\delta(t-nT_s)e^{-st}dt\\=\sum_{n=-\infty}^{+\infty}\int_{-\infty}^{+\infty}h_c(t)\delta(t-nT_s)e^{-st}dt\\=\sum_{n=-\infty}^{+\infty}h_c(nT_s)e^{-snT_s}</script><p>$h(n)$ 的 z 变换为</p><script type="math/tex; mode=display">H(z)=\sum_{n=-\infty}^{+\infty}h[n]z^{-n}</script><p>对比上述的 $H_s(s)$ 和 $H(z)$ 可以看出，它们两个之间的转换关系为</p><script type="math/tex; mode=display">z=e^{-sT_s}</script><p>则 $\omega$ 与 $\Omega$ 之间的转换关系为</p><script type="math/tex; mode=display">\Omega=\frac{\omega}{T_s}</script><p>采用脉冲响应不变法将模拟滤波器变换为数字滤波器时，它所完成的 s 平面到 z 平面的变换，正式从 $laplace$ 变换到 z 变换的标准变换关系，即首先对 $H_c(s)$ 做周期延拓，然后再经过 $z=e^{sT}$ 映射关系映射到 z 平面上</p><p>该映射关系表明，s 平面上的每一条 $\frac{2\pi}{T}$ 的横带部分，都将重叠地映射到 z 平面的全部平面上。每个横带在左半部分映射到 z 平面单位圆之内，每个横带的右半部分映射到 z 平面的单位圆以外， $j\Omega$ 轴映射到单位圆上，但是 $j\Omega$ 轴上每一段 $\frac{2\pi}{T}$ 都对应于绕单位圆一周。则相应的频率变换关系为 $\omega=\Omega T_s$ ，显然 $\omega$ 与 $\Omega$ 为线性关系。其中 $\omega$ 为数字域频率， $\Omega$ 为模拟域频率</p><p>该关系式反映的是 $H_c(s)$ 的周期延拓与 $H(z)$ 的关系，而不是 $H_c(s)$ 本身与 $H(z)$ 的关系，因此，在使用脉冲响应不变法时，从 $H_c(s)$ 到 $H(z)$ 并没有一个由 s 平面到 z 平面的简单代数映射关系，即没有一个 $s=f(z)$ 的代数关系式</p><p>数字滤波器的频响不是简单地重现模拟滤波器的频响，而是模拟滤波器频响的周期延拓，周期为 $\Omega_s=\frac{2\pi}{T_s}=2\pi f_s$ ，即</p><script type="math/tex; mode=display">H(e^{j\omega})=\frac{1}{T_s}\sum_{n=-\infty}^{\infty}H_c(j\Omega+j\frac{2\pi m}{T})</script><p>根据香农采样定律，如果模拟滤波器的频响带限于折叠频率的 $\frac{\Omega_s}{2}$ 之内，即</p><script type="math/tex; mode=display">H_c(j\Omega)=0\quad |\Omega|\geq \frac{\pi}{T_s}</script><p>这时数字滤波器的频响才能不失真地重现模拟滤波器地频响（在折叠频率以内）</p><script type="math/tex; mode=display">H(e^{j\omega})=\frac{1}{T}H_c(j\frac{\omega}{T})\quad|\omega|<\pi</script><p>任何一个实际的模拟滤波器，其频响都不可能时真正带限的，因此不可避免地存在频谱地交叠，即频谱混淆，这时数字滤波器的频响将不同于原模拟滤波器的频响而带来一定的失真。模拟滤波器频响在折叠频率以上衰减越大，失真则越小，这时采用脉冲响应不变法设计的数字滤波器才能有更好的效果</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>频谱交叠产生的混淆，这时从 s 平面到 z 平面的标准变换 $z=e^{sT}$ 的多值对应关系导致的</p><h3 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2d(sys,T,<span class="string">&#x27;z&#x27;</span>)；</span><br></pre></td></tr></table></figure><h2 id="双线性变换法"><a href="#双线性变换法" class="headerlink" title="双线性变换法"></a>双线性变换法</h2><h3 id="推导-1"><a href="#推导-1" class="headerlink" title="推导"></a>推导</h3><p>为了克服脉冲响应不变法的缺点，设想变换分为两步：</p><ol><li>将整个 s 平面压缩到 s1 平面的一条横带上</li><li>通过标准变换将此横带变换到整个 z 平面上去</li></ol><p>由此建立的 s 平面与 z 平面的一一对应的单值关系，消除了多值性，也就消除了混淆现象。为了将 s 平面的 $j\Omega$ 轴压缩到 s1 平面的 $j\Omega$ 轴上的 $-\frac{\pi}{T_s}\sim \frac{\pi}{T_s}$ 一段上，可以通过以下正切变换实现</p><script type="math/tex; mode=display">\Omega=C\times \tan(\frac{\Omega_1T_s}{2})</script><p>此处 $C$ 为待定系数，通常可以选取为 $C=\frac{2}{T_s}$ 。用不同的方法确定 $C$ 可以使得模拟滤波器频率特性与数字滤波器的频率特性在不同的频率点有对应关系</p><p>经过这个变换之后，当 $\Omega_1$ 在 $-\frac{\pi}{T_s}\sim \frac{\pi}{T_s}$ 段变化时， $\Omega$ 在 $-\infty\sim\infty$ 之间变动，映射了整个 $j\Omega$ 轴，这一解析关系延拓到整个 s 平面，即得到 s 平面向 s1 平面的映射关系</p><script type="math/tex; mode=display">s=C\times \tan(\frac{s_1T}{2})\\=C\times\frac{\sin\frac{s_1T}{2}}{\cos\frac{s_1T}{2}}\\=C\times\frac{e^{j\frac{s_1T}{2}}-e^{-j\frac{s_1T}{2}}}{e^{j\frac{s_1T}{2}}+e^{-j\frac{s_1T}{2}}}\\=C\times\frac{1-e^{-js_1T}}{1+e^{-js_1T}}</script><p>再将 s1 平面通过标准变换映射到 z 平面，也就是</p><script type="math/tex; mode=display">z=e^{sT}</script><p>最后得到 s 平面到 z 平面的单值映射关系如下</p><script type="math/tex; mode=display">\left\{\begin{aligned}&s=\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}}\\&z=\frac{1+\frac{T}{2}s}{1-\frac{T}{s}s}\end{aligned}\right.</script><p>这就是双线性变换</p><ul><li>第一次是将 $\Omega$ 从 $+\infty$ 变换到 $\frac{\pi}{T}$ ，从 $-\infty$ 变换到 $-\frac{\pi}{T}$</li><li>第二次是将 S 域的左半平面映射到 Z 域的单位圆内</li></ul><p>变换过程如图所示</p><p><img src="/Blog_ButterFly/2024/06/13/IIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/20210809170655235.png" alt="20210809170655235.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>不存在频率混叠，由于 s 平面与 z 平面一一单值对应，s 平面的虚轴 $j\Omega$ 对应于 z 平面单位圆的一周，s 平面的 $\Omega=0$ 对应于 z 平面的 $\omega=0$ ， $\Omega=\plusmn\infty$ 对应于 z 平面的 $\omega=\plusmn\pi$ ，即数字滤波器的频率响应终止于折叠频率处，所以双线性变换不存在频谱混叠效应</p><p>靠频率的严重非线性关系得到 s 平面与 z 平面的单值一一对应关系，整个 $j\Omega$ 轴单值对应于单位圆一周，这个频率关系是 $\Omega=C\times\tan(\frac{\omega}{2})$ ，其中 $\omega$ 和 $\Omega$ 为非线性关系</p><p>在 0 频率附近， $\omega$ 和 $\Omega$ 接近于线性关系，当 $\Omega$ 进一步增加时， $\omega$ 增长变得缓慢。当 $\Omega\rightarrow \infty$ 时， $\omega=\pi$ ， $\omega$ 终止于折叠频率处。所以双线性变换不会出现由于高频部分超过折叠频率而混淆低频部分的现象</p><p><img src="/Blog_ButterFly/2024/06/13/IIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/1718202504754.png" alt="1718202504754.png"></p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>由于 $\omega$ 与 $\Omega$ 之间的非线性关系，导致数字滤波器的幅频响应相对于模拟器的幅频响应有畸变。对于一个模拟微分器，它的幅值与频率时线性关系，但是经过双线性变换之后，不能得到数字微分器。另外，一个线性相位的模拟滤波器经过双线性变换之后，滤波器就失去了原有的线性相位特征。</p><p>但是，大多数滤波器都有分段常数的频响特性，如低通，高通，带通和带阻等，它们在通带内需要一个衰减为 0 的常数特性，在阻带部分需要一个逼近一个衰减为 $\infty$ 的常数特性，这种滤波器经过双线性变换之后，虽然频率发生了非线性的变化，但是幅值仍旧保持分段常数特性</p><h3 id="matlab代码-1"><a href="#matlab代码-1" class="headerlink" title="matlab代码"></a>matlab代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2d(sys, T, <span class="string">&#x27;tustin&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>利用 matlab 来设计对应的滤波器</p><h3 id="贝塞尔"><a href="#贝塞尔" class="headerlink" title="贝塞尔"></a>贝塞尔</h3><p><strong>整体设计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">[b,a] = besself(n,Wn,options)</span><br><span class="line">[z,p,k] = besself(n,Wn,options)</span><br><span class="line">[A,B,C,D] = besself(n,Wn,options)</span><br></pre></td></tr></table></figure><h3 id="巴特沃斯"><a href="#巴特沃斯" class="headerlink" title="巴特沃斯"></a>巴特沃斯</h3><p><strong>阶数估计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[n,Wn] = buttord(Wp,Ws,Rp,Rs)</span><br></pre></td></tr></table></figure><p><strong>整体设计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[b,a] = butter(n,Wn,options)</span><br><span class="line">[z,p,k] = butter(n,Wn,options)</span><br><span class="line">[A,B,C,D] = butter(n,Wn,options)</span><br></pre></td></tr></table></figure><h3 id="切比雪夫-I-型"><a href="#切比雪夫-I-型" class="headerlink" title="切比雪夫 I 型"></a>切比雪夫 I 型</h3><p><strong>阶数估计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[n,Wn] = cheb1ord(Wp,Ws,Rp,Rs)</span><br></pre></td></tr></table></figure><p><strong>整体设计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[b,a] = cheby1(n,Rp,Wn,options)</span><br><span class="line">[z,p,k] = cheby1(n,Rp,Wn,options)</span><br><span class="line">[A,B,C,D] = cheby1(n,Rp,Wn,options)</span><br></pre></td></tr></table></figure><h3 id="切比雪夫-II-型"><a href="#切比雪夫-II-型" class="headerlink" title="切比雪夫 II 型"></a>切比雪夫 II 型</h3><p><strong>阶数估计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[n,Wn] = cheb2ord(Wp,Ws,Rp,Rs)</span><br></pre></td></tr></table></figure><p><strong>整体设计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[b,a] = cheby2(n,Rs,Wn,options)</span><br><span class="line">[z,p,k] = cheby2(n,Rs,Wn,options)</span><br><span class="line">[A,B,C,D] = cheby2(n,Rs,Wn,options)</span><br></pre></td></tr></table></figure><h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p><strong>阶数估计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[n,Wn] = ellipord(Wp,Ws,Rp,Rs)</span><br></pre></td></tr></table></figure><p><strong>整体设计</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[b,a] = ellip(n,Rp,Rs,Wn,options)</span><br><span class="line">[z,p,k] = ellip(n,Rp,Rs,Wn,options)</span><br><span class="line">[A,B,C,D] = ellip(n,Rp,Rs,Wn,options)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
            <tag> IIR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言可变参数的原理及实现</title>
      <link href="/Blog_ButterFly/2024/06/04/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/Blog_ButterFly/2024/06/04/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用过 C 语言的人都会知道 <code>printf</code> 函数，它的参数中有固定参数 <code>format</code> 和可变参数 <code>...</code> ，那 <code>format</code> 后面的参数个数不确定，类型也不确定，这些参数都存放在栈中。在 <code>format</code> 中在特定的位置指定对应可变参数的类型，也就是根据 <code>format</code> 里的格式依次将数据取出</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>所有可变参数都存放在栈中。在 <code>format</code> 中在特定的位置指定对应可变参数的类型，也就是根据 <code>format</code> 里的格式依次将数据取出。而取出的动作需要用到 <code>va_arg</code> <code>va_list</code> <code>va_end</code> 这些宏定义，而且取出可变参数的时候，就相当于是指针指向栈中存放数据的位置，然后将指针不断移动来取出数据。</p><p>所以就需要对应着可变参数的数量，一定要注意，一旦出现可变参数数量不对应的情况，那就会产生 <code>crash</code> ，主要还是由于参数的数量如果少于使用参数的数量时，就会导致访问栈内存溢出，从而导致 <code>crash</code></p><p>由于参数分为两个部分：固定参数和可变参数，至少需要有一个固定参数，可变参数的数量可以有多个，声明中使用 <code>...</code> 表示</p><h3 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * va_list;</span><br></pre></td></tr></table></figure><p>实际上就是一个指针，用来指向栈中获取参数</p><h3 id="va-start"><a href="#va-start" class="headerlink" title="va_start"></a>va_start</h3><p>开始获取参数，一般来说使用可变参数时，参数都会被存储在栈中，所以需要将可变参数指针指向栈中。但是一般来说，用户是没有办法访问到栈的，所以固定参数就发挥了作用，由于所有参数都保存在栈中，所以固定参数也是保存在栈中的，所以只要指针指向该固定参数那就是指向了栈。</p><p>当然还要考虑指向了栈的什么地方。由于 C 语言的传入参数的规则，当所有参数都被保存到栈中时，那它们压入战中的顺序就是从最后一个开始压栈直到第一个参数，所以第一个参数的地址是最低的，依次向上增长。</p><p>例如 <code>printf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) ap = (va_list) &amp;v</span></span><br></pre></td></tr></table></figure><h3 id="va-end"><a href="#va-end" class="headerlink" title="va_end"></a>va_end</h3><p>使得不能再指向有效地址了，也就是结束从栈中取出参数，所以这里相当于是把指向栈的指针直接指向 <code>null</code> 从而实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) ap = NULL</span></span><br></pre></td></tr></table></figure><h3 id="va-arg"><a href="#va-arg" class="headerlink" title="va_arg"></a>va_arg</h3><p>从栈中指定的位置中获取指定类型的参数，并且使得指针指向下一个参数。但是这里需要注意参数的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t) *((t *) (ap += 4) </span></span><br></pre></td></tr></table></figure><p>上述中 <code>ap += 4</code> 是存在于 32 位机器上的代码，对于 64 位的机器上，这里就需要 <code>ap += 8</code> 。这个是由于需要保证字节对齐的原因</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %s, %c&quot;</span>, <span class="number">23</span>, <span class="string">&quot;hello world&quot;</span>, <span class="string">&#x27;S&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/Blog_ButterFly/2024/06/04/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/IMG_20240604_194012.jpg" alt="IMG_20240604_194012.jpg"></p><p>这里存入到栈中的顺序和参数如下</p><p>由于 <code>va_start</code> 将指针 <code>ap</code> 指向了 <code>fmt</code> ，也就如图所示，之后取出参数的顺序是从低地址开始向上取出。这里面直接保存变量的值，但是需要注意对齐问题。对于 32 位机器上，就是以 4 字节对齐的，而在 64 位机器上是以 8 字节对齐的，这与上述的 <code>ap += 4</code> 和 <code>ap += 8</code> 是对应的</p><p>当然一定要注意，利用上述实现可变参数需要注意两个问题</p><ul><li>如何确认可变参数的数量</li><li>如何确认可变参数的类型</li></ul><h3 id="INTSIZEOF-n"><a href="#INTSIZEOF-n" class="headerlink" title="_INTSIZEOF(n)"></a>_INTSIZEOF(n)</h3><p>获取数据类型的大小，这个函数会注意到对齐的问题。但是对于 32 位机器上，如果使用 <code>double</code> 等 64 位的数据类型的时候，这个 <code>ap += 4</code> 就会出问题，所以就需要一个专门用来实现这个情况的函数</p><p>先看要求：当数据类型是 <code>char, short, int, uint, float</code> 等小于等于 4 个字节的数据结构，这时候就可以直接按照 4 个字节对齐，但是对于 <code>double, long long int</code> 等 64 字节的数据结构，就需要按照 8 个字节对齐。所以这个函数实现的功能应当是 <code>1 &lt;= sizeof(n) &lt;= 4</code> 时返回 4，当 <code>5 &lt;= sizeof(n) &lt;= 8</code> 时返回 8。具体实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)) </span></span><br></pre></td></tr></table></figure><p>这里来验证一下</p><ul><li>1： <code>((1 + 3) &amp; ~(3)) = 4</code></li><li>2： <code>((2 + 3) &amp; ~(3)) = 4</code></li><li>4： <code>((4 + 3) &amp; ~(3)) = 4</code></li><li>8： <code>((8 + 3) &amp; ~(3)) = 8</code></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) ap = (va_list) (&amp;v + _INTSIZEOF(v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t) *((t *) (ap += _INTSIZEOF(n), ap - _INTSIZEOF(n)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) ap = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">itoa</span><span class="params">(uint32 val, <span class="type">char</span>** buf, uint32 base)</span> &#123;</span><br><span class="line"> uint32 m = val % base, i = val / base;</span><br><span class="line"> <span class="keyword">if</span> (i)</span><br><span class="line">  itoa(i, buf, base);</span><br><span class="line"> <span class="keyword">if</span> (m &lt; <span class="number">10</span>)</span><br><span class="line">  *((*buf)++) = m + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  *((*buf)++) = m + <span class="string">&#x27;A&#x27;</span> - <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint32 <span class="title function_">mysprintf</span><span class="params">(<span class="type">char</span>* s, <span class="type">const</span> <span class="type">char</span>* fmt, va_list ap)</span> &#123;</span><br><span class="line"> <span class="type">int</span>  i, c, n, argc;</span><br><span class="line"> <span class="type">float</span> f;</span><br><span class="line"> <span class="type">char</span> *str = s, *args;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; (c = fmt[i] &amp; <span class="number">0xff</span>) != <span class="number">0</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (c != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">   *(str++) = c;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> get_sign:</span><br><span class="line">  c = fmt[++i] &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">    n = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">    itoa(n, &amp;str, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">    n = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">    itoa(n, &amp;str, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">    n = va_arg(ap, uint32);</span><br><span class="line">    itoa(n, &amp;str, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> ((args = va_arg(ap, <span class="type">char</span>*)) == <span class="number">0</span>)</span><br><span class="line">     args = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; *args;) *(str++) = *(args++);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">    argc   = va_arg(ap, <span class="type">char</span>);</span><br><span class="line">    *(str++) = argc;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">    argc = va_arg(ap, <span class="type">float</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">    *(str++) = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    <span class="keyword">goto</span> get_sign;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    *(str++) = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    *(str++) = c;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> str - s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, ...)</span> &#123;</span><br><span class="line"> va_list ap;</span><br><span class="line"> va_start(ap, fmt);</span><br><span class="line"> <span class="type">char</span>  buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> uint32 len    = mysprintf(buf, fmt, ap);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(buf));</span><br><span class="line"> va_end(ap);</span><br><span class="line"> <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">  myprintf(<span class="string">&quot;%d, %s, %c&quot;</span>, <span class="number">23</span>, <span class="string">&quot;hello world&quot;</span>, <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可变参数的原理是直接将参数存入栈中，按照对齐的原理取出数据。但是这样也会带来一些问题，由于栈是存在于内存中的，从内存中读取数据会花费比较长的时间的，但是一般函数传入参数都是存放在寄存器中的，所以相对来说，可变参数的读取会花费比较多的时间</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AT&amp;T汇编基础语法</title>
      <link href="/Blog_ButterFly/2024/06/03/AT-T%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/Blog_ButterFly/2024/06/03/AT-T%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html">x86 Assembly Guide</a></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译汇编语言可以使用 GNU 编译器 <code>gcc</code> 和 汇编器 <code>as</code> 或者 <code>gas</code>。一个快速了解汇编语言的方式就是去看编译器输出的汇编程序。使用 <code>gcc -S a.c</code> 可以将 C 语言编译为汇编语言，就可以查看对应的汇编语言了。使用 <code>gcc a.s</code> 就可以把对应的的汇编语言编译为可执行文件了。使用 <code>gcc a.s -c</code> 或者 <code>as a.s</code> 可以将汇编语言编译为<strong>可重定位目标文件</strong></p><p>例如在 C 语言中经典的 hello world 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为汇编代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> .file <span class="string">&quot;a.c&quot;</span></span><br><span class="line"> .text</span><br><span class="line"> .section .rodata</span><br><span class="line">.LC0:</span><br><span class="line"> .<span class="built_in">string</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"> .text</span><br><span class="line"> .globl main</span><br><span class="line"> .type main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line"> .cfi_startproc</span><br><span class="line"> endbr64</span><br><span class="line"> pushq %rbp</span><br><span class="line"> .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line"> .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line"> movq %rsp, %rbp</span><br><span class="line"> .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line"> leaq .LC0(%rip), %rdi</span><br><span class="line"> movl $<span class="number">0</span>, %eax</span><br><span class="line"> call <span class="built_in">printf</span>@PLT</span><br><span class="line"> movl $<span class="number">0</span>, %eax</span><br><span class="line"> popq %rbp</span><br><span class="line"> .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line"> ret</span><br><span class="line"> .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line"> .size main, .-main</span><br><span class="line"> .ident <span class="string">&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0&quot;</span></span><br><span class="line"> .section .note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line"> .section .note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line"> .align <span class="number">8</span></span><br><span class="line"> .<span class="type">long</span>  <span class="number">1f</span> - <span class="number">0f</span></span><br><span class="line"> .<span class="type">long</span>  <span class="number">4f</span> - <span class="number">1f</span></span><br><span class="line"> .<span class="type">long</span>  <span class="number">5</span></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line"> .<span class="built_in">string</span>  <span class="string">&quot;GNU&quot;</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"> .align <span class="number">8</span></span><br><span class="line"> .<span class="type">long</span>  <span class="number">0xc0000002</span></span><br><span class="line"> .<span class="type">long</span>  <span class="number">3f</span> - <span class="number">2f</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"> .<span class="type">long</span>  <span class="number">0x3</span></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"> .align <span class="number">8</span></span><br><span class="line"><span class="number">4</span>:</span><br></pre></td></tr></table></figure><p>注意汇编程序由三个不同的元素组成</p><ul><li><strong>指示</strong>：以点号开始，用来指示对编译器，连接器，调试器有用的结构信息，指示本身不是汇编指令<ul><li><code>.byte</code> 可不带参数或者带多个表达式参数，表达式之间用逗号分隔，每个表达式参数都被汇编成一个字节</li><li><code>.short</code> 这个表达式表示任意一节中的一个或多个表达式（同样用逗号分开），表达式占一个字（两个字节）</li><li><code>ascii</code> 字符串，并且分配空间</li><li><code>.int</code> 整形，并且分配空间</li><li><code>.long</code> 长整型，并且分配空间</li><li><code>.file</code> 只是记录原始源文件名</li><li><code>.code16</code> 告诉编译器生成 16 位的指令</li><li><code>.data</code> 表示数据段的开始地址,</li><li><code>.text</code> 表示实际程序代码的起始</li><li><code>.string</code> 表示数据段中的字符串常量</li><li><code>.globl xxx</code> 指明标签 <code>xxx</code> 是一个可以在其它模块的代码中被访问的全局符号</li><li><code>.fill repeat, size, value</code> 其中 <code>repeat</code> ， <code>size</code> 和 <code>value</code> 都必须是纯粹的表达式。本命令生成 <code>size</code> 个字节的 <code>repeat</code> 个副本。 <code>repeat</code> 可以是 0 或更大的值。 <code>size</code> 可以是0或更大的值, 但即使 <code>size</code> 大于 8，也被视作 8，以兼容其它的汇编器。各个副本中的内容取自一个 8 字节长的数。最高 4 个字节为零，最低的 4 个字节是 <code>value</code> ，它以 <code>as</code> 正在汇编的目标计算机的整数字节顺序排列。每个副本中的 <code>size</code> 个字节都取值于这个数最低的 <code>size</code> 个字节。这个动作只是为了兼容其他的汇编器。 <code>size</code> 参数和 <code>value</code> 参数是可选的。默认 <code>value</code> 为 0， <code>size</code> 为 1</li></ul></li><li><strong>标签</strong>：以冒号结尾，用来把标签名和标签出现的位置关联起来。一般来说，以点号开始的标签都是编译器生成的临时局部标签，其它标签则是用户可见的函数和全局变量名称<ul><li><code>.LC0:</code> 表示紧接着的字符串的名称是 <code>.LC0</code></li><li><code>main:</code> 表示指令 <code>pushq %rbp</code> 是 <code>main</code> 函数的第一个指令</li></ul></li><li><strong>指令</strong>：实际的汇编代码一般都会缩进，以便和指示以及标签区分开来</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>intel</code> 汇编与 <code>AT&amp;T</code> 汇编语法不一致，由于笔者的电脑编</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>x86-64 将 x86 的 8 个 32 位通用寄存器扩展为 64 位，并且增加 8 个新的 64 位寄存器。调用寄存器操作数可以直接使用寄存器的名称即可，在 <code>AT&amp;T</code> 中需要在寄存器前加 <code>%</code> ，在 <code>intel</code> 语法中不需要</p><p><img src="/Blog_ButterFly/2024/06/03/AT-T%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/8600555f7fbc4f328a0072602c1f7fd7.png" alt="8600555f7fbc4f328a0072602c1f7fd7.png"></p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><div class="table-container"><table><thead><tr><th></th><th>64位</th><th>低32位</th><th>低16位</th><th>低8位</th><th>低16位的高8位</th><th>作用</th></tr></thead><tbody><tr><td>累加器</td><td>rax</td><td>eax</td><td>ax</td><td>al</td><td>ah</td><td>函数返回值</td></tr><tr><td>基址寄存器</td><td>rbx</td><td>ebx</td><td>bx</td><td>bl</td><td>bh</td><td>用作数据存储，遵循被调用者使用规则，随便用，调用子函数之前要备份它，以防他被修改</td></tr><tr><td>计数器</td><td>rcx</td><td>ecx</td><td>cx</td><td>cl</td><td>ch</td><td>函数第4参数</td></tr><tr><td>数据寄存器</td><td>rdx</td><td>edx</td><td>dx</td><td>dl</td><td>dh</td><td>函数第3参数</td></tr><tr><td>栈指针</td><td>rsp</td><td>esp</td><td>sp</td><td>spl</td><td></td><td>指向栈的栈顶</td></tr><tr><td>基址指针</td><td>rbp</td><td>ebp</td><td>bp</td><td>bpl</td><td></td><td>指向栈基</td></tr><tr><td>源地址索引</td><td>rsi</td><td>esi</td><td>si</td><td>sil</td><td></td><td>函数第2参数</td></tr><tr><td>目标地址索引</td><td>rdi</td><td>edi</td><td>di</td><td>dil</td><td></td><td>函数第1参数</td></tr><tr><td>通用寄存器</td><td>r8 - r15</td><td>r8d - r15d</td><td>r8w - r15w</td><td>r8l - r15l</td><td>r8h - r15h</td><td>r8 做函数第5参数</td></tr></tbody></table></div><p>r9 做函数第6参数<br>r12 - r15 用作数据存储，遵循被调用者使用规则，随便用，调用子函数之前要备份它，以防他被修改<br>r10 r11 用作数据存储，遵循调用者使用规则，就是使用之前要先保存原值 |</p><p>一般所说的十六个通用寄存器是因为早期版本的处理器每个寄存器都有其特殊用途，并不是所有指令都可以应用到每一个寄存器。随着设计的进展，新的指令和寻址模式被添加进来，使得很多寄存器变成了等同的。少数留下来的指令，特别是和字符串处理相关的，要求使用 <code>%rsi</code> 和 <code>%rdi</code> 。另外，两个寄存器被保留下来分别作为栈指针 ( <code>%rsp</code> ) 和基址指针 ( <code>%rbp</code> )。最后的 8 个寄存器是编号的并且没有特殊限制</p><p>计算机体系结构从原来的 8 位，扩展为现在的 64 位，每个寄存器内部都有一些内部结构</p><p><img src="/Blog_ButterFly/2024/06/03/AT-T%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/20171008192750274.png" alt="20171008192750274.png"></p><p><img src="/Blog_ButterFly/2024/06/03/AT-T%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/20171008193142962.png" alt="20171008193142962.png"></p><p>一般来说使用 64 位寄存器用来寻址和浮点数运算，而 32 位寄存器用来做整数计算</p><h3 id="其它寄存器"><a href="#其它寄存器" class="headerlink" title="其它寄存器"></a>其它寄存器</h3><p>在 x86 中还包含其它非通用的寄存器</p><div class="table-container"><table><thead><tr><th></th><th>64 位</th><th>32 位</th><th>作用</th></tr></thead><tbody><tr><td>程序寄存器</td><td>rip</td><td>eip</td><td>当于PC指针指向当前的指令地址，指向下一条要执行的指令</td></tr><tr><td>标志寄存器</td><td>rflag</td><td>eflag</td><td>状态寄存器</td></tr><tr><td>控制寄存器</td><td>cr0 - cr4</td><td></td><td>控制寄存器记录CPU运行过程中自身的一些关键信息</td></tr><tr><td>控制寄存器</td><td>cr8</td><td></td><td>用于获取当前的 irql 权限等级</td></tr></tbody></table></div><h2 id="x86-64-指令"><a href="#x86-64-指令" class="headerlink" title="x86-64 指令"></a>x86-64 指令</h2><p>x86指令通常的助记符形式为：目标地址，源地址。助记符是人类可读的机器指令表示，源地址和目标地址是指令的操作数。但是并非所有的指令都有两个操作数，有些指令甚至没有操作数</p><p><img src="/Blog_ButterFly/2024/06/03/AT-T%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/v2-d3a28b8439c00f3cbb3928f36e777fad_720w.png" alt="v2-d3a28b8439c00f3cbb3928f36e777fad_720w.png"></p><p>x86指令由可选前缀（prefix）、操作码（opcode）及零个或多个操作数（operand）组成</p><p>对于 x86 架构的机器指令语法格式主要有两种</p><ul><li><code>intel</code> 语法，目的操作数在前，源操作数在后</li><li><code>AT&amp;T</code> 语法，显式地在每个寄存器名称的前面加上 <code>%</code> 符号，每个常量前面加上 <code>$</code> 符号，目的操作数在后，源操作数在前</li></ul><p>在操作码之后会有后缀，用来表示操作数的位数，一般来说</p><ul><li><code>q</code> 表示 64 位</li><li><code>l</code> 代表 32 位</li><li><code>w</code> 代表 16 位</li><li><code>b</code> 代表 8 位</li></ul><h3 id="AT-amp-T常用的指令"><a href="#AT-amp-T常用的指令" class="headerlink" title="AT&amp;T常用的指令"></a>AT&amp;T常用的指令</h3><div class="table-container"><table><thead><tr><th></th><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>转移</td><td>mov src, dst</td><td>将数据从 src 移动到 dst</td></tr><tr><td>交换</td><td>xchg dst1, dst2</td><td>互换 dst1 和 dst2</td></tr><tr><td>压栈</td><td>push src</td><td>将 src 压入栈中，并且 rsp 减小</td></tr><tr><td>出栈</td><td>pop dst</td><td>将数据出栈，赋给 dst ，并且 rsp 增大</td></tr><tr><td>整数加法</td><td>add src, dst</td><td>将 src 加到 dst 上， dst +=  src ，结果存放到 dst 上</td></tr><tr><td>整数减法</td><td>sub src, dst</td><td>等于 dst -= src ，结果存放到 dst 上</td></tr><tr><td>自增</td><td>inc dst</td><td>等于 dst += 1 ，结果存放到 dst 上</td></tr><tr><td>自减</td><td>dec dst</td><td>等于 dst -= 1 ，结果存放到 dst 上</td></tr><tr><td>整数除法</td><td>idiv dst</td><td>将 rax 除以 dst ，商存放到 rax ，余数放在 rdx ，可以使用第三个操作数来作为商的存放位置</td></tr><tr><td>整数乘法</td><td>imul dst</td><td>将 rax 乘以 dst ，结果存放到 rax ，溢出部分放在 rdx ，可以使用第三个操作数来作为结果的存放位置</td></tr><tr><td>比较</td><td>cmp src1, src2</td><td>比较 src1 和 src2 ，根据结果设置 CPU 的状态寄存器</td></tr><tr><td>无条件跳转</td><td>jmp label</td><td>跳转到 label</td></tr><tr><td>条件跳转</td><td>je label</td><td>相等跳转到 label</td></tr><tr><td>条件跳转</td><td>jne label</td><td>不相等跳转到 label</td></tr><tr><td>条件跳转</td><td>jl label</td><td>小于跳转到 label</td></tr><tr><td>条件跳转</td><td>jg label</td><td>大于跳转到 label</td></tr><tr><td>函数调用</td><td>call label</td><td>调用函数 label</td></tr><tr><td>系统调用</td><td>syscall</td><td>系统调用</td></tr><tr><td>加载有效地址</td><td>lea src, dst</td><td>从 src 所指示的地址中的数据加载到 dst 中</td></tr><tr><td>按位逻辑与</td><td>and src1, src2</td><td>执行按位逻辑与操作，结果存放到 src2 中</td></tr><tr><td>按位逻辑或</td><td>or src1, src2</td><td>执行按位逻辑或操作，结果存放到 src2 中</td></tr><tr><td>按位逻辑异或</td><td>xor src1, src2</td><td>执行按位逻辑异或操作，结果存放到 src2 中</td></tr><tr><td>按位逻辑非</td><td>not src</td><td>反转 src 中所有位</td></tr><tr><td>按位取反</td><td>neg dst</td><td>对操作数内容执行二进制补码求反</td></tr><tr><td>左移</td><td>shl src1, src2</td><td>向左和向右移动它们第一个操作数的内容，用零填充得到的空位位置。移动操作最多 31 次。由第二个操作数指定要移动的位的数量，要么是一个 8 位常数要么由寄存器 CL 指定。这两种情况下大于 31 次移动将会模除 32</td></tr><tr><td>右移</td><td>shr src1, src2</td><td>向左和向右移动它们第一个操作数的内容，用零填充得到的空位位置。移动操作最多 31 次。由第二个操作数指定要移动的位的数量，要么是一个 8 位常数要么由寄存器 CL 指定。这两种情况下大于 31 次移动将会模除 32</td></tr><tr><td>返回</td><td>ret</td><td>首先将返回地址出栈，然后执行无条件跳转至取出的代码位置处</td></tr></tbody></table></div><p><strong>标签查找</strong></p><p>对于用到标签的，如果代码中有多个同名标签，需要查找某一个标签，就在调用指令使用这个标签时在标签名之后添加后缀 <code>f</code> 或者 <code>b</code></p><ul><li><code>f</code> 表示向上查找，使用找到的第一个</li><li><code>b</code> 表示向下查找，使用找到的第一个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1:</span><br><span class="line"> jmp 1b ; 跳转到后面的 1</span><br><span class="line"> jmp 1f ; 跳转到前面的 1</span><br><span class="line">1:</span><br></pre></td></tr></table></figure><p><strong>寄存器清零</strong></p><p>有两种方式</p><ul><li><code>and 0x00, %rax</code></li><li><code>xor %rax, %rax</code></li></ul><p>相比较来说，异或操作执行效率更改</p><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>指令有3种不同类型的操作数：寄存器操作数、内存操作数及立即数</p><h3 id="寄存器操作数"><a href="#寄存器操作数" class="headerlink" title="寄存器操作数"></a>寄存器操作数</h3><p>寄存器非常小，可以快速访问位于CPU的存储器。但是某些寄存器有特殊用途，其它寄存器就是通用存储单元，用来存储 CPU 执行程序时所用到的变量。</p><p>调用寄存器操作数可以直接使用寄存器的名称即可，在 <code>AT&amp;T</code> 中需要在寄存器前加 <code>%</code> ，在 <code>intel</code> 语法中不需要</p><h3 id="内存操作数"><a href="#内存操作数" class="headerlink" title="内存操作数"></a>内存操作数</h3><p>内存操作数指的是一个内存地址，CPU 在这个地址获取单个或多字节，但是在 x86 中，每条指令中只支持一个显式内存操作数，也就是说不能在一条指令中直接将一个值从一个内存地址移动到另一个内存地址，必须使用寄存器作为中间存储</p><p>可以使用 <code>[ base + index * scale + displacement ]</code> 来指定内存操作数，而在 <code>AT&amp;T</code> 中，应该使用 <code>()</code> 代替 <code>[]</code> ，而且语法也不同，使用 <code>displacement(base, index, scale)</code> 。其中</p><ul><li><code>base</code> 是 64 位寄存器，基址</li><li><code>index</code> 64 位寄存器数，索引寄存器</li><li><code>scale</code> 比例，是1，2，4，8的整数值</li><li><code>displacement</code> 偏移，是 32 位常量或者符号</li></ul><h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><p>立即数就是指令中硬编码的常量整数操作数，在 x86 上，立即数以小端格式编码，多字节整数的最低有效字节排在内存中的第一位，使用补码表示法表示有符号整数</p><p>在使用时需要在数字前加 <code>$</code> 表示立即数</p><h2 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h2><h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>直接把一个立即数在指令里给定，把这个数赋给目标操作数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq 123, %rax</span><br></pre></td></tr></table></figure><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>不直接在指令里面给出源操作数，而是把这个源操作数放在一个寄存器里面，通过寄存器来赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rax. %rbx</span><br></pre></td></tr></table></figure><h3 id="存储器寻址"><a href="#存储器寻址" class="headerlink" title="存储器寻址"></a>存储器寻址</h3><ol><li>直接寻址：直接在指令中给出操作数的偏移地址</li><li>寄存器间接寻址：将操作数的地址写入寄存器中，然后利用寄存器寻找操作数的地址</li><li>基址寻址： <code>base + displacement</code></li><li>变址寻址： <code>displacement + index * scale</code></li><li>基址变址寻址： <code>base + index * scale + displacement</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">直接寻址</span><br><span class="line">movq (1000H), %rax</span><br><span class="line">寄存器间接寻址</span><br><span class="line">movq (%eax), %ebx</span><br><span class="line">基址寻址</span><br><span class="line">movq 4(%rbx), %rax</span><br><span class="line">变址寻址</span><br><span class="line">movq 4(, %eax, 4), %rax</span><br><span class="line">基址变址寻址</span><br><span class="line">movq 4(%rax. %eax, 4), %rbx</span><br></pre></td></tr></table></figure><h2 id="指示标号"><a href="#指示标号" class="headerlink" title="指示标号"></a>指示标号</h2><h3 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h3><p>在 x86 汇编里可以使用特定的伪指令来声明静态数据区（类似于全局变量）</p><ul><li><code>.byte</code> 可不带参数或者带多个表达式参数，表达式之间用逗号分隔，每个表达式参数都被汇编成一个字节</li><li><code>.zero</code> 后面的参数表示声明的字节数，初始值为 0，可以为大量的内存区填充零</li><li><code>.short</code> 这个表达式表示任意一节中的一个或多个表达式（同样用逗号分开），每个表达式占一个字（两个字节）</li><li><code>.int</code> 整形，并且分配空间</li><li><code>.long</code> 长整型，并且分配空间</li><li><code>ascii</code> 字符串，并且分配空间</li><li><code>.string</code> 表示数据段中的字符串常量，初始为以 <code>null(0)</code>结尾的</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>以冒号结尾，用来把标签名和标签出现的位置关联起来。一般来说，以点号开始的标签都是编译器生成的临时局部标签，其它标签则是用户可见的函数和全局变量名称</p><p>汇编标签只是一个简单的地址标识符，标签主要用于程序流程控制（如分支、循环和子程序调用）</p><ul><li>标签是汇编语言中用于定义代码位置的符号，通常是一个名称后跟一个冒号（如 <code>measure_pwm_freq_start:</code> ）</li><li>标签相当于程序的一个地址标记，当执行到 <code>jmp</code> ， <code>call</code> 等转移指令时，可以通过标签名来跳转到对应的内存地址继续执行</li><li>汇编标签不封装数据或逻辑，它仅仅代表一段代码的开始位置，没有参数传递和返回值的概念</li></ul><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>伪指令是内嵌在程序源代码中，由汇编器识别并执行相应动作的命令，伪指令在程序运行时并不执行。伪指令可用于定义变量、宏以及过程，可用于命名段以及执行许多其他与汇编器相关的簿记任务</p><h2 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h2><p>调用约定被划分为两组规则集合。第一组由函数调用者使用，第二组由子进程的编写者即被调用者使用。</p><p><strong>注意：</strong>遵守调用约定的这些规则时若产生错误，将会导致严重的程序错误，因为此时的栈处于一个不连续的状态。因此实现调用约定时必须小心</p><h3 id="调用者规则"><a href="#调用者规则" class="headerlink" title="调用者规则"></a><strong>调用者规则</strong></h3><p><strong>调用子进程之前要做的</strong></p><ol><li>调用前应该保存某些寄存器的内容，这些寄存器由 <code>caller-saved</code> 规则指定，包括 <code>eax, ecx, edx</code> 。因为被调用的子例程可以修改这些寄存器，所以如果 <code>caller</code> 需要在子例程返回后使用这些寄存器的值，则必须将这些寄存器入栈（可以在子例程返回后出栈恢复）</li><li>为了向子例程传参，在调用子例程之前就需要将参数入栈。参数入栈遵从反向顺序（即最后一个参数第一个入栈）。因为栈往低处长，所以第一个参数会保存在最低的地址处（这种参数的倒转在历史上被函数用来传递可变数量的参数）</li><li>为了调用子例程，使用 <code>call</code> 指令。这条指令在栈上所传递参数之后入栈其返回地址，然后跳入子例程，之后遵守的是接下来要介绍的 <code>callee</code> 规则</li></ol><p><strong>调用子进程之后，为了恢复原来的硬件状态。需要做</strong></p><ol><li>从栈中移除参数，这会将堆栈恢复到调用之前的状态</li><li>通过出栈 <code>caller-saved</code> 恢复寄存器 <code>eax, ecx, edx</code> 的值。 <code>caller</code> 可以假设子例程中没有其他寄存器被修改</li></ol><h3 id="被调用者规则"><a href="#被调用者规则" class="headerlink" title="被调用者规则"></a><strong>被调用者规则</strong></h3><p><strong>子例程的定义应该在开头处就应坚持遵守以下规则</strong></p><ol><li>将 <code>ebp</code> 入栈，然后使用以下指令将 <code>esp</code> 的值拷贝到 <code>ebp</code></li><li>之后在栈上开辟空间以分配给局部变量。由于栈往低处长，所以为了在栈顶获取空间， <code>esp</code> 应该执行减法。这个减数取决于所需局部变量的数量和大小。例如，如果需要三个整型值（每个 4 字节）， <code>esp</code> 需要减去 12 才能为它的局部变量开辟空间（即 <code>sub $12, %esp</code>）。与参数一样，局部变量也位于距基指针已知的偏移量处</li><li>然后保存函数将要使用的那些 <code>callee-saved</code> 寄存器的值。也是通过入栈来保存。这些寄存器是 <code>ebx</code> ， <code>edi</code> 和 <code>esi</code>（ <code>esp</code> 和 <code>ebp</code> 仍要遵守调用约定，只是这个阶段暂时不需要入栈）</li></ol><p><strong>当子例程返回时，需要遵守以下步骤</strong></p><ol><li>在 <code>eax</code> 中留下返回值</li><li>恢复被修改的 <code>callee-saved</code> 寄存器（ <code>edi</code> 和 <code>esi</code> ）原来的值。通过出栈恢复这些寄存器的值时，出栈顺序应该和入栈顺序相反</li><li>回收局部变量的空间。直接的办法是 <code>esp</code> 加上某个合适的值（因为这些空间是 <code>esp</code> 减去某个值而实现分配的）。事实上，更不容易出错的办法是拷贝 <code>ebp</code> 的值到 <code>esp</code> （<code>mov %ebp, %esp</code>）。这里的原理是 <code>ebp</code> 的值，总是与 <code>esp</code> 分配空间前的值相等</li><li>在返回的那一刻，通过出栈 <code>ebp</code> 而恢复 <code>caller</code> 的 <code>ebp</code> 。回想我们在子例程入口做的第一件事就是将 <code>esp</code> 原来的值入栈</li><li>最后，调用 <code>ret</code> 指令返回 <code>caller</code> 。该指令会从栈中找到合适的返回地址，并删掉这个地址</li></ol><h2 id="C语言与汇编语言共同编译"><a href="#C语言与汇编语言共同编译" class="headerlink" title="C语言与汇编语言共同编译"></a>C语言与汇编语言共同编译</h2><h3 id="传参规则"><a href="#传参规则" class="headerlink" title="传参规则"></a>传参规则</h3><ul><li>一个参数用 <code>rdi</code></li><li>两个参数用 <code>rdi</code> <code>rsi</code></li><li>三个参数用 <code>rdi</code> <code>rsi</code> <code>rdx</code></li><li>四个参数用 <code>rdi</code> <code>rsi</code> <code>rdx</code> <code>rcx</code></li><li>五个参数用 <code>rdi</code> <code>rsi</code> <code>rdx</code> <code>rcx</code> <code>r8</code></li><li>六个参数用 <code>rdi</code> <code>rsi</code> <code>rdx</code> <code>rcx</code> <code>r8</code> <code>r9</code></li><li>返回值存入 <code>rax</code> 寄存器中</li></ul><h3 id="C-语言调用汇编语言"><a href="#C-语言调用汇编语言" class="headerlink" title="C 语言调用汇编语言"></a>C 语言调用汇编语言</h3><p>需要在 C 语言中进行声明对应的函数以及其参数，并且需要在汇编语言中将函数声明为 <code>global</code> 类型的符号，需要注意参数传入顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum is %d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global sum</span><br><span class="line">.type sum, @function</span><br><span class="line">sum:</span><br><span class="line">  movq %rdi, %rax</span><br><span class="line">  addq %rsi, %rax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><h3 id="汇编语言调用-C-语言"><a href="#汇编语言调用-C-语言" class="headerlink" title="汇编语言调用 C 语言"></a>汇编语言调用 C 语言</h3><p>汇编语言调用 C 语言时，不需要声明 <code>extern</code> ，直接在代码中调用该函数即可，需要注意参数传入顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c = func();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum is %d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global func</span><br><span class="line">.type func, @function</span><br><span class="line">func:</span><br><span class="line">  movq $1, %rdi</span><br><span class="line">  movq $2, %rsi</span><br><span class="line">  call sum ; 此时返回值存储在 %rax 寄存器中，所以直接返回也是如此</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> [ <span class="keyword">volatile</span> ] ( </span><br><span class="line">       assembler template</span><br><span class="line">       [ : output operands ]                <span class="comment">/* optional */</span></span><br><span class="line">       [ : input operands  ]                <span class="comment">/* optional */</span></span><br><span class="line">       [ : <span class="built_in">list</span> of clobbered registers ]    <span class="comment">/* optional */</span></span><br><span class="line">       );</span><br></pre></td></tr></table></figure><h3 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h3><p>是 gcc 关键字，表示接下来将要嵌入汇编代码。为了避免 keyword asm 与程序中其它部分产生命名冲突，可以使用 <code>__asm__</code> 关键字，与之等价</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>是 gcc 关键字，表示不需要对下面的汇编代码做任何优化，为了避免 keyword asm 与程序中其它部分产生命名冲突，可以使用 <code>__volatile__</code> 关键字，与之等价</p><h3 id="assember-template"><a href="#assember-template" class="headerlink" title="assember template"></a>assember template</h3><p>这一部分是要嵌入的汇编指令，由于是嵌入在 C 语言之中的，所以需要使用双引号来将命令括起来，从而使得 gcc 将其以字符串的形式将这些命令传递给汇编器 as。需要注意的点如下</p><ol><li><p>有时候汇编指令可能有多个，中间需要换行处理或者是使用分号相隔，例如</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %%eax, %%ebx; movl %%ebx, %%ecx;&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %%eax, %%ebx\n movl %%ebx, %%ecx\n&quot;</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>语法问题需要注意，这里使用的汇编语法是 AT&amp;T 的汇编语法，也就是目的操作数在后面</p></li><li><p>参数调用和寄存器使用需要注意</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;movl %1, %%eax; movl %%eax, %0;&quot;</span> : <span class="string">&quot;=r&quot;</span>(b) : <span class="string">&quot;r&quot;</span>(a) : <span class="string">&quot;%eax&quot;</span>); </span><br></pre></td></tr></table></figure><p> 对于参数调用是使用 <code>%n</code> 来调用的，其中 <code>n</code> 就是第 <code>n</code> 个参数，这个是从第一个 <code>output operands</code> 从 0 开始标号的，直到最后一个 <code>input operand</code></p><p> 同时为了与寄存器的调用分别，所以寄存器的使用会使用 <code>%%</code> 来指代</p></li></ol><h3 id="output-operands"><a href="#output-operands" class="headerlink" title="output operands"></a>output operands</h3><p>该字段是可选字段，用来指明输出的操作数，一般的格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: <span class="string">&quot;=constraints&quot;</span>(output)</span><br></pre></td></tr></table></figure><p>其中引号之内的是指定 <code>output operands</code> 应当遵守的约束。 <code>output</code> 位存放指令结果的变量，通常是一个 C 语言变量。其中 <code>=</code> 是 <code>output operands</code> 特有的约束，表示该操作数是只写的。</p><p>如果输出有多个，典型的格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;xxx&quot;</span>; : <span class="string">&quot;=a&quot;</span>(o1) : <span class="string">&quot;=b&quot;</span>(o2) : <span class="string">&quot;=c&quot;</span>(o3) : <span class="string">&quot;a&quot;</span> (i1))</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>=a</code> 表示先将命令执行结果输出到 <code>eax</code> 寄存器，然后再由寄存器更新位于内存中的 <code>output</code> ，其它的也是如此。可以为 <code>output operand</code> 分别指定约束。这些约束会在下面的约束中介绍</p><h3 id="input-operands"><a href="#input-operands" class="headerlink" title="input operands"></a>input operands</h3><p>这个字段为可选字段，可以指明输入操作数，典型格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: <span class="string">&quot;constraints&quot;</span>(intput)</span><br></pre></td></tr></table></figure><p>其中 <code>constraints</code> 是 gcc 支持的各种约束方式。但是 <code>input operands</code> 与 <code>output operands</code> 的数量是有限的，并且每种指令集体系结构对于涉及到的指令支持的最多操作数也是有限制的，所以这里的操作数数量受到限制。此处具体的上限为 <code>max(10, max_in_instruction)</code> ，其中 <code>max_in_instruction</code> 是 ISA 中拥有最多操作数的那条指令所包含的操作数数目。</p><p>需要注意的是，如果指明 <code>input operands</code> 时，即使指令不会有 <code>output operands</code> 也需要给出对应的 <code>:</code> ，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt %0&quot;</span> : : <span class="string">&quot;m&quot;</span>(idt_operand))</span>;</span><br></pre></td></tr></table></figure><h3 id="list-of-clobbered-registers"><a href="#list-of-clobbered-registers" class="headerlink" title="list of clobbered registers"></a>list of clobbered registers</h3><p>该字段为可选字段，用于列出指令中涉及到的且没有出现在 <code>output operands</code> 和 <code>input operands</code> 字段的那些寄存器，若寄存器被列入到 <code>clobber-list</code> ，就是告诉 gcc，哪些寄存器可能会被内联汇编命令改写。所以在执行内联汇编时，这些寄存器就不会被 gcc 分配给其它进程或者命令使用</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>通常在 <code>output operands</code> 和 <code>input operands</code> 中通常需要指定各自的 <code>constraints</code> ，以便更加明确的完成期望的任务。</p><ol><li><p>寄存器操作数约束</p><p> 操作数被指定这类约束时，表明汇编指令执行时，操作数将被存储在指定的通用寄存器中，使用寄存器进行中转。具体如下</p><ul><li><code>a</code> ： <code>eax</code> ， <code>ax</code> ， <code>al</code></li><li><code>b</code> ： <code>ebx</code> ， <code>bx</code> ， <code>bl</code></li><li><code>c</code> ： <code>ecx</code> ， <code>cx</code> ， <code>cl</code></li><li><code>d</code> ： <code>edx</code> ， <code>dx</code> ， <code>dl</code></li><li><code>S</code> ： <code>esi</code> ， <code>si</code></li><li><code>D</code> ： <code>edi</code> ， <code>di</code></li><li><code>r</code> ：使用以上任意一个可用寄存器</li></ul></li><li><p>内存操作数约束</p><p> 对于不希望使用寄存器中转，直接操作内存时，可以使用 <code>m</code> 来约束</p></li><li><p>关联约束</p><p> 有些时候，如果命令输入输出均为同一个变量，则可以在内联汇编中指定以 <code>matching constraint</code> 的方式分配寄存器，此时 <code>input operands</code> 与 <code>output operands</code> 共用一个中转寄存器</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;incl %0&quot;</span> : <span class="string">&quot;=a&quot;</span>(var) : <span class="string">&quot;0&quot;</span>(var))</span>;</span><br></pre></td></tr></table></figure><p> 由于输入输出均为同一个变量，因此可以使用 <code>0</code> 来指定都用 <code>eax</code> 作为中转寄存器，需要注意的是 <code>0</code> 约束修饰的是 <code>input operands</code></p></li><li><p>约束修饰符</p><ul><li><code>=</code> 表示操作数在这条指令中是仅写的，这个操作数的先前值将被忽略，并向其中写入输出数据</li><li><code>&amp;</code> 表示操作数是一个 <code>early-clobber</code> 操作数，它在指令使用输入操作数之前被写入了值，因此这个操作数不能位于被指令读取的寄存器中，也不能位于任何作为内存地址组成部分的寄存器中。另外，如果一个 <code>early-clobber</code> 操作数也是一个读或写操作数时，该操作数只有在被使用之后才会被写入。而且 <code>early-clobber</code> 操作数总是被写入的，只读的 <code>early-clobber</code> 操作数将会在编译过程报错。实际上就是对 gcc 声明：gcc 不得为任何 <code>input opereands</code> 分配与此 <code>output operands</code> 操作表达式相同的寄存器。如果已经使用 <code>+</code> 或者 <code>=</code> 占据了约束修饰的第一个位置，那 <code>&amp;</code> 只能占据第二个字符</li><li><code>+</code> 添加此修饰符的操作数将同时被指令读写，当编译器修复操作数以满足约束时，它需要知道哪些操作数被指令读取，哪些操作数被指令写入。 <code>=</code> 标识一个只被写入的操作数。 <code>+</code> 标识可读可写的操作数。所有其它操作数都假定只被读取。如果在约束中指定 <code>=</code> 或 <code>+</code> ，则将其放在约束字符串的第一个字符中。在有多个选项的约束中，必须在第一个选项中添加 <code>+</code> 约束修饰符，之后的其它选项会有同样的效果，且不允许再添加 <code>+</code> 约束修饰符</li><li><code>%</code> 可以交换操作数，使得 gcc 生成更好的代码。例如 <code>asm(&quot;fadd %0, %1, %2&quot; : “=f”(c) : “%f”(a), “f”(b));</code> 这个汇编指令计算操作数 <code>a</code> 和 <code>b</code> 的和，然后将结果写入到 <code>c</code> 中，其中 <code>%</code> 表示如果编译器可以通过交换操作数 <code>a</code> 和 <code>b</code> 生成更好的代码的话，那么可以交换两个操作数。但是 <code>gcc</code> 只能处理 <code>asm</code> 中的一个交换对，如果使用多个 <code>%</code> ，编译器会导致错误</li></ul></li><li>其它约束<ul><li>空格：空白字符将被忽略，可以插入除第一个位置以外的任何位置。这使得不同操作数的每个选项在机器描述中对齐，即使它们有不同数量的约束和修饰符</li><li><code>m</code> ：允许内存操作数，它可以是计算机支持的任何类型的地址。注意，用于通用内存约束的字母可以由后端使用 <code>TARGET_MEM_CONSTRAINT</code> 宏重新定义</li><li><code>o</code> ：允许使用内存运算对象，但仅当该地址是可偏移的（offsettable）。这意味着可以向地址添加一个小整数（实际上是操作数的字节宽度，由其机器模式决定），结果也是一个有效的内存地址。例如，一个常量地址是可偏移的;一个寄存器和一个常量之和的地址（只要一个稍大的常量也在机器支持的地址偏移量范围内）也是一样的;但自动递增或自动递减地址是不可偏移的。更复杂的间接/索引地址可以偏移，也可以不偏移，这取决于机器支持的其它寻址模式。需要注意，在一个可以被另一个操作数匹配的输出操作数中，约束字母 <code>o</code> 只有在同时伴有 <code>&lt;</code> （如果目标机器有前任寻址）和 <code>&gt;</code> （如果目标机器有前增量寻址）时才有效。</li><li><code>V</code> ：一种不可偏移的内存运算对象。也就是任何符合 <code>m</code> 约束但不符合 <code>o</code> 约束的东西</li><li><code>&lt;</code> ：允许具有自减法寻址的内存操作数（无论是前置或后置减法）。在内联 asm 中，只有当操作数在可以处理副作用的指令中恰好使用一次时，才允许此约束。在 inline asm 模式的约束字符串中不使用带有 <code>&lt;</code> 的操作数或在多个指令中使用它是无效的，因为副作用不会被执行或将被执行不止一次</li><li><code>&gt;</code> ：允许使用具有自动递增寻址（前置递增或后置递增）的内存运算对象。在 inline asm 中，应用与 <code>&lt;</code> 有着相同的限制</li><li><code>i</code> ：允许使用立即整型操作数（具有常值的操作数）。这包括其值只有在汇编时或以后才知道的符号常量</li><li><code>n</code> ：允许具有已知数值的立即整数操作数。许多系统不能为小于一个字宽的操作数支持汇编时常量。这些操作数的约束应该使用 <code>n</code> 而不是 <code>i</code></li><li><code>I~P</code> ：可以以一种依赖于机器的方式定义，以允许在指定范围内具有明确整数值的整数操作</li><li><code>E</code> ：允许立即浮点操作数（表达式代码const_double），但前提是目标浮点数格式与运行编译器的主机的格式相同</li><li><code>F</code> ：允许立即浮点操作数（表达式代码const_double或const_vector）</li><li><code>G,H</code> ：可以以一种依赖于机器的方式定义，以允许特定值范围内的直接浮点运算对象</li><li><code>s</code> ：允许一个值不明确的立即整数操作数</li><li><code>g</code> ：任何通用寄存器，内存，立即整数的操作都被允许</li><li><code>X</code> ：任何操作数都是允许的</li><li><code>0~9</code> ：匹配约束，真正含义是，汇编程序只有一个操作数来填充 asm 区分的两个角色（在输出中分配与相应输入中相同的寄存器）</li><li><code>p</code> ：允许一个有效的内存地址的操作数，用于 <code>load address</code> 或者 <code>push address</code> 指令。必须和 <code>address_operands</code> 一起使用</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bochs+gdb调试工具链</title>
      <link href="/Blog_ButterFly/2024/05/30/bochs-gdb%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/Blog_ButterFly/2024/05/30/bochs-gdb%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>bochs</code> 中自带一个反汇编器，这只能查看可执行文件的反汇编之后的指令，但是如果书写 C 语言的话，就使得调试非常麻烦（无计可施），所以利用 <code>bochs</code> 来写操作系统还是挺困难的，同时也没有办法查看各个变量的状态和 <code>cpu</code> 的状态。一旦遇到问题就很被动，所以介绍一个 bochs+gdb 的一个调试工具链</p><h2 id="bochs安装与配置"><a href="#bochs安装与配置" class="headerlink" title="bochs安装与配置"></a>bochs安装与配置</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ </span><br><span class="line">sudo apt-get install make</span><br><span class="line">sudo apt-get install libx11-dev xserver-xorg-dev xorg-dev</span><br></pre></td></tr></table></figure><h3 id="安装-bochs"><a href="#安装-bochs" class="headerlink" title="安装 bochs"></a>安装 <code>bochs</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://udomain.dl.sourceforge.net/project/bochs/bochs/2.6.8/bochs-2.6.8.tar.gz</span><br><span class="line">tar zxvf bochs-2.6.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bochs-2.6.8/</span><br><span class="line">./configure --prefix=/your_path/bochs --enable-gdb-stub --enable-disasm --enable-iodebug --enable-x86-debugger --with-x --with-x11 LDFLAGS=<span class="string">&#x27;-pthread&#x27;</span></span><br><span class="line">make -j12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>--enable-debugger</code> 将 Bochs 使用内置的反汇编器进行调试</li><li><code>--enable-gdb-stub</code> 开放端口提供 GDB 远程调试</li><li><code>--enable-readline</code> 使用 Bochs 内置调试器时使用 readline 库提供的自动补全和历史命令功能</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>进入到安装目录中，也就是在 <code>config</code> 中指定的路径 <code>/your_path/bochs</code></p><p>新建一个配置文件 <code>bochsrc.disk</code> ，然后向其中写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一步，首先设置 Bochs 在运行过程中能够使用的内存，本例为 32MB </span></span><br><span class="line">megs: 32 </span><br><span class="line"></span><br><span class="line"><span class="comment">#第二步，设置对应真实机器的 BIOS 和 VGA BIOS </span></span><br><span class="line">romimage: file=/your_path/bochs/share/bochs/BIOS-bochs-latest </span><br><span class="line">vgaromimage: file=/your_path/bochs/share/bochs/VGABIOS-lgpl-latest </span><br><span class="line"></span><br><span class="line"><span class="comment">#第三步，设置 Bochs 所使用的磁盘，软盘的关键字为 floppy。 </span></span><br><span class="line"><span class="comment">#若只有一个软盘，则使用 floppya 即可，若有多个，则为 floppya，floppyb… </span></span><br><span class="line"><span class="comment">#floppya: 1_44=a.img, status=inserted </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第四步，选择启动盘符 </span></span><br><span class="line"><span class="comment">#boot: floppy #默认从软盘启动，将其注释 </span></span><br><span class="line">boot: disk <span class="comment">#改为从硬盘启动。我们的任何代码都将直接写在硬盘上，所以不会再有读写软盘的操作 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第五步，设置日志文件的输出 </span></span><br><span class="line"><span class="built_in">log</span>: bochsout.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#第六步，开启或关闭某些功能 </span></span><br><span class="line"><span class="comment">#下面是关闭鼠标，并打开键盘 </span></span><br><span class="line">mouse: enabled=0 </span><br><span class="line">keyboard: keymap=/your_path/bochs/share/bochs/keymaps/x11-pc-us.map </span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬盘设置 </span></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 gdb 调试端口 1234</span></span><br><span class="line">gdbstub:enabled=1,port=1234,text_base=0,data_base=0,bss_base=0</span><br></pre></td></tr></table></figure><p>完成之后在目录下输入 <code>bin/bochs</code> 测试结果，后面会跳出一个选项，已经有一个默认配置 6 了，所以输入 6，可以发现跳出一个 <code>bochs</code> 虚拟机。退出需要在终端输入指令 <code>exit</code></p><h3 id="创建虚拟硬盘"><a href="#创建虚拟硬盘" class="headerlink" title="创建虚拟硬盘"></a>创建虚拟硬盘</h3><p>使用其中的工具 <code>bximage</code> 来创建虚拟硬盘，使用 <code>bin/bximage</code> 来创建</p><ul><li><code>bin/bximage --help</code> 查看各个选项参数的含义</li><li><code>bin/bximage -mode=&quot;create&quot; -hd=60 -imgmode=&quot;flat&quot; -q hd60M.img</code> 创建虚拟硬盘，将出现的最后依据加入到配置文件 <code>bochsrc</code> 中，把硬盘设置那一句换掉，然后可以运行测试</li></ul><p>之后运行测试都使用 <code>bin/bochs -f bochsrc.disk</code> 来运行，但是应该会出现一些无法读取或者写入的错误，这时候就需要使用 <code>sudo bin/bochs -f bochsrc.disk</code> 执行</p><h3 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h3><p>由于使用的是 <code>nasm</code> ，所以下载对应的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nasm</span><br></pre></td></tr></table></figure><h3 id="bochs的调试"><a href="#bochs的调试" class="headerlink" title="bochs的调试"></a>bochs的调试</h3><p>对于要写一个操作系统来说，不能调试可太麻烦了，所以可以使用 bochs 的调试功能，它的调试指令基本和 gdb 类似，但也有不同之处，可以自己上网查一查手册</p><p>其次有个配置在代码里可以实现断点功能的，在 <code>bochsrc.disk</code> 中添加下面这句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magic_break: enabled=1</span><br></pre></td></tr></table></figure><p>然后在代码中想要暂停的地方可以写下，就会在这条语句中停止，然后就可以开始调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xchg bx, bx</span><br></pre></td></tr></table></figure><p>但是这个很不实用，只能调试汇编语言，所以下面使用 gdb 就可以调试 c 语言</p><h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><p>对于编译方面，需要将所有的编译选项加上 <code>-g</code> ，并且对链接之后得到的可执行目标文件 <code>kernel.bin</code> 提取符号，得到 <code>kernel.sym</code> ，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objcopy --only-keep-debug $(KERNEL_BUILD_PATH)/kernel.bin $(KERNEL_BUILD_PATH)/kernel.sym</span><br></pre></td></tr></table></figure><h2 id="gdb-配置"><a href="#gdb-配置" class="headerlink" title="gdb 配置"></a>gdb 配置</h2><p>上述配置完成之后，使用 <code>bin/bochs -f bochsrc.disk</code> 指令进入运行之后会卡死，会等待 <code>gdb</code> 链接端口进行调试。这时候打开 <code>gdb</code> 输入如下指令之后就可以进行调试了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br><span class="line">symbol-file ./build/kernel/kernel.sym</span><br></pre></td></tr></table></figure><p>但是还是有点麻烦，所以这时候可以创建一个 <code>.gdbinit</code> 来做 <code>gdb</code> 的初始化，实际上就是在打开 <code>gdb</code> 时会自动执行其中的指令，从而完成配置。但是需要在 <code>/home/user</code> 之下创建一个 <code>gdbinit</code> 文件来使得将 <code>,gdbinit</code> 链接到期望的 <code>.gdbinit</code> 。具体操作可以在当前文件夹下运行一下 <code>gdb</code> 就可以得到来自于 <code>gdb</code> 的教程了</p><p>配置结束之后就可以使用 <code>gdb</code> 来进行调试了，调试的指令与 <code>gdb</code> 一致</p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc内置原子操作</title>
      <link href="/Blog_ButterFly/2024/05/27/gcc%E5%86%85%E7%BD%AE%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
      <url>/Blog_ButterFly/2024/05/27/gcc%E5%86%85%E7%BD%AE%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Gcc 4.1.2版本之后，对 X86 或 X86-64 支持内置原子操作。也就是不需要引入第三方库（如pthread）的锁保护，即可对1、2、4、8字节的数值或指针类型，进行原子加/减/与/或/异或等操作</p><h2 id="sync-接口"><a href="#sync-接口" class="headerlink" title="__sync 接口"></a>__sync 接口</h2><p>具体信息查看 <a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html">Built-in functions for atomic memory access</a></p><ul><li><code>type __sync_fetch_and_add (type *ptr, type value, ...)</code> 将 <code>value</code> 加到 <code>*ptr</code> 上，并且结果保存在 <code>*ptr</code> 上，返回操作之前的 <code>*ptr</code> 的值</li><li><code>type __sync_fetch_and_sub (type *ptr, type value, ...)</code> 从 <code>*ptr</code> 减去 <code>value</code> ，结果保存到 <code>*ptr</code> ，并返回操作之前 <code>*ptr</code> 的值</li><li><code>type __sync_fetch_and_or (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 与 <code>value</code> 相或操作，结果保存在 <code>*ptr</code> 中，返回操作之前 <code>*ptr</code> 的值</li><li><code>type __sync_fetch_and_and (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 与 <code>value</code> 相与操作，结果保存在 <code>*ptr</code> 中，返回操作之前 <code>*ptr</code> 的值</li><li><code>type __sync_fetch_and_xor (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 与 <code>value</code> 相异或操作，结果保存在 <code>*ptr</code> 中，返回操作之前 <code>*ptr</code> 的值</li><li><code>type __sync_fetch_and_nand (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 取反后与 <code>value</code> 相与操作，结果保存在 <code>*ptr</code> 中，返回操作之前 <code>*ptr</code> 的值</li><li><code>type __sync_add_and_fetch (type *ptr, type value, ...)</code> 将 <code>value</code> 加到 <code>*ptr</code> 上，结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code> 的值</li><li><code>type __sync_sub_and_fetch (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 减去 <code>value</code> 之后，结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code> 的值</li><li><code>type __sync_or_and_fetch (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 与 <code>value</code> 相或操作，结果保存在 <code>*ptr</code> 中，返回操作之后 <code>*ptr</code> 的值</li><li><code>type __sync_and_and_fetch (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 与 <code>value</code> 相与操作，结果保存在 <code>*ptr</code> 中，返回操作之后 <code>*ptr</code> 的值</li><li><code>type __sync_xor_and_fetch (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 与 <code>value</code> 相异或操作，结果保存在 <code>*ptr</code> 中，返回操作之后 <code>*ptr</code> 的值</li><li><code>type __sync_nand_and_fetch (type *ptr, type value, ...)</code> 将 <code>*ptr</code> 取反后与 <code>value</code> 相与操作，结果保存在 <code>*ptr</code> 中，返回操作之后 <code>*ptr</code> 的值</li><li><code>bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...)</code> 比较 <code>*ptr</code> 与 <code>oldval</code> 的值，如果两者相等，将 <code>newval</code> 更新到 <code>*ptr</code> 中并且返回 <code>true</code> ，否则返回 <code>false</code></li><li><code>type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</code> 比较 <code>*ptr</code> 与 <code>oldval</code> 的值，如果两者相等，将 <code>newval</code> 更新到 <code>*ptr</code> 中并且返回操作之前 <code>*ptr</code> 的值</li><li><code>__sync_synchronize (...)</code> 相当于是内存栅栏，必须保证之前的操作完成之后才进行下一步的操作，保证执行的顺序性</li><li><code>type __sync_lock_test_and_set (type *ptr, type value, ...)</code> 将 <code>value</code> 写入 <code>*ptr</code> ，对 <code>*ptr</code> 加锁，并且发返回操作之前的 <code>*ptr</code> 的值</li><li><code>void __sync_lock_release (type *ptr, ...)</code> 将 0 写入到 <code>*ptr</code> 并且对 <code>*ptr</code> 解锁</li></ul><h2 id="atomic-接口"><a href="#atomic-接口" class="headerlink" title="__atomic 接口"></a>__atomic 接口</h2><p>这些功能旨在取代遗留的 <code>__sync</code> 内置函数。主要区别在于，请求的内存顺序是函数的参数。新代码应始终使用 <code>__atomic</code> 内置函数而不是 <code>__sync builtins</code></p><p>具体信息查看 <a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">Built-in Functions for Memory Model Aware Atomic Operations</a></p><ul><li><code>type __atomic_load_n (type *ptr, int memorder)</code> 原子加载操作，返回 <code>*ptr</code> 的内容</li><li><code>void __atomic_load (type *ptr, type *ret, int memorder)</code> 原子加载的通用版本，返回 <code>*ret</code> 中 <code>*ptr</code> 的内容</li><li><code>void __atomic_store_n (type *ptr, type val, int memorder)</code> 实现原子存储，将 <code>val</code> 写入 <code>*ptr</code> 中</li><li><code>void __atomic_store (type *ptr, type *val, int memorder)</code> 原子存储的通用版本，将 <code>*val</code> 中的值存储到 <code>*ptr</code> 中</li><li><code>type __atomic_exchange_n (type *ptr, type val, int memorder)</code> 内置原子交换操作，将 <code>val</code> 写入到 <code>*ptr</code> 中，并且返回 <code>*ptr</code> 操作之前的内容</li><li><code>void __atomic_exchange (type *ptr, type *val, type *ret, int memorder)</code> 将 <code>*val</code> 的内容存储到 <code>*ptr</code> 中，并且 <code>*ptr</code> 的原始值被复制到 <code>*ret</code> 中</li><li><code>bool __atomic_compare_exchange_n (type *ptr, type *expected, type desired, bool weak, int success_memorder, int failure_memorder)</code> 原子比较和交换操作，将 <code>*ptr</code> 中的内容与 <code>*expected</code> 的内容进行比较，如果相等则将 <code>desired</code> 的内容写入 <code>*ptr</code> 中，如果不相等，则将 <code>*ptr</code> 当前内容写入到 <code>*expected</code> 中， <code>weak</code> 用于若比较交换的 <code>true</code> ，可能会错误的失败，而 <code>false</code> 则用于强变化，永远不会错误的失败。如果将 <code>desired</code> 写入 <code>*ptr</code> 就返回 <code>true</code> ，并且根据 <code>success_memorder</code> 指定的内存顺序影响内存，否则返回 <code>false</code> 并且根据 <code>failure_memorder</code> 堆内存进行操作</li><li><code>bool __atomic_compare_exchange (type *ptr, type *expected, type *desired, bool weak, int success_memorder, int failure_memorder)</code> 该函数内置了 <code>__atomic_compare_exchange</code> 的通用版本，该函数实际上与 <code>__atomic_compare_exchange_n</code> 相同，只是所需要的值也是一个指针</li><li><code>type __atomic_add_fetch (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 与 <code>val</code> 执行相加操作，结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code></li><li><code>type __atomic_sub_fetch (type *ptr, type val, int memorder)</code> 执行 <code>*ptr</code> 减去 <code>val</code> ，并且将结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code></li><li><code>type __atomic_and_fetch (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 与 <code>val</code> 执行相与操作，结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code></li><li><code>type __atomic_xor_fetch (type *ptr, type val, int memorder)</code>  将 <code>*ptr</code> 与 <code>val</code> 执行相异或操作，结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code></li><li><code>type __atomic_or_fetch (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 与 <code>val</code> 执行相或操作之后，将结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code></li><li><code>type __atomic_nand_fetch (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 取反之后再与 <code>val</code> 执行相与操作，结果保存在 <code>*ptr</code> 中，返回操作之后的 <code>*ptr</code></li><li><code>type __atomic_fetch_add (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 与 <code>val</code> 执行相加操作，结果保存在 <code>*ptr</code> 中，返回操作之前的 <code>*ptr</code></li><li><code>type __atomic_fetch_sub (type *ptr, type val, int memorder)</code> 执行 <code>*ptr</code> 减去 <code>val</code> ，并且将结果保存在 <code>*ptr</code> 中，返回操作之前的 <code>*ptr</code></li><li><code>type __atomic_fetch_and (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 与 <code>val</code> 执行相与操作，结果保存在 <code>*ptr</code> 中，返回操作之前的 <code>*ptr</code></li><li><code>type __atomic_fetch_xor (type *ptr, type val, int memorder)</code>  将 <code>*ptr</code> 与 <code>val</code> 执行相异或操作，结果保存在 <code>*ptr</code> 中，返回操作之前的 <code>*ptr</code></li><li><code>type __atomic_fetch_or (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 与 <code>val</code> 执行相或操作之后，将结果保存在 <code>*ptr</code> 中，返回操作之前的 <code>*ptr</code></li><li><code>type __atomic_fetch_nand (type *ptr, type val, int memorder)</code> 将 <code>*ptr</code> 取反之后再与 <code>val</code> 执行相与操作，结果保存在 <code>*ptr</code> 中，返回操作之前的 <code>*ptr</code></li><li><code>bool __atomic_test_and_set (void *ptr, int memorder)</code> 对 <code>*ptr</code> 的字节执行原子测试和设置操作，当前仅当当前内容被设置时，该字节被设置成某个实现定义的非 0 设置值，并且返回值为 <code>true</code> ，只能用于 <code>bool</code> 或者 <code>char</code> 类型的操作数，对于其它类型，只能设置一部分 (1byte)</li><li><code>void __atomic_clear (bool *ptr, int memorder)</code> 在 <code>*ptr</code> 上执行原子清除操作，运算之后 <code>*ptr</code> 中内容为 0，只能用于 <code>bool</code> 或者 <code>char</code> 类型的操作数，并且与 <code>__atomic_test_and_set</code> 结合使用，对于其它类型只能完成部分操作 (1byte)</li><li><code>void __atomic_thread_fence (int memorder)</code> 指定执行的内存顺序当作进程之间的同步的栅栏</li><li><code>void __atomic_signal_fence (int memorder)</code> 充当线程和基于同一线程的信号处理程序之间的同步栅栏</li><li><code>bool __atomic_always_lock_free (size_t size, void *ptr)</code> 如果 <code>size</code> 字节的对象始终为目标体系结构生成无锁原子指令，则返回 <code>true</code> ， <code>size</code> 必须解析为编译时常量，并且结果也解释为编译时常量。 <code>ptr</code> 是一个可选的指针，指向可以用于确定对齐的对象，为 0 表示应该使用典型的对齐方式，编译器也可能忽略此参数</li><li><code>bool __atomic_is_lock_free (size_t size, void *ptr)</code> 如果 <code>size</code> 字节的对象始终为目标体系结果生成无锁原子指令，则返回 <code>true</code> 。如果未知内置函数是无锁的，则会调用 <code>__atomic_is_lock_free</code> 的运行时例程。 <code>ptr</code> 是一个可选的指针，指向可以用于确定对齐的对象，为 0 表示应该使用典型的对齐方式，编译器也可能忽略此参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> gcc </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-kernel下</title>
      <link href="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/"/>
      <url>/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h1><h2 id="内核模式的中断处理"><a href="#内核模式的中断处理" class="headerlink" title="内核模式的中断处理"></a>内核模式的中断处理</h2><p>当一个进程获得一个 trap 时，会调用 <code>stvec</code> 寄存器中存储的 <code>uservec</code> 然后进入 <code>usertrap</code> 函数，在函数中会进入内核处理状态，并且将内核中断向量 <code>kernelvec</code> 写入到 <code>stvec</code> 寄存器中。所以在内核模式下发生中断的话会进入 <code>kernelvec</code> ，然后进入 <code>kerneltrap</code> 中。处理结束之后再从中退出到主管模式中去。在 <code>usertrapret</code> 中会将 <code>uservec</code> 写入 <code>stvec</code> 寄存器，然后退出用户模式，以此来保证用户模式下发生中断会在用户中断处理中进行处理</p><h3 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a>kernelvec</h3><p>这个是在内核模式下发生中断时运行的第一行代码，这里将会保存原先的内核寄存器，然后进入 <code>kerneltrap</code> 函数进行处理中断，然后返回之后重新加载寄存器，回到原来的进程继续处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        # 将栈指针减少 256 个字节，相当于是向下走 256 个字节，也就是分配栈空间</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line">    # 保存寄存器</span><br><span class="line">    # 栈是从上向下增长的</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">    ...</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        # 调用该函数处理设备中断</span><br><span class="line">        # 如果是定时器中断，做 yield，在某一段时间之后会返回到这里来</span><br><span class="line">        call kerneltrap</span><br><span class="line">    # 将所有寄存器的数据加载回到对应的寄存器中</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        # 有可能回来时是另一个内核在运行，就不需要读取原先的数据了</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">      ...</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line">        # 这里相当于释放掉栈内存了</span><br><span class="line">        addi sp, sp, 256</span><br><span class="line">        # 继续在内核模式运行用户模式下的中断的 处理</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><h3 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h3><p>被 <code>kernelvec</code> 调用，在这里处理内核模式下产生的中断</p><p>其中设备中断对应的 <code>devintr()</code></p><ul><li>0：error</li><li>1：UART/DISK</li><li>2：TIMER</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kerneltrap</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 保存 sepc 寄存器，为了回到原来的状态和代码</span></span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  <span class="comment">// 保存内核控制和状态寄存器</span></span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  <span class="comment">// 中断原因</span></span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"> <span class="comment">// 不在内核模式</span></span><br><span class="line">  <span class="keyword">if</span> ((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="comment">// 确保中断被关闭</span></span><br><span class="line">  <span class="keyword">if</span> (intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((which_dev = devintr()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 如果是 2 号，切换进程</span></span><br><span class="line"> <span class="comment">// 做的检测为：2号中断（定时器中断）+当前有进程（防止位于schedler）+当前进程在运行</span></span><br><span class="line">  <span class="keyword">if</span> (which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"> <span class="comment">// yield 中可能会发生很多事，所以需要提前保存 sepc 和 sstatus 以保证进程能返回到之前的地方</span></span><br><span class="line">  <span class="comment">// 在 kernelvec 中会复制这两个寄存器</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="devintr"><a href="#devintr" class="headerlink" title="devintr"></a>devintr</h3><p>用于检查是否是一个外部的中断或者是软件中断，并且进行处理。返回值</p><ul><li>2：定时器中断</li><li>1：其它设备</li><li>0：错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devintr</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 读取中断原因</span></span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">      (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>) &#123;</span><br><span class="line">   <span class="comment">// 这是通过 PLIC 的 Supervisor 外部中断</span></span><br><span class="line">   <span class="comment">// 通过 irq 来指明哪个设备产生的中断</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (irq == UART0_IRQ) &#123;</span><br><span class="line">     <span class="comment">// 串口中断处理</span></span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (irq == VIRTIO0_IRQ) &#123;</span><br><span class="line">     <span class="comment">// 磁盘设备中断处理</span></span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (irq) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// PLIC 允许每个器件一次最多发出一个中断</span></span><br><span class="line">  <span class="comment">// 告诉 PLIC 设备现在允许再次中断</span></span><br><span class="line">    <span class="keyword">if</span> (irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scause == <span class="number">0x8000000000000001</span>L) &#123;</span><br><span class="line">   <span class="comment">// 来自于机器模式下的定时器中断所引起的软件中断</span></span><br><span class="line">  <span class="comment">// 如果是 0 号内核发生的，调用 clockintr 时钟中断处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (cpuid() == <span class="number">0</span>) &#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 通过清除 sip 中的 SSIP 位来清除软件中断标志，从而可以进入下一个软件中断</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clockintr"><a href="#clockintr" class="headerlink" title="clockintr"></a>clockintr</h3><p>在函数中就是将全局的计数器自增。由于 xv6 中没有真实的时钟，只能通过这种方式来计时。 全局变量 <code>ticks</code> 被自旋锁 <code>tickslock</code> 所保护。自增之后唤醒所有正在等待时钟信号的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clockintr</span><span class="params">()</span> &#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PLIC"><a href="#PLIC" class="headerlink" title="PLIC"></a>PLIC</h2><p>平台级中断控制器。例如对于一个计算机，会有很多 I/O 设备，例如磁盘，键盘等。例如当按下键盘一个按键时，系统获得一个输入到 <code>PLIC</code> ，然后它需要被分配到某个内核中去处理。 <code>PLIC</code> 通知 <code>cpu</code> 有一个待处理中断，其中一个 <code>cpu</code> 会 <code>claim</code> 接收中断。所以一旦有数据输入就会产生一个中断，然后 CPU 会通过总线直接与设备通信，然后获得设备的信息。 <code>cpu</code> 处理完中断后会通知 <code>PLIC</code> ，然后 <code>PLIC</code> 接收到通知就会移除掉这个中断信息</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714123472559.png" alt="1714123472559.png"></p><p>这是一个大的使能矩阵，也是一个位的矩阵，展示了哪个设备可以将中断发送到哪个内核里，这个大的使能矩阵在初始化过程中被设置，并且不会改变。其中如果是 1 就表示该设备的中断可以被该内核处理，否则不可以被该内核处理</p><h3 id="PLIC硬件连接"><a href="#PLIC硬件连接" class="headerlink" title="PLIC硬件连接"></a>PLIC硬件连接</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714134410202.png" alt="1714134410202.png"></p><p><code>PLIC</code> 连接着设备和内核，并且设备和内核和与主存之间有着互相连接的总线（如图所示）。所以如果一个内核想要读或者写主存，它会发送一个请求到这个总线上，这个信号将被送到主存和内核中。如果内核想要操作某一个设备，一般会使用内存映射的 I/O 寄存器，所以这些设备每一个都映射到某一个物理地址空间中。而且 <code>PLIC</code> 也会映射到某一个物理地址，所以它将会在初始化时被设置，其中有一些寄存器需要其中一个内核在初始化的时候去设置。</p><p>当内核想要操作设备或者是对主存进行操作时，需要向总线上写入一个请求，然后对应的设备或者主存就会进行相应的操作。其中对于一个设备想要传输给内核一个数据时，需要通过 <code>PLIC</code> ，由 <code>PLIC</code> 通知 CPU 有一个设备中断，然后对应的 CPU 就会向总线上发送请求然后获取该设备的数据。</p><p>有一些设备会被设置在芯片上被认为是内核，其它的被认为是外部设备。一般来说一个芯片上会有多个内核，而 <code>PLIC</code> 被综合到芯片上作为一个内核。以前是被分开在不同的芯片上的，因为单个芯片不支持多核</p><p><code>PLIC</code> 处理中断流程：</p><ol><li>外部中断源发送中断请求，相对应的中断 <code>gateway</code> 处理请求</li><li>中断 <code>gateway</code> 将处理好的请求转至给 <code>PLIC</code> 内核，同时响应外部中断源的中断 <code>pending</code> 挂起，也就是对应中断源的 <code>pending</code> 位置位（<code>SOURCE INTERRUPT PENDING BIT</code> 置为 1）</li><li><code>PLIC</code> 根据配置对多个中断请求进行仲裁，并将仲裁胜利的中断通知给中断目标——内核</li><li>内核接收到中断请求，向 <code>PLIC</code> 内核发送一个请求 <code>claim</code> ，拿到最高优先级的 <code>pending</code> 中断的 id<ul><li>读 <code>claim</code> 寄存器， <code>PLIC</code> 内核清除相对应的外部中断源的 <code>pending</code> 位，这个不是全局中断的 <code>pending</code> 位（EIP），并且这时 <code>gateway</code> 不能将同一个外部中断源的下一个中断请求转进来，因为 <code>gateway</code> 没有收到服务完成通知，清除 <code>pending</code> 位只是表示相对应的外部中断源的中断请求 <code>pending</code> 状态结束，因为这时候中断请求已经开始被处理，并且将其从仲裁队列中删除，也就是不参与接下来的仲裁</li></ul></li><li>中断内核执行中断处理，处理完成之后向对应的 <code>gateway</code> 发送中断完成消息，也就是向 <code>compete</code> 寄存器中写入中断 id 值</li><li>中断 <code>gateway</code> 收到之前中断服务完成之后，这时候同一个外部中断源的下一个中断请求可以进入 <code>gateway</code> 中</li></ol><h3 id="当-pending-被置位时"><a href="#当-pending-被置位时" class="headerlink" title="当 pending 被置位时"></a>当 <code>pending</code> 被置位时</h3><ol><li>所有在使能矩阵中对该设备使能的内核都会被通知，其中需要决定哪一个内核去处理这个中断，被选中的内核将会做<ol><li>一个外部中断被挂起</li><li>如果此时这个内核使能中断，一个 trap 将会发生，否则不会发生（挂起）</li></ol></li><li>当 trap 发生时，在中断处理代码中第一件事就是配合 <code>PLIC</code> 请求 (claim）中断。在 claim 中发生的是<ol><li>读取一个 <code>PLIC</code> 中的一个内存映射寄存器，将会得到中断设备的 id 号</li><li><code>PLIC</code> 将会清除这个 <code>SOURCE INTERRUPT PENDING BIT</code></li></ol></li><li>多个内核被通知时，都会请求 claim 中断<ol><li>只有一个内核将会得到中断的 id 号，其它的都会返回 0</li></ol></li><li>中断处理程序将会运行并且处理设备中断</li><li>处理信号，中断处理结束，下一个中断的信号可以进来<ol><li>写入在 <code>PLIC</code> 中的内存映射寄存器，写入中断完成标志</li></ol></li><li><code>PLIC</code> 将会查看 <code>SOURCE INTERRUPT PENDING BIT</code><ol><li>当其再次被置位时， <code>PLIC</code> 产生另一个中断信号</li></ol></li></ol><h3 id="level-sensitive"><a href="#level-sensitive" class="headerlink" title="level sensitive"></a>level sensitive</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714140321883.png" alt="1714140321883.png"></p><p><code>PLIC</code> 将会检查该线上的电平，如果是高电平将会产生一个中断，然后进行中断处理。中断处理结束之后会再次检查线上的电平，如果还是高电平，不论中间发生了什么，都会再次产生一个中断信号。如果检测到是一个低电平信号，那就不产生中断信号</p><h3 id="edge-triggered"><a href="#edge-triggered" class="headerlink" title="edge triggered"></a>edge triggered</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714140750272.png" alt="1714140750272.png"></p><p>当从低电平变为高电平，这个上升沿将会产生一个中断信号，有两种 <code>gateway</code> 的方式</p><ul><li>one bit<ul><li>获得边沿上升信号时设置位</li><li>保持置位直到中断处理结束，如果期间有上升沿信号产生也不会去处理，忽略掉</li></ul></li><li>counter<ul><li><code>gateway</code> 会有一个计数器</li><li>每一个上升沿计数器增加</li><li>当中断处理开始执行，计数器自减</li><li>处理完成之后，如果计数器依旧是正数就产生下一个中断信号</li></ul></li></ul><h3 id="details-and-complictaions"><a href="#details-and-complictaions" class="headerlink" title="details and complictaions"></a>details and complictaions</h3><ul><li>设备号为 1-1023，0 代表 none</li><li>每一个内核可以包含超过一个硬件线程（hardware thread，hart）<ul><li><code>SUPERSCALAR/SIMMULTANEOUS MULTITHEREADING</code> 即 <code>SMT</code>，想法是核心同时运行两个线程</li></ul></li><li>在 risc-v 中，处于每一种模式下都可以被中断，但是中断只可能会被发送到机器模式和主管模式</li><li>上述内容被称为多目标，也就是每一个设备，每个核心都是一个单独的目标，而且每种模式都是其中的一个单独的目标，所以算起来一共有 15782 种目标，也就是该规范可以处理 15782 种不同的目标，尽管实际的物理实现不可能处理这么多的设备或者说是目标</li><li>每一个设备都被设置了一个优先级，对于高优先级的中断通常会率先处理</li><li>每一个内核（目标）都被分配了一个阈值<ul><li>如果设备优先级超过了内核的阈值，设备只会中断内核</li></ul></li></ul><h3 id="PLIC-Memory-Mapped-Registers"><a href="#PLIC-Memory-Mapped-Registers" class="headerlink" title="PLIC Memory-Mapped Registers"></a>PLIC Memory-Mapped Registers</h3><p>平台级中断控制器。一个进程通过读取和写入内存映射的 I/O 寄存器来控制平台级中断控制器，它们将会占用一定的内存</p><p>下面是这些寄存器</p><ul><li>设备优先级寄存器： 1023 * 4 bytes，这些优先级在启动时初始化。通过将所有设备写入或者存储到这些特定的位置来设置优先级</li><li>使能位矩阵：1023 * 15782 bits，将在启动时初始化</li><li>每个核心的优先级阈值：15782 * 4 bytes，将在启动时初始化</li><li>挂起位（待处理位）：1023 * 1 bit，可以看到哪个设备有待处理的中断</li><li>声明字：15782 * 4 bytes，每一个目标都有一个声明字，可以加载到 <code>CLAIM</code> 或者存储到 <code>COMPLETE</code> 。<ul><li><code>CLAIM</code>：当有一个中断发生时，在特定的内核上发出信号，该内核将从特定的位置上加载一个四字节的值，该值将会是请求中断的设备的 id，或者当其它内核首先达到该位置时，该值可能是 0</li><li><code>COMPLETE</code> ：完成完整的操作通过存储到该字中来完成的，在这中情况下，存储到该字中的值就是刚刚处理完中断的设备的 id 号</li><li>一个内核可能会同时处理多个中断，并且它可以声明多个中断，并且独立完成几个</li></ul></li></ul><p>以上的所有内存映射都被存储到一个 64 MB 内存大小的位置。但是其中有很多保留位和未被使用的位，所以在映射中不会全部映射</p><h3 id="PLIC处理"><a href="#PLIC处理" class="headerlink" title="PLIC处理"></a>PLIC处理</h3><p>实际上在 <code>xv6</code> 中，是通过 qemu 来仿真的，也就是没有真实的物理电路来实现此操作，都是虚拟仿真的</p><p>在 xv6 中的 CPU 的数量是由代码中的 <code>NCPU</code> 宏定义决定的，正好是 8。在 qemu 中，中断只能被发送到机器模式或者是主管模式，而且有 8 个 CPU，所以就有 16 个目标。但是在实际使用中，几乎不会用到机器模式中断，所有的中断都发生在主管模式。而且实际中一共有两个设备会产生中断，对应的 id 号</p><ul><li>1： <code>VIRTIO0_IRQ</code> 虚拟设备 I/O 磁盘</li><li>10： <code>UART0_IRQ</code> 串口设备</li></ul><p>所以在初始化时会有</p><ul><li>设置两个设备的优先级都为 1</li><li>每个核心都为设备设置使能位，也就是每个内核都能处理两个设备的中断，任何设备都能中断任何内核。也就是说，该中断会向所有的内核发送中断信号，只有最快最空闲的内核会率先得到声明该中断，然后进行中断处理，而其它之后声明的得到的就是 null，所以首先声明的内核就是期望的内核（更快的处理中断信息）</li><li>每个内核都将中断阈值设置为 0，这将不会阻止任何中断</li></ul><h3 id="一些宏定义"><a href="#一些宏定义" class="headerlink" title="一些宏定义"></a>一些宏定义</h3><ul><li><code>PLIC</code> 平台级中断控制器的虚拟地址空间，这里只映射了 4MB，实际上这里应该映射 64 MB 的内存空间，但是实际上没有影响</li><li><code>PLIC_PRIORITY</code> 平台级中断控制器的优先级</li><li><code>PLIC_PENDING</code> 平台级中断控制器的待处理位</li><li><code>PLIC_MENABLE(hart)</code> 平台级中断控制器的对应内核下的机器模式使能位</li><li><code>PLIC_SENABLE(hart)</code> 平台级中断控制器的对应内核下的主管模式使能位</li><li><code>PLIC_MPRIORITY(hart)</code> 平台级中断控制器的对应内核下的机器模式优先级</li><li><code>PLIC_SPRIORITY(hart)</code>平台级中断控制器的对应内核下的主管模式优先级</li><li><code>PLIC_MCLAIM(hart)</code> 平台级中断控制器的对应内核下的机器模式下的 <code>CLAIM</code> 存储的地址</li><li><code>PLIC_SCLAIM(hart)</code> 平台级中断控制器的对应内核下的主管模式下的 <code>CLAIM</code> 存储的地址</li></ul><h3 id="plicinit"><a href="#plicinit" class="headerlink" title="plicinit"></a>plicinit</h3><p>将所有设备的优先级设置为 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set desired IRQ priorities non-zero (otherwise disabled).</span></span><br><span class="line">  *(uint32*)(PLIC + UART0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">  *(uint32*)(PLIC + VIRTIO0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="plicinithart"><a href="#plicinithart" class="headerlink" title="plicinithart"></a>plicinithart</h3><p>对于每一个内核都为内核模式设置使能位为串口和虚拟磁盘设备，然后设置优先级阈值为 0，不会阻止任何中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinithart</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set enable bits for this hart&#x27;s S-mode</span></span><br><span class="line">  <span class="comment">// for the uart and virtio disk.</span></span><br><span class="line">  *(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set this hart&#x27;s S-mode priority threshold to 0.</span></span><br><span class="line">  *(uint32*)PLIC_SPRIORITY(hart) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="plic-claim"><a href="#plic-claim" class="headerlink" title="plic_claim"></a>plic_claim</h3><p>声明中断，也就是询问 <code>PLIC</code> 应该处理哪个中断，并且读取中断的设备 id 号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">plic_claim</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line"> <span class="comment">// 如果获得 0，就立即返回，否则对相应的中断做出处理</span></span><br><span class="line">  <span class="type">int</span> irq = *(uint32*)PLIC_SCLAIM(hart);</span><br><span class="line">  <span class="keyword">return</span> irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="plic-complete"><a href="#plic-complete" class="headerlink" title="plic_complete"></a>plic_complete</h3><p>完成中断的处理，向其中写入完成中断处理的设备 id 号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plic_complete</span><span class="params">(<span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  *(uint32*)PLIC_SCLAIM(hart) = irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="磁盘设备"><a href="#磁盘设备" class="headerlink" title="磁盘设备"></a>磁盘设备</h3><p>当把数据传输到主存或者从主存中传输数据时，都是以字节为单位的。对于磁盘，使用更大的单位来传输，称作 <code>BLOCK</code> 块。在 xv6 中 <code>BLOCK</code> 是固定大小的字节，每一个块的大小为 1024 个字节 <code>BSIZE</code> ，其它系统用也会使用不同大小的块，但是其大小总是固定的。而磁盘只不过被视作块的序列，所以编号从 0，1，2 开始。第二个块也就是 <code>BLOCK1</code> 是一个特殊的块，包含 <code>superblock</code> ，它的内容是固定的，不会改变，包含很多参数，其中包含记录磁盘中块的数量的参数，也就是磁盘中有多少个块是可用的，以便存储在磁盘中文件系统</p><p>有时候会使用扇区 <code>SECTOR</code> 来进行数据的读写，有时候它们被用作同义使用，但是却是不同的事情，一般来说扇区比块要小一些。</p><p>但是如果让操作系统按照块的大小对磁盘进行读写，那就可以忽略磁盘驱动器不同的扇区的 大小，如果要对一整个磁盘或者块进行读写，这将导致设备驱动程序读写多个扇区。由于磁盘是一个旋转的设备，会有不同的延迟，对不同的扇区进行读写时，需要等待磁盘转动到特定的地方才能进行读写。通过将扇区分组为一个块就可以确保当读取或者写入大多数扇区时都是顺序读取的，所以就只需要确定第一个扇区读取的第一个位置就可以了，其它的读取都可以直接顺序进行，这就会极大的提高效率。</p><p>但是实际上使用块作为读写内存的单位，这将导致文件的最小大小就是一个块的大小，而且文件的最后一页也占据着一整块，这将导致内存的浪费，但是性能确实提高。</p><p>而在 xv6 中，使用的是 qemu 进行的系统仿真，所以其中的磁盘设备是 <code>VIRTIO-DISK</code> ， 这个东西是标准化设备驱动程序和实际硬件之间的接口的尝试，有着不同的接口，例如 <code>virtio</code> ， <code>uart</code> 以及其它 xv6 系统中不使用的一些东西</p><h3 id="virtio-disk-rw"><a href="#virtio-disk-rw" class="headerlink" title="virtio_disk_rw"></a>virtio_disk_rw</h3><p>可以进行读写操作</p><ul><li>读： <code>virtio_disk_rw(buf_ptr, 0)</code></li><li>写： <code>virtio_disk_rw(buf_ptr, 1)</code></li></ul><p>该函数第一个参数是指向缓冲区的 <code>buff</code> 结构的指针，并且这个缓冲区将包含足够的空间用于块（1024 bytes）。第二个参数就是操作的特定编号，0 表示读取，1 表示写入。在 xv6 中，该函数没有任何错误报告，也不会有任何返回值，如果出现任何故障，将会屏蔽故障，并且在函数中进行处理。如果发生簧片故障，校验和故障或者其它问题，那么扇区或者块就会重新读取，直到在模拟器中获取到数据。由于该磁盘是在主机上的文件系统模拟的，但是也会出现一些问题</p><p>这个函数可能会休眠，例如要读取一个缓冲区，该函数将进行读取操作，然后将进入 <code>sleep</code> ，当请求读取操作完成之后，磁盘将会发送一个中断，然后进入磁盘中断处理程序，并且将唤醒此函数，然后开始读写操作。需要注意的是，这个函数中的指令不会被编译器重新排序，而是完全按照调用该函数的顺序执行的操作</p><h3 id="buf"><a href="#buf" class="headerlink" title="buf"></a>buf</h3><p>这个结构体用于磁盘上块的缓存，结构体内有固定数量的缓冲区，这些缓冲区在内核启动时预先被分配，通过宏定义控制 <code>buf</code> 的数量。每一个 <code>buf</code> 结构体中都有一个块的内存（缓冲区），也就是 1024 bytes，每一个 <code>buf</code> 都有一个关于数据块的编号，用于确定位于缓冲区中的是哪个数据块中的内容。还有一些其它的字段用于同步</p><p><code>buf</code> 可以是空闲的，也可以是被使用中，所以有一个空闲的缓冲区列表，其它的都是被使用中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid; <span class="comment">// 表示该缓冲区是否包含对应块编号的数据，布尔量，或者是它是否包含着垃圾</span></span><br><span class="line">       <span class="comment">// 如果没有该磁盘的数据，就需要读取它</span></span><br><span class="line">  <span class="type">int</span> disk;  <span class="comment">// 完全在磁盘驱动程序中使用，也就是只在磁盘设备的读写操作中使用</span></span><br><span class="line">       <span class="comment">// 实际上就是告诉磁盘，当前是否正在进行读写操作</span></span><br><span class="line">  uint dev; <span class="comment">// 设备号</span></span><br><span class="line">  uint blockno; <span class="comment">// 显示当前缓冲区中的数据来自于哪个块，对应块的编号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// 睡眠锁，用于保护数据，valid, disk</span></span><br><span class="line">  uint refcnt; <span class="comment">// 引用计数，如果计数为 0，那就是当前未被使用，如果愿意可以回收用于其它地方</span></span><br><span class="line">        <span class="comment">// 如果大于 0，那就不能用于其它用途</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// 指向上一个</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span> <span class="comment">// 链表指向下一个</span></span><br><span class="line">  uchar data[BSIZE]; <span class="comment">// 1024 个字节的空间</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h3 id="bcache"><a href="#bcache" class="headerlink" title="bcache"></a>bcache</h3><p>缓冲区缓存 <code>buff cache</code> 是 buf 结构的链表，用于保存磁盘块内容的缓存副本。 在内存中缓存磁盘块可减少磁盘读取次数，并为多个进程使用的磁盘块提供同步点。</p><p>这个结构体是用来管理 <code>buf</code> 的，实际上是把 <code>buf</code> 组织成一个双向链表，如图</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714192009190.png" alt="1714192009190.png"></p><p>其中第一个是一个特殊的 <code>buf</code> 就是双向循环链表的头部，它不会包含任何数据，只是用于指向前一个或者是后一个的指针。而且结构体中一共有 30 个缓冲区，这些缓冲区在双向链表中的排序根据最近使用次数从大到小排序的，所以可以根据 <code>head</code> 的 <code>next</code> 指针找到最近使用的 <code>buf</code> ，根据 <code>head</code> 的 <code>prev</code> 指针找到最不常用的 <code>buf</code> 。使用双向循环链表来定位最近最少使用的元素，就可以轻松的删除一个元素。对于这个双向循环链表，只是在初始化的期间才会访问它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><p>其中的 <code>lock</code> 用于保护整个链表，其实就是保护 <code>next, prev, refcnt, dev, blockno</code> 等 <code>buf</code> 的元素，所以在获取缓冲区或者释放缓冲区时，都需要持有锁</p><p>该结构体有特定的接口</p><ul><li><code>bread</code> 获取特定磁盘块的缓冲区</li><li><code>bwrite</code> 更改缓冲区数据之后，将其写入磁盘</li><li><code>brelse</code> 使用完缓冲区之后释放缓冲区，调用完之后不能再次使用对应的缓冲区</li><li>同一个时刻只有一个进程能使用缓冲区，所以不要长期持有缓冲区</li></ul><p>对于这个双向链表的维护，为了按照使用的次数排序，可以在每次使用时都将其取出，然后放入时就将其放到较为开头的部分，从而可以实现使用次数少的缓冲区都在双向链表的尾部</p><h3 id="binit"><a href="#binit" class="headerlink" title="binit"></a>binit</h3><p>这个初始化函数在内核启动时调用</p><p><code>buf</code> 中有一些变量没被初始化，例如 <code>refcnt, dev, blockno</code> ，实际上这些变量被隐式初始化为 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"> <span class="comment">// 初始化缓冲区锁</span></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="comment">// 创建缓冲区的链表</span></span><br><span class="line">  <span class="comment">// 首先创建一个空的链表</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">   <span class="comment">// 将每个链表添加进来，这里的操作就是把每个缓冲区添加到头指针的下一个位置</span></span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">   <span class="comment">// 初始化每个缓冲区的睡眠锁</span></span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h3><p>寻找到一个对应设备号和磁盘块编号的缓冲区，如果没有，则从后往前找到一个引用数量为 0 的缓冲区，然后初始化该缓冲区，将其引用数量加一，然后设置为无效的缓冲区，之后会在 <code>bread</code> 中进行读取磁盘数据然后设置为有效的。在函数中会获得对应缓冲区的睡眠锁，因为会对缓冲区中的数据进行读写操作</p><p>在所有缓冲区中查看对应内存块的 <code>buf</code> ，如果未找到，需要分配缓冲区，无论哪种情况，都返回锁定的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="comment">// 访问循环链表需要获得锁</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"> <span class="comment">// 查找是否有对应磁盘的缓冲区，先从最常用的开始找</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">     <span class="comment">// 找到需要的缓冲区，增加引用计数</span></span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="comment">// 找到之后释放锁</span></span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没找到，找一个没人用的缓冲区，如果 refcnt&gt;0 则表示缓冲区正在被使用中</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 找到之后释放锁</span></span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓冲区全部被占用，直接报错</span></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bread"><a href="#bread" class="headerlink" title="bread"></a>bread</h3><p>该函数返回一个包含指定磁盘块内容的锁定的 <code>buf</code></p><p>如果当前已经有一个 <code>buf</code> 包含着该磁盘的内容，那就直接返回，否则就需要重新从磁盘中读取数据，然后设置为有效的缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"> <span class="comment">// 找到一个缓冲区</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="comment">// 没人用的缓冲区，需要读取磁盘内容</span></span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">   <span class="comment">// 读取 b 所对应的磁盘块的数据，其中 b 都被之前 的 bget 设置好了</span></span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bwrite"><a href="#bwrite" class="headerlink" title="bwrite"></a>bwrite</h3><p>向磁盘中写入缓冲区的内容，前提是必须持有该缓冲区的锁，用于保证每次只有一个进程对磁盘进行写入，防止发生数据竞争。该函数并不会释放缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="brelse"><a href="#brelse" class="headerlink" title="brelse"></a>brelse</h3><p>释放锁住的缓冲区，将缓冲区移动到双向循环链表的头部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  <span class="comment">// 释放睡眠锁</span></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line">  <span class="comment">// 对链表进行操作需要获取锁</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="comment">// 已经没有引用的设备了，但是它依旧保持着特定块的数据，并且设备和块编号依旧准确，以及有效标志位依旧置位</span></span><br><span class="line">  <span class="comment">// 所以未来需要对该块的调用能够重新使用它</span></span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bpin"><a href="#bpin" class="headerlink" title="bpin"></a>bpin</h3><p>固定缓冲区，或者说向缓冲区添加引用，如果其他人已经正在使用该缓冲区，可以使用该函数直接增加引用数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bunpin"><a href="#bunpin" class="headerlink" title="bunpin"></a>bunpin</h3><p>取消固定缓冲区，向缓冲区减少引用，允许其它线程来释放该缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="磁盘日志文件系统"><a href="#磁盘日志文件系统" class="headerlink" title="磁盘日志文件系统"></a>磁盘日志文件系统</h2><h3 id="文件系统崩溃"><a href="#文件系统崩溃" class="headerlink" title="文件系统崩溃"></a>文件系统崩溃</h3><p>首先看文件系统的崩溃</p><ul><li>复杂的数据结构</li><li>一个更新需要几个写入的操作</li><li>在其中可能会发生崩溃</li><li>数据结构可能处于一个不一致的状态</li></ul><p>例如一个单向链表，需要更改两个节点之间的位置，就需要更改三个指针，所以当崩溃发生在更改某一个指针时，这就会导致链表的顺序发生错误，也就是文件系统的数据结构出现了不一致的情况</p><p>这个问题要去解决需要解决文件系统的问题</p><ul><li>数据结构保存在磁盘上，并且用于表示文件，目录， <code>i-nodes</code> 和空闲映射</li><li>每次写入都会更新一整个块，并且特定的更新可能涉及多个块，可能需要将多个块写入磁盘</li><li>每次的崩溃都不允许将文件系统弄乱</li></ul><p>所以就是在发生更新时执行所有更改，没有发生更新时不执行任何更改</p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>对于一个文件，希望能增大文件的大小，需要两个操作</p><ul><li>从空闲池列表中删除一个块</li><li>将块添加到文件后执行数据结构更新</li></ul><p>这两个操作需要获得两个锁，空闲池链表的锁和块的锁。但是这时候计算机崩溃了，一个写入操作完成了，但是第二个操作未完成，那文件系统就会处于不一致的情况下</p><p><strong>方法1</strong></p><p>如果按照上述的顺序来执行，从空闲池中删除完一个块了，但是在添加到文件中之前计算机崩溃了，这将导致永久的丢失了一个块的内存，这样是肯定不行的。</p><p><strong>方法2</strong></p><p>先将块添加到文件中执行完数据结构更新，再从空闲池列表中删除。如果在添加完成之后发生崩溃，重启之后就会发现有一个块既处于空闲池列表中，也存在于文件中，这也是一个大问题</p><p><strong>目标</strong></p><p>要么两个操作都完成，要么两个操作都不执行</p><p>更普遍来说，将几个磁盘的更新分为一个事务组，每一个事务组要么什么都没有发生，要么已经执行结束</p><p><strong>在 xv6 中的实现</strong></p><p>调用程序的顺序就是</p><p><code>begin_op</code> → <code>bread</code> → … → <code>bread</code> → … → <code>log_write</code> → … → <code>log_write</code> → … → <code>end_op</code></p><p>在这个流程中， <code>begin_op</code> 相当于就是整个事务开始执行，然后 <code>end_op</code> 就是整个事务执行结束，而在最后的 <code>end_op</code> 将会将整个事务提交，进行更新，所以就是整个事务要么都发生，要么不发生，这操作就是延迟对磁盘的实际写入，将这写写入操作几乎放在一起完成</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714274647954.png" alt="1714274647954.png"></p><p>如图所示，在右侧的 <code>END</code> 处不进行写入 106 的操作，除非 103 和 108 写入操作也在执行，而且需要将 103 的写入操作移动到最后 <code>END</code> 处，与 108 写入操作一起执行。所以就是多个磁盘写入操作同时执行。直到这个事务的所有操作完成之后才进行提交操作</p><p>上述中所有事务操作都包含 <code>begin</code> ， <code>read</code> ， <code>write</code> ， <code>end</code> 四个操作</p><ul><li><code>begin</code> 这个操作是在 <code>begin_op</code> 函数中完成的，每一个事务的开始都需要调用该函数。如果另一个线程正在提交状态，那就进入睡眠等待。如果没有足够的日志块，那就进入睡眠等待。当一切正常时就增加一个计数器，这个计数器就是记录当前正在进行多少事务</li><li><code>read</code> 实际上就是调用 <code>bread</code> ，查找缓冲区高速缓存，如果找到对应的磁盘区的缓冲区就直接使用，否则重新选择一个缓冲区并且从磁盘中读取</li><li><code>write</code> 这个操作就是调用 <code>log_write</code> 来实现的。先 PIN 固定缓冲区，基本上就是给缓冲区设置一个标志来指示这个缓冲区不应该被释放。然后找到下一个可以使用的日志块，在 <code>header</code> 的日志数组中添加条目，然后将使用日志的数量增加<ul><li>实际上首先会先查找需要写入的块是否已经存在于日志块中，因为正在写入的块可能已经被写入，所以就直接使用该日志块就可以。</li></ul></li><li><code>end</code> 实际上是调用 <code>end_op</code> 函数。需要减少计数器，如果计数器 &gt; 0，那就什么都不做，立即返回。否则就意味着这是最后一个事务，可以继续进行提交，提交操作将执行所有写入操作，而在写操作中并没有实际写入磁盘，只是将内容保存到内存中。写入之后清空日志，可以唤醒所有被卡在 <code>begin</code> 操作的进行</li></ul><h3 id="磁盘分布"><a href="#磁盘分布" class="headerlink" title="磁盘分布"></a>磁盘分布</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714279447324.png" alt="1714279447324.png"></p><p>其中每个小方块都代表着磁盘上的一个块，而磁盘不过是一组连续的块</p><ul><li>其中 <code>Boot</code> 是引导记录或者主引导记录</li><li><code>SUPERBLOCK</code> 包含很多固定参数，是只读的，在启动时内核将读取这个块，其中还包含日志块开始的位置以及数量，主块区开始的位置以及数量和磁盘上一共有多少个块</li><li>其中日志块是由一个标头和一块用于存储多个日志块的地址，在 xv6 中正好是 30 块，实际上日志块并不会考虑主块区域的组织形式，所以在它看来不过是一组块的集合<ul><li>标头块在启动时被读入内存并且存储在一个结构中，所以这是保存在内存中的结构体，并且时不时的需要写回到磁盘上。包含一个计数 <code>n</code> ，用来存储正在使用的日志块的数量。并且每一块日志在数组中都有一个条目，所以这个计数 <code>n</code> 用于说明多少个日志块正在被使用，数组元素正在使用中</li></ul></li><li>主块区域是文件系统的存储位置，文件系统包含各种内容，目录，文件，索引节点等</li></ul><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>这个操作涉及到四个函数</p><ul><li><code>commit</code> 提交操作</li><li><code>write_log</code> 写入日志</li><li><code>write_head</code> 写入日志标头</li><li><code>install_trans</code> 将被提交的块复制到磁盘中</li></ul><p>提交有两个阶段</p><ul><li>将块的更新的版本移动到磁盘上的日志区域中，然后将日志表头写入磁盘，如果崩溃发生在写入标头之前，这些操作将不会发生，如果在写入标头之后，这些操作将会成功执行</li><li>遍历日志数组，将块写入磁盘的主块区域。写入完成之后，将 <code>header</code> 中的计数器设为 0，然后将其写回到磁盘中</li></ul><h3 id="Crash-Reboot"><a href="#Crash-Reboot" class="headerlink" title="Crash + Reboot"></a>Crash + Reboot</h3><p>重启需要调用的函数</p><ul><li><code>initlog</code> 初始化日志文件</li><li><code>fsinit</code> 初始化文件系统</li><li><code>recover_from_log</code> 从日志中恢复</li><li><code>install_trans</code> 将被提交的块复制到磁盘中</li><li><code>read_head</code> 读取日志标头</li><li><code>write_head</code> 写入日志标头</li></ul><p>发生崩溃之后重启，进行的操作有</p><p>由于重启是不知道系统是否崩溃的，所以无论是否发生过崩溃，开机时都会读取日志标头。</p><ul><li>如果标头的计数器为 0，那就什么也不做，也就是进行的事务由于崩溃而丢失，将被忽略，这样事务或者提交就不会发生。</li><li>如果标头的计数器不为 0，那就是成功将标头数据写入到了磁盘中，所以需要重新进行提交的第二个操作，以保证所有的内容都被写入到了主存中</li></ul><p>一旦成功，就可以将标头的计数器设为 0，然后将标头写入到磁盘中</p><h3 id="logheader"><a href="#logheader" class="headerlink" title="logheader"></a>logheader</h3><p>日志标头，包含一个计数器 <code>n</code> 和 <code>LOGSIZE</code> 个日志块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>所有与日志操作相关的变量都集合在这个结构体中，而且这个结构体只有一个实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>lock</code> 用于保护 <code>outstanding</code> 和 <code>committing</code> 两个变量</li><li><code>start</code> 表示日志在磁盘上开始的位置，常量，实际上是日志标头的地址</li><li><code>size</code> 表示日志在磁盘上的大小，常量</li><li><code>outstanding</code> 一个计数器，每次执行开始操作时，都会增一，执行结束操作时都会减一</li><li><code>committing</code> 一个布尔量。如果正处于提交中，这个标志位将置为 <code>true</code> ，这会导致其它操作处于等待状态</li><li><code>dev</code> 设备，一般来说一个设备对应着一个 <code>log</code> 结构体，但是在 xv6 中只有一个磁盘设备，但是依旧保留了此字段，用于表示当前日志是哪个设备的日志</li></ul><h3 id="initlog"><a href="#initlog" class="headerlink" title="initlog"></a>initlog</h3><p>初始化日志，这个函数在内核启动时被调用，这个函数被 <code>fsinit</code> 函数调用，而 <code>fsinit</code> 在第一次调用 <code>forkret</code> 函数时调用。在这个函数中需要执行一些恢复操作，执行恢复操作时可能需要访问磁盘，这就涉及到了 <code>sleep</code> ，所以需要在用户模式下运行，所以在 <code>forkret</code> 中调用。这个函数在第一个时间片中调用，作为用户模式的第一部分运行</p><p>传入的参数为</p><ul><li><code>dev</code> 初始化的设备编号</li><li><code>sb</code> 对应的 <code>superblock</code> 的地址</li></ul><p>函数中做的操作：首先初始化锁，初始化一些固定的变量，之后从日志中恢复数据。在 <code>recover_from_log</code> 中会先读取头块，如果 <code>n</code> 非 0，它将执行恢复操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog;</span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op"></a>begin_op</h3><p>每一个事务开始时需要调用，这个函数主要做的就是增加未完成的事务的计数器，该计数器受到 <code>log.lock</code> 这个自旋锁保护。首先需要检查是否有其它线程正在提交，是否有足够的日志块来执行该事务，不满足条件就会进入 <code>sleep</code> ，并且将 <code>log.lock</code> 短暂的释放掉，当其它进程完成提交操作之后就会唤醒该进程，被唤醒之后还需要重新检查是否满足条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="log-write"><a href="#log-write" class="headerlink" title="log_write"></a>log_write</h3><p>在调用时已经修改 <code>b-&gt;data</code> 并且完成缓冲区，通过增加 <code>refcnt</code> 在缓存中记录块号和 <code>pin</code> ，实际上这个函数并不执行实际的写入操作，但是会安排这个写入操作，可能会做更多的修改，并且再次调用 <code>log_write</code> 操作写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">// 修改日志之前需要获得锁</span></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">// 检查是否有足够的空间来执行操作，在 begin_op 中已经进行过一次，这里还要检查一次</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="comment">// 确保正处于某个事务之中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">   <span class="comment">// 查看是否已经有一个日志块保存着该块的内容，否则就会使得 i=n，这就是一个可用的条目</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorption</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用存储块号来更新下一个可用条目，进行覆盖操作</span></span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">   <span class="comment">// 将块锁定，以至于不会用于其它块，直到写入磁盘操作之后</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="comment">// 将该块的编号写入数组中</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="end-op"><a href="#end-op" class="headerlink" title="end_op"></a>end_op</h3><p>用于事务结束的操作，会在每个文件系统系统调用之后执行，如果当前事务是最后一个事务，提交数据，也就是把数据写入磁盘中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">// 当前操作完成，将正在执行的事务的数量减一</span></span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 如果有一个事务正在提交</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="comment">// 最后一个事务，执行提交操作</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 提交操作中</span></span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// begin_op 可能正在等待日志空间，而减少 log.outstanding 会减少保留空间量</span></span><br><span class="line">    <span class="comment">// 唤醒其它正在等待的进程，在 begin_op 中等待</span></span><br><span class="line">    <span class="comment">// 当前执行结束之后，不需要保留额外的日志空间，所以可能会有足够的日志空间来开始某一个事务</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"> <span class="comment">// 开始执行提交操作</span></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">  <span class="comment">// 调用 commit</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="comment">// 清除提交标志位</span></span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>提交操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 首先检查计数器，如果有一些事务的话 n&gt;0，否则的话 n=0，就不会做任何操作</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// 会将缓冲区中所有的块写入到磁盘上的日志区域</span></span><br><span class="line">    write_head();    <span class="comment">// 将该日志的标头复制到磁盘块，该块位于磁盘上的日志文件中</span></span><br><span class="line">    <span class="comment">// 在 write_head 之后执行提交完成的所有操作都会被保存，即使崩溃也会从日志中恢复</span></span><br><span class="line">    <span class="comment">// 如果之前的话，就相当于没有这些事务操作</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// 将日志写入到对应磁盘主块区域中的实际位置</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>; <span class="comment">// 事务数量设置为 0</span></span><br><span class="line">    write_head();    <span class="comment">// 将日志标头写入到磁盘中，使得 n 恢复到 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write-log"><a href="#write-log" class="headerlink" title="write_log"></a>write_log</h3><p>将修改后的块从缓冲区写入到日志文件中，这个函数仅仅在 <code>commit</code> 中调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"> <span class="comment">// 对日志中保存的所有块进行操作</span></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">   <span class="comment">// 获得保存日志块的缓冲区，将日志块读入缓冲区</span></span><br><span class="line">   <span class="comment">// 这里 +1 是因为 start 对应着标头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="comment">// 获得对应的缓存块，该块被固定了，所以会被找到，这里并没有实际从磁盘中读取</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    <span class="comment">// 移动数据</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    <span class="comment">// 从缓冲区写入到日志区域</span></span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    <span class="comment">// 释放缓冲区</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write-head"><a href="#write-head" class="headerlink" title="write_head"></a>write_head</h3><p>将日志标头写入到磁盘中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 获得对应块缓冲区</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="comment">// 该标头块中保存的就是一个标头结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">   <span class="comment">// 将计数器中的保存的日志块直接存储到标头中</span></span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入磁盘，释放缓冲区</span></span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="install-trans"><a href="#install-trans" class="headerlink" title="install_trans"></a>install_trans</h3><p>在 <code>commit</code> 函数中被调用，从日志中复制提交的块到磁盘空间中，将缓冲区中对应的块写入到对应的磁盘区域中。如果在提交函数中调用 <code>recovering=false</code> ，如果在恢复函数中调用就是 <code>recovering=true</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">   <span class="comment">// 如果在提交操作中，就已经从磁盘中读取了，所以这里实际上不需要从磁盘中读取了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="comment">// 获得对应的缓存块，该块被固定了，所以会被找到，这里并没有实际从磁盘中读取</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="comment">// 如果是提交操作，就不再固定对应的缓冲区。</span></span><br><span class="line">    <span class="comment">// 如果是恢复操作，本来就没有固定缓冲区，也就不需释放</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);</span><br><span class="line">    <span class="comment">// 释放缓冲区</span></span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="recover-from-log"><a href="#recover-from-log" class="headerlink" title="recover_from_log"></a>recover_from_log</h3><p>从日志中恢复数据，这个函数仅被 <code>initlog</code> 调用，只在初始化时调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  read_head();</span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-head"><a href="#read-head" class="headerlink" title="read_head"></a>read_head</h3><p>从磁盘中读取日志标头结构体，仅被 <code>recover_from_log</code> 中调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">read_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">lh</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 将从磁盘中读到的日志的标头数据存储到日志标头中</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = lh-&gt;n;</span><br><span class="line">  <span class="comment">// 这里实际上可以使用 memmove 函数实现，但是这样的操作可以避免复制一些不必要的块</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="built_in">log</span>.lh.block[i] = lh-&gt;block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="磁盘布局"><a href="#磁盘布局" class="headerlink" title="磁盘布局"></a>磁盘布局</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714493100090.png" alt="1714493100090.png"></p><p>在磁盘上只有一组连续的磁盘块，对磁盘操作的几个函数</p><ul><li><code>bread</code> 提供磁盘的块号，它从缓存中分配一个缓冲区，将磁盘块读入内存并且返回一个缓冲区指针，</li><li><code>log_write</code> 提供一个指向缓冲区的指针，将缓冲区的数据写回到磁盘上。实际上这个函数并不执行实际的写入操作，但是会安排这个写入操作，可能会做更多的修改，并且再次调用 <code>log_write</code> 操作写入</li><li><code>brelse</code> 释放该磁盘块的缓冲区，在 <code>bread</code> 与 <code>brelse</code> 之间，缓冲区被强制独占，该缓冲区只有该线程可以访问</li></ul><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714545779066.png" alt="1714545779066.png"></p><p>这是更加细致的磁盘布局</p><ul><li><code>Boot Record</code> 引导块，既不被内核读取，也不修改的块，仅在引导和启动过程中使用，以便将内核加载到内存中</li><li><code>SUPER BLOCK</code> 里面包含很多参数，被内核读取，但是不会被修改，记录磁盘上其它项目的位置</li><li><code>Log</code> 日志块</li><li><code>inodes</code> 每个 <code>inode</code> 都是固定大小的，并且被存储到一个数组中，数组被保存在这些块中，这些块仅用来分配 <code>inode</code> 的存储</li><li><code>BitMap</code> 在这里面，磁盘上的每一块都对应着一个位，用来表示该块是否正在使用，这对于数据块很有用。但是这里面只有 1000 个块，也就有 1000 个位与之对应，其中前 41 个块都是被使用中<ul><li>1：被使用中</li><li>0：空闲</li></ul></li><li><code>Data Blocks</code> 这里是文件和目录实际存储的地方</li></ul><h3 id="文件系统-2"><a href="#文件系统-2" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统包含一个单个目录树以及其中的一堆文件。而所有的这些目录都位于一个设备上，例如磁盘或者 USB 驱动器。目录被组织为一棵树，没有循环，但是不是有向无环图。</p><p>下图是一个文件系统的示例，其中红色表示文件目录，绿色表示文件。可以看出目录是一棵树，除了根目录以外，每个目录都有父目录。对于文件来说可能有多个父目录。如图所示，文件并没有文件名，只是通过路径来引用它，还可以用另一个路径引用同一个文件</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714525386772.png" alt="1714525386772.png"></p><p>由于目录本身就是一个文件，所以在 xv6 中多种文件类型</p><ul><li>常规文件</li><li>目录</li><li>设备</li></ul><p>但是在 unix/linux 中实现了其它的标准的文件系统 <code>POSIX</code> ，但是这些在 xv6 中是无法使用的。例如</p><ul><li><code>char device</code></li><li><code>block device</code></li><li><code>symbolic link</code></li><li><code>named pipe</code></li><li><code>sockets</code></li></ul><h3 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h3><p>POSIX（Portable Operating System Interface，可移植操作系统接口）是由 IEEE（Institute of Electrical and Electronics Engineers）定义的一组操作系统接口标准。它的目标是为应用程序提供一套与操作系统无关的接口，使得这些应用程序能够在不同的 POSIX 兼容系统上编译和运行。</p><p>POSIX 标准包含了进程管理、文件管理、网络通信、线程和同步、信号处理等方面的功能。这些接口定义了函数、数据类型和常量等，为开发者提供了一个可移植的方法来与操作系统进行交互</p><p>POSIX 接口的设计基于 Unix 操作系统的经验和理念。它通过定义一组通用的 API，将底层操作系统的功能封装起来，从而提供了与具体操作系统无关的高级功能。</p><p>POSIX 接口定义了一系列函数、数据类型和常量，这些接口分为不同的模块，涵盖了进程管理、文件管理、网络通信、线程和同步、信号处理等各个方面的功能。开发者可以使用这些接口来编写可移植的应用程序，而无需关心底层操作系统的实现细节。</p><p>以下是 <code>POSIX</code> 标准定义的主要接口，包括 <code>ioctl</code> 接口</p><ul><li>进程管理接口<ul><li><code>exit</code>：进程终止</li><li><code>fork</code>：创建子进程</li><li><code>wait</code>：等待子进程结束</li></ul></li><li>文件管理<ul><li><code>open</code>：打开文件</li><li><code>close</code>：关闭文件</li><li><code>read</code>：读取文件内容</li><li><code>write</code>：写入文件内容</li></ul></li><li>目录管理<ul><li><code>opendir</code>：打开目录</li><li><code>readdir</code>：读取目录项</li><li><code>closedir</code>：关闭目录</li></ul></li><li>网络通信<ul><li><code>socket</code>：创建套接字</li><li><code>bind</code>：绑定套接字到地址</li><li><code>listen</code>：监听传入连接</li><li><code>accept</code>：接受传入连接</li></ul></li><li>线程和同步<ul><li><code>pthread_create</code>：创建线程</li><li><code>pthread_join</code>：等待线程结束</li><li><code>pthread_mutex_lock</code>：加锁互斥量</li><li><code>pthread_cond_signal</code>：发送条件变量信号</li></ul></li><li>信号处理<ul><li><code>signal</code>：注册信号处理函数</li><li><code>kill</code>：向进程发送信号</li><li><code>sigaction</code>：设置信号处理动作</li></ul></li><li>时间和日期<ul><li><code>time</code>：获取当前时间</li><li><code>clock</code>：获取时钟时间</li><li><code>strftime</code>：格式化时间</li></ul></li><li>共享内存<ul><li><code>shmget</code>：获取共享内存标识符</li><li><code>shmat</code>：连接到共享内存</li><li><code>shmdt</code>：分离共享内存</li></ul></li><li><code>ioctl</code> 接口<ul><li><code>ioctl</code>：控制设备操作</li></ul></li></ul><p>POSIX 接口在很多场景中有广泛的应用，为开发者提供了一种标准化、可移植的方法来编写应用程序</p><ul><li>系统编程：POSIX 接口提供了开发者直接访问底层操作系统功能的能力，适用于系统级别的开发任务</li><li>跨平台开发：POSIX 接口的可移植性使得开发者能够在多个 POSIX 兼容的操作系统上进行编译和运行，从而实现跨平台开发</li><li>高性能计算：POSIX 接口提供了线程和同步机制的支持，适用于并行和并发的高性能计算任务</li><li>嵌入式系统开发：POSIX 接口的轻量级特性使其成为嵌入式系统开发的重要工具，可以方便地控制硬件资源和执行实时任务</li></ul><h3 id="Hard-Links"><a href="#Hard-Links" class="headerlink" title="Hard Links"></a>Hard Links</h3><p>在 xv6 和 unix/linux 中都实现了硬链接。常规文件有多个指向它的硬链接，也就是一个常规文件可以有多个父项。但是每个目录文件只能有一个父项，就是说文件系统必须是一棵树，不能是一个图。硬链接需要所有的链接的文件都位于一个文件系统中</p><h3 id="Symbol-Links"><a href="#Symbol-Links" class="headerlink" title="Symbol Links"></a>Symbol Links</h3><p>符号链接有时候称作 <code>soft link</code> 软链接，但是在 xv6 中没有实现软链接。符号链接就是另一种文件类型。符号链接的文件中没有包含数据，只是包含了一个路径名，当用到该链接文件时，就直接使用链接文件中目录来定位目标文件的位置。而且符号链接可能会有错误，也就是链接的是一个不存在的路径。符号链接一个有点就是可以指向其它文件系统中的某一个设备文件</p><h3 id="i-number"><a href="#i-number" class="headerlink" title="i-number"></a>i-number</h3><p>每一个文件有一个不唯一的路径名称，可以更改，是内核使用一个数字来识别和处理文件，也就是 <code>i-number</code> ，这个数字是一个整数，在创建文件时将其分配给文件，当文件被删除之后，可以将其回收，重新用于新的文件。对于目录是有固定的 <code>i-number</code> ，为 1，以便内核可以定位根目录。文件系统的编号从 1 开始，用 0 表示未使用</p><h3 id="i-node"><a href="#i-node" class="headerlink" title="i-node"></a>i-node</h3><p>是一个小型的固定大小的结构体，保存在磁盘上，不保存在任何文件中，保存在磁盘中单独的某个区域内，因此在磁盘的某个位置本质上有个数组，该数组中有多个 <code>i-node</code> 结构体，当调用文件时，内核将会把 <code>i-node</code> 的数组加载到缓存中。这个结构体被保存在有编号索引的数组中，所以对应的编号就是隐式的编号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>type</code> 文件类型<ul><li>0：free，空闲的，可用于之后的文件</li><li>1： <code>T_DIR</code> 目录文件</li><li>2： <code>T_FILE</code> 常规文件</li><li>3： <code>T_DEVICE</code> 设备文件</li></ul></li><li><code>major</code> 主设备号，只在 <code>T_DEVICE</code> 文件类型中有效，是一个标识符，用于表示设备的类型</li><li><code>minor</code> 次设备号，只在 <code>T_DEVICE</code> 文件类型中有效，表示设备的编号<ul><li>主设备号与次设备号本质上就是设备号，设备号是 32 为整数，分为两个 16 位整数，高 16 位表示主设备号，低 16 位表示次设备号</li></ul></li><li><code>nlink</code> 在文件系统中，链接该文件的数目，也就是硬链接的数量</li><li><code>size</code> 文件的大小，单位是字节</li><li><code>addrs</code> 磁盘上块序号的队列</li></ul><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><p>与每个文件相关联的有几个属性</p><ul><li><code>i-number</code> 用于唯一标识每个文件</li><li><code>size</code> 需要知道问价的大小，多少个 <code>bytes</code></li><li><code>type</code> 用于说明文件的类型（directory，regular，device）</li><li><code>number of hard link</code> 硬链接的数量，也就是在树中父级的数量。如果没有硬链接，那就无法引用到该文件，所以当硬链接数量为 0 时，就会将文件的内存空间回收</li><li><code>location on disk</code> 数据在磁盘上存储的位置，基本上是有一个块号列表，用于存储文件数据用到的块号</li></ul><p>在 unix/linux 中有一些其他的附加属性</p><ul><li><code>modification date/timestamp</code> 文件创建的时间和最后修改的时间</li><li><code>owner</code> 文件的拥有者</li><li><code>permissions</code> 指示文件权限的标志，用于告诉用户如何访问该文件</li></ul><h3 id="Super-Block"><a href="#Super-Block" class="headerlink" title="Super Block"></a>Super Block</h3><p>这个结构体中包含了一些属性，只会被内核读取，但是不会被修改</p><ul><li><code>magic</code> 只是一个常量，系统在读取时，会检查这个数字以确保它具有正确的值。如果不是，可能表明这不是我们期望的文件系统类型或者出现了严重错误： <code>0x10203040</code></li><li><code>size</code> 在整个磁盘系统中一共有多少个块可用 <code>1000</code></li><li><code>nblocks</code> 数据块的数量 <code>959</code></li><li><code>ninodes</code> <code>inode</code> 的数量，这意味着文件的数量不能超过这个数字 <code>200</code></li><li><code>nlog</code> 日志块的数量 <code>30</code></li><li><code>logstart</code> 日志块开始的块号 <code>2</code></li><li><code>inodestart</code> <code>inode</code> 块开始的块号 <code>32</code></li><li><code>bmapstart</code> <code>bitmap</code> 开始的位置 <code>38</code></li></ul><p>这个结构体在启动时从磁盘读取，通过 <code>readsb</code> 来读取，然后它将永不会改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">  uint magic;        <span class="comment">// Must be FSMAGIC</span></span><br><span class="line">  uint size;         <span class="comment">// Size of file system image (blocks)</span></span><br><span class="line">  uint nblocks;      <span class="comment">// Number of data blocks</span></span><br><span class="line">  uint ninodes;      <span class="comment">// Number of inodes.</span></span><br><span class="line">  uint nlog;         <span class="comment">// Number of log blocks</span></span><br><span class="line">  uint logstart;     <span class="comment">// Block number of first log block</span></span><br><span class="line">  uint inodestart;   <span class="comment">// Block number of first inode block</span></span><br><span class="line">  uint bmapstart;    <span class="comment">// Block number of first free map block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>目录存储在文件中，因此对于每个目录都有一个文件，并且该文件包含许多块，目录信息是存储在这些块中的内容。</p><p>在 xv6 中目录表示位数组，每个数组条目都对应着一个名称和文件的引用编号。其中这个名称是不能大于 14 个字符的，对目录的查找就是将空字符作为名称的结尾的字符串的匹配，遍历寻找对应的文件名称。但是这样的查找效率太低了，所以最新的 unix/linux 对目录有着不同的组织结构，可以容纳更长的文件名称，而且也允许更快的查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h3><p>make file system 建立文件系统</p><p>它是独立的 C 程序，不属于 xv6 内核的一部分，也不是在内核模式下运行的一个用户程序。在主机上编译运行，当运行 <code>make</code> 文件时，它会编译 xv6 内核并且编译所有用户模式程序，并且还会编译此程序，并且运行此程序</p><p>它将创建磁盘映像文件，磁盘映像文件名为 <code>fs.img</code> ，这是主机上的一个文件，将会被 qemu 来模拟磁盘，所以磁盘的所有内容都将保存在该文件系统，每当对磁盘进行读写操作，实际上都是对该文件的操作。将会初始化磁盘，并且创建整个文件系统，创建目录树，并将许多文件放入其中，所以当内核启动时，会发现文件系统已经存在。初始化磁盘所做的事情为</p><ul><li>写入 <code>superblock</code></li><li>初始化所有的 <code>inodes</code></li><li>初始化 <code>bitmap</code></li><li>创建目录结构，并且初始化目录文件</li><li>对于用户文件，即用户模式可执行文件，将会创建一个文件，并将其添加到文件系统目录中</li></ul><p>所以执行结束之后，映像文件将包含一个完整的文件系统，以便内核可以启动并找到文件系统。在 unix/linux 中也有类似的函数，不过不是初始化 <code>fs.img</code> 文件，而是初始化设备，它将会编写初始化该文件结构的组织所需要的任何内容，这将会比 xv6 更加复杂</p><h2 id="dinode"><a href="#dinode" class="headerlink" title="dinode"></a>dinode</h2><p>数组 <code>dinode</code> 从特定编号的块开始，这个值位于 <code>spuerblocks</code> 中，用于找到该数组的起始位置，它们之间尽可能地紧密排列在一起，在一个块中放入尽可能多的 <code>inode</code> ，然后剩下的空间就是空闲的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>type</code> 文件类型<ul><li>0：free，空闲的，可用于之后的文件</li><li>1： <code>T_DIR</code> 目录文件</li><li>2： <code>T_FILE</code> 常规文件</li><li>3： <code>T_DEVICE</code> 设备文件</li></ul></li><li><code>major</code> 主设备号，只在 <code>T_DEVICE</code> 文件类型中有效，是一个标识符，用于表示设备的类型</li><li><code>minor</code> 次设备号，只在 <code>T_DEVICE</code> 文件类型中有效，表示设备的编号<ul><li>主设备号与次设备号本质上就是设备号，设备号是 32 为整数，分为两个 16 位整数，高 16 位表示主设备号，低 16 位表示次设备号</li></ul></li><li><code>nlink</code> 在文件系统中，链接该文件的数目，也就是硬链接的数量，一般来说根目录的链接数为 0</li><li><code>size</code> 文件的大小，单位是字节，只在 <code>T_FILE</code> 文件类型中有效</li><li><code>addrs</code> 磁盘上块序号的队列，正好有 12 个。如果文件大小增长超过 12 个块的大小，那就会使用间接块，因此最后一个指针可以指向磁盘上的某一块，这一块中存储的就是其他磁盘的块号或者是指向其它块的指针。由于块号大小为 4 字节，所以可以将 256 个额外的指针打包进去。所以在 xv6 中，文件的限制大小是有限的。但是在 unix/linux 中，会有二级间接块甚至三级间接块，也就是间接块中的每个块号都是指向的一个间接块，这样得到的最大文件大小会很大。但是在 xv6 中只有一级间接块</li></ul><p>在内存中有关于 <code>dinode</code> 的缓存结构，是一个大小为 50 的 <code>inode</code> 数组，当初始化时，磁盘中会保存 <code>dinode</code> 的数据，而在使用 <code>dinode</code> 时，就会先将其从磁盘中读出来，放在内存的这个缓冲区中。</p><h3 id="itable"><a href="#itable" class="headerlink" title="itable"></a>itable</h3><p>这里是个 <code>inode</code> 的数组，用于存放 <code>inode</code> 的缓存，一共是 50 个缓存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; itable;</span><br></pre></td></tr></table></figure><h3 id="缓存inode"><a href="#缓存inode" class="headerlink" title="缓存inode"></a>缓存inode</h3><p>这里面存储的就是 <code>inode</code> 的缓存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上这个缓存 <code>inode</code> 与之前的块的缓存是类似的，其中</p><ul><li><code>dev</code> 设备号，用于识别文件</li><li><code>inum</code> <code>inode</code> 的编号，用于识别文件，在每一个文件系统中都是唯一的，如果有多个文件系统，就需要靠着 <code>dev</code> 来识别文件了</li><li><code>ref</code> 引用数量，如果是 0，那就说明是空闲的，可以用于缓存不同的索引节点</li><li><code>lock</code> 睡眠锁，将会保护 <code>valid</code> 和下面的 <code>inode</code> 字段</li><li><code>valid</code> 是否有效，用于设置是否数据已经从磁盘中读入了，只有是 1 的时候才是读入完成</li></ul><p>剩下的就是 <code>dinode</code> 的内容了。其中 <code>dev</code> ， <code>inum</code> ， <code>ref</code> 这些都受到 <code>itable</code> 中的 <code>lock</code> 的保护</p><h3 id="devsw"><a href="#devsw" class="headerlink" title="devsw"></a>devsw</h3><p>是一个数组，正好包含 10 个元素，由 <code>NDEV</code> 给定，主设备数，实际上，每个元素在数组中的排序就是它的设备号。每一个数组元素都是一个结构体，结构体中包含两个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*read)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*write)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，其中 <code>1</code> 号元素就是控制台 <code>console</code> ，所以这个函数指针就会指向 <code>consoleread</code> 和 <code>consolewrite</code> ，本质上控制台就是 1 号设备</p><p>对于上述的函数，其中</p><ul><li>参数1：一个布尔值<ul><li>0：内核地址</li><li>1：用户虚拟地址</li></ul></li><li>参数2：地址</li><li>参数3：字节长度</li></ul><p>由于上述函数是函数指针，所以对于不同的设备，可以使用不同的函数</p><h3 id="fs-h"><a href="#fs-h" class="headerlink" title="fs.h"></a>fs.h</h3><ul><li><code>ROOTINO</code> 文件系统根块的地址</li><li><code>BSIZE</code> 块的尺寸</li><li><code>superblock</code> 在启动时读入的块，包含许多不改变的参数</li><li><code>FSMAGIC</code> 只能赋值给 <code>superblock.magic</code></li><li><code>NDIRECT</code> 直接块的数量</li><li><code>NINDIRECT</code> 间接块的数量</li><li><code>MAXFILE</code> 最大文件数量，是由 <code>NDIRECT</code> 与 <code>NINDIRECT</code> 决定的</li><li><code>dinode</code> 在磁盘上的 <code>inode</code> 结构体，其中 <code>addr</code> 是个 13 个长度的数组</li><li><code>IPB</code> 每一块中 <code>inode</code> 的数量，如果不能正好放进去，那就会有一点空闲空间，由块的大小和结构体的大小决定</li><li><code>IBLOCK</code> 磁盘上哪个块包含特定的 <code>inode</code></li><li><code>BPB</code> 每一块中包含的 <code>bitmap</code> 的数量，一个 <code>bitmap</code> 是一个位</li><li><code>BBLOCK</code> 磁盘上的那个块包含着特定的 <code>bitmap</code></li><li><code>DIRSIZ</code> 目录的大小，也就是文件的大小，不能超过 14 个字符</li><li><code>dirent</code> 目录，包含着编号 <code>inode number</code> 和目录名称</li></ul><h3 id="fs-c"><a href="#fs-c" class="headerlink" title="fs.c"></a>fs.c</h3><p>这个文件中的所有函数都是默认在一个事务中处理的</p><ul><li><code>itable</code> 保存 <code>inode</code> 缓存的结构体，有一个自旋锁和一个将用于缓存的 <code>inode</code> 数组</li><li><code>superblock sb</code> 这个结构体应当是每个设备都对应一个，但是在 xv6 中只是用一个设备，所以只有一个</li></ul><h3 id="file-h"><a href="#file-h" class="headerlink" title="file.h"></a>file.h</h3><ul><li><code>file</code> 文件结构体，定义了一些关于文件的东西，之后再说</li><li><code>major</code> 主设备号位于设备号的高 16 位</li><li><code>minor</code> 次设备号位于设备号的低 16 位</li><li><code>mkdev</code> 创建设备号</li><li><code>inode</code> 位于内存中的 <code>inode</code> 结构体，实际上用作缓存</li><li><code>devsw</code> 映射主设备号到对应的设备功能上，每个结构包含两个函数指针</li><li><code>CONSOLE</code> 定义控制台的设备号为 1</li></ul><h3 id="file-c"><a href="#file-c" class="headerlink" title="file.c"></a>file.c</h3><ul><li><code>devsw</code> 主设备数组</li></ul><h3 id="either-copyout"><a href="#either-copyout" class="headerlink" title="either_copyout"></a>either_copyout</h3><p>复制到用户地址或内核地址，具体取决于 <code>user_dst</code> 。成功时返回0，错误时返回-1</p><p>其中</p><ul><li><code>user_dst</code> 布尔值，表示目标地址是用户地址或内核地址<ul><li>1：用户虚拟地址</li><li>0：内核地址</li></ul></li><li><code>dst</code> 目标地址</li><li><code>src</code> 源数据</li><li><code>len</code> 传输数据长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">either_copyout</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">void</span> *src, uint64 len)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span> (user_dst) &#123;</span><br><span class="line">    <span class="keyword">return</span> copyout(p-&gt;pagetable, dst, src, len);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memmove((<span class="type">char</span> *) dst, src, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="either-copyin"><a href="#either-copyin" class="headerlink" title="either_copyin"></a>either_copyin</h3><p>从用户地址或内核地址复制，具体取决于 <code>user_src</code> 。成功时返回0，错误时返回-1</p><p>其中</p><ul><li><code>dst</code> 目标地址</li><li><code>user_dst</code> 布尔值，表示源数据地址是用户地址或内核地址<ul><li>1：用户虚拟地址</li><li>0：内核地址</li></ul></li><li><code>src</code> 源数据地址</li><li><code>len</code> 传输数据长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">either_copyin</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> user_src, uint64 src, uint64 len)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span> (user_src) &#123;</span><br><span class="line">    <span class="keyword">return</span> copyin(p-&gt;pagetable, dst, src, len);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memmove(dst, (<span class="type">char</span> *) src, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iinit"><a href="#iinit" class="headerlink" title="iinit"></a>iinit</h3><p>用于初始化 <code>inode</code> 缓存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 初始化保护 inode 缓存队列中的一个锁</span></span><br><span class="line">  initlock(&amp;itable.lock, <span class="string">&quot;itable&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NINODE; i++) &#123;</span><br><span class="line">   <span class="comment">// 初始化所有缓存的睡眠锁，其中每个结构体中有个引用数量字段，默认初始化为 0</span></span><br><span class="line">    initsleeplock(&amp;itable.inode[i].lock, <span class="string">&quot;inode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fsinit"><a href="#fsinit" class="headerlink" title="fsinit"></a>fsinit</h3><p>初始化文件系统，包括调用 <code>readsb</code> ，读取 <code>superblock</code> 数据，从磁盘中读取，并将其存储在 <code>sb</code> 结构体中。传入的参数为</p><ul><li><code>dev</code> 设备号，初始化对应设备的文件系统</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line"> <span class="comment">// 从磁盘中读取 superblock</span></span><br><span class="line">  readsb(dev, &amp;sb);</span><br><span class="line">  <span class="comment">// 验证是否包含期望的文件系统，文件系统是否正确初始化</span></span><br><span class="line">  <span class="keyword">if</span>(sb.magic != FSMAGIC)</span><br><span class="line">    panic(<span class="string">&quot;invalid file system&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始化日志，在这之后可以创建事务，可以调用 begin_op end_op 等</span></span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readsb"><a href="#readsb" class="headerlink" title="readsb"></a>readsb</h3><p>从磁盘中读取对应文件系统的 <code>superblock</code> 数据，并将其存储在 <code>sb</code> 结构体中</p><ul><li><code>dev</code> 设备号，对应文件系统</li><li><code>sb</code> 用于存储对应文件系统的 <code>superblock</code> 数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">readsb</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"> <span class="comment">// 读取编号为 1 的块到缓冲区中，返回指向该缓冲区的指针</span></span><br><span class="line">  bp = bread(dev, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 将其复制到 sb 中</span></span><br><span class="line">  memmove(sb, bp-&gt;data, <span class="keyword">sizeof</span>(*sb));</span><br><span class="line">  <span class="comment">// 释放块</span></span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bzero"><a href="#bzero" class="headerlink" title="bzero"></a>bzero</h3><p>将一整个块都写入 0，这将写入磁盘，这个函数仅在 <code>balloc</code> 中调用。传入的参数为</p><ul><li><code>dev</code> 设备号</li><li><code>bno</code> 块号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bzero</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> bno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"> <span class="comment">// 读缓存中对应的块（在 balloc 调用时，一定位于缓存中）</span></span><br><span class="line">  bp = bread(dev, bno);</span><br><span class="line">  <span class="comment">// 设置为 0</span></span><br><span class="line">  <span class="built_in">memset</span>(bp-&gt;data, <span class="number">0</span>, BSIZE);</span><br><span class="line">  <span class="comment">// 改变了块，写入到日志中，这会在事务中被处理，写入到磁盘中</span></span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="balloc"><a href="#balloc" class="headerlink" title="balloc"></a>balloc</h3><p>在分配块的时候使用，分配一个置零的磁盘块。如果磁盘空间不足，则返回 <code>NULL</code> 。查找一个未使用的块，并且在 <code>bitmap</code> 中置 1，指示它正在使用，并且返回块的编号，参数为</p><ul><li><code>dev</code> 设备号，也就是从对应的文件系统分配一个块</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"> <span class="comment">// 其中 bp 是位图缓冲区， b+bi 是找到的空闲块的块号</span></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">   <span class="comment">// BBLOCK 就是查看 b 块位于位图中的那一块，然后读这一块的数据到缓存中</span></span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="comment">// 遍历所有该位图块中的位，找到一个能用的块</span></span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;</span><br><span class="line">     <span class="comment">// 用这个来找到位于哪个字节内的哪一位</span></span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free?</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">        <span class="comment">// 这里由于修改了位图中的一位，所以需要写回磁盘</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        <span class="comment">// 释放块</span></span><br><span class="line">        brelse(bp);</span><br><span class="line">        <span class="comment">// 将该块归 0</span></span><br><span class="line">        bzero(dev, b + bi);</span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放对应的块，继续下一个位图</span></span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没找到可用的区块</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;balloc: out of blocks\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个函数的搜索做的并不是很好，例如：查找空闲的位图可以按字来搜索，是否为 <code>0xff</code> ，否则就包含空闲块，按位搜索太费时间。而且这里是使用线性搜索，遍历所有的位来找空闲位，实际上太费时间了。可以利用链表+栈来实现，将空闲的块放入栈中，每次分配都从栈中推出，然后进行分配，每一个链表的元素都是一个栈（块），当这个元素分配完之后再进行下一个栈的分配，回收就是反过来</p><h3 id="bfree"><a href="#bfree" class="headerlink" title="bfree"></a>bfree</h3><p>使用完块之后需要释放掉，将对应的块号放回到对应的文件系统中，文件中的块返回空闲池，释放时只需要找到位图中的对应位并且更改它就可以了</p><ul><li><code>dev</code> 设备号</li><li><code>b</code> 对应的块号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line"> <span class="comment">// 读取对应的位图块到缓存中</span></span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="comment">// 如果对应的块已经是未使用的，报错</span></span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  <span class="comment">// 实际上只是把这一位设置为 0</span></span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  <span class="comment">// 写入日志中</span></span><br><span class="line">  log_write(bp);</span><br><span class="line">  <span class="comment">// 释放块</span></span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ialloc"><a href="#ialloc" class="headerlink" title="ialloc"></a>ialloc</h3><p>在创建新文件时使用，在对应的文件系统中分配一个 <code>inode</code> ，返回一个指向分配的 <code>inode</code> 的指针。</p><p>具体内容就是从磁盘上找到一个未使用的 <code>inode</code> ，用 <code>type=0</code> 来表示空闲，然后设置类型来指示已经被使用，然后调用 <code>iget</code> 并且返回一个指向 <code>inode</code> 的指针</p><p>在设备 <code>dev</code> 上分配一个 <code>inode</code> ，通过给它类型 <code>type</code> 将它标记为已分配。返回一个未锁定但已分配和引用的 <code>inode</code> ，如果没有空闲的 <code>inode</code> 则返回 <code>NULL</code></p><p>该函数仅在创建文件的系统调用 <code>create</code> 中调用，用来创建一个 <code>type</code> 类型的新文件</p><p>传入的参数</p><ul><li><code>dev</code> 对应的文件系统，在那个文件系统创建文件</li><li><code>type</code> 新文件类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"> <span class="comment">// 查找所有的 inum，找到空闲的 inode 来分配，从 1 开始，只有 199 个文件</span></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">   <span class="comment">// inode 所在块的块号</span></span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    <span class="comment">// inode 的具体地址</span></span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode</span></span><br><span class="line">     <span class="comment">// 将块置 0</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ialloc: no inodes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iget"><a href="#iget" class="headerlink" title="iget"></a>iget</h3><p>查找设备 <code>dev</code> 上编号为 <code>num</code> 的 <code>inode</code> 并返回内存副本（缓存）。不锁定 <code>inode</code> ，也不从磁盘读取它</p><p>如果对应编号的 <code>inode</code> 正处于缓存中，那就使用它，否则直接返回一个新的 <code>inode</code> 并且设置好，但是不从磁盘中读取，不论如何都会将其引用数量 +1，用以指示它是被使用中。但是未从磁盘中读取，也不锁定，把它的 <code>valid=0</code> ，用来表示没有从磁盘中读取，还是无效的</p><p>传入的参数为</p><ul><li><code>dev</code> 设备号</li><li><code>inum</code> 对应的 <code>inode</code> 编号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"> <span class="comment">// 查找在缓存中是否有该 inode 的缓存，如果有，那就将其引用+1，返回，否则初始化一个未使用的 inode 缓存并且返回</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;itable.inode[<span class="number">0</span>]; ip &lt; &amp;itable.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;itable.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle an inode entry.</span></span><br><span class="line">  <span class="comment">// 缓存满了，都被用掉了</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line"> <span class="comment">// 这里的数据设置受到 itable.lock 的保护</span></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ilock"><a href="#ilock" class="headerlink" title="ilock"></a>ilock</h3><p>给对应的 <code>inode</code> 上锁，如果它是无效的 <code>inode</code> ，就从磁盘中读取，存储到这个缓存中</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"> <span class="comment">// 确认有被引用</span></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"> <span class="comment">// 获取睡眠锁，睡眠锁保护其中的位于磁盘中的 inode 字段</span></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"> <span class="comment">// 如果无效的缓存，那就需要从磁盘中读取数据了</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="comment">// 磁盘数据读到缓存中，找到 inode 所在的块</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    <span class="comment">// 找到 inode 确切地址</span></span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里需要保证类型不为 0，也就是被使用</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iunlock"><a href="#iunlock" class="headerlink" title="iunlock"></a>iunlock</h3><p>给对应的 <code>inode</code> 解锁，释放其睡眠锁</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 一些检查</span></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iupdate"><a href="#iupdate" class="headerlink" title="iupdate"></a>iupdate</h3><p>将修改后的内存 <code>inode</code> 写回到磁盘。必须在每次更改 <code>inode</code> 的字段后调用。调用方必须持有该 <code>inode</code> 的锁。</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iupdate</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line">  <span class="comment">// 获取 inode 所在的块，读入缓存，并且找到对应的 inode</span></span><br><span class="line">  bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">  dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">  <span class="comment">// 这里是把所有数据都更新了</span></span><br><span class="line">  dip-&gt;type = ip-&gt;type;</span><br><span class="line">  dip-&gt;major = ip-&gt;major;</span><br><span class="line">  dip-&gt;minor = ip-&gt;minor;</span><br><span class="line">  dip-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">  dip-&gt;size = ip-&gt;size;</span><br><span class="line">  memmove(dip-&gt;addrs, ip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">  <span class="comment">// 将缓存写入日志，用于之后写入磁盘</span></span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="idup"><a href="#idup" class="headerlink" title="idup"></a>idup</h3><p>需要增加引用计数时可以调用该函数，这个引用计数受到 <code>itable.lock</code> 的保护</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">idup</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 修改引用数需要持有 table 锁</span></span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line">  <span class="comment">// 引用数增加</span></span><br><span class="line">  ip-&gt;ref++;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iput"><a href="#iput" class="headerlink" title="iput"></a>iput</h3><p>删除对内存中索引节点的引用。如果这是最后一次引用，则可以回收 <code>inode</code> 表项。如果这是最后一个引用，并且 <code>inode</code> 没有指向它的链接，则释放磁盘上的 <code>inode</code> (及其内容)。所有对 <code>input</code> 的调用都必须在事务内部，以防必须释放索引节点</p><p>如果该 <code>inode</code> 的引用数为 1（表示当前是最后一个引用的文件了）并且硬件链接是 0，就会释放掉这个 <code>inode</code> 和与之相关的空间。锁上这个 <code>inode</code> ，将文件长度截断为 0，并将其文件类型设置为 0 以表示未使用，调用 <code>iupdate</code> 更新 <code>inode</code> ，将其写回到磁盘中，释放掉锁</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"> <span class="comment">// 将删除该文件</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="comment">// ip-&gt;nlink == 0 表示 inode 没有链接，也没有其他引用</span></span><br><span class="line">   <span class="comment">// free.ip-&gt;ref == 1 表示没有其他进程可以锁定 IP，</span></span><br><span class="line">   <span class="comment">// 因此此 acquiresleep() 不会阻塞（或死锁）</span></span><br><span class="line">    <span class="comment">// 修改下面的变量需要获得锁</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line">  <span class="comment">// 这里可以释放锁，也可以不释放锁，但是有可能下面的操作会花费很多时间，所以就释放锁了</span></span><br><span class="line">    release(&amp;itable.lock);</span><br><span class="line">  <span class="comment">// 将文件截断为 0</span></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 更新对应的 inode，写入磁盘</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">    <span class="comment">// 设置为无效，这个是缓存中的数据，这里应该为了防止它被使用，在下面会出现两个锁都未持有的情况</span></span><br><span class="line">    <span class="comment">// 所以可能会出现被其它进行调用这个缓存，而且在处理完之后再将 ref-- 也是为了防止被重用</span></span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;itable.lock);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 减少引用数，如果减少到 0，就可以被重用，否则将持续存在</span></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iunlockput"><a href="#iunlockput" class="headerlink" title="iunlockput"></a>iunlockput</h3><p>释放对应的 <code>inode</code> 的锁，并且调用 <code>iput</code> 函数</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlockput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  iunlock(ip);</span><br><span class="line">  iput(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h3><p>索引节点的内容。与每个 <code>inode</code> 相关联的内容(数据)以块的形式存储在磁盘上，第一个 <code>NDIRECT</code> 块编号列在 <code>ip-&gt;addr[]</code> 中。下一个 <code>NDIRECT</code> 块列在块 <code>ip-&gt; address[NDIRECT]</code> 中。返回 <code>inode ip</code> 中第n块的磁盘块地址。如果没有这样的块， <code>bmap</code> 会分配一个。如果磁盘空间不足，则返回 0。</p><p>函数会查找直接的和间接的指针，用来定位磁盘上的块，它将会计算其块号。如果对应的块号没有被分配（不在文件中），那将会分配一个空闲的块，然后更新 <code>inode</code> 将该块添加到该文件 <code>inode</code> 中，并且会将该块归 0</p><p>该函数仅在 <code>readi</code> 和 <code>writei</code> 中被调用，在 <code>readi</code> 中不会分配块，而在 <code>writei</code> 中可能会分配块</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li><li><code>bn</code> 需要申请的第几个文件块，如果超过了直接引用的块数，那就放在间接引用中，如果也满了，就会报错</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"> <span class="comment">// 小于直接引用块号</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[bn] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"> <span class="comment">// 小于间接引用块号</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">        a[bn] = addr;</span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="itrunc"><a href="#itrunc" class="headerlink" title="itrunc"></a>itrunc</h3><p>截断 <code>inode</code> 文件大小为 0，会丢弃其中的内容，释放所有的数据块，设置大小为 0，调用 <code>iupdate</code>，调用该函数时必须持有该 <code>inode</code> 的锁.</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"> <span class="comment">// 释放掉所有直接块</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">     <span class="comment">// 在其中会将对应的位图中的块置为 0，表示未使用</span></span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      <span class="comment">// 指向的块号设置为 0 表示未使用</span></span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 如果不为 0，最后一个块号指向的是间接块</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">// 释放所有间接块</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">     <span class="comment">// 如果间接块存在</span></span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="comment">// 释放最后一块</span></span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stati"><a href="#stati" class="headerlink" title="stati"></a>stati</h3><p>只是将一些数据从缓存 <code>inode</code> 中复制数据到 <code>stat</code> 中去，调用者必须持有该 <code>inode</code> 的锁</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li><li><code>st</code> 指定的 <code>stat</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">stati</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="keyword">struct</span> stat *st)</span></span><br><span class="line">&#123;</span><br><span class="line">  st-&gt;dev = ip-&gt;dev;</span><br><span class="line">  st-&gt;ino = ip-&gt;inum;</span><br><span class="line">  st-&gt;type = ip-&gt;type;</span><br><span class="line">  st-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">  st-&gt;size = ip-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readi"><a href="#readi" class="headerlink" title="readi"></a>readi</h3><p>从 <code>inode</code> 读取数据到目标地址。调用方必须持有该 <code>inode</code> 的锁，成功的话返回写入的字节数，如果写入失败就返回 -1</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li><li><code>user_dst</code> 布尔值<ul><li>1：用户虚拟地址</li><li>0：内核地址</li></ul></li><li><code>dst</code> 目标地址</li><li><code>off</code> 从文件中获取数据的偏移量</li><li><code>n</code> 传输的字节数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"> <span class="comment">// 检查是否偏移大于文件大小和传输字节数 &gt; 0</span></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果传输字节 + 开始地址 &gt; 文件大小，则截断，也就是传输最多到文件结尾</span></span><br><span class="line">  <span class="comment">// 这里的 size 是当前文件的大小，不包括未分配的文件块</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"> <span class="comment">// 每次循环传输多个字节</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">   <span class="comment">// 读取对应块中的数据， off/BSIZE 就是对应的偏移所在的块号</span></span><br><span class="line">    uint addr = bmap(ip, off/BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    <span class="comment">// 下一步传输的数据数量，从当前位置到块的结尾，要保证所有数据都能读到</span></span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="comment">// 复制函数</span></span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="comment">// 失败了</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      tot = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="writei"><a href="#writei" class="headerlink" title="writei"></a>writei</h3><p>从源数据地址写入数据到 <code>inode</code> 对应的文件中，调用方法时必须持有锁，返回成功写入的字节数，如果小于 <code>n</code> 意味着出错了</p><p>传入的参数</p><ul><li><code>ip</code> 指定的 <code>inode</code></li><li><code>user_src</code> 布尔值<ul><li>1：用户虚拟地址</li><li>0：内核地址</li></ul></li><li><code>src</code> 源数据地址</li><li><code>off</code> 向文件中写入数据的偏移量</li><li><code>n</code> 传输的字节数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"> <span class="comment">// 应当从文件末尾或者文件中部开始写入，保证 n &gt; 0</span></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 超过了最大文件大小</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="comment">// 这里与 readi 类似</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    uint addr = bmap(ip, off/BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    <span class="comment">// 传输数据数量，剩余数据/该块剩余大小</span></span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 写入了新的内容，将 size 更新</span></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line">    ip-&gt;size = off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write the i-node back to disk even if the size didn&#x27;t change</span></span><br><span class="line">  <span class="comment">// because the loop above might have called bmap() and added a new</span></span><br><span class="line">  <span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">  <span class="comment">// 上面写入的操作实际上有可能使得 bmap 创建了一个新块，所以需要更新 inode</span></span><br><span class="line">  iupdate(ip);</span><br><span class="line"> <span class="comment">// 返回传输的总数目</span></span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="namecmp"><a href="#namecmp" class="headerlink" title="namecmp"></a>namecmp</h3><p>用于比较文件名称是否相同，直接调用字符串比较，比较的最大值就是 <code>DIRSIZ</code> 就是名称的最大字符数——14 字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">namecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *t)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(s, t, DIRSIZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dirlookup"><a href="#dirlookup" class="headerlink" title="dirlookup"></a>dirlookup</h3><p>在缓存中的目录中循环查找文件名，如果找到，调用 <code>iget</code> 给该文件的 <code>inode</code> 添加一个缓存，保存文件入口的地址到 <code>poff</code> 中，返回找到的文件的 <code>inode</code> ，否则返回 <code>NULL</code></p><p>传入的参数</p><ul><li><code>dp</code> 指向该目录文件的缓存 <code>inode</code> 的指针</li><li><code>name</code> 查找的文件的名称</li><li><code>poff</code> 用于存储找到的文件的入口或者偏移地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"> <span class="comment">// 保证是目录</span></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line"> <span class="comment">// 遍历查找条目</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">   <span class="comment">// 读取失败，必须读取到对应大小的字节</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="comment">// 未使用</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 文件名一致，找到了对应的文件名</span></span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 是否将偏移量需要保存到地址中</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="comment">// 获得对应编号的文件块</span></span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未找到匹配项</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dirlink"><a href="#dirlink" class="headerlink" title="dirlink"></a>dirlink</h3><p>在目录 <code>dp</code> 中写入一个新的目录条目 <code>(name, inum)</code> 。成功时返回 0，失败时返回 -1（例如磁盘块耗尽或者当前目录中已存在这个条目）。并且此函数根据需要从磁盘进行读取以进行检查，添加条目之后，将以以下方式将其写回磁盘</p><p>传入的参数</p><ul><li><code>dp</code> 指定的目录的 <code>inode</code></li><li><code>name</code> 新目录条目的名称</li><li><code>inum</code> 对应目录的 <code>inode</code> 编号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="comment">// 查看链接的文件是否存在于该目录下，存在的话，删除一个对 ip 的引用</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 寻找一个空的 dirent，遍历查找</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">   <span class="comment">// 创建的变量位于物理内存中</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 复制文件名</span></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  <span class="comment">// 设置文件编号</span></span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="comment">// 写入到目录条目中</span></span><br><span class="line">  <span class="comment">// de 为内核空间中的地址</span></span><br><span class="line">  <span class="comment">// 这里写入的话，可能是文件中的某一个 dirent</span></span><br><span class="line">  <span class="comment">// 也有可能是文件末尾结束了的某一个，不够的话会分配页面</span></span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skipelem"><a href="#skipelem" class="headerlink" title="skipelem"></a>skipelem</h3><p>不是访问磁盘的函数，不执行任何读取或者写入，它只是一个字符串处理函数，帮助解析路径名。传入一个指针，内存某处路径名称的字符串。该函数会处理这个路径，会找到第一个元素所在的位置，并将其存储在 <code>name</code> 中，然后 <code>path</code> 指向下一层的目录</p><p>例如 <code>path=/a//b//c, name</code>  ⇒ <code>name=a, path= b//c</code></p><p>如果 <code>path</code> 是空的，那就返回 <code>null</code></p><ul><li><code>path</code> 传入的路径名称</li><li><code>name</code> 存放路径名称的变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>*</span><br><span class="line"><span class="title function_">skipelem</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"> <span class="comment">// 略过名称头的 /</span></span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line"> <span class="comment">// 略去之后剩下空字符串了</span></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 第一层路径的起始</span></span><br><span class="line">  s = path;</span><br><span class="line">  <span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="number">0</span>)</span><br><span class="line">    path++;</span><br><span class="line">  len = path - s;</span><br><span class="line">  <span class="comment">// 超长也只复制最大尺寸，截断，不考虑以 \0 结尾</span></span><br><span class="line">  <span class="keyword">if</span>(len &gt;= DIRSIZ)</span><br><span class="line">    memmove(name, s, DIRSIZ);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    memmove(name, s, len);</span><br><span class="line">    <span class="comment">// 字符串以 \0 结尾</span></span><br><span class="line">    name[len] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 经过第一个字符名称之后，略过 /</span></span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="namex"><a href="#namex" class="headerlink" title="namex"></a>namex</h3><p>查找并返回索引节点以获取路径名，将在磁盘上找到这个路径指定的文件或者父级目录。如果 <code>parent != 0</code> ，则返回父节点的索引节点，并将最后的 <code>path</code> 元素复制到 <code>name</code> 中，该元素必须有容纳 <code>DIRSIZ</code> 字节的空间。必须在事务中调用，因为它调用 <code>input()</code></p><p>传入路径名称，它将在磁盘上找到这个文件，并且将其 <code>inode</code> 添加到 <code>inode</code> 缓存中，并且返回一个指向缓存的 <code>inode</code> 的指针，这样 <code>inode</code> 将被存入缓存，并且引用计数将会增加，如果没有找到，那就会返回 -1。返回有效值不会减少引用计数，否则减少引用计数，在循环内返回需要解锁，循环外返回不需要解锁。</p><ul><li><code>path</code> 传入的路径</li><li><code>nameiparent</code> 是否查找目录的上一级</li><li><code>name</code> 存放路径名称的变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 不论如何都会添加一个引用计数，并且加入到缓存中</span></span><br><span class="line"> <span class="comment">// 如果 / 开头，需要从根目录开始</span></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="comment">// 否则当前工作目录开始</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"> <span class="comment">// 处理路径名中所有文件名，根据路径名挨个定位所有路径，如果没有下一个元素，那就查找完成了</span></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 如果当前不是目录，并且路径下还有至少一层就会报错，释放锁减少引用计数并且推出</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经读到最后一个文件了，并且找父目录，当前 ip 就是父目录</span></span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">   <span class="comment">// 返回当前目录，返回有效值不减少引用计数</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找本目录下是否有该名称的文件</span></span><br><span class="line">    <span class="comment">// 0 是保存查找到文件在目录中偏移量的地址，0 就是不需保存</span></span><br><span class="line">    <span class="comment">// 找到的话就是下一层目录/文件</span></span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">     <span class="comment">// 没找到</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="comment">// 前进到该目录中</span></span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果查找父目录，到这里那就是没找到，出现错误了</span></span><br><span class="line">  <span class="comment">// 文件名不在对应目录下？之类的问题</span></span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">   <span class="comment">// 锁定发生在循环中，不需要解锁，减少引用计数</span></span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回有效值不减少引用计数</span></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个小例子</strong></p><p>对于需要的路径 <code>\a\b\c</code> 来说，由于是根目录下的路径，然后获得根目录的 <code>inode</code> ，之后进入循环</p><ol><li>第一次循环，进入循环内时 <code>path=b\c, name=a, ip=rootinode</code></li><li>第二次循环，开始循环时 <code>path=c, name=b, ip=a_inode</code></li><li>第三次循环，开始循环时 <code>path=\0, name=c, ip=b_inode</code><ol><li>此时需要返回父目录的 <code>inode</code> 的话，就可以返回 <code>ip</code> 了，对应的 <code>name</code> 就是该子文件名称</li></ol></li><li>第四次不进入循环，得到 <code>ip=c_node, path=\0, name=c</code><ol><li>此时返回的 <code>ip</code> 就是该文件的 <code>inode</code> ，对应的 <code>name</code> 就是该文件名称</li></ol></li></ol><h3 id="namei"><a href="#namei" class="headerlink" title="namei"></a>namei</h3><p>传入路径名称，它将在磁盘上找到这个路径指定的文件，并且将其 <code>inode</code> 添加到 <code>inode</code> 缓存中，并且返回一个指向缓存的 <code>inode</code> 的指针，这样 <code>inode</code> 将被存入缓存，并且引用计数将会增加，如果没有找到，那就会返回 -1。</p><p>直接调用 <code>namex</code></p><ul><li><code>path</code> 传入路径</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nameiparent"><a href="#nameiparent" class="headerlink" title="nameiparent"></a>nameiparent</h3><p>传入路径名称，找到这个路径指定的文件的上一级目录，例如查找 <code>a/b/c</code> 找到的为 <code>b</code> ，并且将其 <code>inode</code> 添加到 <code>inode</code> 缓存中，并且返回一个指向缓存的 <code>inode</code> 的指针，这样 <code>inode</code> 将被存入缓存，并且引用计数将会增加，如果没有找到，那就会返回 -1。该函数将会在 <code>name</code> 中保存传入条目所指向的文件的名称，上述例子中返回 <code>c</code></p><p>直接调用 <code>namex</code></p><ul><li><code>path</code> 传入的路径</li><li><code>nameiparent</code> 是否查找目录的上一级<ul><li>1：查找到目录的上一级</li><li>0：查找到当前目录文件</li></ul></li><li><code>name</code> 保存父目录的名称变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>在 Unix 中，管道有点像文件，可以向其中写入数据，也可以从其中读取数据，唯一不同的就是，文件保存在磁盘上，而管道保存在内存中。在管道中，一个进程可以向管道内写入数据，而其它进程就可以读取，管道数据保存在内核内存中某个缓冲区中，并且该缓冲区的大小有限，因此如果写入太多的数据到缓冲区中时，内核需要暂停写入，直到缓冲区不再满了，而且其它进程读取管道的数据时，管道空了，内核将会把该进程挂起</p><p>与分配文件 <code>inode</code> 缓存不同，每当需要申请分配一个新的管道时，内核都会调用 <code>kalloc</code> 并分配整个页，用完之后返回空闲池。这个结构仅仅使用不到 1k 的内存，剩下的都不被使用，所以可能需要考虑更好的办法来存储 <code>pipe</code></p><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>在每个打开的管道中，内核将分配一个管道类型的结构体</p><ul><li><code>spinlock</code> 自旋锁，用来保护 <code>pipe</code> 中其它的字段</li><li><code>data</code> 512 字节的缓冲区，用来存放写入管道的数据，是一个循环的缓冲区，所以两个索引都需要对 512 取模</li><li><code>nread</code> 索引值，在缓冲区中的读索引，指向下一个读取的数据</li><li><code>nwrite</code> 索引值，在缓冲区中的写索引，指向下一个写入的位置</li><li><code>readopen</code> 读取的文件是否还打开着</li><li><code>writeopen</code> 写入的文件是否还打开着</li></ul><p><strong>缓冲区满</strong></p><p>缓冲区满了的标志就是 <code>nwrite - nread = PIPESIZE</code></p><p><strong>缓冲区空</strong></p><p>缓冲区空的标志就是 <code>nread = nwrite</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe</code> 两端的文件描述符类型必须是 <code>FD_PIPE</code> ， <code>pipe</code> 的读入一端的文件描述符被标记为可读但是不可写，写入的一段被标记为可写但不可读，这两个文件都会被该进程打开，放入该进程的打开文件的数组中，而且这两个文件中的 <code>pipe</code> 指针会指向对应的管道，这将导致 <code>readopen</code> 和 <code>writeopen</code> 为 <code>true</code> 。当这个文件描述符的引用计数减小为 0 时，就将其释放到空闲的内存中，而且当这个 <code>pipe</code> 的 <code>readopen</code> 和 <code>writeopen</code> 都为 0 时，会将这个 <code>pipe</code> 释放，通过调用 <code>kfree</code> 来释放这一页内存</p><p>实际上这个操作需要调用管道系统调用来创建管道并且分配两个文件描述符。具体的操作就是，在当前进程的进程结构体中找到 <code>ofile</code> 中空闲的块，然后就使用这两个块，然后将这两个块返回到用户模式进程，以便进行读写操作。</p><h3 id="pipealloc"><a href="#pipealloc" class="headerlink" title="pipealloc"></a>pipealloc</h3><p>创建管道并且分配两个文件描述符，设置对应的文件描述符，返回指向两个文件描述符指针的地址，下图中中间块表示文件描述符指针。如果设置成功返回 0，否则返回 -1，并且把分配好的内存都释放掉</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1714877856378.png" alt="1714877856378.png"></p><ul><li><code>f0</code> 是一个指向指针的指针，用于读取端</li><li><code>f1</code> 是一个指向指针的指针，用于写入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipealloc</span><span class="params">(<span class="keyword">struct</span> file **f0, <span class="keyword">struct</span> file **f1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pi</span>;</span></span><br><span class="line"> <span class="comment">// 初始化</span></span><br><span class="line">  pi = <span class="number">0</span>;</span><br><span class="line">  *f0 = *f1 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 只要有一个出问题都会出错</span></span><br><span class="line">  <span class="keyword">if</span>((*f0 = filealloc()) == <span class="number">0</span> || (*f1 = filealloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="comment">// 给管道分配一个页面</span></span><br><span class="line">  <span class="keyword">if</span>((pi = (<span class="keyword">struct</span> pipe*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  pi-&gt;readopen = <span class="number">1</span>;</span><br><span class="line">  pi-&gt;writeopen = <span class="number">1</span>;</span><br><span class="line">  pi-&gt;nwrite = <span class="number">0</span>;</span><br><span class="line">  pi-&gt;nread = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 初始化管道的元素</span></span><br><span class="line">  initlock(&amp;pi-&gt;lock, <span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">  <span class="comment">// 读取文件的初始化，可读不可写，类型为 FD_PIPE</span></span><br><span class="line">  (*f0)-&gt;type = FD_PIPE;</span><br><span class="line">  (*f0)-&gt;readable = <span class="number">1</span>;</span><br><span class="line">  (*f0)-&gt;writable = <span class="number">0</span>;</span><br><span class="line">  (*f0)-&gt;pipe = pi;</span><br><span class="line">  <span class="comment">// 写入文件的初始化，可写不可读，类型为 FD_PIPE</span></span><br><span class="line">  (*f1)-&gt;type = FD_PIPE;</span><br><span class="line">  (*f1)-&gt;readable = <span class="number">0</span>;</span><br><span class="line">  (*f1)-&gt;writable = <span class="number">1</span>;</span><br><span class="line">  (*f1)-&gt;pipe = pi;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pi)</span><br><span class="line">    kfree((<span class="type">char</span>*)pi);</span><br><span class="line">  <span class="keyword">if</span>(*f0)</span><br><span class="line">   <span class="comment">// 用来删除文件描述符</span></span><br><span class="line">    fileclose(*f0);</span><br><span class="line">  <span class="keyword">if</span>(*f1)</span><br><span class="line">    fileclose(*f1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="piperead"><a href="#piperead" class="headerlink" title="piperead"></a>piperead</h3><p>处理管道读取，从指定管道 <code>pi</code> 中读取 <code>n</code> 字节数据写入到用户虚拟空间地址 <code>addr</code> 中，正常读取返回读到的字节数，否则返回 -1</p><p>实际上当管道没有写入并且已经空了的话，会直接退出，不进行读取</p><ul><li><code>struct pipe *pi</code> 指向管道的指针</li><li><code>addr</code> 从管道读出之后写入对应的用户虚拟空间地址</li><li><code>n</code> 读取的字节数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty</span></span><br><span class="line">   <span class="comment">// 空了，但是这个管道依旧可写，是否要杀死进程，否则必须进入等待</span></span><br><span class="line">   <span class="comment">// 如果管道没有写入的文件，那就不能进入 sleep 了</span></span><br><span class="line">    <span class="keyword">if</span>(killed(pr))&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">   <span class="comment">// 读到空或者读 n 个字节</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="comment">// 写入到对应用户虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒写进程，由于已经从中读取到了一些数据，所以已经空出来一些位置了</span></span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="comment">// 返回读取的字节数</span></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pipewrite"><a href="#pipewrite" class="headerlink" title="pipewrite"></a>pipewrite</h3><p>从指定用户虚拟空间地址 <code>addr</code> 读取 <code>n</code> 字节数据写入到指定管道 <code>pi</code> 中，成功写入返回写入字节数，否则返回 -1</p><p>写函数不像读函数，一般会写完所有 <code>n</code> 个字节（如果不发生错误的话），但是读取函数发生错误或者空了就不再读取了</p><p>实际上当管道没有读取的话，会直接退出，不进行读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="comment">// n 次循环，每次循环写入一个字节</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">   <span class="comment">// 如果管道没有读取的话，那就不写入了</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || killed(pr))&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果满了，进入 sleep，前提是存在读取文件</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123; <span class="comment">//DOC: pipewrite-full</span></span><br><span class="line">     <span class="comment">// 进入 sleep 之前唤醒所有的读进程</span></span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 否则写入单个字节</span></span><br><span class="line">      <span class="type">char</span> ch;</span><br><span class="line">      <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pipeclose"><a href="#pipeclose" class="headerlink" title="pipeclose"></a>pipeclose</h3><p>关闭对应管道的某一端，每当关闭读取端或者写入端时，都会调用该函数。如果所有管道的读写口全部被关掉了，就释放掉这个管道</p><ul><li><code>pi</code> 对应的管道</li><li><code>writable</code> 是一个布尔值，关闭写端还是读端，实际上对应 <code>file</code> 中 <code>writable=1</code> 的一定是读取端，否则是写入端<ul><li>1：关闭写端</li><li>0：关闭读端</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pipeclose</span><span class="params">(<span class="keyword">struct</span> pipe *pi, <span class="type">int</span> writable)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span>(writable)&#123;</span><br><span class="line">   <span class="comment">// 将写端关闭，设置为 0</span></span><br><span class="line">    pi-&gt;writeopen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有可能存在进程正在读取</span></span><br><span class="line">    wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 否则读端关闭</span></span><br><span class="line">    pi-&gt;readopen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 唤醒写端进程</span></span><br><span class="line">    wakeup(&amp;pi-&gt;nwrite);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果读写全关了</span></span><br><span class="line">  <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> &amp;&amp; pi-&gt;writeopen == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pi-&gt;lock);</span><br><span class="line">    kfree((<span class="type">char</span>*)pi);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    release(&amp;pi-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过管道实现进程间通信"><a href="#通过管道实现进程间通信" class="headerlink" title="通过管道实现进程间通信"></a>通过管道实现进程间通信</h3><p>由于 <code>pipe</code> 是临时存在于在内存中的，所以其它进程找不到这个管道，无法调用这个管道</p><p>由于 <code>fork()</code> 和 <code>exec()</code> 系统调用可以保证文件描述符的复制品既可供双亲进程使用，也可供它的子女进程使用。也就是说，一个进程用 <code>pipe()</code> 系统调用创建管道，然后用 <code>fork()</code> 调用创建一个或多个进程，那么，管道的文件描述符将可供所有这些进程使用</p><p>假设一个进程在创建完一个管道之后，又 <code>fork</code> 了两个子进程，每个进程都会完全复制父进程的数据，也就是子进程也有父进程的文件描述符，对应的管道和文件的引用次数将增加。假设一个进程负责读，一个进程负责写入。那么可以假设读进程会失去写入的文件的描述符，而写进程会失去读的文件的描述符，也会减少对应的引用次数。父进程依旧持有这些文件描述符的指针。读进程可以通过使用“读取文件”的文件描述符发出读取系统调用从管道中获取数据，写进程可以通过使用对应“写入文件”的文件描述符发出写入系统调用向管道中写入数据</p><p>所以<strong>一个普通的管道仅可供具有共同祖先（或者父子进程）的两个进程之间共享，并且这个祖先（父进程）必须创建对应的子进程之前就已经建立好了供它们使用的管道</strong></p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/v2-1d2f5d49649f59a00c9f3f4525f09be3_720w.webp" alt="v2-1d2f5d49649f59a00c9f3f4525f09be3_720w.webp"></p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>在系统中，有三种文件，它们都有共同的参数 <code>inode</code> 和 <code>pathname</code></p><ul><li>常规文件</li><li>目录文件</li><li>设备文件</li></ul><p>在 C 语言中，有个文件描述符结构体 <code>FILE</code> ，这个仅存在于用户模式虚拟地址中，内核不知道它的存在，它有对应的库函数，这些函数并非是系统调用，但是为了完成对应的工作，会调用系统调用</p><ul><li><code>fopen</code> 打开文件，调用系统调用 <code>open</code></li><li><code>fread</code> 读取文件，调用系统调用 <code>read</code></li><li><code>fwrite</code> 写入文件，调用系统调用 <code>write</code></li><li><code>fclose</code> 关闭文件，调用系统调用 <code>close</code></li></ul><p>所以内核与用户之间使用文件描述符来进行通信，通过文件描述符可以引用设备，管道，常规文件等</p><p>在进程结构体 <code>proc</code> 中，有一个 <code>file*</code> 数组 <code>ofile</code> ，存储着该进程中打开的文件的文件描述符，长度为 15，也就是最多打开 15 个文件</p><p>在 Unix 中，文件描述符 0 用于标准输入，文件描述符 1 用于标准输出，文件描述符 2 用于标准错误。进程可以连接管道的读取端作为标准输入，而对于标准输出，实际上就是指向一个文件的 <code>inode</code> 并且其中定义 <code>size=900</code></p><p>当进程 <code>fork</code> 一个子进程时，这些文件将也会在子进程中打开</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>文件描述符结构体，其中</p><ul><li><code>type</code> 该文件描述符的类型，在被分配时设置<ul><li><code>FD_NONE</code> 文件未使用</li><li><code>FD_PIPE</code> 管道文件</li><li><code>FD_INODE</code> 常规文件和目录</li><li><code>FD_DEVICE</code> 设备文件</li></ul></li><li><code>ref</code> 该文件描述符的引用数目，如果为 0，那就未使用，被 <code>ftable</code> 中的锁保护</li><li><code>readable</code> 可读权限</li><li><code>writable</code> 可写权限</li><li><code>pipe</code> 指向管道的指针，只在 <code>FD_PIPE</code> 类型下有效</li><li><code>ip</code> 指向 <code>inode</code> 的指针，只在 <code>FD_INODE</code> 和 <code>FD_DEVICE</code> 下有效</li><li><code>off</code> 文件中数据的偏移量，一般来说应当是当前写入多少数据了，或者类似于读文件当前读到的位置，只在 <code>FD_INODE</code> 下有效，意味着是常规文件或者目录文件。说明下一次进行读取或者写入时在文件中的位置，这个值受到 <code>inode</code> 中的锁的保护</li><li><code>short</code> 主设备号，只在 <code>FD_DEVICE</code> 下有效，在 <code>FD_DEVICE</code> 中，将会被复制到 <code>ip</code> 指向的 <code>inode</code> 中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个进程都可以打开很多文件，每一个打开的文件都会被赋予一个文件描述符，进程中打开的文件被 <code>proc</code> 中的 <code>ofile</code> 指针所指向。其中文件描述符的引用数就是指向该文件描述符的指针数量， <code>off</code> 受到 <code>inode</code> 中的锁的保护，其它的数据在分配时被初始化，之后不会被改变，所以不需要锁</p><h3 id="ftable"><a href="#ftable" class="headerlink" title="ftable"></a>ftable</h3><p>文件描述符表，其中存储着 100 个文件描述符，类似于 <code>inode</code> 缓冲区的作用。这些 <code>file</code> 的 <code>ref</code> 被 <code>lock</code> 保护，这些文件描述符要么正在使用，要么空闲以供将来使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure><h3 id="fileinit"><a href="#fileinit" class="headerlink" title="fileinit"></a>fileinit</h3><p>只做了初始化 <code>ftable</code> 的锁，在 0 号内核中被调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fileinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  initlock(&amp;ftable.lock, <span class="string">&quot;ftable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filealloc"><a href="#filealloc" class="headerlink" title="filealloc"></a>filealloc</h3><p>分配一个 <code>file</code> 结构体，并且返回对应的指针，在文件描述符表中找到一个未使用的 <code>file</code> 来分配，返回对应的指针，未找到返回 <code>null</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"> <span class="comment">// 访问文件描述符数组需要获得锁</span></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">   <span class="comment">// 引用计数为 0，说明是空闲的</span></span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lo ck);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没找到返回 null</span></span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filedup"><a href="#filedup" class="headerlink" title="filedup"></a>filedup</h3><p>增加文件的引用计数，可以在 <code>fork</code> 子进程时使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span> &#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="comment">// 需要保证该文件存在引用</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fileclose"><a href="#fileclose" class="headerlink" title="fileclose"></a>fileclose</h3><p>释放掉文件描述符，实际上就是删除这个指向对应 <code>file</code> 结构体的指针，减少引用计数，如果引用计数到达 0，那就关闭该文件描述符，实际上就是将引用计数设置为 0，并且文件类型设置为 <code>FD_NONE</code> 表示文件描述符未使用</p><ul><li><code>struct file* f</code> 文件描述符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="comment">// 已经关闭会报错</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line">  <span class="comment">// 减小后，引用计数不为 0，不止有这一个文件引用该 file</span></span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存一个副本用于之后的操作，将对应的 file 恢复</span></span><br><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="comment">// 制作副本以访问它的 inode 和 pipe</span></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">   <span class="comment">// 关闭对应的管道，writable=1 表示可写不可读，也就是用于写入的文件</span></span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">   <span class="comment">// 开启事务来关闭对应的 inode</span></span><br><span class="line">    begin_op();</span><br><span class="line">    <span class="comment">// 删除对内存中索引节点的引用，如果这是最后一次引用，则可以回收 inode 表项</span></span><br><span class="line">   <span class="comment">// 这个操作需要在事务中完成</span></span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fileread"><a href="#fileread" class="headerlink" title="fileread"></a>fileread</h3><p>从文件 <code>f</code> 中读取 <code>n</code> 个字节到用户虚拟地址 <code>addr</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果文件不可读，返回 -1</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">   <span class="comment">// 管道类型文件描述符，用管道读取函数</span></span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">   <span class="comment">// 主设备数不对或者不可读（读取函数指针为 null），返回-1</span></span><br><span class="line">   <span class="comment">// 确保主设备数不为空</span></span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 读取操作，虚拟地址</span></span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">   <span class="comment">// 如果是文件类型，就是 inode</span></span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="comment">// 读取对应的 inode 到 addr 中，需要用到 off 表示在文件中的偏移地址</span></span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">     <span class="comment">// 当前文件偏移地址向后移动，也就是文件从头开始往后读</span></span><br><span class="line">     <span class="comment">// 下一次读取或者写入文件的地址</span></span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 否则报错，文件类型错误</span></span><br><span class="line">    panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回读取的字节数</span></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filewrite"><a href="#filewrite" class="headerlink" title="filewrite"></a>filewrite</h3><p>从用户虚拟地址 <code>addr</code> 中读取 <code>n</code> 字节数据，写入到 <code>f</code> 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 不可写</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">   <span class="comment">// 管道写入</span></span><br><span class="line">    ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">   <span class="comment">// 设备号不合法，或者写入函数指针为 null，没有对应的写入方法</span></span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">    ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">  <span class="comment">// 一次写入分成写入多个块以避免超过最大日志事务大小，</span></span><br><span class="line">  <span class="comment">// 包括i-node，间接块，分配块和2块非对齐写入的slop块</span></span><br><span class="line">  <span class="comment">// 这实际上属于底层，因为writei()可能正在编写像控制台这样的设备。</span></span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">      <span class="type">int</span> n1 = n - i;</span><br><span class="line">      <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="comment">// 写入文件中</span></span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line">   <span class="comment">// 没有完全写入，说明出现了问题/满了</span></span><br><span class="line">      <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">        <span class="comment">// error from writei</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没写够字节数就返回 -1</span></span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filestat"><a href="#filestat" class="headerlink" title="filestat"></a>filestat</h3><p>这个函数用于 <code>fstat</code> 系统调用。</p><p>获取文件 <code>f</code> 元数据到用户虚拟地址 <code>addr</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span> <span class="comment">// 在内核空间中的变量</span></span><br><span class="line">  <span class="comment">// 只对 inode 和 设备 文件执行操作，如果是管道文件就会出错</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="comment">// 将 ip 的数据复制到内核地址空间 st 中</span></span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="comment">// 从内核地址空间 st 中将数据读到由这个页表描述的用户虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="argfd"><a href="#argfd" class="headerlink" title="argfd"></a>argfd</h3><p>获取第 <code>n</code> 个系统调用参数作为文件描述符，并返回描述符和相应结构体的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">argfd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *pfd, <span class="keyword">struct</span> file **pf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="comment">// 获取系统调用参数中的文件描述符</span></span><br><span class="line">  argint(n, &amp;fd);</span><br><span class="line">  <span class="comment">// 判断文件描述符是否合法</span></span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f=myproc()-&gt;ofile[fd]) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 保存文件描述符</span></span><br><span class="line">  <span class="keyword">if</span>(pfd)</span><br><span class="line">    *pfd = fd;</span><br><span class="line">  <span class="comment">// 保存获得的文件结构体指针 file</span></span><br><span class="line">  <span class="keyword">if</span>(pf)</span><br><span class="line">    *pf = f;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-fstat"><a href="#sys-fstat" class="headerlink" title="sys_fstat"></a>sys_fstat</h3><p>这个函数不需要任何参数，最终会返回到用户的代码，所以返回 0 或 -1，表示成功与否</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line"> <span class="comment">// 获取用户传递的参数</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;st);</span><br><span class="line"> <span class="comment">// 这里并不在意返回的文件描述符，获得对应文件的指针 file</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件相关的系统调用"><a href="#文件相关的系统调用" class="headerlink" title="文件相关的系统调用"></a>文件相关的系统调用</h2><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>需要三个参数</p><ul><li><code>int fd</code> 文件描述符</li><li><code>addr</code> 将数据读入到的地址，用户虚拟地址空间</li><li><code>n</code> 读取的字节数</li></ul><p>在用户模式下首先将这三个参数放入到寄存器 <code>a0, a1, a2</code> 中，将在 <code>a7</code> 寄存器中放入一个代码号，这个代码号用来使内核确定使用哪个系统调用，然后用户模式代码将执行。在 risc-v 中，会使用 <code>ecall</code> 指令来执行系统调用，此时内核将获得控制权，并开始保存用户寄存器，然后查看 <code>a7</code> 中的值以确定涉及哪个系统调用。如果是 <code>read</code> 系统调用，将调用 <code>sys_read</code> 函数</p><p>在这个函数中，定位参数并且从其最初的存储位置中获取它们</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 p;</span><br><span class="line"> <span class="comment">// 获取 1 号位置中的地址</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">  <span class="comment">// 获取 2 号位置中的读取字节数</span></span><br><span class="line">  argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">  <span class="comment">// 获取 0 号位置上的文件描述符，并且返回 file 指针</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 直接调用 fileread 函数读取数据</span></span><br><span class="line">  <span class="keyword">return</span> fileread(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-write"><a href="#sys-write" class="headerlink" title="sys_write"></a>sys_write</h3><p>需要三个参数</p><ul><li><code>int fd</code> 文件描述符</li><li><code>addr</code> 读取数据的地址，用户虚拟地址空间</li><li><code>n</code> 读取的字节数</li></ul><p>系统调用的写入函数，这个函数本质上就是从寄存器读取数据，然后进入 <code>filewrite</code> 函数来写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 p; </span><br><span class="line">  <span class="comment">// 获取地址</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">  argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-close"><a href="#sys-close" class="headerlink" title="sys_close"></a>sys_close</h3><p>系统调用关闭文件</p><ul><li><code>fd</code> 需要关闭的文件的文件描述符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"> <span class="comment">// 从寄存器中获取文件描述符和指向该 file 结构体的指针</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 清除进程打开的对应的文件描述符</span></span><br><span class="line">  myproc()-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 调用 fileclose 关闭该文件描述符</span></span><br><span class="line">  fileclose(f);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-dup"><a href="#sys-dup" class="headerlink" title="sys_dup"></a>sys_dup</h3><p>传入一个已经打开的文件的文件描述符，将为此文件分配一个新的文件描述符并且返回该新文件描述符，如果没有剩余的 <code>ofile</code> 那就返回 -1</p><p>但是对于 Unix 最重要的就是，文件描述符 0 用于标准输入，文件描述符 1 用于标准输出，文件描述符 2 用于标准错误，所以对于 <code>dup</code> 查找就需要注意这一点，当然这 3 个一定是分配不到的</p><ul><li><code>fd</code> 对应文件的文件描述符，需要是已经打开的文件的文件描述符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="comment">// 获取第一个参数作为文件描述符，并返回对应的文件指针</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 为该文件重新分配一个文件描述符</span></span><br><span class="line">  <span class="keyword">if</span>((fd=fdalloc(f)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 这个函数作用就是增加引用计数</span></span><br><span class="line">  filedup(f);</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fdalloc"><a href="#fdalloc" class="headerlink" title="fdalloc"></a>fdalloc</h3><p>遍历进程的 <code>ofile</code> 数组，找到空位分配一个文件描述符，如果找到返回该文件描述符，否则返回 -1</p><ul><li><code>f</code> 对应的文件结构体，为该文件分配一个文件描述符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;ofile[fd] = f;</span><br><span class="line">      <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-fstat-1"><a href="#sys-fstat-1" class="headerlink" title="sys_fstat"></a>sys_fstat</h3><p><code>fstat</code> 系统调用，传入两个参数，打开文件的文件描述符和一个用户虚拟空间地址，用于将文件的信息保存到该用户虚拟空间地址</p><ul><li><code>fd</code> 对应文件描述符</li><li><code>st</code> 目标用户虚拟地址空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// 用户虚拟空间地址</span></span><br><span class="line"> <span class="comment">// 获取用户传递的参数</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;st);</span><br><span class="line"> <span class="comment">// 这里并不在意返回的文件描述符，获得对应文件的指针 file</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-chdir"><a href="#sys-chdir" class="headerlink" title="sys_chdir"></a>sys_chdir</h3><p>由于每个进程都有当前的工作目录，有时候可以使用该系统调用来更改目录，传入一个字符串，该字符串描述一个文件的路径名，该文件最好存在并且是一个目录，然后就把当前工作目录改为该文件</p><ul><li><code>path</code> 将当前进程的运行位置改为 <code>path</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 读取路径并且根据路径名称获得该文件的 inode</span></span><br><span class="line">  <span class="comment">// 到最大大小停止</span></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span> || (ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 inode 上锁</span></span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// 判断是否为目录文件，否则退出</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(ip);</span><br><span class="line">  <span class="comment">// 删除对内存中索引节点的引用。如果这是最后一次引用，则可以回收对应的 inode 表项</span></span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="comment">// 设置当前路径为 ip 的节点</span></span><br><span class="line">  p-&gt;cwd = ip;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-link"><a href="#sys-link" class="headerlink" title="sys_link"></a>sys_link</h3><p>该函数作用就是将当前存在的条目添加到新的条目中，以便使新的路径有效，并且它们将引用同一个文件。正常返回 0，否则返回 -1</p><ul><li><code>existingpath</code> 当前存在的路径</li><li><code>newpath</code> 新的路径</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 新路径和旧路径</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"> <span class="comment">// 获取路径名</span></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 获取旧的目录下该文件的 inode</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// 目录文件就退出</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 更新对应的 inode 节点，将该节点的硬链接数量增加</span></span><br><span class="line">  ip-&gt;nlink++;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlock(ip);</span><br><span class="line"> <span class="comment">// 获取新条目的上一级目录，为了创建硬链接，这会增加引用计数，并且将目录的最后一级名称存放到 name 中</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  ilock(dp);</span><br><span class="line">  <span class="comment">// 如果不在同一个文件系统中或者创建连接失败，就会报错</span></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消上锁，减少引用计数</span></span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  <span class="comment">// 减少旧文件引用次数，旧文件已经解锁了</span></span><br><span class="line">  iput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bad:</span><br><span class="line"> <span class="comment">// 出错了就需要把东西恢复到调用 link 之前的状态</span></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;nlink--;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isdirempty"><a href="#isdirempty" class="headerlink" title="isdirempty"></a>isdirempty</h3><p>遍历目录文件中所有的 <code>dirent</code> ，是否该目录中仅存在 <code>.</code> 和 <code>..</code> 两个目录，其它 <code>dirent</code> 的编号必须是 <code>0</code> 表示未使用。如果是空的，返回 -1，否则返回 0</p><ul><li><code>dp</code> 传入的文件的 <code>inode</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">isdirempty</span><span class="params">(<span class="keyword">struct</span> inode *dp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="comment">// 从第 3 个开始查找，前两个是 . 和 ..</span></span><br><span class="line">  <span class="keyword">for</span>(off=<span class="number">2</span>*<span class="keyword">sizeof</span>(de); off&lt;dp-&gt;size; off+=<span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">   <span class="comment">// 将文件 dp 中数据读取到 de 中去， off 是当前的偏移，这里的 0 表示是物理地址</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;isdirempty: readi&quot;</span>);</span><br><span class="line">    <span class="comment">// de 的编号为 0，表示无文件，只有所有的 inumber = 0 才认定无其它文件</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是空的返回 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-unlink"><a href="#sys-unlink" class="headerlink" title="sys_unlink"></a>sys_unlink</h3><p>删除文件硬链接，如果正常，返回 0，否则返回 -1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ], path[MAXPATH];</span><br><span class="line">  uint off;</span><br><span class="line"> <span class="comment">// 获得该路径名称</span></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="comment">// 开始事务</span></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 查找该条目的父级目录，在 name 中保存要删除文件的名称，增加 dp 的引用计数</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 对 dp 上锁</span></span><br><span class="line">  ilock(dp);</span><br><span class="line"> <span class="comment">// 查看正在删除的是否是 . 或者 .. 这两个不能删除</span></span><br><span class="line">  <span class="keyword">if</span>(namecmp(name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || namecmp(name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"> <span class="comment">// 从目录 dp 中查找对应的条目 name，找到了为其分配一个 inode，在 off 中保存该条目的偏移</span></span><br><span class="line"> <span class="comment">// 如果未找到，那就报错了</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, &amp;off)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="comment">// 找到之后锁定</span></span><br><span class="line">  ilock(ip);</span><br><span class="line"> <span class="comment">// 如果该文件硬链接数量小于 1，那就是文件系统出问题了，这是个致命的问题</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;nlink &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;unlink: nlink &lt; 1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果该文件还是个目录文件，并且不是空的，那就会出问题，不能直接删除目录</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; !isdirempty(ip))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 直接将父目录中对应的引用条目清零</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;de, <span class="number">0</span>, <span class="keyword">sizeof</span>(de));</span><br><span class="line">  <span class="comment">// 将清零后的 de 写入到目录文件对应的位置中，0 表示是物理地址空间</span></span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    panic(<span class="string">&quot;unlink: writei&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果文件类型是目录，但是是空的，可以减少父目录硬链接数量，并且更新 dp</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">    dp-&gt;nlink--; <span class="comment">// 这里原因就是，子文件夹会有 .. 实际上就是对父目录的硬链接，所以这里得 --</span></span><br><span class="line">    iupdate(dp); <span class="comment">// 更新到磁盘中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解锁并且减少引用计数</span></span><br><span class="line">  iunlockput(dp);</span><br><span class="line"> <span class="comment">// 磁盘更新，减少 ip 的硬链接数量</span></span><br><span class="line">  ip-&gt;nlink--;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  <span class="comment">// 减少 ip 的引用次数，如果没有引用次数了，就可以删除该文件了</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line"> <span class="comment">// 结束事务</span></span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line"> <span class="comment">// 发生错误就解锁目录并且减少目录的引用计数</span></span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1715054232482.png" alt="1715054232482.png"></p><p>文件系统结构类似于上图。简述一下这个函数成功运行的流程</p><ol><li>传入路径条目名称</li><li>根据路径条目名称获得该条目的父目录，并且获得该路径条目对应的文件 <code>inode</code></li><li>将父级目录中该文件的条目清空，然后减少子文件或子空目录和父目录的硬链接数，如果是非空子目录，那就不操作</li><li>之后减少两个文件的引用数量，如果子文件或子空目录引用数为 0，就会删除该子文件或子空目录</li><li>更新所有的 <code>inode</code> ，将修改后的 <code>inode</code> 写回到磁盘</li></ol><p>在这个函数中需要注意锁的顺序</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>创建一个对应类型的文件，如果是设备文件的话，会需要 <code>major</code> 和 <code>minor</code> 两个参数，也就是主设备号和次设备号，而其它文件，这两个参数可以传入 0，不会被使用。成功创建之后，返回一个新创建的文件的 <code>inode</code> 指针，并且会对其上锁。这个函数被三个地方调用， <code>open</code> 系统调用， <code>mknod</code> 系统调用和 <code>mkdir</code> 系统调用。成功执行返回创建的文件的 <code>inode</code> 指针，否则返回 <code>null</code></p><ul><li><code>path</code> 例如 <code>a/b/c</code> ，就是将要把 <code>c</code> 文件创建在 <code>a/b</code> 目录下</li><li><code>type</code> 将要创建的文件的类型<ul><li><code>T_DIR</code> 目录文件</li><li><code>T_FILE</code> 常规文件</li><li><code>T_DEVICE</code> 设备文件</li></ul></li><li><code>major</code> 设备文件的主设备号</li><li><code>minor</code> 设备文件的次设备号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line"> <span class="comment">// 解析这个路径名称，获得对应父目录的 inode，并且 name 中存储的是 将要创建的文件的名称</span></span><br><span class="line">  <span class="keyword">if</span> ((dp = nameiparent(path, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 对父目录上锁</span></span><br><span class="line">  ilock(dp);</span><br><span class="line"> <span class="comment">// 如果在父目录中找到了该文件名称，会增加引用计数</span></span><br><span class="line">  <span class="keyword">if</span> ((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip); <span class="comment">// 在检查字段之前必须锁定</span></span><br><span class="line">    <span class="comment">// 这里就相当于从 open 函数中调用的</span></span><br><span class="line">    <span class="comment">// 将要创建一个常规文件，并且存在的文件正好是常规文件或者设备文件的话，直接返回该文件的 inode</span></span><br><span class="line">    <span class="keyword">if</span> (type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    <span class="comment">// 否则返回 null</span></span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 上述已经确定文件不存在了，所以这时候开始创建一个文件</span></span><br><span class="line"> <span class="comment">// 这里会分配一个 inode，增加其引用计数，并且将其类型设置为 type</span></span><br><span class="line">  <span class="keyword">if</span> ((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>) &#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// 设置主设备号和次设备号，如果是设备文件，那就会设置为对应的数字，添加硬链接</span></span><br><span class="line">  ip-&gt;major = major;</span><br><span class="line">  ip-&gt;minor = minor;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line"> <span class="comment">// 如果创建一个目录文件的话，需要为其添加一个 . 和 .. 的硬链接</span></span><br><span class="line">  <span class="keyword">if</span> (type == T_DIR) &#123;<span class="comment">// Create . and .. entries.</span></span><br><span class="line">   <span class="comment">// 添加 . 和 .. 的硬链接</span></span><br><span class="line">    <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line">    <span class="keyword">if</span> (dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 将 ip 在 dp 中创建硬链接</span></span><br><span class="line">  <span class="keyword">if</span> (dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line"> <span class="comment">// 如果是目录文件，为负文件增加 硬链接数</span></span><br><span class="line">  <span class="keyword">if</span> (type == T_DIR) &#123;</span><br><span class="line">    <span class="comment">// now that success is guaranteed:</span></span><br><span class="line">    <span class="comment">// 需要在链接完成之后再增加</span></span><br><span class="line">    dp-&gt;nlink++;<span class="comment">// for &quot;..&quot;</span></span><br><span class="line">    <span class="comment">// 更新 dp 中的数据</span></span><br><span class="line">    iupdate(dp);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 释放 dp</span></span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">fail:</span><br><span class="line">  <span class="comment">// something went wrong. de-allocate ip.</span></span><br><span class="line">  <span class="comment">// 如果出现问题，就把 ip 复原，不需要复原 dp 因为 dp 几乎没改变</span></span><br><span class="line">  <span class="comment">// 释放 ip 和 dp</span></span><br><span class="line">  ip-&gt;nlink = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-mkdir"><a href="#sys-mkdir" class="headerlink" title="sys_mkdir"></a>sys_mkdir</h3><p>创建目录的系统调用，读取第一个参数作为路径名称。创建成功返回 0，否则返回 -1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 读取参数，创建一个目录</span></span><br><span class="line">  <span class="keyword">if</span> (argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span> || (ip = create(path, T_DIR, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 创建失败或者路径无效 </span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 由于 create 中，给 inode 上锁了，这里需要释放</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-mknod"><a href="#sys-mknod" class="headerlink" title="sys_mknod"></a>sys_mknod</h3><p>这个函数将创建一个设备文件，其中会传入指定路径，主设备号和次设备号，如果成功返回 0，否则返回 -1</p><ul><li><code>path</code> 创建的文件路径</li><li><code>major</code> 主设备号</li><li><code>minor</code> 次设备号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> major, minor;</span><br><span class="line">  begin_op();</span><br><span class="line">  argint(<span class="number">1</span>, &amp;major); <span class="comment">// 读取主设备号</span></span><br><span class="line">  argint(<span class="number">2</span>, &amp;minor); <span class="comment">// 读取次设备号</span></span><br><span class="line">  <span class="comment">// 读取路径名称，并且创建一个设备文件</span></span><br><span class="line">  <span class="keyword">if</span> ((argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> ||</span><br><span class="line">      (ip = create(path, T_DEVICE, major, minor)) == <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在 create 中会对 ip 上锁，这里释放</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-open"><a href="#sys-open" class="headerlink" title="sys_open"></a>sys_open</h3><p>传递一个路径名称，是将要打开的文件，以及一个标志值的整数，并且定义了一些位，用来表示在某些情况下该做什么，这将会返回对应文件的文件描述符，需要注意的是<strong>该系统调用只能创建常规文件，能打开现存的设备文件，目录和常规文件</strong></p><ul><li><code>path</code> 将要打开的文件的路径</li><li><code>omode</code> 标志位<ul><li><code>O_RDONLY: 0x000</code> 只读，实际上根本没有设置位</li><li><code>O_WRONLY: 0x001</code> 只写</li><li><code>O_RDWY: 0x002</code> 读写</li><li><code>O_CREATE: 0x200</code> 创建对应的文件</li><li><code>O_TRUNC: 0x400</code> 将文件截断为 0</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"> <span class="comment">// 读取文件权限</span></span><br><span class="line">  argint(<span class="number">1</span>, &amp;omode);</span><br><span class="line">  <span class="comment">// 读取文件路径</span></span><br><span class="line">  <span class="keyword">if</span> ((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  begin_op();</span><br><span class="line"> <span class="comment">// 如果需要创建一个文件</span></span><br><span class="line">  <span class="keyword">if</span> (omode &amp; O_CREATE) &#123;</span><br><span class="line">   <span class="comment">// 如果文件存在将尝试打开该文件，否则创建该文件</span></span><br><span class="line">   <span class="comment">// 增加引用计数，并且锁定该 inode</span></span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ip == <span class="number">0</span>) &#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 不需要创建该文件</span></span><br><span class="line">   <span class="comment">// 找到该文件，并且返回其 inode，引用计数增加</span></span><br><span class="line">    <span class="keyword">if</span> ((ip = namei(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁定该 inode</span></span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 如果是打开目录文件那就只能是只读模式</span></span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY) &#123;</span><br><span class="line">     <span class="comment">// 减少引用计数并且解锁</span></span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 如果已经打开文件或者创建好文件了</span></span><br><span class="line"> <span class="comment">// 如果文件类型为设备文件，需要保证主设备号在合法范围内</span></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV)) &#123;</span><br><span class="line">  <span class="comment">// 减少引用计数并且解锁</span></span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要在 proc 中加入对应的文件的 file 结构体到 ofile 中，然后对应的把 file 结构体的 ip 号指向对应的 inode</span></span><br><span class="line"> <span class="comment">// 创建文件结构体，就是在 file 结构体表 ftable 中找到一个空闲的槽来存放该结构体，返回该结构体的指针</span></span><br><span class="line"> <span class="comment">// 在对应的 proc 中的 ofile 找到空闲的位置，然后指向 file 结构体，返回对应的文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> ((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 如果创建了文件，需要将其关闭</span></span><br><span class="line">    <span class="keyword">if</span> (f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 设备文件类型</span></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;type == T_DEVICE) &#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    <span class="comment">// 复制主设备号</span></span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 常规文件</span></span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置对应的 inode</span></span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY); <span class="comment">// 非只写，那就是可读</span></span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR); <span class="comment">// 可写或者可读写</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE) &#123;</span><br><span class="line">   <span class="comment">// 如果是常规文件，那就截断大小为 0，释放占用的所有空间</span></span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"> <span class="comment">// 将保持该 inode 的引用计数增加的状态</span></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-pipe"><a href="#sys-pipe" class="headerlink" title="sys_pipe"></a>sys_pipe</h3><p>管道系统调用，传入一个指向文件描述符数组的指针，该数组有两个元素</p><p>该函数调用做的就是，在进程中找到一个未使用的 <code>ofile</code> ，然后将其指向创建出的管道的读取端，在找到另一个指向管道的写入端，最终会在数组中保存两个文件描述符，大小正好是 2，0 号元素为读取端，1 号元素为写入端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 fdarray; <span class="comment">// user pointer to array of two integers</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">rf</span>, *<span class="title">wf</span>;</span></span><br><span class="line">  <span class="type">int</span> fd0, fd1;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"> <span class="comment">// 获取第一个参数，是一个地址（指针）</span></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;fdarray);</span><br><span class="line">  <span class="comment">// 创建一个管道，同时也分配写入端和读取端两个文件结构体</span></span><br><span class="line">  <span class="keyword">if</span> (pipealloc(&amp;rf, &amp;wf) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  fd0 = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 在进程中分配 ofile 返回对应的文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> ((fd0 = fdalloc(rf)) &lt; <span class="number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fd0 &gt;= <span class="number">0</span>)</span><br><span class="line">      p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果出错了就关闭创建的文件，实际上会关闭对应的管道，会释放管道</span></span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将文件描述符写入到对应的用户虚拟空间地址中，所以这里一共是 8 位</span></span><br><span class="line">  <span class="keyword">if</span> (copyout(p-&gt;pagetable, fdarray, (<span class="type">char</span> *) &amp;fd0, <span class="keyword">sizeof</span>(fd0)) &lt; <span class="number">0</span> ||</span><br><span class="line">      copyout(p-&gt;pagetable, fdarray + <span class="keyword">sizeof</span>(fd0), (<span class="type">char</span> *) &amp;fd1, <span class="keyword">sizeof</span>(fd1)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 释放掉 ofile</span></span><br><span class="line">    p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ofile[fd1] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 关闭对应的文件，也会关闭管道</span></span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ELF-file-format"><a href="#ELF-file-format" class="headerlink" title="ELF file format"></a>ELF file format</h2><p>ELF 文件是一种用于二进制文件、可执行文件、目标代码、共享库和 core 转存格式文件</p><p>不同的系统上使用的文件格式也不一样</p><div class="table-container"><table><thead><tr><th>文件格式</th><th>系统</th></tr></thead><tbody><tr><td>ELF</td><td>Linux/Unix</td></tr><tr><td>Mach-O</td><td>MacOS, IOS</td></tr><tr><td>PE</td><td>windows</td></tr></tbody></table></div><h3 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h3><div class="table-container"><table><thead><tr><th>ELF Header</th><th>ELF 文件都以固定格式的文件头开始</th></tr></thead><tbody><tr><td>Program Headers</td><td>文件头后面紧跟着的就是程序头表，其中的每个程序头完全相同，具有相同的大小</td></tr><tr><td>Segments</td><td>很多段，要加载到内存中的实际代码就位于这些段中，这些段有着不同的大小，每个段都被一个程序头指向，并且这将包含对应的段在可执行文件中的位置的信息</td></tr><tr><td>Other Stuff</td><td>例如在可重定位文件中，这一部分就是节头表，包含重定位和调试信息</td></tr></tbody></table></div><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1715079218202.png" alt="1715079218202.png"></p><p>这里并没有展示各个字段的大小和偏移量，因为对于不同版本的 elf 文件都是不一样的，取决于是 32 位还是 64 位</p><ul><li><code>magic</code> 这里面包含着四个字节，就是 <code>0x7F 0x45 0x4C 0x46</code> ，可以通过检验这四个字节确保当前文件是 ELF 文件</li><li><code>class</code> 用于指定文件是 32 位文件还是 64 位文件<ul><li>1：32 位</li><li>2：64位</li></ul></li><li><code>data</code> 用于指定文件格式是小端模式还是大端模式<ul><li>1：小端模式</li><li>2：大端模式</li></ul></li><li><code>osabi</code> 应用程序二进制接口，用于指示该文件要在哪个操作系统上运行。但是不包括 xv6<ul><li>3：Linux</li><li>6：Solaris</li><li>9：FreeBSD</li></ul></li><li><code>type</code> 文件类型<ul><li>1：可重定位文件格式，由链接器处理生成可执行文件</li><li>2：可执行文件格式</li><li>4：内核文件，当系统崩溃或者出现某种错误时，需要捕获主内存的数据进行调试，这时候可以创建内核文件。当然内核文件可以是其他格式的文件</li></ul></li><li><code>machine</code> 当前文件格式所适应的处理器类型<ul><li><code>0x03</code> : x86</li><li><code>x03E</code> : x86-64</li><li><code>0xF3</code> : Risc-V</li></ul></li><li><code>entry</code> 程序开始执行的地址，这可能是主函数的第一个字节，通常还会有一些序言代码在可执行文件中， <code>prolog</code> 代码是实际调用 <code>main</code> 函数的代码，这时候入口地址就是 <code>prolog</code> 代码的第一个字节。所以在内核将可执行文件加载到内存中时，它将跳转到入口点，然后开始执行</li><li><code>phoff</code> 程序头偏移，程序头在文件的位置</li><li><code>phnum</code> 程序头数量，可以在 ELF 文件中可以找到多少个程序头</li></ul><p>在 xv6 中，忽略了很多字段，只会查看 <code>magic</code> ， <code>entry</code> ， <code>phoff</code> ， <code>phnum</code> 等，其它字段都会被忽略</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">  uint magic;  <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">  uchar elf[<span class="number">12</span>];</span><br><span class="line">  ushort type;</span><br><span class="line">  ushort machine;</span><br><span class="line">  uint version;</span><br><span class="line">  uint64 entry;</span><br><span class="line">  uint64 phoff;</span><br><span class="line">  uint64 shoff; <span class="comment">// 标头偏移量</span></span><br><span class="line">  uint flags;</span><br><span class="line">  ushort ehsize;</span><br><span class="line">  ushort phentsize;</span><br><span class="line">  ushort phnum;</span><br><span class="line">  ushort shentsize;</span><br><span class="line">  ushort shnum;</span><br><span class="line">  ushort shstrndx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="程序头"><a href="#程序头" class="headerlink" title="程序头"></a>程序头</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1715080737367.png" alt="1715080737367.png"></p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1715084360951.png" alt="1715084360951.png"></p><p>由许多字段组成，大小是固定的</p><ul><li><code>type</code> 描述存储段的类型或特殊节的类型<ul><li>1：loadable segment，可加载段</li></ul></li><li><code>flags</code> 用于指示该程序头的权限，指示该段在加载到内存中时应该标记的权限。每个权限由一位表示<ul><li>可执行</li><li>可写</li><li>可读</li></ul></li><li><code>off</code> 偏移量，可以在文件中找到数据的位置，程序头的位置</li><li><code>vaddr</code> 指出本段首字节的虚拟地址，加载时加载到虚拟内存的哪个位置</li><li><code>paddr</code> 指出本段首字节的物理地址。通常由操作系统动态确定</li><li><code>filesz</code> 用于指示该段中有多少数据，多少字节</li><li><code>memsz</code> 在内存中需要占用多少字节，可以大于或等于 <code>filesz</code> 但是不能小于，如果大于 <code>filesz</code> ，剩余空间将被 0 填充</li><li><code>align</code> 对齐字段，事实上会把程序加载到页面边界对齐的地址中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">  uint32 type;</span><br><span class="line">  uint32 flags;</span><br><span class="line">  uint64 off;</span><br><span class="line">  uint64 vaddr;</span><br><span class="line">  uint64 paddr;</span><br><span class="line">  uint64 filesz;</span><br><span class="line">  uint64 memsz;</span><br><span class="line">  uint64 align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一些定义的常量"><a href="#一些定义的常量" class="headerlink" title="一些定义的常量"></a>一些定义的常量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="comment">// &quot;\x7FELF&quot; in little endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_LOAD           1</span></span><br><span class="line"><span class="comment">// Flag bits for Proghdr flags</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_FLAG_EXEC      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_FLAG_WRITE     2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_FLAG_READ      4</span></span><br></pre></td></tr></table></figure><ul><li><code>ELF_MAGIC</code> 文件头魔数</li><li><code>ELF_PROG_LOAD</code> 可加载段</li><li><code>ELF_PROG_FLAG_EXEC</code> 可执行权限</li><li><code>ELF_PROG_FLAG_WRITE</code> 可写权限</li><li><code>ELF_PROG_FLAG_READ</code> 可读权限</li></ul><h2 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec 系统调用"></a>exec 系统调用</h2><p>系统调用传入了两个参数</p><ul><li><code>path</code> 指向路径名的指针，就是将要加载和执行的可执行文件</li><li><code>argv</code> 指向数组的指针，这些是将要传递给可执行文件的参数，该数组包含以 <code>null</code> 结尾的字符串的指针，并且以一个 <code>null</code> 指针结尾，这些参数位于虚拟地址空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="comment">// MAXARG：最多接收 32 个参数，但是实际上只有 31 个参数，因为最后一个参数后是 null</span></span><br><span class="line">  <span class="type">char</span> path[MAXPATH], *argv[MAXARG];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  uint64 uargv, uarg;</span><br><span class="line"> <span class="comment">// 获取指向数组的指针</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;uargv);</span><br><span class="line">  <span class="comment">// 获取路径名称字符串</span></span><br><span class="line">  <span class="keyword">if</span> (argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(argv));</span><br><span class="line">  <span class="comment">// 遍历所有的参数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">   <span class="comment">// 如果参数数量大于 31 个</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= NELEM(argv)) &#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取每一个数组中的元素，实际上这个 uargv 所指向的是一个二维指针，所以这里的</span></span><br><span class="line">    <span class="comment">// uarg 就是一个数组头。从进程地址空间中读取到内核地址</span></span><br><span class="line">    <span class="keyword">if</span> (fetchaddr(uargv + <span class="keyword">sizeof</span>(uint64) * i, (uint64 *) &amp;uarg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果得到的参数为 null，跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> (uarg == <span class="number">0</span>) &#123;</span><br><span class="line">      argv[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为每一个字符串分配一个页面</span></span><br><span class="line">    argv[i] = kalloc();</span><br><span class="line">    <span class="keyword">if</span> (argv[i] == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 包这个参数复制到这个参数的页面中，最多复制一整页的数据，从进程地址空间中读取到内核地址</span></span><br><span class="line">    <span class="keyword">if</span> (fetchstr(uarg, argv[i], PGSIZE) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 该函数将会导致可执行文件被加载</span></span><br><span class="line"> <span class="comment">// 如果返回会将其返回值传回确切调用这个系统调用的用户进程</span></span><br><span class="line"> <span class="comment">// 这个函数会返回，将接收 exec 中传出的数据</span></span><br><span class="line">  <span class="type">int</span> ret = exec(path, argv);</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 循环遍历整个数组，然后释放掉所有页面到空闲池，不论 exec 成功与否都会执行</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NELEM(argv) &amp;&amp; argv[i] != <span class="number">0</span>; i++)</span><br><span class="line">    kfree(argv[i]);</span><br><span class="line">  <span class="comment">// 这里返回会回到执行系统调用的地方，那是在内核中处理的，所以在返回到用户模式时，就会返回到新的进程中去</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">bad:</span><br><span class="line"> <span class="comment">// 循环遍历整个数组，然后释放掉所有页面到空闲池</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NELEM(argv) &amp;&amp; argv[i] != <span class="number">0</span>; i++)</span><br><span class="line">    kfree(argv[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec 函数"></a>exec 函数</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1715099855304.png" alt="1715099855304.png"></p><p>执行成功则会在新的虚拟地址空间中执行新的程序，执行失败返回 -1，该函数传入两个参数，为新的程序分配一系列内存空间，分配一个页表，并且为其分配存放程序的空间，并且加载程序，分配栈和保护页，分配 trampoline 页面和 trap frame 页面</p><ul><li><code>path</code> 可执行文件的地址</li><li><code>argv</code> 指向参数数组的指针，这数组包含指向参数的指针，这些是传递给新的可执行程序的参数</li></ul><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8B/1715100337913.png" alt="1715100337913.png"></p><p>在该函数中，还会为参数分配空间，如图所示，参数都会被分配到栈中，最后分配完之后如图所示，先将参数字符串压入栈中，然后再将指向对应的参数的指针压入栈中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"> <span class="comment">// 找到可执行文件的 inode，这将增加该文件的引用计数</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// 读入 elf 标头，从文件的偏移 0 处开始读取，将其放入变量 elf 中</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"> <span class="comment">// 检查文件标头的魔数</span></span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"> <span class="comment">// 为该进程创建一个新的页表，返回该页表的指针</span></span><br><span class="line"> <span class="comment">// 为给定进程创建一个用户页表，没有用户内存，但有trampoline和trapframe页</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="comment">// 将程序加载到内存中</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">   <span class="comment">// 读取对应的程序头，0 表示内存地址位于内核中</span></span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 如果不是可加载段，查找下一个</span></span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 如果该加载段的内存大小小于文件大小</span></span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 检验是否溢出</span></span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 页面边界对齐</span></span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">// 用于增长虚拟地址空间，初始为 0，从 0 增长到所需的地址大小，成功返回新的大小，否则返回 0</span></span><br><span class="line">    <span class="comment">// 将这一块虚拟地址赋予对应的权限</span></span><br><span class="line">    <span class="comment">// 增长的虚拟地址空间已经被映射了，以调用下面的 loadseg</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="comment">// 将对应的程序头指向的内容加载到页表的虚拟地址中</span></span><br><span class="line">    <span class="comment">// off 为程序头指向对应程序的开始处，filesz 要加载文件的大小</span></span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"> <span class="comment">// 分配两个页表作为进程的栈，并且第一个作为保护页，第二个作为栈</span></span><br><span class="line"> <span class="comment">// 四舍五入到最近的页面边界，是下一页面的开始</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="comment">// 增长虚拟地址空间，并且定义为 可写，可读，用户模式可访问</span></span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// 删除保护页面的权限，在用户模式下将保护页标记为不可访问，防止栈溢出</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// 栈指针</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 栈基指针（地址），可用于检测是否将要溢出栈</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line">  <span class="comment">// 将该函数的参数存放到栈中，其中每个参数都被放置在内核地址空间中一个单独的页面上</span></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">   <span class="comment">// 大于最大参数数量</span></span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 分配字符串长度 + 1 的内存，最后一个表示终止空字符</span></span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 堆栈指针 16 字节对齐</span></span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="comment">// 确保没有溢出</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 将参数分配到对应的栈空间中，对齐将会导致一些未使用的空间</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 保存对应参数的地址</span></span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终的位置保存一个空指针，表示参数到此为止</span></span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 将指向参数的指针压入栈中，也就是将 ustack 压入栈中</span></span><br><span class="line">  <span class="comment">// 这里也需要对齐</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 确保没有溢出栈</span></span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="comment">// 将对应参数的指针压入栈中</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"> <span class="comment">// 这是设置被调用进程的参数</span></span><br><span class="line"> <span class="comment">// 第一个参数为 argc，以返回值的形式来保存到 a0 中</span></span><br><span class="line"> <span class="comment">// 第二个参数为 argv，设置在 a1 中</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="comment">// 保存进程名称以便调试</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 最终 last 就是该进程的名字了，例如 a/b/c，last 中保存的就是 c</span></span><br><span class="line"> <span class="comment">// 如果没有斜杠，那 path 就是这个进程名称了</span></span><br><span class="line">  <span class="comment">// 将进程名称复制到对应的进程结构体中</span></span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  <span class="comment">// 准备切换旧的虚拟地址空间到新的虚拟地址空间中去，并且确保程序从新程序头开始执行</span></span><br><span class="line">  <span class="comment">// 保存副本，用于释放</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="comment">// 初始化 epc 指向新程序的程序入口</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  <span class="comment">// 初始化栈指针</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="comment">// 释放旧页表</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">bad:</span><br><span class="line"> <span class="comment">// 如果成功分配页表，就需要释放掉所有分配的页面</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="comment">// 如果分配了 ip，那就得减少引用计数并且解锁，结束事务</span></span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flag2perm"><a href="#flag2perm" class="headerlink" title="flag2perm"></a>flag2perm</h3><p>该函数将设定文件权限的标志位转为对应的权限，由于设定文件的权限标志位与页表条目的权限标志位不一致，所以需要该函数来转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">flags2perm</span><span class="params">(<span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> perm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flags &amp; <span class="number">0x1</span>)</span><br><span class="line">      perm = PTE_X;</span><br><span class="line">    <span class="keyword">if</span>(flags &amp; <span class="number">0x2</span>)</span><br><span class="line">      perm |= PTE_W;</span><br><span class="line">    <span class="keyword">return</span> perm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadseg"><a href="#loadseg" class="headerlink" title="loadseg"></a>loadseg</h3><p>将一个程序段加载到虚拟地址 <code>va</code> 的页表中， <code>va</code> 必须对齐，并且从 <code>va</code> 到 <code>va+sz</code> 的页必须已经映射。成功时返回0，失败时返回-1</p><ul><li><code>pagetable</code> 对应进程的页表</li><li><code>va</code> 在上述页表中的虚拟地址，也是目标地址，需要保证虚拟地址被映射</li><li><code>ip</code> 对应文件的 <code>inode</code></li><li><code>offset</code> 在文件中的偏移位置，也就是开始读取数据的位置</li><li><code>sz</code> 需要读取内容的大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">loadseg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint i, n;</span><br><span class="line">  uint64 pa;</span><br><span class="line"> <span class="comment">// 每次循环加载一页大小到目标位置</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">   <span class="comment">// 得到对应的物理地址空间</span></span><br><span class="line">    pa = walkaddr(pagetable, va + i);</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;loadseg: address should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sz - i &lt; PGSIZE)</span><br><span class="line">      n = sz - i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      n = PGSIZE;</span><br><span class="line">    <span class="comment">// 读取对应文件中的数据到 得到的物理地址 pa 处</span></span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)pa, offset+i, n) != n)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>xv6 内核代码就介绍到这里，内容比较多，一开始是只用了一个文件的，但是内容过于多导致加载太卡了，所以直接从中间分成上下两篇了。之后可能会看看用户模式的代码，并做一些总结</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-kernel上</title>
      <link href="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/"/>
      <url>/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于 <code>xv6-kernel</code> 的代码是在 <code>qemu+riscv</code> 中进行仿真的，所以首先我们需要安装 <code>qemu</code> 和 <code>riscv</code> 仿真工具链</p><h2 id="riscv工具链"><a href="#riscv工具链" class="headerlink" title="riscv工具链"></a>riscv工具链</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>源码地址为</p><p><a href="https://gitcode.com/riscv-collab/riscv-gnu-toolchain/overview">risc-v</a></p><p>也可以直接使用 git 指令下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitcode.com/riscv-collab/riscv-gnu-toolchain/overview</span><br></pre></td></tr></table></figure><p>这里直接下载默认分支</p><h3 id="下载模块"><a href="#下载模块" class="headerlink" title="下载模块"></a>下载模块</h3><p>打开下载的源码目录下，找到名为 <code>.gitmodules</code> 的文件，这里面就是每个子模块的路径和分支。如果没有梯子，就可以根据其对应的名字在 Gitee 上查找对应的模块，然后直接将其下载到 <code>riscv-gnu-toolchain</code> 这个文件夹下，但是对应的模块要下载到对应的文件夹里。不仅如此，还需要下载该模块对应的分支，分支一定不能错。可以使用如下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b branch_name url module_name</span><br></pre></td></tr></table></figure><p>其中 <code>branch_name</code> 是分支名称， <code>url</code> 是下载链接，也就是 Gitee 上对应的模块的仓库地址， <code>module_name</code> 就是需要将这个模块放入的文件夹的名称，需要与 <code>.gitmodules</code> 文件中指定的模块的 <code>path</code> 一致</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>安装之前需要先安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev</span><br></pre></td></tr></table></figure><p>然后在 <code>/opt</code> 下创建 riscv 目录，并且修改其权限为所有权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /opt/riscv</span><br><span class="line">sudo chmod 777 /opt/riscv</span><br></pre></td></tr></table></figure><p>还需要安装 libncurses5-dev 库，这个库使得能够在使用 gdb 调试时使用 <code>layout</code> 指令，先安装再编译 riscv 才生效</p><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd riscv-gnu-toolchain</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=/opt/riscv --enable-multilib</span><br><span class="line">make linux -j 12</span><br></pre></td></tr></table></figure><p>执行完成没有报错的话，就可以查看 <code>/opt/riscv</code> 目录下，可以看到里面有 riscv 的工具</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>需要编辑 <code>~/.bashrc</code> 文件，在文件末尾添加如下两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RISCV=&quot;/opt/riscv&quot;</span><br><span class="line">export PATH=$PATH:$RISCV/bin</span><br></pre></td></tr></table></figure><p>然后使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>创建一个文件 <code>hello.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;hello RISCV!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 riscv 的 gcc 编译器编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unkonwn-linux-gnu-gcc hello.c -o hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>如果编译没有报错就成功了，但是 Ubuntu 不是 riscv 架构的，所以不能运行这个可执行文件</p><h2 id="qemu安装"><a href="#qemu安装" class="headerlink" title="qemu安装"></a>qemu安装</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install zlib1g-dev</span><br><span class="line">sudo apt install pkg-config</span><br><span class="line">sudo apt install libglib2.0-dev  </span><br><span class="line">sudo apt install binutils-dev</span><br><span class="line">sudo apt install libboost-all-dev</span><br><span class="line">sudo apt install autoconf</span><br><span class="line">sudo apt install libtool</span><br><span class="line">sudo apt install libssl-dev</span><br><span class="line">sudo apt install libpixman-1-dev</span><br><span class="line">sudo apt install virtualenv</span><br><span class="line">sudo apt install flex</span><br><span class="line">sudo apt install bison</span><br><span class="line">sudo apt install libgcrypt20-dev</span><br></pre></td></tr></table></figure><h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><p>python版本必须是 ≥ 3.6 的，使用下列指令查看 python 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 --version</span><br></pre></td></tr></table></figure><h3 id="安装-ninja"><a href="#安装-ninja" class="headerlink" title="安装 ninja"></a>安装 ninja</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ninja-build</span><br></pre></td></tr></table></figure><h3 id="下载源码-1"><a href="#下载源码-1" class="headerlink" title="下载源码"></a>下载源码</h3><p>由于官网下载较慢，所以可使用命令下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-6.2.0.tar.xz</span><br></pre></td></tr></table></figure><p>在终端输入指令解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d qemu-6.2.0.tar.xz</span><br><span class="line">tar -xvf qemu-6.2.0.tar</span><br></pre></td></tr></table></figure><h3 id="编译安装-1"><a href="#编译安装-1" class="headerlink" title="编译安装"></a>编译安装</h3><p>首先进入解压后的文件夹，新建安装目录，然后 <code>configure</code> 指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-6.2.0</span><br><span class="line">sudo <span class="built_in">mkdir</span> /opt/qemu</span><br><span class="line">./configure --prefix=/opt/qemu</span><br></pre></td></tr></table></figure><p>编译源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="下载-xv6源代码"><a href="#下载-xv6源代码" class="headerlink" title="下载 xv6源代码"></a>下载 xv6源代码</h2><p>xv6源代码仓库地址为 <a href="https://github.com/mit-pdos/xv6-riscv.git">github-xv6</a></p><p>使用指令下载该源代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mit-pdos/xv6-riscv.git</span><br></pre></td></tr></table></figure><h1 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>代码非常简洁，只有 6000 行代码，大部分是 C 语言和汇编语言，而且代码中没有依赖任何库函数，这也是内核程序员需要注意的</p><p>在 xv6 中所实现的用户操作有</p><ul><li>sh</li><li>cat</li><li>echo</li><li>grep</li><li>kill：用于杀死一个终端程序</li><li>ln：创建一个文件的硬链接</li><li>ls：内容目录</li><li>mkdir：创建目录</li><li>rm：删除文件</li><li>wc：计算文件的单词数量</li></ul><h3 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h3><p>它是适用于多核的处理器的，并且所有进程共享内存，一共是 128MB</p><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><ul><li>UART：同步串口通信设备，多个内核公用</li><li>DISK：磁盘，多个内核公用</li><li>TIMER：定时器，一个内核有一个定时器</li><li>PLIC：平台级中断处理器，这是一个单独的芯片或者电路处理来自于不同的设备的中断，会计算那个核心中断并且允许处理中断。模拟器将会模拟平台级中断处理</li><li>CLINT：核心本地中断控制器，这也是模拟的一部分，每个核心都有一个核心本地中断控制器，所以操作系统也需要处理这些东西</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内存管理比较简单</p><ul><li>物理内存分为页，页面大小是固定的 4KB</li><li>从空闲列表中为内核分配内存，空闲链表至少有一个未使用的页面。这是一个简单的链表，它从空闲列表中分配页面。当一个页面不再使用时，会将该页面返回到空闲链表的最先面</li><li>在操作系统中没有对象。在 xv6 中有几种不同的结构，当然它们是指着，但是使用面向对象的编程语言，可以分配可变大小的内存</li><li>没有 <code>malloc</code> ，虚拟地址空间由页表处理</li><li>页表：分为三个等级。每个进程有一个页表，此外内核本身还有一个页表，用于映射所有内存空间。内核页表被所有进程共享。页表硬件可以将数据页标记为可读，可写和可执行。R / W / X / U / V</li></ul><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ul><li>基本上是一个循环调度</li><li>每个过程有一个时间片，并且是固定的时间片——1000000 cycles。每个被调度的程序都在任务队列上等待着被调用。</li><li>所有进程共享一个就绪队列。内核会搜索一个准备好运行的进程，从队列中取出，并且为它分配时间片，运行结束之后会把它放回到就绪队列中，继续寻找另一个可运行的进程，并且内核会不断遍历该就绪队列。在这个队列中，线程会被标记为可运行和不可运行两种状态</li></ul><h3 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h3><ul><li>使用 <code>qemu</code> 来启动内核几乎跳过了所有的引导项</li><li>RISC-V 会模拟物理内存，把内核代码放在一个固定的位置。</li><li>xv6 不支持引导加载项，主引导记录或者 BIOS 之类的东西</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>xv6 使用了几种锁来进行锁定和并发控制</p><ul><li><p>Spin Locks 自旋锁，在内存中只有一个字来表示锁。如果锁是未持有的或者自由的，这个字为 0，否则为 1。有两个用户可调用的方法。</p><ul><li>acquire 获取，就是等待自旋锁状态被释放，一旦获取锁就会将其置为 1</li><li><p>release 释放，就是简单的将自旋锁状态设置为 0</p><p>还有两个线程所调用的方法</p></li><li><p>sleep 执行之后，线程将会结束它的时间片，并且将以不可运行的状态放回到就绪队列中，直到被唤醒</p></li><li>release 如果一个睡眠中的进程被唤醒，那它将会从睡眠状态改为可运行状态，然后它就会得到时间片</li></ul></li><li>选择性禁用中断，每个核心都有一个状态控制字，这个控制字可以被设置也可以被清除。它表示要么启用并且允许中断，要么禁用。通过禁用中断可防止一个线程被中断。但是这只能保证在当前内核中的线程不会被其它线程中断，不能保证其他内核的中断</li></ul><h3 id="一些固定的限制"><a href="#一些固定的限制" class="headerlink" title="一些固定的限制"></a>一些固定的限制</h3><ul><li>xv6 中有一些固定的限制，这些都是用磅符号定义声明的，例如进程数量只是一个固定的数字，最大可打开的文件数量也是固定的。</li><li>在内核中更加倾向于使用数组而不是链表，在一些情况下，使用线性搜索来遍历这些链表。例如杀死某个进程就是通过遍历进程表并且对比进程号进行线性搜索来杀死该进程</li></ul><h3 id="用户地址空间"><a href="#用户地址空间" class="headerlink" title="用户地址空间"></a>用户地址空间</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713355145892.png" alt="1713355145892.png"></p><p>这就是用户地址空间，分配内存时以页为单位进行内存分配。</p><ul><li>当使用 <code>exec</code> 操作时，内核将进入文件系统并且找到可执行文件，它将分配几个整页面，会把数据读入到 <code>data and code</code> 区域，然后这些页面将会被标记为可读，可写，并且可由内核执行。</li><li>并且还为栈分配了一个页面，而且这个栈只有一个页面，这导致很多需要将堆栈超出 4KB 的程序不能在 xv6 中运行。如果一个程序的堆栈需要增长到 4KB 以上时，会被系统终止</li><li>在 linux 或者 unix 系统中，栈通常放在高内存中，并且向下增长，直到堆栈相互触碰</li><li>除此以外，xv6 还有一个安全页，不可读，不可写，在用户模式下无法访问，当用户想要获取这部分空间时，整个进程将会被终止</li><li>堆在栈之后开始，并且以页面为单位增长，会调用内存来分配一些空闲的时间给堆使用，这些页面将会标记为可读可写<ul><li>用户可以在堆内存中任意的 <code>malloc</code> 内存，分配内存</li></ul></li><li>在虚拟内存空间最上面还有两个页面<ul><li><code>trampaline page</code> 被标记为<strong>用户模式不可访问</strong>，包含代码，所以它是<strong>可执行的</strong>。当陷阱或者异常发生时，将在 trampaline page 中执行代码</li><li><code>trap frame</code> 是可读可写的，寄存器将会被保存在这个位置</li><li>当中断或者异常发生时，寄存器以及用户进程的整个状态都会被保存，并且将其按照 <code>trampaline page</code> 中的代码保存在陷阱帧中。每个虚拟地址空间都有自己的陷阱框架页面， <code>trampalline page</code> 被所有进程共享，所以它们都被映射到相同的地址空间，但是有着不同的物理记忆页面。</li></ul></li><li>虚拟内存的大小正还是 256GB ，所以空闲内存会有很多，并且堆可能不会占用太多。而且内存中所存储的内容不可能超过实际的物理内存大小</li><li>在 C 语言程序运行时的入口 <code>main</code> 函数可以传入 <code>argc</code> 表示参数数量， <code>args</code> 表示传入参数， <code>arge</code> 来传入系统环境变量，但是 xv6 不支持环境变量。内核中的代码设置虚拟地址空间，并且将为栈分配一个页面，会将参数推入栈中，并且将栈的指针指向栈底，然后将栈的指针存入寄存器中。所以在用户程序运行第一条指令时，它会在栈上找到参数</li><li>页表有三种方案，xv6 使用 SV39，所以虚拟地址的内存大小为 $2^{39}$ ，正好是 512GB 的大小，所以使用这种方案意味着可以访问 512GB 大小的内存。而 xv6 只使用 $2^{38}$ 的内存，就是 256GB，所以最大内存地址为 0x4000000000<ul><li>SV32：是一个两级页表方案</li><li>SV39：应用于 xv6，是一个三级页表方案</li><li>SV48：是一个四级页表方案</li></ul></li></ul><h2 id="内核代码"><a href="#内核代码" class="headerlink" title="内核代码"></a>内核代码</h2><h3 id="risc-v汇编指令码"><a href="#risc-v汇编指令码" class="headerlink" title="risc-v汇编指令码"></a>risc-v汇编指令码</h3><ul><li><code>ld</code> 例如 <code>ld t0, 0(t1)</code> <code>t0 = memory[t1 + 0]</code> 将 <code>t1</code> 的值加上 0,将这个值作为地址，取出这个地址所对应的内存中的值，将这个值赋值给 <code>t0</code></li><li><code>lw</code> 例如 <code>lw t2, 20(t3)</code> <code>t2 = memory[20 + t3]</code> <code>lw</code> 与 <code>ld</code> 的区别就在于 <code>ld</code> 是从内存取出64位数值，而lw是取出32位数值。</li><li><code>lh</code> 例如 <code>lh t4, 30(t5)</code> <code>t4 = memory[30 + t5]</code> 从内存中取出16位数值</li><li><code>lb</code> 例如 <code>lb t4, 30(t5)</code> <code>t4 = memory[30 + t5]</code> 从内存中取出8位数值</li><li><code>sd</code> 例如 <code>sd t0, 0(t1)</code> <code>memory[0+t1] = t0</code> 将 <code>t1</code> 的值加上0,将这个值作为地址，将 <code>t0</code> 的值存储到上述地址所对应的内存中去</li><li><code>sw</code> 例如 <code>sw t0, 0(t1)</code> <code>memory[0+t1] = t0</code> 与 <code>sd</code> 的区别在于 <code>sw</code> 只会将 <code>t0</code> 的低32位数值存储到相应的内存。 <code>sd</code>会将 <code>t0</code> 的64位都存入</li><li><code>sh</code> 例如 <code>sh t0, 0(t1)</code> <code>memory[0+t1] = t0</code> 只将 <code>t0</code> 的低16位所对应的数值存入，也就是一个half word大小</li><li><code>sb</code> 例如 <code>sb t0, 0(t1)</code> <code>memory[0+t1] = t0</code> 只存入8位，一个byte大小</li><li><code>lwu</code> 例如 <code>lwu t2, 20(t3)</code> <code>t2 = memory[20 + t3]</code> <code>lw</code> 与 <code>lwu</code> 的区别在于，前者取出32位数值作符号扩展到64位，而后者做无符号扩展到64位</li><li><code>lhu</code> 例如 <code>lhu t4, 30(t5)</code> <code>t4 = memory[30 + t5]</code></li><li><code>lbu</code> 例如 <code>lbu t4, 30(t5)</code> <code>t4 = memory[30 + t5]</code></li></ul><h3 id="内核代码文件"><a href="#内核代码文件" class="headerlink" title="内核代码文件"></a>内核代码文件</h3><ul><li><code>bio.c</code> 文件系统的磁盘块缓存</li><li><code>console.c</code> 连接到用户的键盘和屏幕</li><li><code>entry.S</code> 首次启动指令</li><li><code>exec.c</code> exec()系统调用</li><li><code>file.c</code> 文件描述符支持</li><li><code>fs.c</code> 文件系统</li><li><code>kalloc.c</code> 物理页面分配器</li><li><code>kernelvec.S</code> 处理来自内核的陷入指令以及计时器中断</li><li><code>log.c</code> 文件系统日志记录以及崩溃修复</li><li><code>main.c</code> 在启动过程中控制其他模块初始化</li><li><code>pipe.c</code> 管道</li><li><code>plic.c</code> RISC-V中断控制器</li><li><code>printf.c</code> 格式化输出到控制台</li><li><code>proc.c</code> 进程和调度</li><li><code>sleeplock.c</code> Locks that yield the CPU</li><li><code>spinlock.c</code> Locks that don’t yield the CPU.</li><li><code>start.c</code> 早期机器模式启动代码</li><li><code>string.c</code> 字符串和字节数组库</li><li><code>swtch.c</code> 线程切换</li><li><code>syscall.c</code> Dispatch system calls to handling function.</li><li><code>sysfile.c</code> 文件相关的系统调用</li><li><code>sysproc.c</code> 进程相关的系统调用</li><li><code>trampoline.S</code> 用于在用户和内核之间切换的汇编代码</li><li><code>trap.c</code> 对陷入指令和中断进行处理并返回的C代码</li><li><code>uart.c</code> 串口控制台设备驱动程序</li><li><code>virtio_disk.c</code> 磁盘设备驱动程序</li><li><code>vm.c</code> 管理页表和地址空间</li></ul><h2 id="系统开始"><a href="#系统开始" class="headerlink" title="系统开始"></a>系统开始</h2><p>xv6 系统在多核的计算机上运行时，开始时每个核心都同时开始，并且它们享有共同的内存，所以他们会执行相同的代码，这个代码位于 <code>entry.S</code> 文件中</p><h3 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h3><p>代码很少，在这个文件中运行的是将一些环境设置好，以便可以执行 C 程序代码。初始化栈指针寄存器（SP寄存器）以及 线程指针（TP寄存器，会存储当前是第几个内核，整个过程中，寄存器将在核心上保持不变）。由于每个核心都是共享内存的，所以它们将访问同一组全局变量，但是每个内核都会需要自己的栈，并且不能重合，所以每个核心都有一个单独的空间。然后将控制权转交给 <code>start.c</code> 中一个名为 <code>start</code> 的 C 函数。</p><h3 id="start-c"><a href="#start-c" class="headerlink" title="start.c"></a>start.c</h3><p>将控制权转交给 <code>main.c</code> ，也就是 main 函数。进入 <code>start.c</code> 函数之后，程序会进入机器模式，然后会做一些 bookkeeping 的事情，之后进入监督模式，也就是把系统交给用户管理。每个核心都会执行 <code>start</code> 函数和 <code>main</code> 函数</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>在函数中会判断内核号，0 号内核会进行一些初始化的操作，等待 0 号内核初始化完成之后，其它的内核会进行一些页面，内核陷阱列表和系统级中断等初始化。0 号内核的最后语句是初始化用户程序。当所有内核执行完成之后，每个内核都会调用一个调度器，就是寻找一个要执行的进程。</p><p>在 <code>main</code> 中有一段神奇的代码 <code>__sync_synchronize</code> ，这个函数将会告诉编译器，一定要完成这条代码之前的东西再执行这条代码之后的东西</p><h2 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h2><p>用一个单词表示自旋锁，如果内容是 0，那就表示锁是释放掉的，内容是 1，表示锁被占用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有两个参数</p><ul><li><code>name</code> 可以给该自旋锁设置名字，它所指向的是一个字符串</li><li><code>cpu</code> 指定某一个 CPU，每个核都有一个与之相关联的结构体 <code>cpu</code> ，这个字段包含一个指向 <code>cpu</code> 结构的指针，用于表示当前持有锁的内核</li></ul><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>用于请求锁，代码格式类似于下列代码，也就是会并不断循环来请求锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (locked == <span class="number">0</span>)</span><br><span class="line"> locked = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> loop;</span><br></pre></td></tr></table></figure><p>这个自旋锁是有风险的，一旦两个线程同时请求锁，并且锁是释放的，这两个线程会同时将锁置 1，它们都会认为自己获得了锁，所以就会出现问题。在 risc-v 中提供了<strong>原子内存操作</strong>，它会不间断的检索该单词的前一个值，所以它不允许其它任何线程或者任何其它内核的指令来访问这段内存。</p><p>自旋锁具体实现就是，向内存中写入 1，并且读取内存的前一个值，如果前一个值为 0，那就大功告成，否则会一直循环请求，直到前一个值为 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   a5 = 1</span></span><br><span class="line"><span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line"><span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line"><span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>这段代码将会被编译为上面的汇编指令，就是一段原子交换指令，这个函数的作用就是，传入一个想要修改的地址，并且传入新值，返回旧值。</p><p>整个请求的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 禁止中断来防止死锁的发生</span></span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk)) <span class="comment">// 判断是否持有锁，如果持有锁，那就出问题了，报错指令</span></span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>) <span class="comment">// 原子内存交换，获取锁</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和处理器不要移动超过这个点的加载或存储，以确保临界区的内存引用严格发生在获得锁之后。</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会发出一个fence指令。</span></span><br><span class="line">  __sync_synchronize(); <span class="comment">// 同步操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu(); <span class="comment">// 将锁的持有CPU改为当前CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>用于释放锁，释放锁只需要向锁的内存中写入 0 就可以，它不是一个原子操作，只是一个内存的读取与存储，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk)) <span class="comment">// 首先确定真的拿到了这把锁</span></span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// 释放锁，相当于lk-&gt;locked = 0</span></span><br><span class="line"> <span class="comment">// 这段代码没有使用C语言赋值，因为C语言标准暗示赋值可以用多个存储指令来实现。</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off(); <span class="comment">// enable interrupts </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initlock"><a href="#initlock" class="headerlink" title="initlock"></a>initlock</h3><p>在第一次调用锁之前初始化锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>; <span class="comment">// 初始化锁的 CPU 相当于是 NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="holding"><a href="#holding" class="headerlink" title="holding"></a>holding</h3><p>用于输出哪个内核正在持有锁，用于检查 CPU 是否获得了锁，如果当前锁是 1，并且锁被当前 CPU 持有，则返回 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="push-off"><a href="#push-off" class="headerlink" title="push_off"></a>push_off</h3><p>在请求锁的函数的第一条语句就是禁用中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get(); <span class="comment">// 获取失能中断前的中断使能状态</span></span><br><span class="line"></span><br><span class="line">  intr_off(); <span class="comment">// 关闭中断</span></span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>) <span class="comment">// 如果时第一次调用就设置中断使能状态，见下面的解释</span></span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>; <span class="comment">// 中断层数计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pop-off"><a href="#pop-off" class="headerlink" title="pop_off"></a>pop_off</h3><p>在释放锁的函数的最后一条语句就是使能中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu(); <span class="comment">// 对当前内核进行操作</span></span><br><span class="line">  <span class="keyword">if</span>(intr_get()) <span class="comment">// 中断已经启用了，就报错，因为在释放所有锁之前，中断不能使能</span></span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>) <span class="comment">// 已经释放所有锁，但是依旧调用释放，就报错</span></span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on(); <span class="comment">// 如果第一次请求锁之前中断是使能状态，就使能中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>自旋锁不应该被长期持有，如果一个线程想要获得锁，并且不断自旋，会浪费很多时间。当然 xv6 中还有其它锁定技术 <code>sleep()</code> 和 <code>wakeup()</code> 这些可以在需要拿着锁很长一段时间下使用</p><p>所以不会让一个线程获得锁时间太长，内核会集中处理拿到锁的线程的核心程序，尽可能快地释放锁</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>锁是用来保护共享数据的，在 xv6 中会有如下精巧的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acquire();</span><br><span class="line">...<span class="comment">// 访问共享数据，一次只能一个线程进行</span></span><br><span class="line">release();</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713974680722.png" alt="1713974680722.png"></p><p>当一个线程获得了锁的时候，恰巧按下键盘，触发键盘中断，键盘中断调用中断处理程序，向某一个共享内存写入数据，需要获得锁。但是持有锁的线程被中断，这导致系统卡死。也就是拿着锁的线程不运行无法释放锁，中断请求锁但是拿不到，这就是死锁</p><p>所以解决死锁的方法就是在请求锁时禁用中断，在释放锁之后，打开中断，当然持有锁的时间一定需要很短</p><h3 id="如果需要调用多个锁"><a href="#如果需要调用多个锁" class="headerlink" title="如果需要调用多个锁"></a><strong>如果需要调用多个锁</strong></h3><p>例如需要调用 3 个锁，每个锁获取时都会禁用中断，但是在第一个释放锁就会启用中断，这个并不是我们想要的。希望可以使用多层嵌套调用 <code>acquire</code> 和 <code>release</code> 函数，所以可以使用一个计数器。例如每个内核都有一个 <code>CPU</code> 结构体，而每个结构体内部都有一个计数器，所以请求和释放函数可以如下实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">acquire() &#123;</span><br><span class="line"> cnt++;</span><br><span class="line"> disableInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">release() &#123;</span><br><span class="line"> cnt--;</span><br><span class="line"> <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">  enableInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中断使能函数 <code>enableInterrupt</code> 中，当 <code>cnt==0</code> 时，需要判断在第一次请求锁之前中断是否是使能状态，如果已经使能，那就会启用中断，所以在 <code>CPU</code> 结构体中，有一个专门用来存储第一次请求锁之前中断的使能状态。</p><h2 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h2><p>在 xv6 中，所有的内存管理都是 4KB 为单位的，也就是以 page 为单位，它们被放在一个空闲列表中，内存管理有两个关键的函数</p><ul><li><code>kalloc()</code> 只是从空闲列表中删除了一些东西</li><li><code>kfree()</code> 将一个空闲页重新添加回空闲列表中</li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>run</code> 是一个指向下一个空闲空间的指针</li><li><code>kmem</code> 里面实现了自旋锁和空闲链表，用自旋锁对空闲链表进行分组，称为简单锁，用于将锁与空闲列表关联，每当操作空闲列表，需要获取锁或者设置锁，当访问完空闲列表之后，需要把锁释放掉</li></ul><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br></pre></td></tr></table></figure><p>这是链接器在链接时生成的，里面存放的是内核之后的第一个地址，也就是第一个可用内存，这将会在初始化时被使用</p><h3 id="kinit"><a href="#kinit" class="headerlink" title="kinit"></a><strong>kinit</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP); <span class="comment">// PHYSTOP-end=128MB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="comment">// 将起始内存四舍五入到最近的页面边界，页面对齐</span></span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p); <span class="comment">// 将所有可用内存初始化，释放掉所有内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中所做的就是初始化锁，并且释放掉范围之内的内存，这个范围就是第一个内存空间和顶端物理空间的内存，这是一个常数，正好是 128MB ，但是由于需要内存页面对齐，所以真实内存可能不到 128MB</p><h3 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span> </span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock); <span class="comment">// 请求自旋锁</span></span><br><span class="line">  r = kmem.freelist; <span class="comment">// 请求第一个物理页</span></span><br><span class="line">  <span class="keyword">if</span>(r) <span class="comment">// 请求成功</span></span><br><span class="line">    kmem.freelist = r-&gt;next; <span class="comment">// 修改空闲列表以指向下一个项目</span></span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) <span class="comment">// 请求成功之后</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713408912376.png" alt="1713408912376.png"></p><p>在 <code>kalloc</code> 中所进行的操作如上图所示</p><h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><p>传递一个页面的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"> <span class="comment">// 错误检查</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数中首先回进行错误检查，确保 <code>pa</code> 的物理地址在页边界上对齐，确保页面内存位于申请的首尾内存之间。之后会将页面写满 1，这样做目的就是防止内核其它代码出现任何bug，所以不想将页面返回空闲链表之后被使用，所以就将其中的每个字节都设置为某个值。然后请求锁，并将释放的内存链接到空闲内存链表中，与 <code>kalloc()</code> 正好相反</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>用户模式如何进入系统调用</p><p>系统调用的所有函数原型（声明）位于 <code>user.h</code> 中，其中的系统调用代码的实现位于 <code>usys.pl</code> 脚本生成 <code>usys.S</code> 文件中</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印声明，也就是将这些东西写入 usys.S 文件中</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">my</span> $name = <span class="keyword">shift</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;.global $name\n&quot;</span>; <span class="comment"># 全局声明</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;<span class="subst">$&#123;name&#125;</span>:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; li a7, SYS_<span class="subst">$&#123;name&#125;</span>\n&quot;</span>; <span class="comment"># 加载系统调用</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ecall\n&quot;</span>; <span class="comment"># 调用</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ret\n&quot;</span>; <span class="comment"># 返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个就是将对应的系统调用进行实现，实际上每个系统调用的最终都是调用了 SYS 的系统调用</span></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">...</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br></pre></td></tr></table></figure><p>最后生成的对应的汇编代码为</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generated by usys.pl - do not edit</span></span><br><span class="line"><span class="comment">#include &quot;kernel/syscall.h&quot;</span></span><br><span class="line">.global <span class="keyword">fork</span></span><br><span class="line"><span class="keyword">fork</span>:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>会生成很多系统调用的代码，每个系统调用码都对应着一个数字，位于 <code>syscall.h</code> 文件中。 <code>ecall</code> 在用户模式下被调用，进入到内核模式中，然后内核将执行对应的代码，然后返回用户模式 <code>return</code></p><p>当调用该函数时，函数传入的参数会依次被放入 <code>a0, a1...</code> 寄存器中，而返回值将出现在 <code>a0</code> 中，内核会做到这一点，系统调用中的参数位于 <code>a0, a1, ...</code> 中，而且返回值会位于 <code>a0</code> 中。这些系统调用没有直接在寄存器中赋予参数，是因为调用之前就假定已经将参数写入到对应的寄存器中了，而调用结果将会在 <code>a0</code> 中被返回</p><h3 id="initcode-S"><a href="#initcode-S" class="headerlink" title="initcode.S"></a>initcode.S</h3><p>是内核在用户模式下执行的第一个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><p>代码量很少，在 <code>start</code> 中执行的代码就是 <code>exec</code> 系统调用，开始初始化的系统调用，加载两个参数，第一个参数就是 <code>/init\0</code> ，第二个参数包含 <code>init</code> 的地址，一个 0 和一个对齐语句，加载完成之后，进行系统调用。在 <code>exit</code> 中执行的代码就是系统退出代码，调用 <code>exit</code> 系统调用退出，这个调用需要一个参数，就是退出码或者返回码。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/15cdb032846d43dfb241acb2c1a7ddf3.png" alt="15cdb032846d43dfb241acb2c1a7ddf3.png"></p><p>在 risc-v 架构中，有 32 个通用寄存器和一个程序计数器，每个都是 64 位寄存器</p><ul><li><code>zero</code> 是以硬件线路作为寄存器的，在进程之间上下文切换中不需要保存</li><li><code>ra</code> 返回地址寄存器，当在 risc-v 中进行函数调用时，函数返回地址位于 <code>ra</code> 寄存器，而不是推入栈中，返回地址只是简单的从 <code>ra</code> 中复制值，所以许多函数不需要访问主存</li><li><code>sp</code> 栈指针，栈向下生长</li><li><code>tp</code> 是 xv6 中所谓的线程指针，包括内核代码，实际上是不可改变的，在启动过程中 <code>mhartid</code> 寄存器的数据将会被 move 到这里</li><li><code>gp</code> 是全局指针，被编译器使用，将被设置而不被更改，基本上只是用来使得访问全局和共享变量更快更有效</li><li><code>a0,...,a7</code> 用于将参数传递给函数， <code>a0</code> 用于存放函数返回值</li><li><code>t0,...,t6</code> 这些寄存器可以在函数中自由使用，做函数任何想做的事情</li><li><code>s0,...,s11</code> 有12个所谓的被调用方保存寄存器。调用方将假设它所调用的任何函数都不会修改这些寄存器。该函数必须在使用它们之前保存它们，通常将它们推入栈中。返回之前必须恢复这些寄存器</li><li><code>pc</code> 是代码执行地址的寄存器，指向下一条该运行的代码</li></ul><h3 id="risc-v-模式"><a href="#risc-v-模式" class="headerlink" title="risc-v 模式"></a>risc-v 模式</h3><p>任何情况下 risc-v 都处于以下三种模式之一，<strong>每个内核都有自己的寄存器</strong>，<strong>每个内核在任何时候都以一种模式运行</strong></p><ul><li>machine mode：机器模式是最高和最强大的模式，拥有最大的权限。在系统启动或者重启之后 xv6 内核会进入机器模式。这个模式使用不多。有些代码在启动时以机器模式运行，做一些初始化的工作<ul><li>startup——initialization</li><li>time interrupt require：定时器中断要求处理程序在机器模式下运行。而在机器模式下运行的这段代码立即将中断转换为 supervisor mode 的代码中断，这个程序会很快返回</li></ul></li><li>supervisor mode：是所有动作发生的地方<ul><li>所有内核代码都在此运行</li><li>有些中断是有权限的，无法在 user mode 下运行，只能在 supervisor mode 和 machine mode 下运行</li></ul></li><li>user mode<ul><li>所有用户代码都在此运行</li><li>高权限的指令会产生一个陷阱，并且内核将会中止此进程</li></ul></li></ul><h3 id="Control-And-Status-Registers-CSRs"><a href="#Control-And-Status-Registers-CSRs" class="headerlink" title="Control And Status Registers CSRs"></a>Control And Status Registers CSRs</h3><p>事实上，系统能容纳 4096 个控制和状态寄存器。在 xv6 中，只有 19 个是重要的。</p><p>下面是三条具有高权限的指令，是对<strong>控制和状态寄存器的读写操作</strong></p><ul><li><code>csrr a0, sstatus</code> 将 s 状态寄存器读取到 a0 寄存器中</li><li><code>csrw sstatus, a0</code> 将 a0 寄存器写入到 s 状态寄存器中</li><li><code>csrrw a0 mscratch a0</code>  将 a0 寄存器与 mscratch 寄存器内容交换，这个交换是原子操作。这条指令的实际操作就是，将 mscratch 复制到 a0 寄存器中，同时将 a0 寄存器复制到 mscracth 中，这两个操作是同时进行的</li></ul><p>下面是那 19 个<strong>比较重要的寄存器</strong>，其中 <code>m</code> 开头的只能在机器模式下使用和访问，而 <code>s</code> 开头的可以在机器模式和主管模式下访问</p><ul><li><code>mhartid</code> 包含内核号。这个寄存器是硬件连线的，不能修改，可查询代码运行在哪个内核中，并且将内容移居到 <code>tp</code> 寄存器， <code>tp</code> 寄存将永不改变。 函数 <code>cpuid()</code> 将会返回 <code>tp</code> 寄存器</li><li><code>mstatus</code> <code>sstatus</code> 状态寄存器</li><li><code>mtvec</code> <code>stvec</code> 陷阱向量也就是陷阱发生时被调用的处理程序的地址</li><li><code>mepc</code> <code>sepc</code> 当陷阱发生时，以前的程序计数器将会保存在该寄存器</li><li><code>scause</code> 当陷阱发生时，陷阱发生的原因会被保存于此，如果有额外信息， <code>stval</code> 寄存器也会更新</li><li><code>stval</code> 保存出错的指令或者地址</li><li><code>mscratch</code> <code>sscratch</code> 工作寄存器，可以被 <code>trap handler</code> 所使用</li><li><code>satp</code> 包含指向页表的指针，是地址转换指针。注册地址转换指针，指向页表，而页表存储在主存中。任何时候都会有一个页表被使用，就是 satp 所指向的页表</li><li><code>mie</code> <code>sie</code> 可以在机器模式或者用户模式下有选择地使能中断</li><li><code>sip</code> 可以找到任何一点，有哪些中断被挂起了</li><li><code>medeleg</code> 异常可以从机器模式委托到主管模式</li><li><code>mideleg</code> 中断可以从机器模式委托到主管模式</li><li><code>pmp0cfg</code> <code>pmp0addr</code> PMP控制寄存器和PMP地址寄存器，但是未在 <code>xv6</code> 中使用。<strong>物理内存保护</strong>，限制运行在用户模式或者主管模式的打码对物理内存的访问，具体可查看 <a href="https://tinylab.org/riscv-pmp-1/#%E5%89%8D%E8%A8%80">RISC-V 物理内存保护（PMP）机制探究 - 泰晓科技 (tinylab.org)</a><ul><li>可以提供安全处理和故障隔离功能，对现代处理器来说是非常重要的。</li><li>PMP 机制适用于所有特权模式为 S 或 U 的指令和数据访问，通过在 M 态下修改每个 hart 对应的控制寄存器，可以指定每个物理内存区域的读、写和执行等访问权限。</li><li>PMP 机制也可用于 S 态中的页表访问。</li><li>违反 PMP 机制的访存将被处理器捕获并触发异常</li></ul></li></ul><h3 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h3><p>陷阱，分为两种</p><ul><li><code>exceptions</code> 异常是同步的，是由某种指令引起的，分为两种<ul><li>系统调用指令，在 risc-v 系统中，系统调用指令为 <code>ecall</code></li><li>程序错误。一些非法的指令，对齐错误，内存访问错误会导致异常</li></ul></li><li><code>interrupts</code> 中断是异步的，来自于当前代码以外的某个其它的地方<ul><li>timer：处理程序必须在机器模式下运行，任何情况下都可能发生，但是恰好处理程序会在机器模式下运行。这个中断处理会通知内核，并且导致主管级别的软件中断</li><li>device: uart，disk and so on：硬件设备的中断</li><li>软件中断：软件中断将由在机器模式下运行的代码引起。软件中断将由运行在监管模式下的代码来处理。也就是内核有软件中断处理程序，做一些需要为定时器中断所做的事</li></ul></li></ul><h2 id="页表架构"><a href="#页表架构" class="headerlink" title="页表架构"></a>页表架构</h2><h3 id="虚拟地址转换"><a href="#虚拟地址转换" class="headerlink" title="虚拟地址转换"></a>虚拟地址转换</h3><p><code>satp</code> 包含指向页表的指针，是地址转换指针。注册地址转换指针，指向页表，而页表存储在主存中。任何时候都会有一个页表被使用，就是 <code>satp</code> 所指向的页表</p><p>虚拟地址转换在初始化之后总是打开的，一开始 <code>satp</code> 是 0，也就没有地址转换发生，但是在初始化阶段之后，该指针会指向第一个页表。也就是说，在机器模式下，虚拟地址转换还未打开，在用户模式和主管模式下就打开了</p><p>RISC-V 指令操作的是虚拟地址，RISC-V的页表硬件支持了虚拟地址到物理地址的转换</p><p>xv6运行在<strong>Sv39 RISC-V</strong>上， 这意味着<strong>只使用64位虚拟地址的低39位</strong>，而高25位不使用，高25位作为保留位</p><p>分页硬件通过利用39位中的高27位索引到页表中找到一个PTE来转换一个虚拟地址，并计算出一个<strong>56位的物理地址</strong>，该物理地址的<strong>前44位</strong>来自PTE中的PNN，而它的后12位则是从原来的虚拟地址中的<strong>低12位</strong>复制过来，如下图</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/bc36ba6be7424686a4beb8d99969b6fe.png" alt="bc36ba6be7424686a4beb8d99969b6fe.png"></p><p>实际上 xv6 的地址转换时分三步运行的，页表是以三级页表的形式存储在物理内存中</p><p>第二级页表也就是根页表是一个 <strong>4KB 的页表</strong>，包含<strong>512个页表项</strong>。这些页表项包含树的下一级页表的物理地址首址。第一级页表也包含<strong>512个页表项</strong>，这些页表项包含第零级页表的物理首址。第一级页表的物理首址由页表寄存器 <code>satp</code> 提供，而 <code>satp</code> 寄存器由内核写入根页表的物理地址。最终的叶页表就是实际的物理页</p><p>虚拟地址的低39位的高27位用来定位页框号。这27位被分为3份，每份9位，分别定位对应的页表的页表项。具体过程如下图所示</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/051adbe8cb4241d2a1b6488218f25b23.png" alt="051adbe8cb4241d2a1b6488218f25b23.png"></p><p>每个CPU都有自己的satp寄存器。因此，一个CPU将使用自己的satp寄存器所指向的页表来翻译后续指令产生的所有地址。这保证了不同CPU可以运行不同的进程，因为这使每个CPU的进程可以拥有不同的私有地址空间。</p><blockquote><p><strong>缺页异常：若转换一个地址所需的三个页表项中的任何一个不存在，分页硬件就会引发一个缺页异常（page-fault exception），内核会处理这个异常</strong></p></blockquote><p>页表项是一个 64 位的数字，各个位的分配如下图所示</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/395c31c158c6434f98dc5bd2053528fe.png" alt="395c31c158c6434f98dc5bd2053528fe.png"></p><p>其中</p><ul><li>V ：表示页表是否存在，没置位则不允许引用该页表对应的页</li><li>R ：是否允许指令读取</li><li>W ：是否允许指令写入</li><li>X ：是否可以将页表内容解释为指令并执行</li><li>U ：决定是否允许用户态下得到指令访问页面，没置位则只能在内核态下使用</li></ul><h3 id="内核页表"><a href="#内核页表" class="headerlink" title="内核页表"></a>内核页表</h3><p>内核页表只有一个，所有内核共同使用。是一对一的映射，所有的页表内存都映射着物理内存，不需要进行地址运算。还有一些内存映射，是一个 IO 设备</p><h3 id="用户进程页表"><a href="#用户进程页表" class="headerlink" title="用户进程页表"></a>用户进程页表</h3><p>每一个用户进程都有一个页表，页表的实现有多个选项</p><ul><li>sv32 二级页表，例如RV32</li><li>sv39 三级页表，xv6</li><li>sv48 四级页表，例如RV64</li></ul><h3 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h3><p>每一次内存的读取，存储都会遍历页表，遍历页表将涉及几次内存访问，这个效率是非常低的。</p><p>所以在实际的系统中是有地址转换的缓存的（Translation Lookaside Buffers，TLBs），用于减少这些低效率的操作。它会缓存最近的页表。当需要切换页表时，必须清空所有的 LTBs</p><p>实际上在 risc-v 架构提供了方法 <code>sfence.vma</code> ，而在内核中会有函数 <code>sfence_vma</code> 用于调用这个方法</p><h3 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h3><p>虚拟地址一共有 39 位</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713431149889.png" alt="1713431149889.png"></p><ul><li><code>0-11</code> 位表示在页面上的偏移量</li><li><code>12-20</code> 位表示页表项在第三级页表中的偏移地址</li><li><code>21-29</code> 位表示第一级页表的页表项在第二级页表中的偏移量</li><li><code>30-38</code> 位表示第零级页表的页表项在第一级页表中的偏移位置</li><li><code>39-63</code> 位被忽略</li></ul><p>具体过程表示i可以看看上面</p><h3 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/395c31c158c6434f98dc5bd2053528fe.png" alt="395c31c158c6434f98dc5bd2053528fe.png"></p><p>其中</p><ul><li>V ：表示页表是否存在，没置位则不允许引用该页表对应的页</li><li>R ：是否允许指令读取</li><li>W ：是否允许指令写入</li><li>X ：是否可以将页表内容解释为指令并执行</li><li>U ：决定是否允许用户态下得到指令访问页面，没置位则只能在内核态下使用</li><li>其它的 G, A, D 和 RSW 并没有在 xv6 中使用</li></ul><p>其中 <code>10-53</code> 位是该页表对应的物理页的地址，一共 44 位，将其与虚拟地址的低 12 位组合得到最终的真实地址，一共占 56 位，所以最多可以支持 56 位的主物理内存</p><h2 id="Trap-Processing"><a href="#Trap-Processing" class="headerlink" title="Trap Processing"></a>Trap Processing</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><code>exception</code><ul><li><code>syscall</code> : <code>ecall</code></li><li><code>Error</code> : Illegal instruction, Aligment Error,…</li></ul></li><li><code>interrupt</code><ul><li>device interrupt：会在用户模式和主管模式下出现，而且处理程序是在主管模式下运行</li></ul></li></ul><h3 id="stvec"><a href="#stvec" class="headerlink" title="stvec"></a>stvec</h3><p>是一个状态和控制寄存器，包含指向中断处理程序代码的指针。每个中断处理程序的第一条指令的地址，将处理发生的任何陷阱</p><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><ul><li><code>kernelvec</code>：处理在主管模式下运行时发生的 <code>trap</code></li><li><code>uservec</code>：处理在用户模式下运行时所发生的 <code>trap</code></li></ul><h3 id="sstatus"><a href="#sstatus" class="headerlink" title="sstatus"></a>sstatus</h3><p>一共是64个位，每一个位表示一个状态标志位</p><ul><li><code>sie</code> 第 3 位，是否启用中断。如果是中断导致的 <code>trap</code> ，这个值必须是 1，否则不会处理<ul><li>在 xv6 的内核中可以改变启用中断的状态来防止核心部分代码受到打扰。</li><li>不同核之间不会相互干扰，但有可能会对同一块内存同时进行读写操作，这个是由锁来保护</li></ul></li><li><code>spie</code> 第 7 位，当前中断使能状态，主要是用于保存多层嵌套的锁中最初的中断使能状态</li><li><code>spp</code> 第 11 位，当前权限等级。主要是为了区分当前异常或者中断发生时，是在什么模式下的，中断处理不可能从机器模式到主管模式<ul><li>0：用户态</li><li>1：内核态</li></ul></li><li><code>seie</code> 第 1 位，设备中断使能，初始化置为 1</li><li><code>stie</code> 第 5 位，时钟定时器中断使能，初始化置 1</li><li><code>ssie</code> 第 9 位，软件中断使能，也就是委托中断，初始化置 1</li><li><code>sip</code> 用于中断挂起的标志位，保存了发生但是为处理的中断或者异常<ul><li>1：一个中断被挂起</li><li>0：没有中断</li></ul></li></ul><h3 id="mstatus"><a href="#mstatus" class="headerlink" title="mstatus"></a>mstatus</h3><p>是 64 位，每一个位表示一个状态标志位</p><ul><li><code>mie</code> 第 3 位，是否启用中断</li><li><code>spie</code> 第 7 位，表示最初中断使能状态</li><li><code>mpp</code> 第 11 和 第 12 位，用于保存先前的模式<ul><li>00：用户模式</li><li>01：主管模式</li><li>11：机器模式</li></ul></li><li><code>mtie</code> 第 8 位，用于使能定时器中断，在初始化阶段会被设为 1，这发生在 <code>start</code> 函数中，并且在机器模式下运行</li></ul><h3 id="trap处理"><a href="#trap处理" class="headerlink" title="trap处理"></a>trap处理</h3><ul><li>首先判断中断是否启用，如果未启用会将中断处理程序挂起，等到重新启用中断</li><li>但是如果是 <code>expection</code>，不管是否禁用中断都会立即处理</li></ul><h3 id="主管模式处理-trap"><a href="#主管模式处理-trap" class="headerlink" title="主管模式处理 trap"></a>主管模式处理 trap</h3><ol><li>硬件将会做<ul><li>将 <code>pc</code> 保存在 <code>sepc</code></li><li>将中断处理程序的第一条指令放入 <code>pc</code> 中，也就是 <code>stvec-&gt;pc</code></li><li>在 <code>scause</code> 寄存器中保存陷阱处理程序的原因<ul><li>1：软件中断，与时钟中断有关</li><li>8：系统调用</li><li>9：外部设备</li><li>其它都是程序异常以及代码中的错误</li></ul></li><li>可能会在 <code>stval</code> 中保存额外的信息</li><li>硬件会立即保存之前的模式，会保存在 <code>sstatus.SPP</code></li><li>将 <code>sstatus.sie</code> 写入 <code>sstatus.spie</code> 中，也就是保存多层嵌套的锁中最初的中断使能状态</li><li>禁用中断 <code>sstatus.sie=0</code></li><li>模式改为主管模式</li></ul></li><li>硬件处理做完之后将会开始执行第一条中断处理程序的代码</li><li>中断处理程序结束之后会返回到中断代码，然后<strong>从主管模式返回</strong>，这被称为 <code>sret</code><ul><li><code>sstatus.spie</code> 写入到 <code>sstatus.sie</code> 中，还原启用中断的位</li><li><code>sstatus.SPP</code> 写入到 <code>mode</code> 中，还原之前的模式</li><li><code>sepc</code> 写入到 <code>pc</code> 中，还原到运行中断之前的代码</li></ul></li></ol><p>大部分内核都是在主管模式下完成的，只有少部分是在机器模式下完成的</p><h3 id="机器模式处理-trap"><a href="#机器模式处理-trap" class="headerlink" title="机器模式处理 trap"></a>机器模式处理 trap</h3><ol><li>大致与主管模式一致，但是有一个不同的寄存器 <code>mstatus</code><ul><li>机器模式处理的唯一中断就是时间定时器中断。有一个委派机制来委派所有其他陷阱，所有其他中断和异常将会在主管模式下处理</li><li>中断总是在机器模式启用，每一个定时器中断都会处理，其它 trap 都会被委派到主管模式，而是否处理中断都由是否启用中断来决定</li><li>当一个定时器中断发生，处理的代码将会做：<ul><li>强制创建一个软件中断到主管模式，并且中断主管模式代码</li><li>机器模式的运行依旧继续，并且使能中断</li><li>返回到中断的代码，哪个模式中断代码就返回哪个模式。如果在主管模式启用了中断，会在主管模式立即发生中断，否则会将中断保持挂起，直到启用中断</li></ul></li></ul></li><li>机器模式只处理时间中断，其他都是硬件级别上的委托，立即进入主管模式</li><li>在 <code>mtvec</code> 保存了机器模式中断处理程序的地址，代码叫做 <code>timervec</code></li><li>硬件处理<ul><li><code>pc</code> 写入 <code>mepc</code></li><li><code>mtvec</code> 写入到 <code>pc</code></li><li>当前的模式写入到 <code>mstatus.mpp</code> 中</li><li><code>mstatus.mie</code> 写入到 <code>mstatus.mpie</code> 中</li><li>禁用中断 <code>mstatus.mie=0</code></li><li>切换到机器模式</li></ul></li><li>执行计时器 <code>vec</code> 代码—— <code>timevec</code><ul><li>这将导致主管级别的中断，这个中断是软件中断，这个代码很短</li></ul></li><li>在机器模式下执行 <code>mret</code> 的指令，将会返回到机器模式中去<ul><li>恢复中断启用的标志位 <code>mstatus.spie</code> 写入到 <code>mstatus.sie</code> 中，还原启用中断的位</li><li><code>mstatus.SPP</code> 写入到 <code>mode</code> 中，还原之前的模式</li><li><code>mepc</code> 写入到 <code>pc</code> 中，还原到运行中断之前的代码</li></ul></li><li>产生的软件中断会发生什么取决于是否在主管模式里启用中断<ul><li>如果未启用，将软件中断挂起，直到启用中断之后再进行处理</li><li>如果启用， <code>trap</code> 会立即在主管模式下发生</li></ul></li></ol><h3 id="定时器中断处理"><a href="#定时器中断处理" class="headerlink" title="定时器中断处理"></a>定时器中断处理</h3><p>是在机器模式下运行的，需要将 <code>ssie</code> 寄存器置为 1，迫使软件中断发生在主管模式的内核级别</p><h3 id="Trap-Delegation"><a href="#Trap-Delegation" class="headerlink" title="Trap Delegation"></a>Trap Delegation</h3><p>所有的中断都需要进入机器模式来处理，但是也有可以绕过机器模式处理程序的委托，可以直接在主管模式处理中断。由两个寄存器用于委派异常或者中断</p><ul><li><code>medeleg</code> 用于委派异常</li><li><code>mideleg</code> 用于委派中断</li></ul><p>这两个寄存器用于委派异常和中断，当有异常或者中断产生时，它将立即由内核代码在监管模式下处理。但是由于定时器中断不能委托，所以与其它中断不同，因为它做了软件中断</p><p>这两个寄存器在启动时初始化，发生在机器模式下的启动函数中。一旦初始化将不会改变</p><p>由于委派了这些中断或者异常而发生的陷阱，所以机器模式下什么都不会做，这将会立即成为主管级别的中断或者异常</p><h3 id="medeleg"><a href="#medeleg" class="headerlink" title="medeleg"></a>medeleg</h3><p>寄存器中所包含的委派 trap 类型</p><ul><li>存储，加载和指令获取页面错误</li><li>三种模式下的系统调用</li><li>访问错误</li><li>未命中的错误</li><li>加载权限错误</li><li>加载未命中</li><li>断点</li><li>非法指令</li><li>INST 权限错误</li><li>INST 未命中</li></ul><p>有一个专门的指令来初始化 <code>medeleg</code> 寄存器，就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrw medeleg 0xffff</span><br></pre></td></tr></table></figure><p>虽然不是一个合法的指令，但是提供了一个想法可以用于将所有标志位置 1</p><h3 id="mideleg"><a href="#mideleg" class="headerlink" title="mideleg"></a>mideleg</h3><p>寄存器中委派的 <code>trap</code> 类型</p><ul><li>在机器模式和主管模式下的设备中断</li><li>在机器模式和主管模式下的定时器中断</li><li>在机器模式和主管模式下的软件中断</li></ul><p>初始化也很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrw mideleg 0xffff</span><br></pre></td></tr></table></figure><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>一个用户的线程，可通过 <code>trap</code> 进入内核态，中断处理结束之后调用 <code>sret</code> 返回到原来的程序中。</p><p>如果是发生的中断，那用户线程将不知道发生了此陷阱，会在线程返回之后继续运行代码。发生中断时，将会保存用户线程所有的寄存器，然后在系统返回时，这些寄存器将会被恢复或者重新加载，所以线程相当于是从它中断的时候继续开始。所以在用户态相当于是一系列的时间片。</p><p>如果发生的是定时器中断，那在这种情况下，内核进入处理时会在这个区域内关闭，然后调用其它的线程来处理。在之后，内核决定给用户线程另一个时间片，然后将返回到用户进程，最终还是返回到用户线程。其实这一段就是讲的线程调度。</p><p>对于多线程时间片分配处理，利用 <code>sret</code> 开始时间片，使用定时器中断来结束时间片</p><h3 id="单核处理Trap流程"><a href="#单核处理Trap流程" class="headerlink" title="单核处理Trap流程"></a>单核处理Trap流程</h3><ol><li>用户代码接受到 trap 之后，一般来说 trap 可以分为定时器中断，设备中断（外部信号导致，非同步，与用户代码无关），系统调用和错误（与用户代码有关）<ol><li>中断失能</li><li>进入主管模式 <code>spp=s mode</code></li><li>保存用户 <code>pc</code> 指针</li><li>读取 <code>stvec</code> 更新 <code>pc</code> ，其中的指令应该是跳转到 <code>uservec</code></li><li>更新中断原因</li></ol></li><li>接受 trap 之后会进入内核态，然后根据中断类型信息从 <code>uservec</code> 用户中断处理程序中找到中断处理程序的地址，然后进入中断处理，进入 <code>uservec</code><ol><li>保存用户寄存器和 <code>pc</code> 寄存器到 trap frame 中</li><li>加载内核的 <code>sp</code> 和 <code>tp</code> 寄存器</li><li>将内核页表的地址加载到 <code>satp</code> 中（加载内核地址空间）</li><li>然后跳转到 <code>usertrap()</code> 函数</li></ol></li><li>用户处理中断程序 <code>usertrap()</code> 实际上这不是个真正的函数，可以说是一个代码块，永远不会返回到 <code>uservec</code> 。这里会将内核的 trap vector 加载到 <code>stvec</code> 寄存器中<ol><li><code>exception</code>：退出 <code>exit()</code> ，打印错误报告</li><li><code>device</code>：设备中断处理，判断 <code>killed</code> 标志位，如果为 <code>true</code> ，就会 <code>exit()</code> 处理完回到原线程</li><li><code>syscall</code>：系统调用，判断 <code>killed</code> 标志位，如果为 <code>true</code> ，就会 <code>exit()</code> 处理完回到原线程。在处理系统调用时，会使能中断，也就是在处理系统调用时可能会去做其它的事情</li><li><code>timer</code>：定时器中断，判断 <code>killed</code> 标志位，如果为 <code>true</code> ，就会 <code>exit()</code> ，是时间片线程调度，下一步会执行 <code>yield</code> ，这将调用调度器和其它进程</li></ol></li><li><code>usertrapret()</code>  C 语言代码<ol><li>禁用中断，防止在 <code>syscall</code> 中启用</li><li>将 <code>uservec</code> 保存到 <code>stvec</code> 中，以备下一次的 trap</li><li>保存内核的 <code>sp</code> 和 <code>tp</code> 寄存器</li><li>将被保存的用户的 <code>pc</code> 写入到 <code>sepc</code></li></ol></li><li><code>userret</code> 汇编语言代码，这个代码位于 trampoline page<ol><li>恢复寄存器 <code>satp</code> ，也就是将用户页表地址加载进去，加载用户虚拟空间地址，将内核地址空间切换到用户地址空间</li><li>恢复用户寄存器</li><li>更新控制和状态寄存器<ul><li>设置用户模式， <code>spp=u mode</code></li><li>恢复中断</li></ul></li><li><code>sret</code></li></ol></li><li>返回到用户线程 <code>sret</code></li></ol><h3 id="多核多线程的调度"><a href="#多核多线程的调度" class="headerlink" title="多核多线程的调度"></a>多核多线程的调度</h3><p>有时候一个线程会受到多个内核的调度</p><p>所以当一个内核运行这个线程时，发生时间中断之后会将该线程的各种数据保存在一个共享的内存中，并且再次调度这个现成的内核有权限读取这段内存</p><p>每个线程都有用户部分和内核部分，从用户态转到内核态是需要上下文切换的，需要保存所有的通用寄存器</p><p>实际上调度线程的程序也是一个单独的线程，当线程进入内核态之后，会上下文切换到线程调度程序中，然后由该程序决定切换到哪个进程中</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>在 xv6 中线程调度使用的函数是汇编函数 <code>swtch()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        sd s2, 32(a0)</span><br><span class="line">        sd s3, 40(a0)</span><br><span class="line">        sd s4, 48(a0)</span><br><span class="line">        sd s5, 56(a0)</span><br><span class="line">        sd s6, 64(a0)</span><br><span class="line">        sd s7, 72(a0)</span><br><span class="line">        sd s8, 80(a0)</span><br><span class="line">        sd s9, 88(a0)</span><br><span class="line">        sd s10, 96(a0)</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        ld s2, 32(a1)</span><br><span class="line">        ld s3, 40(a1)</span><br><span class="line">        ld s4, 48(a1)</span><br><span class="line">        ld s5, 56(a1)</span><br><span class="line">        ld s6, 64(a1)</span><br><span class="line">        ld s7, 72(a1)</span><br><span class="line">        ld s8, 80(a1)</span><br><span class="line">        ld s9, 88(a1)</span><br><span class="line">        ld s10, 96(a1)</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，该函数内部的操作就是将一些常用寄存器给保存，然后初始化，也就是上下文切换</p><p>在 xv6 中，进入到内核态之后，如果需要线程调度，用到的代码就是 <code>sched()</code> ，这个代码与 <code>scheduler</code> 向关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">sched(void)</span><br><span class="line">&#123;</span><br><span class="line">  int intena;</span><br><span class="line">  struct proc *p = myproc();</span><br><span class="line"></span><br><span class="line">  if(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(&quot;sched p-&gt;lock&quot;);</span><br><span class="line">  if(mycpu()-&gt;noff != 1)</span><br><span class="line">    panic(&quot;sched locks&quot;);</span><br><span class="line">  if(p-&gt;state == RUNNING)</span><br><span class="line">    panic(&quot;sched running&quot;);</span><br><span class="line">  if(intr_get())</span><br><span class="line">    panic(&quot;sched interruptible&quot;);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br><span class="line">void</span><br><span class="line">scheduler(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc *p;</span><br><span class="line">  struct cpu *c = mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = 0;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    // Avoid deadlock by ensuring that devices can interrupt.</span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    for (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      if (p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        // Switch to chosen process.  It is the process&#x27;s job</span><br><span class="line">        // to release its lock and then reacquire it</span><br><span class="line">        // before jumping back to us.</span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        // Process is done running for now.</span><br><span class="line">        // It should have changed its p-&gt;state before coming back.</span><br><span class="line">        c-&gt;proc = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，当初始化时，CPU 的进程会先清空，然后进入调度，为了避免死锁会使能设备中断。</p><p>然后 CPU 会从任务列表中找一个进程来调用，调用该进程时会给该进程上锁，防止其它 CPU  调度。如果进程状态是准备好运行了，那就会进入调度，将进程状态切换为运行中，然后将其挂载到该 CPU 上，进行上下文切换，切换到该进程中。</p><p>当该进程运行的时间片结束时，会调用 <code>sched</code> 函数。进入该函数，首先会检查该进程的锁，检查 CPU 的 <code>noff</code> 标志，检查进程是否还在运行，检查中断是否使能，在线程调度时是不能使能。然后保存当前进程的 <code>intena</code> 标志，切换上下文。</p><p>函数 <code>swtch</code> 的作用就是保存当前进程的寄存器并且加载下一个进程的寄存器，是写在汇编代码里的</p><h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="用户的地址空间"><a href="#用户的地址空间" class="headerlink" title="用户的地址空间"></a>用户的地址空间</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713530338748.png" alt="1713530338748.png"></p><p>从下往上依次为</p><ul><li>代码和数据段</li><li>安全页</li><li>栈</li><li>堆</li><li>空闲空间</li><li>陷阱框架页</li><li>trampoline 页面</li></ul><p>由于取决于用户程序，栈页面的位置会有不同，但是最上面的两个页面总是在同一个位置，这两个页面是可读可写的，但是在用户模式下不可访问，如果用户尝试访问会得到一个错误。</p><p>每一个用户进程都会有一段这样的空间，每一个都有一个 trap frame 和 trampoline 页面，但是内核进程只有一个虚拟地址空间，所有的内核都会共享这一个虚拟空间</p><p>在内核进程的虚拟地址空间中，最上层是 trampoline 页面，但是没有 trap frame 页面</p><h3 id="trampoline-page"><a href="#trampoline-page" class="headerlink" title="trampoline page"></a>trampoline page</h3><ul><li>包含代码，只包含了 <code>uservec</code> 和 <code>userret</code> 函数，都是汇编代码</li><li>所有用户进程的 trampoline page 都在同一个位置，也就是虚拟地址空间和内核虚拟地址空间的最顶端</li><li>标记为可读可写，但是用户模式下不可访问</li><li>在实际中，所有的 trampoline page 都被映射到同一块物理地址空间，这个是共享的。这个是没问题的，因为这里的代码所有进程都是一样的并且不可改变</li></ul><h3 id="trap-frame-page"><a href="#trap-frame-page" class="headerlink" title="trap frame page"></a>trap frame page</h3><ul><li>每一个用户进程都有自己的页面，每一个页面都是不一样的，每个虚拟地址空间都包含一个 trap frame，但是内核虚拟地址空间中是没有的</li><li>在页面中包含数据，它将包含将保存用户寄存器的数据</li><li>标记为可读可写，但是用户模式下无法访问</li><li>实际中，每一个 trapframe page 都被映射到不同的物理地址空间，不是共享的</li></ul><h3 id="物理地址与内核虚拟地址"><a href="#物理地址与内核虚拟地址" class="headerlink" title="物理地址与内核虚拟地址"></a>物理地址与内核虚拟地址</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713531933212.png" alt="1713531933212.png"></p><p>其中右边是真实物理空间，左边是内核虚拟地址空间。真实物理空间的内存分配如下</p><ul><li><code>boot ROM</code> 启动项的只读内存</li><li>核心本地中断控制器</li><li>平台级中断控制器</li><li>串行通信设备</li><li>虚拟磁盘</li><li>物理地址的 RAM</li></ul><p>内核的虚拟地址空间分配如下</p><ul><li>左侧的虚拟地址空间几乎都是真实映射的，也就是内核可以提供一个地址，不需要真正区分物理地址空间还是虚拟地址空间，相同的地址可以直接用于物理地址。</li><li>当需要访问虚拟磁盘，串口还是平台级中断控制器都是直接访问的</li><li>核心本地中断控制器只能在机器模式下运行，在机器模式下，所有的寻址都是使用物理地址的，而且没有虚拟寻址页，页表 not active，只使用物理地址，所以不需要映射到虚拟地址空间</li><li>虚拟地址的顶端有一个 trampoline 页面，然后就是安全页和栈页面的组合，者将会有 64 个，就是为每一个用户进程都分配一个。安全页没有映射真实的物理空间，因为它已经被标记为不可读不可写不可执行，任何试图访问它的进程都会出错，它用来捕获内核中任何堆栈的溢出<ul><li>这里的栈的页面只是虚拟内存的映射，初始化时会在虚拟内存地址中分配栈的空间，然后映射到这里</li></ul></li><li>在 <code>KERNELBASE</code> 之后会有 Kernel text 区域，这个区域用于存储可读可执行的代码和只读的数据</li><li>Kernel data 段保存内核的可读写数据，也就是内核中使用的变量</li><li>最后会有一段空闲的内存，这一段内存将会用于页面分配。这些区域一开始被分为几页，并且保存在空闲列表中<ul><li><code>kalloc</code> 分配空间，会从空闲列表中分配一页空闲内存</li><li><code>kfree</code> 释放空间，当 <code>kalloc</code> 分配的空间使用完之后，会归还到该空闲内存区域，也会回到空闲列表中</li><li>用户进程的 trap frame page 将会在这段内存中分配空间</li></ul></li></ul><h3 id="memlayout"><a href="#memlayout" class="headerlink" title="memlayout"></a>memlayout</h3><p>在这个文件中，定义了一些设备的地址</p><ul><li><code>UART0</code> 定义串口设备的地址，与上文中一致</li><li><code>UART0_IRQ</code> 定义串口中断</li><li><code>VIRTIO0</code> 定义虚拟磁盘设备地址</li><li><code>VIRTIO0_IRQ</code> 定义虚拟磁盘设备中断</li><li><code>CLINT</code> 定义核心本地中断地址</li><li><code>CLINT_MTIMECMP</code> 就是一个函数，用于查找核心硬件寄存器的地址<ul><li>这个寄存器由内核加载，它会告诉你下一次打断的时间，所以内核会把打断的时间写到这个寄存器中，当时间到了该打断的时候，将会自动生成中断</li></ul></li><li><code>CLINT_MTIME</code> 指向一个地址，该地址存储了从启动开始的 cycles 数</li><li><code>PLIC</code> 平台级中断的地址</li><li><code>PLIC_PRIORITY</code> 平台级中断优先级</li><li><code>PLIC_PENDING</code> 平台级中断是否挂起</li><li><code>PLIC_MENABLE</code> 平台级中断在机器模式下是否使能</li><li><code>PLIC_SENABLE</code> 平台级中断在主管模式下是否使能</li><li><code>PLIC_MPRIORITY</code> 平台级中断在机器模式下的优先级</li><li><code>PLIC_SPRIORITY</code> 平台级中断在主管模式下的优先级</li><li><code>PLIC_MCLAIM</code> 平台级中断在机器模式下的声明</li><li><code>PLIC_SCLAIM</code> 平台级中断在主管模式下的声明</li><li><code>KERNBASE</code> 内核加载位置</li><li><code>PHYSTOP</code> 物理主存的顶部</li><li><code>TRAMPOLINE</code> 定义了 trampoline 页面的地址，就是虚拟地址最顶端的一页</li><li><code>KSTACK</code> 定义了栈的地址，每一个进程都有一个栈地址，传入进程号，根据进程号获得栈的地址</li><li><code>TRAPFRAME</code> 定义 trap frame 页面的地址，也就是顶端的第二个页面的地址</li></ul><h2 id="目标文件链接"><a href="#目标文件链接" class="headerlink" title="目标文件链接"></a>目标文件链接</h2><h3 id="连接器作用"><a href="#连接器作用" class="headerlink" title="连接器作用"></a>连接器作用</h3><p>从目标文件中提取所有数据，并将其合并到可执行文件中</p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713544498536.png" alt="1713544498536.png"></p><p>上面显示了来自于内核的各个部分的可执行文件中的内容，链接器将找到内存中放置所有这些材料的位置，然后会构建可执行文件，它包含了以后要加载到内存中的所有数据，当加载好内核并且开始运行内核时，模拟器（qemu）将读取可执行文件，并且把这些东西放到链接器所选择的地址中。</p><p>目标文件中会包含很多数据段，但是编译器和汇编器并不知道这些东西将会放在内存中的什么位置，这些数据段都是给定的名字。其中</p><ul><li><code>.text</code> 包含可执行的代码</li><li><code>.data</code> 包含程序的变量，是需要读写的值，有可能会有初值</li><li><code>.rodata</code> 只读数据，这个数据会进行初始化，但是不会在运行中更新</li><li><code>.bss</code> 包含未初始化的数据，而它被加载到内存中时会被 0 填充或者用 0 初始化，没有任何初始化数据，所以在目标文件和可执行文件中可能很小</li><li><code>trampsec</code> trampoline 段，这必须放在特殊的地方</li></ul><p>链接器会从内存中找到这些数据，并且从 <code>0x80000000</code> 的边界开始，将这些代码和数据按照图中的方式将这些派那段放在一起，它们将会按顺序被放到这些位置。链接器的命令将列出此输入代码的目标文件。第一个 <code>.text</code> 中存储的是 <code>entry.S</code> 文件，而第一条指令的标签为 <code>_entry</code> ，会首先开始执行 <code>.text</code> 段，也就是代码段会先执行。这些代码存放的数据与命令行中链接的顺序有关， <code>trampsec</code> 这个文件放在代码段之后</p><p>链接器会找到所有东西的地址用于填充之前未填充的部分，例如有些变量在编译时并不知道在哪里，只有链接之后才知道变量的地址。链接器将代码中不确定的变量的地址改为确定的地址位置。而且编译器将确定几个重要的值，例如 <code>etext</code> 就是代码段的结尾和内核数据的开始，然后 <code>end</code> 是数据段的结尾， <code>_entry</code> 是代码段的开始， <code>_trampoline</code> 就是 trampoline 页面的位置。链接器一旦确定所有变量的位置，会将代码中所有关于此变量的引用都替换成该位置</p><p>链接器会构建一个页表来描述这块内存，例如 <code>.text</code> 段可读可执行，数据段可读可写。链接器会将所有数据和代码对齐</p><h3 id="kernel-ld"><a href="#kernel-ld" class="headerlink" title="kernel.ld"></a>kernel.ld</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line">ENTRY( _entry )</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">   * ensure that entry.S / _entry is at 0x80000000,</span><br><span class="line">   * where qemu&#x27;s -kernel jumps.</span><br><span class="line">   */</span><br><span class="line">  // 当前位置，表示从这个位置开始存放下列数据</span><br><span class="line">  . = 0x80000000;</span><br><span class="line"></span><br><span class="line">  // 抓取所有的 .text 片段放到文本段中，这是按照命令行中的顺序来的，所以命令行上第一个对象文件将是 entry.S 文件</span><br><span class="line">  .text : &#123;</span><br><span class="line">    *(.text .text.*)</span><br><span class="line">    . = ALIGN(0x1000); // 强行走到下一页，也就是对齐，中间会有一些未使用的空闲内存</span><br><span class="line">    _trampoline = .;</span><br><span class="line">    *(trampsec)</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line">    ASSERT(. - _trampoline == 0x1000, &quot;error: trampoline larger than one page&quot;); // 确保 trampoline 只有一页</span><br><span class="line">    PROVIDE(etext = .); // 生成一个简单的文本 etext</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .rodata : &#123;</span><br><span class="line">    . = ALIGN(16); // 四字节对齐</span><br><span class="line">    *(.srodata .srodata.*) /* do not need to distinguish this from .rodata */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.rodata .rodata.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .data : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.sdata .sdata.*) /* do not need to distinguish this from .data */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.data .data.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .bss : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.sbss .sbss.*) /* do not need to distinguish this from .bss */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.bss .bss.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PROVIDE(end = .); // 定义结束，没有对齐操作，可能不在页面边界上</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内核启动过程"><a href="#内核启动过程" class="headerlink" title="内核启动过程"></a>内核启动过程</h2><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br><span class="line"></span><br><span class="line">uint64 timer_scratch[NCPU][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>stack0</code> 的大小为 <code>4096 * NCPU</code> 给每一个 CPU 都分配一个栈，为每个栈都分配一页的内存。由于是 <code>char</code> 类型的数组，所以可能不会对齐，所以前面声明强制对齐</li><li><p><code>timer_scratch</code> 每个 CPU 中有 5 个，是一个 64 字的数组，具体的构造如下</p><p>  <img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713580881396.png" alt="1713580881396.png"></p></li></ul><h3 id="entry-S-1"><a href="#entry-S-1" class="headerlink" title="entry.S"></a>entry.S</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        # qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>.section .text</code> 是表示下面的代码将会被存放到 <code>.text</code> 段</li><li><code>.global _entry</code> 声明该标签是全局的标签</li><li><code>_entry</code> 这段代码的作用就是初始化栈指针寄存器，然后调用 <code>start</code> 函数，该函数不打算返回，但是如果返回了，将会执行下面的代码</li><li><code>spin</code> 是本地的标签，这就是为了防止 <code>start</code> 函数返回，如果返回就死循环，锁定这个内核</li></ul><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>这段代码是在机器模式运行的</li><li>以 <code>r_</code> 开头的函数表示对该寄存器的读取</li><li>以 <code>w_</code> 开头的表示对寄存器的写入</li></ul><p><strong>流程</strong></p><ul><li>首先设置 <code>mpp</code> 寄存器，设置先前的模式为主管模式</li><li>设置 <code>mepc</code> 寄存器，也就是说明 <code>mret</code> 之后返回到哪里的代码，实际上在这之前并没有执行任何一条指令，通过设置各个寄存器来制造一个假象，使得 CPU 回到 main 函数中</li><li>机器模式没有页表，所以将 <code>satp</code> 寄存器设置为 0</li><li>将 <code>medeleg</code> 和 <code>mideleg</code> 寄存器全部置为 1，也就是会将所有中断和异常委托给主管模式，所以当异常或者是错误发生，不会在机器模式下处理</li><li>设置 <code>sie</code> ，读取原先值，并且设置使能软件中断，定时器中断和设备中断</li><li>物理内存保护，实际上希望将这些内存中写入常数来判断这些物理内存是否都可访问</li><li><code>timerinit</code> 定时器初始化</li><li>读取当前内核 id，并且写入 <code>tp</code> 寄存器，用于之后确定代码运行在哪个内核上</li><li><code>mret</code> 这里将会回到 <code>main</code> 函数处执行</li></ul><h3 id="timerinit"><a href="#timerinit" class="headerlink" title="timerinit"></a>timerinit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec.</span></span><br><span class="line">  <span class="comment">// scratch[0..2] : space for timervec to save registers.</span></span><br><span class="line">  <span class="comment">// scratch[3] : address of CLINT MTIMECMP register.</span></span><br><span class="line">  <span class="comment">// scratch[4] : desired interval (in cycles) between timer interrupts.</span></span><br><span class="line">  uint64 *scratch = &amp;timer_scratch[id][<span class="number">0</span>];</span><br><span class="line">  scratch[<span class="number">3</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">4</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程</strong></p><ul><li>获得当前内核 id 号。核心本地中断寄存器上有几个寄存器，其中有 <code>timecmp</code> 寄存器。 <code>CLINT_MTIMECMP</code> 会返回特定 id 的 <code>timecmp</code> 寄存器的地址，在这里会记下当前的时间加上 1000000 次循环作为定时器的下次中断</li><li>然后将当前内核的 <code>timecmp</code> 寄存器的地址存储在 <code>time_scratch</code> 的第 4 个元素上，把中断间隔时间存储在 <code>time_scratch</code> 的第 5 个元素上，然后将 <code>time_scratch</code> 的地址存放到 <code>mscratch</code> 寄存器中。这个 <code>mscratch</code> 寄存器只在机器模式下才可访问。系统只在一开始时在机器模式，而在发生时间中断时也会位于机器模式</li><li>更新陷阱向量，也就是当陷阱出现时应该执行的处理函数的地址。在机器模式下就是定时器中断处理程序，也就是当定时器中断发生时会跳转到该函数中</li><li>启用机器模式中断</li><li>将定时器中断启用</li></ul><h3 id="timevec"><a href="#timevec" class="headerlink" title="timevec"></a>timevec</h3><p>定时器中断处理函数，将会在定时器中断发生时调用。这个函数在计时器初始化中调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.globl timervec</span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">timervec:</span><br><span class="line">        <span class="meta"># start.c has set up the memory that mscratch points to:</span></span><br><span class="line">        <span class="meta"># scratch[0,8,16] : register save area.</span></span><br><span class="line">        <span class="meta"># scratch[24] : address of CLINT<span class="string">&#x27;s MTIMECMP register.</span></span></span><br><span class="line"><span class="string"><span class="meta">        # scratch[32] : desired interval between interrupts.</span></span></span><br><span class="line"><span class="string"><span class="meta">        </span></span></span><br><span class="line"><span class="string"><span class="meta">        csrrw a0, mscratch, a0</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a1, 0(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a2, 8(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a3, 16(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # schedule the next timer interrupt</span></span></span><br><span class="line"><span class="string"><span class="meta">        # by adding interval to mtimecmp.</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld a1, 24(a0) # CLINT_MTIMECMP(hart)</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld a2, 32(a0) # interval</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld a3, 0(a1)</span></span></span><br><span class="line"><span class="string"><span class="meta">        add a3, a3, a2</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a3, 0(a1) # 把 a3 存入 a1 中</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # arrange for a supervisor software interrupt</span></span></span><br><span class="line"><span class="string"><span class="meta">        # after this handler returns.</span></span></span><br><span class="line"><span class="string"><span class="meta">        li a1, 2</span></span></span><br><span class="line"><span class="string"><span class="meta">        csrw sip, a1</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        ld a3, 16(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld a2, 8(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld a1, 0(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        csrrw a0, mscratch, a0</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        mret</span></span></span><br></pre></td></tr></table></figure><ul><li>首先前面所说的 <code>time_scratch</code> 中保存了 5 个 8 字节的数据，其中前三个时用来存储在次数需要用到的三个数据</li><li>交换 <code>mscratch</code> 和 <code>a0</code> 中的数据，然后再代码的末端会再交换回来。保存当前 <code>a1, a2, a3</code> 寄存器的值在 <code>mscratch</code> 中，并且在函数结束之前会把这些寄存器恢复</li><li>之后是相当于把当前的 <code>timecmp</code> 加上了 1000000 次循环时间，也就是下一次定时器中断</li><li>然后会在这个处理中断结束之后，生成一个主管模式下的软件中断，当然这个中断的处理取决于主管模式下是否允许中断。通过将 2（b10) 写入寄存器 <code>sip</code> 中。但是当前是机器模式，所以并不会立即处理这个软件中断，也就是会先挂起，当之后的 <code>mret</code> 回到主管模式时就会处理该中断。如果中断使能就会立即处理，否则就会挂起中断</li></ul><h2 id="陷阱处理"><a href="#陷阱处理" class="headerlink" title="陷阱处理"></a>陷阱处理</h2><p>陷阱出现的原因</p><ul><li>异步中断：设备中断，定时器中断</li><li>同步中断：系统调用，错误</li></ul><h3 id="内核中代码运行流程"><a href="#内核中代码运行流程" class="headerlink" title="内核中代码运行流程"></a>内核中代码运行流程</h3><ol><li>用户代码接受到 trap 之后，一般来说 trap 可以分为定时器中断，设备中断（外部信号导致，非同步，与用户代码无关），系统调用和错误（与用户代码有关）<ol><li>中断失能</li><li>进入主管模式 <code>spp=s mode</code></li><li>保存用户 <code>pc</code> 指针</li><li>读取 <code>stvec</code> 更新 <code>pc</code> ，其中的指令应该是跳转到 <code>uservec</code></li><li>更新中断原因</li></ol></li><li>接受 trap 之后会进入内核态，然后根据中断类型信息从 <code>uservec</code> 用户中断处理程序中找到中断处理程序的地址，然后进入中断处理，进入 <code>uservec</code><ol><li>保存用户寄存器和 <code>pc</code> 寄存器到 trap frame 中</li><li>加载内核的 <code>sp</code> 和 <code>tp</code> 寄存器。每个进程都会为内核栈留出一个页面，这个就是加载到 <code>sp</code> 中的</li><li>将内核页表的地址加载到 <code>satp</code> 中（加载内核地址空间）</li><li>然后跳转到 <code>usertrap()</code> 函数</li></ol></li><li>用户处理中断程序 <code>usertrap()</code> 实际上这不是个真正的函数，可以说是一个代码块，永远不会返回到 <code>uservec</code> 。这里会将内核的 trap vector 加载到 <code>stvec</code> 寄存器中<ol><li><code>exception</code>：退出 <code>exit()</code> ，打印错误报告</li><li><code>device</code>：设备中断处理，判断 <code>killed</code> 标志位，如果为 <code>true</code> ，就会 <code>exit()</code> 处理完回到原线程</li><li><code>syscall</code>：系统调用，判断 <code>killed</code> 标志位，如果为 <code>true</code> ，就会 <code>exit()</code> 处理完回到原线程。在处理系统调用时，会使能中断，也就是在处理系统调用时可能会去做其它的事情</li><li><code>timer</code>：定时器中断，判断 <code>killed</code> 标志位，如果为 <code>true</code> ，就会 <code>exit()</code> ，是时间片线程调度，下一步会执行 <code>yield</code> ，这将调用调度器和其它进程，调度其他线程也会进行上下文切换，这里的上下文切换开关与其它的不同</li></ol></li><li><code>usertrapret()</code>  C 语言代码<ol><li>禁用中断，防止在 <code>syscall</code> 中启用</li><li>将 <code>uservec</code> 保存到 <code>stvec</code> 中，以备下一次的 trap</li><li>保存内核的 <code>sp</code> 和 <code>tp</code> 寄存器</li><li>将被保存的用户的 <code>pc</code> 写入到 <code>sepc</code></li></ol></li><li><code>userret</code> 汇编语言代码，这个代码位于 trampoline page<ol><li>恢复寄存器 <code>satp</code> ，也就是将用户页表地址加载进去，加载用户虚拟空间地址，将内核地址空间切换到用户地址空间</li><li>恢复用户寄存器</li><li>更新控制和状态寄存器<ul><li>设置用户模式， <code>spp=u mode</code></li><li>恢复中断</li></ul></li><li><code>sret</code></li></ol></li><li>返回到用户线程 <code>sret</code></li></ol><h3 id="trapframe"><a href="#trapframe" class="headerlink" title="trapframe"></a>trapframe</h3><p>当在用户模式下，会有一个控制和状态寄存器 <code>sscratch</code> ，它将会指向这个 trap frame，其中 trap frame 的结构如下。它是一个页面，并且将以页面对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在处理 trap 的流程中，保存用户的寄存器到 trap frame 中，就是这个 trap frame ，每个进程都有一个 trap frame。由于一共有 32 个寄存器，但是其中一个寄存器是硬件连接到 0，所以只保存 31 个寄存器，也就是上面的 <code>ra~t6</code> 寄存器，剩下的</p><ul><li><code>kernel_satp</code> 内核的页表</li><li><code>kernel_sp</code> 进程的内核栈顶</li><li><code>kernel_trap</code> 保存 <code>usertrap()</code> 的地址</li><li><code>kernel_hartid</code> 保存 <code>tp</code> 寄存器中内容，就是当前内核 id</li><li><code>epc</code> 保存用户的 <code>pc</code> 寄存器</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span></span><br></pre></td></tr></table></figure><p>有个 CPU 的数组，也就是每一个 CPU 都有一个对应的结构体。</p><p>在 CPU 结构体中</p><ul><li><code>proc</code> 就是进程指针，如果用户模式进程在该内核上运行，会有一个指向描述该进程的 proc 结构的指针。如果该 CPU 上没有运行进程或者正在程序调度进程，该字段将为 0 或者空</li><li><code>noff</code> 记录失能中断层数的数据，也就是 <code>push_off</code> 层数</li><li><code>intena</code> 记录最初是否启用中断。如果想要失能中断，就将 <code>noff++</code> 并且用 <code>intena</code> 记录下最初中断的使能状态，用于回到最初的状态。在最初的 <code>push_off</code> 之前是否启用中断</li><li><code>context</code> 一个名为上下文的寄存器保存区域。这个寄存器保存区存在是为了在线程调度时保存寄存器，只需要保存 <code>ra</code> 和 <code>sp</code> 寄存器和 <code>s0-s11</code> 寄存器</li></ul><h3 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"> <span class="comment">// 使用这些量必须拿到进程的锁</span></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>lock</code> 自旋锁</li><li><code>state</code> 进程状态，可以为<ul><li><code>UNUSED</code> 未使用</li><li><code>USED</code> 已使用</li><li><code>SLEEPING</code> 挂起</li><li><code>RUNNABLE</code> 可运行，等待一个时间片</li><li><code>RUNNING</code> 正在运行</li><li><code>ZOMBIE</code> 僵尸进程，也就是已经被杀死的进程，整个结构被回收和闲置之前。直到退出 <code>xstate</code> 就变成了未使用的</li></ul></li><li><code>chan</code> 在睡眠状态时，等待什么信号，只有进程在 <code>SLEEPING</code> 时才有意义，用于存储 <code>SLEEPING</code> 信息，也可能在等待什么东西</li><li><code>killed</code> 杀死进程的标志</li><li><code>xstate</code> 进程的退出状态，用于传递给其它等待它的进程</li><li><code>pid</code> 进程的 id 号</li><li><code>parent</code> 指向进程的父，也就是会指向另一个进程的结构体，处理该字段必须持有 <code>wait_lock</code></li><li><code>kstack</code> 内核栈的虚拟地址</li><li><code>sz</code> 虚拟地址空间大小</li><li><code>pagetable</code> 指向描述虚拟地址空间的页表的指针</li><li><code>trapfram</code> 指向 trap frame page，每个进程在物理内存中都有一个唯一的页，位于每个进程虚拟地址空间的最顶端的第二页面，但是这里指向的是物理内存空间地址</li><li><code>context</code> 这里是另一个上下文保存区域，所以在调度器调度进程和线程的时候可以使用这两个区域保存</li><li><code>ofile[NOFILE]</code> 打开的文件的数组，指针指向对应的文件描述符，其中 <code>NOFILE</code> 是可以同时打开的文件数</li><li><code>cwd</code> 当前地址</li><li><code>name[16]</code> 进程名字</li></ul><h3 id="killed函数"><a href="#killed函数" class="headerlink" title="killed函数"></a>killed函数</h3><p>用来检查进程的 <code>killed</code> 标志位，读取并且返回该标志位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">killed</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line"> <span class="comment">// 需要获取对应的锁</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  k = p-&gt;killed;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是一个上下文内容的结构体，其中</p><ul><li><code>ra</code> 返回地址寄存器，将会保存 <code>pc</code> 的内容</li><li><code>sp</code> 栈指针</li><li><code>s0-s11</code> 用于保存通用寄存器</li></ul><h2 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h2><p>这个文件中有两段代码，被声明为 <code>trampsec</code> 段，所以会被链接器放置在 <code>trampsec</code> 区域中。</p><p>这里定义了标签 <code>trampoline</code> 这是此页面所在物理内存中的地址，并且这段代码将会以 4 字节对齐。但是实际上 <code>.section trampsec</code> 是页面的边界，已经对齐了，所以下面的对齐语句 <code>align 4</code> 是没有作用的。所以 <code>trampoline</code> 与 <code>uservec</code> 的地址是一样的，相当于是为同一个地址分配两个标签。这样的话， <code>uservec</code> 相对于页面边界 <code>trampoline</code> 计算偏移量为 0，而下面的 <code>userret</code> 计算的偏移量是大于 0 的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:  # 这是这个页面的开始</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec: # 这个是第一个例程的开始</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h3 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h3><p>这是汇编代码，这段代码和 <code>userret</code> 将会被链接器放置在 <code>trampsec</code> 区域中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec</span><br><span class="line">uservec: </span><br><span class="line"> # 状态和控制寄存器 sscratch 实际上就是指向了 trap frame page，保存 a0 寄存器</span><br><span class="line">  csrw sscratch, a0</span><br><span class="line">  # 这里的 TRAPFRAME 就是 trap frame page 页面的地址</span><br><span class="line">  li a0, TRAPFRAME</span><br><span class="line">  </span><br><span class="line">  # 在 trap frame 中保存所有寄存器</span><br><span class="line">  sd ra, 40(a0)</span><br><span class="line"> ...</span><br><span class="line">  sd t6, 280(a0)</span><br><span class="line"> # 将用户的最开始的 a0 保存到 trap frame 中</span><br><span class="line">  csrr t0, sscratch</span><br><span class="line">  sd t0, 112(a0)</span><br><span class="line"> # 保存寄存器之后，使用内核的栈指针，初始化内核的栈指针。每一个进程中都专门留了一个页面作为内核栈页面</span><br><span class="line">  ld sp, 8(a0)</span><br><span class="line">  # 从 trap frame 中获取当前的内核 id</span><br><span class="line">  ld tp, 32(a0)</span><br><span class="line"> # 加载 usertrap 的地址到 t0 寄存器中，为了之后的 jr t0 作准备</span><br><span class="line">  ld t0, 16(a0)</span><br><span class="line">  # 从 trap frame 中加载内核页表的地址加载到 t1 中</span><br><span class="line">  ld t1, 0(a0)</span><br><span class="line">  # 等待其它先前的内存操作完成，等到它们使用用户页表，也就是退出内核态</span><br><span class="line">  # 这是个围栏指令，需要之前的事情都做完才能执行之后的代码</span><br><span class="line">  sfence.vma zero, zero</span><br><span class="line"> # 将内核页表的地址放入到 satp 寄存器中</span><br><span class="line">  csrw satp, t1</span><br><span class="line">  # 这是个围栏指令，需要之前的事情都做完才能执行之后的代码</span><br><span class="line">  sfence.vma zero, zero</span><br><span class="line">  # 跳转到 usertrap</span><br><span class="line">  jr t0</span><br></pre></td></tr></table></figure><p>在这段代码里，首先是获取用户的寄存器的地址，保存到 <code>a0</code> 寄存器中，然后就能够通过 <code>a0</code> 寄存器实现对各个寄存器的保存了。</p><p>一般来说，会用 <code>ra</code> 寄存器保存返回值，但是 <code>usertrap</code> 没有返回值</p><h3 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(pagetable)</span><br><span class="line">        # called by usertrapret() in trap.c to</span><br><span class="line">        # switch from kernel to user. 从内核态转到用户态</span><br><span class="line">        # a0: user page table, for satp.</span><br><span class="line">        # 围栏函数</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        # 转到用户的页表，将 a0 写入到 satp 中</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        # 围栏函数</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">    # 将 TRAPFRAME 加载到 a0 中</span><br><span class="line">        li a0, TRAPFRAME </span><br><span class="line">        # 恢复所有寄存器除了 a0，因为 a0 正在使用，作为 trap frame 的地址</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ...</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line">    # 最后恢复 a0</span><br><span class="line">        ld a0, 112(a0)</span><br><span class="line">        # 返回用户模式和用户模式的 pc</span><br><span class="line">        # sepc 和 sstatus 都在 usertrapret 中被设置</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><h2 id="trap-frame"><a href="#trap-frame" class="headerlink" title="trap frame"></a>trap frame</h2><h3 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h3><p>用户 trap 处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;  </span><br><span class="line"> <span class="comment">// 判断当前运行是以内核态运行还是用户模式运行，最好是在用户模式下运行</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"> <span class="comment">// 如果处于内核态，那就给 kerneltrap() 发送一个 trap，所以这里向 stvec 中写入内核中断处理函数的地址</span></span><br><span class="line">  <span class="comment">// 这里实际上就是保存寄存器来进入 kernelvec</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"> <span class="comment">// 获得当前进程的结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 保存 pc</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  <span class="comment">// 系统调用</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(p)) <span class="comment">// 如果进程的 killed 置位，那就退出</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 调用系统调用时，会将寄存器保存，对于 pc 寄存器，会保存到 epc 中</span></span><br><span class="line">  <span class="comment">// sepc 指针指向系统调用语句，但是希望跳过这条语句，系统调用占 4 个字节，所以 +=4</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 使能中断，所以允许其它的设备中断。也就是在系统调用时，允许其它设备的中断</span></span><br><span class="line">    intr_on();</span><br><span class="line">  <span class="comment">// 系统调用</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123; <span class="comment">// 0(other) 1:uart/disk 2:timer</span></span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是其它的什么错误之类的，那就将 killed 置1</span></span><br><span class="line">   <span class="comment">// 这里的 %p 实际上是打印一个 16进制的64位数字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// 如果是时间中断，那就需要进行线程调度，然后从这里放弃 cpu，也就是 cpu 调度其他的线程</span></span><br><span class="line">  <span class="comment">// 调用这个函数，然后从这个函数返回，但是不会立即返回，因为会去调度其它的线程</span></span><br><span class="line">  <span class="comment">// 然而不一定会返回到这个内核，因为可能换了一个内核</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h3><p>这个函数 <code>usertrapret</code> 不仅使用在 <code>usertrap</code> 之后，而且对于 fork 进程也可以返回，所以这一段被单独拿出来作为一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 获得当前进程的结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"> <span class="comment">// 防止系统调用打开中断，所以这里关掉中断，而且因为要对系统的控制和状态寄存器做处理，所以需要关掉中断</span></span><br><span class="line">  intr_off();</span><br><span class="line"> <span class="comment">// 由于在 usertrap 中，将 kernelvec 写入到 stvec 中，所以这里写回来</span></span><br><span class="line"> <span class="comment">// 这个地址就是 uservec 相对于 trampoline 的偏移再加上 trampoline 的首地址</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"> <span class="comment">// 设置当进入到内核模式时 uservec 将会需要的</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// 内核页表</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// 设置进程内核的栈地址，初始化站寄存器，指向栈页面后面的地址，所以这里相当于是一个空的栈</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap; <span class="comment">// 将 trap 字段指向用户trap 字段</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// 当前运行的内核号，由于之前的一个 yield 指令导致可能没有运行在同一内核中</span></span><br><span class="line">  <span class="comment">// 为下面的 sret 做准备 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// 恢复到先前的用户模式</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// 在用户模式下使能中断</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"> <span class="comment">// 还原用户模式下的程序计数器</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"> <span class="comment">// 选择用户进程的页表</span></span><br><span class="line"> <span class="comment">// 右移12位，然后与 SATP_SV39</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"> <span class="comment">// 将内核地址空间中的函数映射到进程虚拟地址空间中</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核调度"><a href="#内核调度" class="headerlink" title="内核调度"></a>内核调度</h2><h3 id="cpuid"><a href="#cpuid" class="headerlink" title="cpuid"></a>cpuid</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpuid</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> id = r_tp();</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数简单的返回 <code>tp</code> 寄存器中的值，这个寄存器始终保存目前内核的 id 号，由于可能会被打断而导致返回时 <code>return</code> 的 id 过时，所以调用此函数之前需要禁用中断</p><h3 id="mycpu"><a href="#mycpu" class="headerlink" title="mycpu"></a>mycpu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *</span><br><span class="line"><span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[id];</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前 CPU 的 id 找到当前 CPU 对应的结构体，返回这个结构体，这个函数调用必须是在中断禁用的条件下的</p><h3 id="myproc"><a href="#myproc" class="headerlink" title="myproc"></a>myproc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc *</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off(); <span class="comment">// 禁用中断，并且增加 CPU 的计数器</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off(); <span class="comment">// 如果 CPU 的计数为 0，中断使能恢复到之前的状态</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得当前的 CPU 中正在运行的进程，然会该进程的结构体，在这个过程中将会禁用中断，然后获取当前 CPU 的进程，最后重启中断返回进程结构体。在 CPU 结构体中，有一个指向当前进程的指针，一般来说 CPU 不是运行进程调度程序就是运行在某一个进程上，只有运行在某一个进程上时，这个指针才是有效的，指向对应的进程的结构体</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>该函数中首先请求进程的锁，然后才能将进程状态设置为可执行（更改进程状态需要权限），然后进入调度函数 <code>sched</code> ，从调度函数中返回之后，释放锁</p><p>在 <code>sched</code> 函数中有 <code>swtch</code> 函数，这个函数会直接返回到内核进程调度程序中，也就是不会返回到原来的 <code>sched</code> 函数中，所以这将会导致可能需要一段时间才能从 <code>sched</code> 函数返回到当前这个 <code>yield</code> 函数中，才能继续释放锁进行之后的操作</p><p>这个函数会在 <code>usertrap</code> 和 <code>kerneltrap</code> 中被调用，到那时不会有任何锁，在 <code>acquire</code> 中会禁用中断，记录之前中断状态，然后计数，这时候 <code>noff=1</code> 。会将进程的运行状态设置为 <code>RUNNABLE</code></p><h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (intr_get())</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数需要正常运行的条件</p><ul><li>拿到进程的锁</li><li>CPU 的 <code>noff</code> 计数为 1，也就是锁在这个进程中嵌套的层数为 1，也就是该 CPU 只在这个进程中被锁，</li><li>需要当前的进程不是运行中，而是被设置为 <code>RUNNABLE</code> 因为需要被放入进程队列中</li><li>在此过程中不能使能中断，否则出现死锁</li></ul><p>然后保存当前 CPU 的最初的中断使能状态，进行上下文切换。等到这个进程再次被调度，就会恢复 CPU 中记录最初中断使能状态的标志。</p><h3 id="swtch"><a href="#swtch" class="headerlink" title="swtch"></a>swtch</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd sp, <span class="number">8</span>(a0)</span><br><span class="line">        sd s0, <span class="number">16</span>(a0)</span><br><span class="line">        sd s1, <span class="number">24</span>(a0)</span><br><span class="line">        sd s2, <span class="number">32</span>(a0)</span><br><span class="line">        sd s3, <span class="number">40</span>(a0)</span><br><span class="line">        sd s4, <span class="number">48</span>(a0)</span><br><span class="line">        sd s5, <span class="number">56</span>(a0)</span><br><span class="line">        sd s6, <span class="number">64</span>(a0)</span><br><span class="line">        sd s7, <span class="number">72</span>(a0)</span><br><span class="line">        sd s8, <span class="number">80</span>(a0)</span><br><span class="line">        sd s9, <span class="number">88</span>(a0)</span><br><span class="line">        sd s10, <span class="number">96</span>(a0)</span><br><span class="line">        sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(a1)</span><br><span class="line">        ld sp, <span class="number">8</span>(a1)</span><br><span class="line">        ld s0, <span class="number">16</span>(a1)</span><br><span class="line">        ld s1, <span class="number">24</span>(a1)</span><br><span class="line">        ld s2, <span class="number">32</span>(a1)</span><br><span class="line">        ld s3, <span class="number">40</span>(a1)</span><br><span class="line">        ld s4, <span class="number">48</span>(a1)</span><br><span class="line">        ld s5, <span class="number">56</span>(a1)</span><br><span class="line">        ld s6, <span class="number">64</span>(a1)</span><br><span class="line">        ld s7, <span class="number">72</span>(a1)</span><br><span class="line">        ld s8, <span class="number">80</span>(a1)</span><br><span class="line">        ld s9, <span class="number">88</span>(a1)</span><br><span class="line">        ld s10, <span class="number">96</span>(a1)</span><br><span class="line">        ld s11, <span class="number">104</span>(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>在这个函数中，就是调度器函数，只负责进行上下文切换，保存当前进程的寄存器，然后加载内核的寄存器， <code>ret</code> 之后会进入进程调度程序，选择一个进程开始运行</p><p>当从 p 进程 <code>swtch</code> 到线程调度进程中去时，会保存 P 进程的各种寄存器，保存到 p 进程的 <code>context</code> 中，并且加载 CPU 的上下文到寄存器中。如果是从线程调度寄存器 <code>swtch</code> 到 P 进程时，保存进程调度函数的寄存器到 CPU 的 <code>context</code> 中，并且加载 p 进程 的上下文到寄存器中</p><p>其中有一个 RISC-V 的特性，就是对于一个函数调用，该函数会做现场保护，如果被调用的函数不调用别的函数的话，就可以把当前的 <code>pc</code> 值保存在 <code>ra</code> 寄存器中，而不用推入栈中，所以当函数返回就会从 <code>ra</code> 寄存器中读到 <code>pc</code> 指针，进而恢复到原来的代码中。而在 <code>swtch</code> 中，是使用了这个特性，把之前的 <code>ra</code> 寄存器保存，然后将将要运行的代码保存在 <code>ra</code> 寄存器中，之后代码返回就会返回到新的代码地址中去</p><p>在 RISC-V 中，假设任何函数都可以更新，使用和修改，覆盖 a 寄存器和 t 寄存器，所以当调用 <code>swtch</code> 函数时，没有办法对 a 和 t 返回后的寄存器的值做任何假设，所以没有必要保存这些寄存器的数据，只需要保存 <code>ra</code> ， <code>sp</code> 和 s 寄存器就可以了。在 xv6 中不使用 <code>gp</code> 寄存器，所以不予考虑。而 <code>tp</code> 寄存器保存的是当前内核的 id，所以是不会改变的，不予考虑</p><h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// 使能中断防止死锁</span></span><br><span class="line">    intr_on();</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="comment">// 这些状态必须在锁之后才拿到</span></span><br><span class="line">      <span class="keyword">if</span> (p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">    <span class="comment">// 选中的进程改为运行中的状态</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p; <span class="comment">// 将 cpu 当前进程设置为 p</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中有一个死循环，也就是 CPU 会不断循环执行这个调度程序，而这个死循环之前有初始化，将当前 CPU 的进程结构体初始化为 NULL，之后就进入死循环的调度任务</p><p>在调度任务中，需要使能中断防止死锁。然后遍历进程队列，找到一个可运行的进程，然后将其改为运行状态，切换上下文到该进程中运行，当 <code>swtch</code> 函数返回，就不再执行那个进程了，所以就会将 CPU 的进程改为 NULL</p><p>这个调度任务中有一个请求进程的锁，这里的话与上面的 <code>yield</code> 函数相对，也就是这里请求的锁会在调度回 <code>yield</code> 函数中释放，而在 <code>yield</code> 请求的锁会在这里被释放，所以就很奇妙的完成了只有进程在调度中时才会被锁上，其他时候都会被释放掉，也就不至于其它的内核在调度进程请求锁这里浪费太多时间</p><p>如果总是找不到一个可执行的进程，那么就会进入到外层的死循环中</p><h3 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">p-&gt;&gt;c:yield&gt;sched&gt;swtch&gt;schedler</span><br><span class="line">c-&gt;&gt;p:yield&lt;sched&lt;swtch&lt;schedler</span><br></pre></td></tr></table></figure><h3 id="中断状态"><a href="#中断状态" class="headerlink" title="中断状态"></a>中断状态</h3><p>在 <code>scheduler</code> 函数中，如果进程调度循环结束一轮之后，会进入大的循环，在这里会把中断打开，以防止一直没有可运行的进程而导致内核锁死在这里。每次在进程队列中循环一遍之后，就会把中断打开，一段时间之后，会的得到中断并且会去处理 trap，这可能会唤醒一些进程，从而使得该内核可以运行</p><p>每当程序进入 <code>usertrap</code> 中之后都会禁用中断，而重新返回到该线程之后会将中断启用状态恢复到处理 trap 之前的状态。这也就是说，在这个进程调度的过程中，中断是被禁用的</p><h2 id="进程挂起和唤醒"><a href="#进程挂起和唤醒" class="headerlink" title="进程挂起和唤醒"></a>进程挂起和唤醒</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul><li>保存在 <code>proc</code> 结构体中的 <code>chan</code></li><li>是一个 <code>void *</code> 变量。这里面可以存储函数 <code>sleep</code> 的原因和唤醒该进程的条件</li><li>在唤醒函数 <code>wakeup</code> 中作为匹配唤醒的条件</li></ul><h3 id="一个典型的语法"><a href="#一个典型的语法" class="headerlink" title="一个典型的语法"></a>一个典型的语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition is <span class="literal">false</span>) &#123;</span><br><span class="line"> sleep(untile condition is updated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个正在 sleep 的进程，其它进程可能并不知道该进程在等待怎样的 wake up 条件。所以其它的进程有可能唤醒所有与该条件有关的进程，所以会发生下列情况之一</p><ul><li>唤醒了太多的进程</li><li>唤醒几个正在等待在共享数据中做更改的进程</li></ul><p>它们其中之一有可能会抓住该条件，然后检查这个条件，如果这个条件满足要求，就会唤醒，如果发现这个条件是假的然后继续 sleep，所以必须在唤醒时重新检查条件</p><p>这会有一个<strong>问题</strong>：如果这个条件变成了 true，但是进程并没有执行完 sleep，那它就会错过这个信号，从而陷入永久的 sleep</p><h3 id="sys-sleep"><a href="#sys-sleep" class="headerlink" title="sys_sleep"></a>sys_sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;n); <span class="comment">// 将进程中的 a 寄存器的值赋予 n</span></span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ticks</code> 是一个全局变量，受到 <code>ticklock</code> 的保护，必须获得 <code>ticklock</code> 之后才能访问 <code>ticks</code></li><li>不能错过任何一个 <code>wakeup</code> ，每当 <code>wakeup</code> 时都会重新检查一下是否满足 <code>wakeup</code> 的条件，然后进行下一步，打开锁，以此保证请求和释放锁都是配对的</li><li>当 sleeping 过程中不能 hold 锁，所以就是自旋锁必须迅速释放。所以可以看到在 <code>sys_sleep</code> 函数中，调用 <code>sleep</code> 函数之前，实际上是持有 <code>tickslock</code> 的，所以 <code>sleep</code> 函数将 <code>tickslock</code> 传入，在函数内会把该锁给释放掉，而当 <code>wakeup</code> 之后就会重新请求锁，以此来保证 <code>sleep</code> 过程中不能持有锁，只有在检查条件时才会持有锁。需要保证请求和释放锁都是配对的</li></ul><p>这是一个 <code>sleep</code> 的系统调用，就是会 <code>sleep</code> 固定 <code>tick</code> 数的一个函数。当睡眠时间不够，会在循环中持续 <code>sleep</code> ，直到用户退出杀死这个进程或者是 <code>sleep</code> 时间足够了，就会释放 <code>ticklock</code> 锁，然后退出</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"> <span class="comment">// 一旦我们持有p-&gt;lock，我们可以保证我们不会错过任何唤醒(唤醒将会锁定p-&gt;lock)，所以可以释放lk。</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);<span class="comment">//DOC: sleeplock1</span></span><br><span class="line">  release(lk);</span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line">  sched();</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  acquire(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>sleep</code> 与 <code>yield</code> 函数相似，两者都会停止该进程的运行，两者都会获取进程的锁以此来把该进程标记为一个非运行的状态。在该函数中，会获取进程的锁，然后设置进程唤醒的条件，将进程状态设置为 <code>sleeping</code> ，然后进入 <code>sched</code> 进程调度函数，进行程序调度，那该函数就会保持 <code>sleep</code> 直到被唤醒，然后将唤醒条件清除，释放进程锁，然后返回</p><p>可以看到，函数的参数中传入一个自旋锁 <code>lk</code> ，在函数中将其释放掉，以此来保证该锁不会被长期占用，然后 <code>wakeup</code> 之后再请求锁，返回到之前的函数中</p><p>通常在循环中使用 <code>sleep</code> 寻找某个条件，这个条件由某个共享的变量保证</p><p>需要注意的是，在这个函数中的请求锁的函数必须是原子的，进入睡眠之前也不会被中断打扰。由于进程的锁一次只能由一个进程获取，所以会有两种情况</p><ul><li><code>wakeup</code> 比 <code>sleep</code> 先获得锁，那 <code>wakeup</code> 已经走过之后， <code>sleep</code> 函数才会设置 <code>SLEEPING</code> 状态，所以 <code>wakeup</code> 看来该进程并没有进入 <code>SLEEPING</code> 的状态</li><li><code>sleep</code> 比 <code>wakeup</code> 先获得锁，会设置好进程的 <code>chan</code> 变量并且将进程的状态设置为 <code>SLEEPING</code> 之后进入到 <code>sched</code> 函数才会释放该进程的锁。然后 <code>wakeup</code> 函数运行才能重新唤醒该进程</li></ul><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup"></a>wakeup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != myproc()) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数中，参数就是唤醒进程的信号，用于确定哪些进程可以被唤醒。在函数中遍历所有的进程，把所有符合唤醒条件的进程都唤醒，改变其状态为 <code>RUNNABLE</code> ，改变其状态需要获得该进程的锁。该函数需要在没有任何进程的锁被 hold 的时候调用。在代码中会判断只有在 <code>SLEEPING</code> 状态下的进程符合条件才会被改变状态为 <code>RUNABLE</code> ，所以一开始的 <code>p!=myproc</code> 实际上是一个无效的判断，也许就是个历史产物，但是实质上不会有什么影响，除了多费点时间</p><p>实际上， <code>wakeup</code> 的调用一般都是在该进程获得锁之后才进行</p><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713683756164.png" alt="1713683756164.png"></p><p>16650A 是一个早期的串口的通讯的芯片，它的协议至今还在使用，而 <code>xv6</code> 就是使用的该协议来做的。</p><p>内核将通过串口将数据输入到显示屏上，而键盘的数据也会通过串口输入到内核中，内核将从某个特定的字节读取。芯片 16650A 中可能没有 FIFO 队列，但是内部的 FIFO 队列可以被忽略</p><p>在内核中有 <code>uart_tx_buf</code> 来向显示屏发送串口数据，使用 <code>cons_buf</code> 来存储从键盘得到的数据，而且这两个数据都有自己的锁保护。所以在串口输出时，会调用 <code>uartputc</code> 来向 <code>uart_tx_buf</code> 中添加一个字节，并且使用 <code>consoleread</code> 来读取 <code>cons_buf</code> 缓冲区的字符。还有其它的方式，例如键盘中输入数据之后，可以使用 <code>echo</code> 来将其展示到显示屏上，这将会被内核自动响应并且立即显示，并且 <code>echo</code> 将会绕过输入缓冲区直接显示在设备上，如果缓冲区满了，将会拿到串口输出数据的锁来延迟 <code>echo</code> 。 <code>printf</code> 函数将会调用 <code>uartputc_sync</code> 函数同步的发送到显示设备上，这个是十分重要的，所以会绕过缓冲区</p><h3 id="uart-tx-buf"><a href="#uart-tx-buf" class="headerlink" title="uart_tx_buf"></a>uart_tx_buf</h3><p>这是串口输出缓冲区，尺寸有限，有 32 个字节，缓冲区中有两个索引， <code>r</code> 用于读取， <code>w</code> 用于写入</p><p>每写入一个都会把字符存到当前 <code>w</code> 的位置上，然后将 <code>w</code> 自增 1，读取时会将 <code>r</code> 所指的读取，然后 <code>r</code> 自增 1，但是它们两个索引只会在 32 个字节中循环追赶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buf[w++ % sz] = ch;</span><br><span class="line">ch = buf[r++ % sz];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实际代码中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TX_BUF_SIZE 32</span></span><br><span class="line"><span class="type">char</span> uart_tx_buf[UART_TX_BUF_SIZE];</span><br><span class="line">uint64 uart_tx_w; <span class="comment">// write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]</span></span><br><span class="line">uint64 uart_tx_r; <span class="comment">// read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]</span></span><br></pre></td></tr></table></figure><p><strong>empty</strong></p><p>如果是空的，那就是 <code>r</code> 追上 <code>w</code> 相互重合</p><p><strong>full</strong></p><p>如果是满的，就是 <code>w</code> 超过 <code>r</code> 正好是缓冲区的大小</p><p><strong>lock</strong></p><p>由于这个缓冲区可能会被多个进程访问，所以需要加上锁，这个锁是 <code>uart_tx_lock</code></p><h3 id="cons-buf"><a href="#cons-buf" class="headerlink" title="cons_buf"></a>cons_buf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="comment">// 保护缓冲区和索引</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// 128字节的buf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF_SIZE 128</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF_SIZE];</span><br><span class="line">  uint r;  <span class="comment">// Read index</span></span><br><span class="line">  uint w;  <span class="comment">// Write index</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index</span></span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure><p>在这个 buffer 中，有三个索引值</p><ul><li><code>r</code> 用于读取数据</li><li><code>w</code> 用于写数据</li><li><code>e</code> 是一个编辑的指针，在输入命令时，有时候会输入错误，这时候按下退格键将之前的命令字符删除，也就是说，在用户确认自己的输入之前，这些字符都是有可能被删除的。 所以在使用键盘键入字符时， <code>console</code> 会先使用编辑指针 <code>e</code> 来记录用户输入的字符，如果用户此时按下 <code>Ctrl-D</code> （EOF组合键）或者是换行 <code>\n</code> 时，这时候写指针就会确认之前编辑指针的输入，并且更新位置到编辑指针的位置</li></ul><h3 id="UART-Hardware-Regs"><a href="#UART-Hardware-Regs" class="headerlink" title="UART Hardware Regs"></a>UART Hardware Regs</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713697482142.png" alt="1713697482142.png"></p><p>上述说到从串口读取数据是从某个位置读取的数据，那个位置就是内存映射位置，内存地址映射到物理地址空间中的某个地址，这个地址由常数 <code>uart0</code> 表示，这个地址恰好为 <code>0x10...00</code> 。在这个地址上有几个字节，这些字节被认为是 IO 寄存器</p><ul><li><code>THR</code> ：发送保存寄存器，发送的数据存入这里</li><li><code>IER</code> ：中断使能寄存器，如果想使能中断，需要在该寄存器中写入一些特殊的东西</li><li><code>FCR</code> ：板上 <code>FIFO</code> 控制寄存器，如果想要使用芯片上的 <code>FIFOs</code> ，需要向该寄存器写入点东西</li><li><code>LCR</code> ：线路控制寄存器，用于设置波特率</li></ul><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713700068389.png" alt="1713700068389.png"></p><p>还有用于接收的地址</p><ul><li><code>RHR</code> ：接收保存寄存器，从这里读取接收数据</li><li><code>ISR</code> ：中断状态寄存器，显示中断的状态</li><li><code>LSR</code> ：线路状态寄存器，有两位特别重要<ul><li>在 <code>RHR</code> 中是否有输入，可以检查这个寄存器来读取数据</li><li>告诉发送保存寄存器，准备接收下一个输出字节。所以当写入 <code>THR</code> 太快就会导致数据丢失</li></ul></li></ul><h3 id="uartputc-sync"><a href="#uartputc-sync" class="headerlink" title="uartputc_sync"></a>uartputc_sync</h3><p>用于将字符尽快发送到硬件输出，被 <code>printf</code> 用来将错误消息尽可能快的打印在显示上，可以绕过输出队列。也可以使用 <code>echo</code> 方法将消息打印在显示设备上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc_sync</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 禁用中断</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="comment">// panicked 这个全局的变量会在硬件错误或者内核错误之后设置为 true，会进入死循环，冻结所有想要做的输出</span></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取寄存器 LSR 并且判断这个位是否置位。如果这个位是置位的话，就是准备好接收一个字节了</span></span><br><span class="line">  <span class="keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="comment">// 当准备好接收一个字节之后，写入一个字节</span></span><br><span class="line">  WriteReg(THR, c);</span><br><span class="line"> <span class="comment">// 开启中断</span></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uartputc"><a href="#uartputc" class="headerlink" title="uartputc"></a>uartputc</h3><p>这将由控制台调用，将在输出队列中添加一个字符，要想做到这一点，需要获得这个队列的锁，还要测试缓冲器的情况，是否有一些额外的空间在其中，然后将字符串放入到队列中，之后就调用 <code>uartstart</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 获得串口输出队列的锁</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"> <span class="comment">// 如果出现硬件或者内核错误，就死循环</span></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当串口输出队列满了，就进入 sleep</span></span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向串口队列写入数据</span></span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 如果硬件设备准备好接收数据的话，开始发送串口数据</span></span><br><span class="line">  uartstart();</span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart"></a>uartstart</h3><p>将信息从串口缓冲队列发送到 16650A 芯片中，将下一个数据发送到硬件中，如果硬件接收端准备好接收这个字段的话就会发送，否则就先不发送退出函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="comment">// 检查缓冲区是否是空的</span></span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 缓冲区空了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查硬件是否准备好接收一个字节</span></span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 未准备好</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓冲区中读取字节</span></span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>; <span class="comment">// 释放了缓冲区中的一个位置</span></span><br><span class="line">    <span class="comment">// 唤醒所有向串口写入但是在 sleep 的函数，也就是现在的缓冲区一定不是满的了</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    <span class="comment">// 写入硬件寄存器</span></span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uartgetc"><a href="#uartgetc" class="headerlink" title="uartgetc"></a>uartgetc</h3><p>如果硬件设备准备好了，并且 <code>RHR</code> 中有输入，从硬件中读取一个字节，这个函数不会等待，如果没有数据或者硬件没准备好，直接返回 -1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uartgetc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 检查 LSR 寄存器，是否有数据输入</span></span><br><span class="line">  <span class="keyword">if</span>(ReadReg(LSR) &amp; <span class="number">0x01</span>)&#123;</span><br><span class="line">    <span class="comment">// input data is ready.</span></span><br><span class="line">    <span class="keyword">return</span> ReadReg(RHR);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uartintr"><a href="#uartintr" class="headerlink" title="uartintr"></a>uartintr</h3><p>串口中断处理函数。只要有输入字符可以从硬件中读取，或者每当硬件准备好接收下一个输出字符时，硬件会产生中断，然后该中断会调用串口中断处理函数</p><p>它会读取串口硬件上的所有数据，然后每读到一个数据都会调用一次 <code>consoleintr</code> 函数</p><p>它也会调用串口开始发送的函数用于串口数据发送到硬件设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 获取串口信息一直到串口中没有信息</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 读到一个字节就丢到控制台中断中</span></span><br><span class="line">    <span class="comment">// 控制台中断控制器，由于当前处于中断控制器中，所以控制台中断不会休眠</span></span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送下一个字节</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  <span class="comment">// 开始向输出缓冲区发送字符</span></span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uartinit"><a href="#uartinit" class="headerlink" title="uartinit"></a>uartinit</h3><p>串口初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 写入寄存器，失能寄存器，保证初始化期间不会受到打扰</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line"> <span class="comment">// 设置波特率控制位，使能控制位之后，写入的数据就是波特率，进入设置波特率模式</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line"> <span class="comment">// 写入波特率 LSB</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line"> <span class="comment">// MSB 设置波特率</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">  <span class="comment">// 退出设置波特率模式</span></span><br><span class="line">  <span class="comment">// 设置 LCR 是 8 字节</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line">  <span class="comment">// 初始化并且使能 FIFOs，有可能已经有一些数据正在缓存中，所以清除 FIFOs 并且使能 FIFOs</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line"> <span class="comment">// 使能发送和接收中断</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line"> <span class="comment">// 初始化串口缓冲器保护的锁</span></span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="consputc"><a href="#consputc" class="headerlink" title="consputc"></a>consputc</h3><p>由上图可知， <code>printf</code> 调用 <code>uartputc_sync</code> 直接将数据输出到显示设备上，但是实际上，它不直接调用 <code>uartputc_sync</code> ，而是通过调用 <code>consputc</code> 来调用 <code>uartputc_sync</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">  <span class="comment">// 如果输入退格键，就会向左移动一个字符，然后用空格填充原来输入的字符</span></span><br><span class="line">  <span class="comment">// 然后再向左移动一个字符，这样下一个字符就会填充在退格的部分</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uartputc_sync(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="consolewrite"><a href="#consolewrite" class="headerlink" title="consolewrite"></a>consolewrite</h3><p>用于调用 <code>uartputc</code> 函数来将数据写入缓冲区中，如果函数 <code>uartputc</code> 进入 sleep 状态，那这个函数也会罢工</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consolewrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    uartputc(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数有三个形参，其中</p><ul><li><code>user_src</code> 一个布尔值，传递表示 <code>src</code> 表示的缓冲区地址空间是虚拟地址空间还是真实的物理地址空间</li><li><code>src</code> 源数据的地址</li><li><code>n</code> 传递字节数</li></ul><p>在该函数中，如果读取数据失败（地址非法）就会退出，否则就一直读到 <code>n</code> 个字节为止，最后该函数返回写入的字节数</p><h3 id="consoleread"><a href="#consoleread" class="headerlink" title="consoleread"></a>consoleread</h3><p>等待在 <code>cons_buf</code> 中有数据可以被检索，它将从缓冲区中复制字符串，并将其移动到用户空间的某个地方，直到得到 <code>\n</code> 或者时 <code>EOF</code> 字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line">  target = n;</span><br><span class="line">  <span class="comment">// 获得源缓冲区的锁</span></span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// 如果缓冲区中没有数据，就进入 sleep</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line">    <span class="comment">// C(x) = ctrl+x</span></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file:ctrl+D </span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">    <span class="comment">// 就是说如果已经读到了文件末尾，那就将 r 指针倒退一格保证下一次循环依旧是 ctrl+D</span></span><br><span class="line">    <span class="comment">// 从而实现文件读不出数据了，或者说读出来空的数据</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 写入数据</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">// 写入失败</span></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to the user-level read().</span></span><br><span class="line">      <span class="comment">// 已经读取到一整行，将新行移动到用户缓冲区，退出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">  <span class="comment">// 返回成功读取多少字节 </span></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数有三个参数，其中</p><ul><li><code>user_dst</code> 表示目的缓冲区地址 <code>dst</code> 的地址空间是虚拟地址空间还是真实的物理地址空间</li><li><code>dst</code> 目标缓冲区地址</li><li><code>n</code> 读取字节数</li></ul><h3 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr"></a>consoleintr</h3><p>终端的中断处理函数，在 <code>uartintr</code> 中被调用</p><ul><li>用于将一个字符添加到 <code>cons_buf</code> 中</li><li>将字符回显到输出中</li><li>如果得到一个 <code>\n</code> 或者是 <code>EOF</code> 文件结尾字符，都会将 <code>w=e</code> 然后唤醒任何等待输入的函数，例如 <code>consoleread</code> 函数来处理信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line.</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF_SIZE] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;: <span class="comment">// Delete key</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">        <span class="comment">// has arrived.</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中传入一个字节，会将它传入输入缓冲区，会对字符进行判断，各种情况如下</p><ul><li><code>ctrl+P</code> 打印进程列表，会调用 <code>procdump</code> 函数，这对于调试内核很有用</li><li><code>ctrl+H</code> ， <code>\x7f</code> 就是退格和 <code>delete</code> ，这将做的事情就是备份原先输入的数据，然后调用 <code>uartputc(BACKSPACE)</code></li><li><code>ctrl+U</code> 就是删除当前的一整行，或者是将编辑索引删除到与写入索引一个位置，并且调用一个 <code>uartputc(BACKSPACE)</code></li><li><code>default</code> 当字符是空的或者缓冲区中已经满了，就会忽略输入字符串<ul><li>如果字符串是返回字符 <code>\r</code> 就将其转为新行 <code>\n</code> 字符，否则不变</li><li>然后将字符直接显示在显示器上并且输入到缓冲区中</li><li>如果写入了换行或者文件末尾或者是缓冲区满了，会将 <code>w</code> 移动到 <code>e</code> 以便将所有字符读到，还会唤醒正处于 <code>SLEEPING</code> 的读取缓冲区的进程</li></ul></li></ul><h3 id="consoleinit"><a href="#consoleinit" class="headerlink" title="consoleinit"></a>consoleinit</h3><p>初始化函数，在其中会初始化锁，将串口初始化，并且链接函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);</span><br><span class="line">  uartinit();</span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化缓冲区的锁</li><li>串口初始化</li><li>链接函数指针</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="pagetable"><a href="#pagetable" class="headerlink" title="pagetable"></a>pagetable</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713800246070.png" alt="1713800246070.png"></p><p>页表表现为树状，并且在 xv6 中为三级树</p><h3 id="一些定义-1"><a href="#一些定义-1" class="headerlink" title="一些定义"></a>一些定义</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/Untitled.png" alt="Untitled"></p><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/Untitled%201.png" alt="Untitled"></p><ul><li><code>PGSIZE</code> 页面最大尺寸</li><li><code>PGSHIFT</code> 这个就是虚拟地址中，页表的地址的偏移</li><li><code>PX(level, va)</code> 返回第 <code>level</code> 级页表中虚拟地址 <code>va</code> 的地址</li><li><code>PXMASK</code> 返回页表地址的掩码，是 9 位，对应上图</li><li><code>MAXVA</code> 虚拟地址的最大地址</li><li><code>PA2PTE</code> 物理地址转为页表项虚拟地址</li><li><code>PTE2PA</code> 页表项虚拟地址转为物理地址</li><li><code>PTE_FLAGS</code> 页表项标志位的掩码</li><li><code>PGROUNDUP(sz)</code> 该地址的上一页页表的地址（内存从下向上排）</li><li><code>PGROUNDDOWN(a)</code> 该地址的下一页页表的地址（内存从下向上排）</li><li><code>MAKE_SATP(pagetable)</code></li></ul><h3 id="walk"><a href="#walk" class="headerlink" title="walk"></a>walk</h3><p>该函数会在页表树上查找，将返回指向数据页的页表项的地址，如果不能分配页面并且也不选择创建页面，会返回一个空指针，成功返回该页表的地址，返回的是虚拟地址</p><p>64 位的虚拟地址被拆分如下</p><ul><li><code>39-63</code> 必须为 0</li><li><code>30-38</code> 9 位的二级页表索引</li><li><code>21-29</code> 9 位的一级页表索引</li><li><code>12-20</code> 9 位的零级页表索引</li><li><code>0-11</code> 12 位在页面的偏移量</li></ul><p>该函数需要传入的参数</p><ul><li><code>pagetable</code> 指向页表根节点和虚拟地址的指针</li><li><code>va</code> 虚拟地址</li><li><code>alloc</code> 是一个布尔量，当这个页表不存在的话，可以将 <code>alloc=1</code> 来创建页表，这个就是是否需要创建页表项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 虚拟地址不能大于最大的虚拟地址</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">  <span class="comment">// 三级别页表</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">     <span class="comment">// 切换到下一级页表</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 不存在该页表调用 kalloc 分配页面</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 初始化内存</span></span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="comment">// 物理内存转为虚拟页表地址</span></span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回页表指针</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mappages"><a href="#mappages" class="headerlink" title="mappages"></a>mappages</h3><p>用于将页表项添加到页表中，也就是添加一个虚拟映射，创建一个虚拟地址开始于 <code>va</code> 的页表，虚拟地址空间映射的物理空间开始于 <code>pa</code> 。 <code>va</code> 和 <code>size</code> 没必要页面对齐，会使用最小的能包含所有大小的页面数。成功返回 <code>0</code>，如果 <code>walk</code> 不能分配一个需要的页表页面就返回 <code>-1</code></p><p>参数如下</p><ul><li><code>pagetable</code> 页表</li><li><code>va</code> 虚拟地址空间，告诉页面将在虚拟地址空间中添加到哪里</li><li><code>size</code> 添加页面的大小</li><li><code>pa</code> 传递一个物理地址，指向很多页面，所以需要使用 <code>size</code> 来表示页面数</li><li><code>perm</code> 该页面被赋予的权限 <code>R/W/X/U</code></li></ul><p>如果函数运行出错将会返回 <code>-1</code> ，否则返回 <code>0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"> <span class="comment">// 大小为0</span></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  <span class="comment">// 找到可以容纳所有内存的最小的页面内存</span></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">   <span class="comment">// 申请页面</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 刚申请好的页面必须是无效的</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    <span class="comment">// 标记为有效的，并且赋予权限</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="comment">// 把所有页面都包含进去的页表数</span></span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kvmmap"><a href="#kvmmap" class="headerlink" title="kvmmap"></a>kvmmap</h3><p>这个就是添加一个内核页表的映射，<strong>只在初始化时调用</strong>，不刷新 <code>TLB</code> 或启用页面</p><p>由于内核只有一个共享页表，所以当创建页表时，使用这个函数映射内核虚拟内存，实际上这个创建操作与 <code>mappages</code> 是类似的，除此以外，如果创建出错会直接报错，因为内核页表创建出错会导致无法正常运行</p><p>函数的形参：</p><ul><li><code>kpgtbl</code> 内核的页表</li><li><code>va</code> 映射的虚拟地址</li><li><code>pa</code> 映射的实际物理地址</li><li><code>sz</code> 内核页面大小</li><li><code>perm</code> 页面的权限</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 直接调用 mappages 来映射地址空间</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kvmmake"><a href="#kvmmake" class="headerlink" title="kvmmake"></a>kvmmake</h3><p>这个函数将会调用 <code>kvmmap</code> 来创建和初始化内核的页表，为内核创建一个直接映射页面表</p><ul><li>通过直接映射将所有物理内存添加到页表中</li><li>将所有设备直接映射到页表中</li><li>为 trampoline page 创建了一个映射，trampoline page 是位于某个物理地址中的，另外·还会有一个映射到虚拟地址的最高的页面的映射</li><li>调用 <code>proc_mapstacks</code> 函数，在这个函数中<ul><li>调用 <code>kalloc</code> 来为每一个进程的栈分配一个页面，这些页面将被映射到某些物理页面上</li><li>当进程以内核模式运行时，需要用到栈，所以在内核模式的页表中创建了 64 个对每个进程的内核栈的映射，这中间用到了 <code>KSTACK</code> 宏定义函数，可以计算对应进程的栈的内存地址</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"> <span class="comment">// 申请分配页面，并且初始化</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"> <span class="comment">// 串口寄存器，串口映射</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// virtio mmio磁盘接口映射</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// 映射内核代码，并且赋予可执行和可读权限</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  <span class="comment">// 映射内核数据页和将要使用的物理的 RAM</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"> <span class="comment">// 在最高的内核虚拟地址空间地址映射 trampoline </span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"> <span class="comment">// 为每一个进程都映射一个内核栈的虚拟地址空间</span></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  <span class="comment">// 返回申请好的内核页表</span></span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kvminit"><a href="#kvminit" class="headerlink" title="kvminit"></a>kvminit</h3><p>通过调用 <code>kvmmake</code> 来创建内核页表，并且将其地址保存在某个全局变量中 <code>kernel_pagetable</code> ，这个初始化函数将由 0 号内核调用来初始化内核页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kvminithart"><a href="#kvminithart" class="headerlink" title="kvminithart"></a>kvminithart</h3><p>在初始化阶段，每个内核都会调用这个函数，每个内核的寄存器 <code>satp</code> 将保存内核的页表地址，这对于每个内核将会比较有效的打开这个页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 等待先前的操作完成</span></span><br><span class="line">  sfence_vma();</span><br><span class="line"> <span class="comment">// 将kvminit得到的内核页表根目录地址放入SATP寄存器，其实就是内核共享页表</span></span><br><span class="line"> <span class="comment">// 清楚LTB中过时的条目</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="walkaddr"><a href="#walkaddr" class="headerlink" title="walkaddr"></a>walkaddr</h3><p>用于将虚拟地址并且将其转化为物理地址，如果没有映射的话返回 <code>NULL</code> ，只能在用户模式下使用</p><ul><li><code>pagetable</code> 页表</li><li><p><code>va</code> 虚拟地址</p><p>  这个函数将使用页表映射，将虚拟地址转为物理地址。这个页表必须被标记为有效，并且必须有用户权限，如果中间出现错误，就会返回 0，由于任何虚拟地址的物理地址都不会对应为 0（从0x80..000开始），所以返回 0 是安全的</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 找到页表项对应的虚拟地址</span></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 页表项的虚拟地址转为物理地址</span></span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uvmcreate"><a href="#uvmcreate" class="headerlink" title="uvmcreate"></a>uvmcreate</h3><p>这将创建一个空的页表，它只是分配一个物理页面，并将其清除为 0，并且返回该页面的根索引，这个用于用户地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">uvmcreate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uvminit"><a href="#uvminit" class="headerlink" title="uvminit"></a>uvminit</h3><p>在 xv6 代码中没找到这个函数，用于创建第一个用户虚拟地址空间，这个有点特别。这个函数将创建一个页面，并且将其映射到虚拟地址 0，并标记为可读可写可执行用户权限，并且会用一些代码填充，将会用 <code>initcode</code> 来填充这个页面，这个 <code>initcode</code> 是一个 52 个字节组成的数组。这个数组来自于 <code>initcode.S</code> 是系统执行的第一个用户模式的进程</p><h3 id="initcode-S-1"><a href="#initcode-S-1" class="headerlink" title="initcode.S"></a>initcode.S</h3><p>在 <code>initcode.S</code> 代码中所做的是调用确切的系统调用，并且调用的进程名称为 <code>/init</code> ，还有 0 参数，这个 <code>init</code> 函数不应该返回，这个 <code>init</code> 函数应该存在，并且如果由于某种原因返回了，这将调用 <code>exit</code> 系统调用，然后循环退出。函数只能在用户模式下调用</p><p>这个汇编代码汇编好之后，从可执行文件中提取字节存放在 <code>initcode</code> 数组中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><h3 id="uvmalloc"><a href="#uvmalloc" class="headerlink" title="uvmalloc"></a>uvmalloc</h3><p>该函数将向现有虚拟地址空间添加页面，可以说是将虚拟地址空间给重新分配大小了。这个函数中调用 <code>kalloc</code> 来分配物理内存，并且使用 <code>mappages</code> 将内存映射到页表中。而且该函数申请的新的页表的新的大小不需要页表对齐，页表会在这段内存中尽可能地多分配页面。函数运行结束就返回 <code>newsz</code> 。如果运行中出现任何问题，就会调用 <code>kfree</code> 和 <code>uvmdealloc</code> 将页表大小重新恢复到原大小，并且将所有申请的页面退回到空闲内存中，并且返回 0 表示失败了。</p><p>在这个函数中，会给扩大的内存直接赋予可读权限和用户模式可访问权限，可写和可执行权限由外部指定</p><p>例如对于堆内存的扩展就可以使用 <code>uvmalloc</code> 函数来实现</p><p>其中参数为</p><ul><li><code>pagetable</code> 页表地址</li><li><code>oldsz</code> 虚拟空间原来的大小</li><li><code>newsz</code> 新的大小</li><li><code>xperm</code> 给新的页面添加的权限</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line">  <span class="comment">// 从 oldsz 所在的页面的下一个页面开始</span></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">   <span class="comment">// 分配内存</span></span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 出现申请失败，释放所有申请的内存</span></span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">   <span class="comment">// 创建虚拟地址映射</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 释放掉该页面</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="comment">// 释放所有页面的虚拟地址映射</span></span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uvmunmap"><a href="#uvmunmap" class="headerlink" title="uvmunmap"></a>uvmunmap</h3><p>删除从 <code>va</code> 开始的映射的 <code>npage</code> 个页表。 <code>va</code> 必须与页面对齐并且映射必须存在，可以选择释放物理内存。这个函数将遍历每个页面并且将其页表项设为 0。其中包括有效位，所以就是将这个页表设置为无效的页表</p><p>这个函数传入的参数为</p><ul><li><code>pagetable</code> 指向页表的指针</li><li><code>va</code> 虚拟地址</li><li><code>npages</code> 从虚拟地址空间删除的页面数</li><li><code>do_free</code> 是否释放数据页，如果为 <code>true</code> 还将调用 <code>kfree</code> 来释放数据页，会释放进空闲池</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"> <span class="comment">// 未对齐</span></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">   <span class="comment">// 清除所有设置的权限</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="comment">// 无效的页面</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line">    <span class="comment">// 页面没有任何权限</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="comment">// 释放物理内存</span></span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uvmdealloc"><a href="#uvmdealloc" class="headerlink" title="uvmdealloc"></a>uvmdealloc</h3><p>释放用户页面以将大小从 <code>oldsz</code> 调整为 <code>newsz</code> 。 <code>oldsz</code> 和 <code>newsz</code> 不需要页面对齐， <code>newsz</code> 如果大于 <code>oldsz</code> 那就不会取消分配的页面，直接返回。 <code>oldsz</code> 可以大于实际大小，返回新的大小</p><p>调用 <code>uvmunmap</code> 函数来从虚拟地址空间释放页面，用来缩小地址空间，并且会释放数据页，所以需要将 <code>do_free=1</code> ，而且新的大小和旧的大小不需要页面对齐。需要保证新的大小不大于旧的大小，否则将会返回旧的大小，并且不做处理。</p><p>其中传入的参数为</p><ul><li><code>pagetable</code> 页表地址</li><li><code>oldsz</code> 旧的大小</li><li><code>newsz</code> 新的大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"> <span class="comment">// newsz 所在页面上一页小于 oldsz 所在页面的上一页地址</span></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    <span class="comment">// 取消虚拟映射，并且释放内存</span></span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="freewalk"><a href="#freewalk" class="headerlink" title="freewalk"></a>freewalk</h3><p>用于删除页表，释放页表中的所有索引页，但是不释放数据页，所以需要率先删除所有的叶映射来防止内存泄漏，这是一个递归调用。最后删除根索引页。如果使用递归函数需要注意不要递归的太深，主要是因为内核没有很大的栈，实际上树只有三层，所以不用担心</p><p>其中参数为</p><ul><li><code>pagetable</code> 指向页表的指针，作用是调用该节点的子结点来删除子树</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 每个页表中有 512 个页表项</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 这是指向下一级页表的地址</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">    <span class="comment">// 递归释放</span></span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 如果已经是最后一层那所查询的页表项是没有权限或者无效的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除释放页表</span></span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uvmfree"><a href="#uvmfree" class="headerlink" title="uvmfree"></a>uvmfree</h3><p>将会释放掉位于指定地址以下的虚拟地址空间的所有页面。先释放用户内存页，再释放页表索引</p><p>在用户的虚拟地址空间的顶部会有 trampoline 页面和 trap 页面，由于 trampoline 页面是由所有的虚拟地址空间共享的页面，所以不去释放，trap 页面也是预先分配的，所以也没有释放</p><p>其中传入的参数为</p><ul><li><code>pagetable</code> 指向页表的指针</li><li><code>sz</code> 要释放的虚拟地址空间的地址（实际上也是释放的大小）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">   <span class="comment">// sz 以下的所有内存页都释放掉</span></span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>);</span><br><span class="line">  freewalk(pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uvmcopy"><a href="#uvmcopy" class="headerlink" title="uvmcopy"></a>uvmcopy</h3><p>给定父进程的页表，将其内存复制到子进程的页表格中。复制页表和物理内存。成功时返回0，失败时返回-1。失败时释放所有分配的页面。</p><p>当使用 <code>fork</code> 指令复制进程时，需要复制整个进程的虚拟地址空间，需要为子进程创建第二个虚拟地址空间，会调用该函数</p><p>它会从旧的地址开始复制指定大小的页面到新的地址空间。新的地址空间的 trampoline 页面是映射于同一个位置的，新的虚拟地址空间会有新的 trap frame 页面，而且它将会为所有的虚拟地址空间的 data 页面创建映射到新的物理地址，而且这些新的页面会有相同的权限。如果失败会调用 <code>kfree</code> 和 <code>uvmunmap</code> 删除掉页表的条目并且释放掉所有申请的页面</p><p>参数为</p><ul><li><code>old</code> 旧的页表地址，父进程页表地址</li><li><code>new</code> 新的页表的地址，子进程页表地址</li><li><code>sz</code> 复制的大小，父进程页表的大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line"> <span class="comment">// 释放所有子进程所申请的也表空间</span></span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uvmclear"><a href="#uvmclear" class="headerlink" title="uvmclear"></a>uvmclear</h3><p>这个函数仅用于在用户模式下将保护页标记为不可访问，防止栈溢出，这就是它唯一用到的地方，通过清除页表条目中的 <code>U</code> 位来标记该页面</p><p>传入的参数</p><ul><li><code>pagetable</code> 页表地址</li><li><code>va</code> 虚拟地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmclear</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  </span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmclear&quot;</span>);</span><br><span class="line">  *pte &amp;= ~PTE_U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copyin-and-copyout"><a href="#copyin-and-copyout" class="headerlink" title="copyin and copyout"></a>copyin and copyout</h3><p>对于一个进程来说，需要时不时地将进程的数据移动到虚拟地址空间以内或者之外的地方</p><p>但是有时候一个字节块在虚拟地址空间中是连续的块，但是有可能横跨几个页面，而不同的页面存储的位置不一定连续，所以可以将其移动进缓冲区从而将物理地址中这些不连续的字节块连续起来。</p><p><strong>copyin</strong></p><p>从用户复制到内核，将 <code>len</code> 字节从给定页表中的虚拟地址 <code>srcva</code> 复制到 <code>dst</code> 。成功时返回 0，错误时返回 -1</p><p>这个函数将会从用户虚拟空间复制字节到目标内核区域，所以它会复制碎片的地址的数据，传入</p><p>传入的参数</p><ul><li><code>pagetable</code> 传入的页表</li><li><code>dst</code> 目标地址，这就像缓冲区一样，想要存储字节的地方，位于内核中</li><li><code>srcva</code> 源数据地址，位于用户地址空间</li><li><code>len</code> 传递数据大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove(dst, (<span class="type">void</span> *)(pa0 + (srcva - va0)), n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    dst += n;</span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>copyout</strong></p><p>从内核复制到用户，将len字节从src复制到给定页表中的虚拟地址dstva。成功时返回0，错误时返回-1</p><p>用于将数据从这个缓冲区移回虚拟地址空间。或者说是将内核空间的数据复制到用户虚拟地址空间中</p><p>传入参数为</p><ul><li><code>pagetable</code> 页表</li><li><code>dstva</code> 目标地址，应该是虚拟地址空间地址，是用户地址空间</li><li><code>src</code> 指向源数据的指针，内核地址空间</li><li><code>len</code> 传入数据长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两个函数在出错时返回 -1，否则返回 0</p><p><strong>copyinstr</strong></p><p>将以 <code>null</code> 结尾的字符串从用户复制到内核，将字节从给定页表中的虚拟地址 <code>srcva</code> 复制到 <code>dst</code> ，直到 <code>\0</code> 或最大值。成功时返回 0，错误时返回 -1</p><p>函数与 <code>copyin</code> 相似，但是这个传递的是一个字符串，而不是特定的长度</p><p>传入的参数为</p><ul><li><code>pagetable</code> 页表项</li><li><code>dst</code> 目标地址/缓冲区地址</li><li><code>srcva</code> 源虚拟地址</li><li><code>max</code> 将会传递的最大大小，如果遇到字符串末尾的空终止字时就会停止，传递的字符数量不会超过这个大小，可能是缓冲区的大小。如果一直到最大长度都没有遇到终止字，就会返回 -1 以表示出现了某种错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; max)</span><br><span class="line">      n = max;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *) (pa0 + (srcva - va0));</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        got_null = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *dst = *p;</span><br><span class="line">      &#125;</span><br><span class="line">      --n;</span><br><span class="line">      --max;</span><br><span class="line">      p++;</span><br><span class="line">      dst++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(got_null)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="一些定义-2"><a href="#一些定义-2" class="headerlink" title="一些定义"></a>一些定义</h3><ul><li><code>cpus[NCPU]</code> 实力化所有 CPU 结构体</li><li><code>proc[NPROC]</code> 实例化所有进程的结构体</li><li><code>initproc</code> 指向初始进程指针</li><li><code>nextpid</code> 进程计数器，初始化为 1</li><li><code>pid_lock</code> 进程锁，自旋锁</li><li><code>KSTACK(p)</code> 映射 trampoline page 下的内核堆栈，每个都被无效的保护页包围</li></ul><h3 id="allocpid"><a href="#allocpid" class="headerlink" title="allocpid"></a>allocpid</h3><p>当需要一个新的进程 id 的话，可以调用这个函数，他将会返回新进程 id，并将进程计数器加一，对进程计数器进行修改需要请求锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocpid</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  acquire(&amp;pid_lock);</span><br><span class="line">  pid = nextpid;</span><br><span class="line">  nextpid = nextpid + <span class="number">1</span>;</span><br><span class="line">  release(&amp;pid_lock);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="procinit"><a href="#procinit" class="headerlink" title="procinit"></a>procinit</h3><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713883564531.png" alt="1713883564531.png"></p><p>用于初始化进程数组，只在 0 号内核中被调用一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"> <span class="comment">// 初始化进程锁</span></span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始化另一个锁</span></span><br><span class="line">  initlock(&amp;wait_lock, <span class="string">&quot;wait_lock&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">   <span class="comment">// 初始化每一个进程的自旋锁</span></span><br><span class="line">    initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">    <span class="comment">// 将状态初始化为未使用</span></span><br><span class="line">    p-&gt;state = UNUSED;</span><br><span class="line">    <span class="comment">// kstack 指向内核虚拟地址空间中栈的地址，实际上就是真实的地址空间</span></span><br><span class="line">    p-&gt;kstack = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="procdump"><a href="#procdump" class="headerlink" title="procdump"></a>procdump</h3><p>基本上是为了调试，遍历 <code>proc</code> 数组并且打印每一个被使用的进程的信息，进程号，状态和名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> *states[] = &#123;</span><br><span class="line">    [UNUSED] <span class="string">&quot;unused&quot;</span>,</span><br><span class="line">    [USED] <span class="string">&quot;used&quot;</span>,</span><br><span class="line">    [SLEEPING] <span class="string">&quot;sleep &quot;</span>,</span><br><span class="line">    [RUNNABLE] <span class="string">&quot;runble&quot;</span>,</span><br><span class="line">    [RUNNING] <span class="string">&quot;run   &quot;</span>,</span><br><span class="line">    [ZOMBIE] <span class="string">&quot;zombie&quot;</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">char</span> *state;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state == UNUSED)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state &gt;= <span class="number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])</span><br><span class="line">      state = states[p-&gt;state];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      state = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %s&quot;</span>, p-&gt;pid, state, p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proc-pagetable"><a href="#proc-pagetable" class="headerlink" title="proc_pagetable"></a>proc_pagetable</h3><p>为给定的进程创建一个用户页表，没有用户内存，但是有 trampoline page 的映射，返回创建的页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 为 trampoline 创建映射，将内核的 trampoline 的（物理）地址映射到 TRAMPOLINE 虚拟地址空间中</span></span><br><span class="line">  <span class="comment">// 并且将其标记为可执行，可读</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">               (uint64) trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 出问题，释放创建的页表</span></span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将陷阱框架映射到内存中第二高的页面，由于之前（在allocproc中）为进程创建过一个 trap frame page</span></span><br><span class="line">  <span class="comment">// 所以这里直接映射该页面到虚拟地址空间中</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">               (uint64) (p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 出问题，释放创建的页表</span></span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocproc"><a href="#allocproc" class="headerlink" title="allocproc"></a>allocproc</h3><p>当需要利用 <code>proc</code> 数组创建一个新的进程时，调用 <code>allocproc</code> 函数，会找到一个未使用的进程结构体，然后初始化它并且返回一个指向它的指针。如果找到了，初始化它并且带着锁返回，如果有任何意外，就返回 <code>NULL</code> ，函数工作流程</p><ul><li>寻找一个未使用的进程结构体</li><li>创建一个 trap frame 页，trampoline 被所有页面共享</li><li>创建一个新页表</li><li>添加 trap frame 和 trampoline 的映射</li><li>设置上下文 <code>context</code> （这里是寄存器保存区），也就是初始化上下文，为过程的第一个切片做准备</li></ul><p>这个函数不会将代码或者数据添加到地址空间中，如果出现问题就撤销所作的一切操作，返回 <code>NULL</code> ，调用这个函数时应该在之后将这个进程设置为 <code>RUNNABLE</code> 的状态以在未来某一时刻运行。 <code>allocproc</code> 函数只在两个地方使用，一个就是进程初始化，另一个就是 <code>fork</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"> <span class="comment">// 创建一个 trap frame page</span></span><br><span class="line">  <span class="keyword">if</span> ((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 创建失败，清空所有进程所申请的内存，</span></span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个空的用户页表，将所有位于 trap frame 之下的页面都映射</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pagetable == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 创建失败，撤销做的所有事</span></span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置初始化的上下文</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line"> <span class="comment">// 初始化返回地址寄存器，程序开始执行的地址</span></span><br><span class="line">  p-&gt;context.ra = (uint64) forkret;</span><br><span class="line">  <span class="comment">// 初始化栈指针寄存器，由于栈向下增长，所以初始化指针指向栈的最顶部</span></span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forkret"><a href="#forkret" class="headerlink" title="forkret"></a>forkret</h3><p>上述代码中返回时并未释放锁，所以需要释放锁，但是从调度器出来之后依旧是拿着锁的</p><p>从 <code>fork</code> 产生的进程，可以从 trap 中 return，但是对于新创建的进程，需要伪装一个 trap，然后返回。这里有个静态变量 <code>first</code> ，当这个函数是 <code>fork</code> 产生的，它一定会是 0</p><p>文件系统初始化必须在常规进程的上下文中运行（例如，因为它调用 <code>sleep</code> ），因此不能从  <code>main()</code> 运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 文件系统初始化</span></span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proc-freepagetable"><a href="#proc-freepagetable" class="headerlink" title="proc_freepagetable"></a>proc_freepagetable</h3><p>释放进程的页表，首先释放掉 trampoline page 和 trap frame page，之后释放掉页表，并且释放掉所有的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;</span><br><span class="line"> <span class="comment">// 释放 trampoline page 不要求释放内存，这个是所有进程与内核共享的，不需释放</span></span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 取消 trap frame 不要求释放内存，因为这个是在 freeproc 中调用这个函数之前就被释放了</span></span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="freeproc"><a href="#freeproc" class="headerlink" title="freeproc"></a>freeproc</h3><p>当出现问题，会调用该函数，或者进程结束也会调用该函数。传入参数为需要释放的进程的指针，会释放该进程的 trap frame page 的物理地址和进程的页表的数据页的地址和页表索引页，将进程的剩余字段清零（虽然都是不太必要的），并且进程转台标记为未使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span> *) p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="userinit"><a href="#userinit" class="headerlink" title="userinit"></a>userinit</h3><p>用于设置第一个用户进程，其中的 <code>initcode</code> 是一段机器代码，基本功能就是执行系统调用，传入一个 <code>/init</code> 的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"> <span class="comment">// 调用 alloc 找到 proc 结构并且设置它</span></span><br><span class="line">  p = allocproc();</span><br><span class="line">  <span class="comment">// 这是一个初始化进程，所以需要保存它的指针</span></span><br><span class="line">  initproc = p;</span><br><span class="line">  <span class="comment">// 分配一个用户页面，并且复制初始的代码和数据到其中</span></span><br><span class="line">  <span class="comment">// initcode 是一个字节序列，有 52 个字节，要将这些数据复制到虚拟地址空间的第 0 页</span></span><br><span class="line">  uvmfirst(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  <span class="comment">// 进程对应的虚拟内存空间的大小</span></span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  <span class="comment">// 准备从内核到用户的第一次返回</span></span><br><span class="line">  <span class="comment">// 将程序计数器设置为 0，表示第一次程序的返回是从第一条指令开始执行的</span></span><br><span class="line">  <span class="comment">// 需要注意的是，之后得每一个进程都是直接 fork 的初始进程，所以不会再执行这段代码了</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 栈指针指向第一页顶部，需要注意的是，第一个程序的页面，包含着代码和栈，所以希望第一个进程不会占用太多栈内存</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;</span><br><span class="line">  <span class="comment">// 设置进程的名称，这个安全字符复制函数会将字符串从一个地方复制到另一个地方</span></span><br><span class="line">  <span class="comment">// 而且这个过程是安全的，不会超出目标区域的大小，所以第三个参数为传入的最大的字节数</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  <span class="comment">// 进程的工作目录，初始化进程的工作目录就是 &#x27;/&#x27;</span></span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"> <span class="comment">// 设置进程状态为可执行</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"> <span class="comment">// 再 allocproc 中设置了锁，这里释放掉</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><p>系统调用处理流程，基本上就是一次向下调用</p><ul><li><code>uservec</code> 当中断发生就会调用这个函数，这个函数是一段汇编代码</li><li><code>usertrap</code> 这个函数由 <code>uservec</code> 调用，这个函数决定是否要做系统调用，如果运行系统调用，会打开中断</li><li><code>syscall</code> 该函数由 <code>usertrap</code> 调用来处理系统调用，这个函数具体决定做出怎样的系统调用，需要检查进程的 <code>killed</code> 标志位，如果置 1，那就杀死进程，退出</li><li><code>sys_call</code> 系统调用将做一定的操作，然后返回</li><li><code>usertrapret</code> 每当系统调用返回时都会回到这个函数，然后就会像调度程序一样返回</li><li><code>userret</code> 被 <code>usertrapret</code> 调用，将会返回运行用户模式代码</li></ul><h3 id="ecall"><a href="#ecall" class="headerlink" title="ecall"></a>ecall</h3><p>所有的系统调用的汇编指令都是首先将系统调用号载入 <code>a7</code> 寄存器，系统调用号在后面将会被用来请求对应的内核服务，因此它起到了一个纽带的关系，将对应的内核系统调用例程一一地映射到用户态函数。然后这段汇编调用了 <code>ecall</code> 指令来请求内核的服务，接下来就是重头戏了：</p><p>当主动发起一个系统调用时，意味着我们要请求内核的服务（一种情况是系统调用，当用户程序执行 <code>ecall</code> 指令以要求内核为其执行某些操作时）。 <code>ecall</code> 指令就像是一个钥匙，帮助我们打开内核服务的大门，那么 <code>ecall</code> 指令具体功能</p><p><code>ecall</code> (environment call) 指令负责提升 risc-v 的优先级模式，risc-v 有三种模式：用户模式，监视者模式和机器模式。这三种模式的优先级依次升高，当我们主动调用一个系统调用时时，需要提升CPU的特权模式，以获得对某些寄存器的访问权和某些指令的执行权。就是当处于内核态时就会提升为机器模式</p><p>事实上， <code>ecall</code> 主动触发了一个用户态异常，进而会导致一系列的陷阱动作，它们都是由硬件自动完成的：</p><ul><li>将用户的特权模式从 <code>U-Mode</code> 提升至 <code>S-Mode</code> ，为陷阱的处理做准备</li><li>将当前正在执行的指令地址(或当前指令的下一条)放入 <code>sepc</code> 中保存</li><li>将 <code>stvec</code> 中保存的 <code>trampoline</code> 程序入口地址放入 <code>pc</code> 中，准备进入</li><li>将当前导致陷阱的原因记录在 <code>scause</code> 寄存器中</li><li>将当前模式保存在 <code>sstatus</code> 的 <code>SPP</code> 位，并清空 <code>sstatus</code> 中的 <code>SIE</code> 位来关闭中断，之前的 <code>SIE</code> 为保存在 <code>SPIE</code> 位</li><li>更新 <code>stval</code> 寄存器的值，使其指向出现异常的地址</li></ul><p>上述步骤是处理一个陷阱的自动动作，无论导致陷阱的原因是异常还是中断，它们的硬件流程都是上面这些。一般来说在用户模式下运行时， <code>stvec</code> 中的内容就是 <code>uservec</code> 的第一行代码，但是进入到 <code>usertrap</code> 之后就是内核状态了，这时候设置 <code>stvec</code> 为 <code>kernelvec</code> ，也就是进入内核模式之后中断会进入内核中断处理程序</p><h3 id="syscalls"><a href="#syscalls" class="headerlink" title="syscalls"></a>syscalls</h3><p>这是一个函数指针的队列，指向各种系统调用，一共有 21 个，这些系统调用的函数都不需要传入参数，并且返回参数都是 <code>uint64</code> 类型的数据，返回数据将会被保存到 <code>a0</code> 寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="user-h"><a href="#user-h" class="headerlink" title="user.h"></a>user.h</h3><p>这个文件中包含了一系列系统调用的声明和一些辅助的函数。这个函数用于获得参数，传入数字 <code>0-5</code> 然后获得对应的 <code>trapframe</code> 中的 <code>a</code> 寄存器中的数据</p><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用的代码是一段汇编代码，这段汇编代码由 <code>usys.pl</code> 这个脚本生成，具体代码如下，实际上就是调用的 <code>SYS_sbrk</code> 来实现的，在 <code>syscall.h</code> 中有各种系统调用的指令，这些指令依次对应着一个数字。系统调用会从用户模式进入到内核模式。在 risc-v 中，参数传入一般都放在 <code>a0, ... ,a5</code> 寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global sbrk</span><br><span class="line">sbrk:</span><br><span class="line"> li a7, SYS_sbrk # 将系统调用指令写入 a7 寄存器中</span><br><span class="line"> ecall # 该指令在 risc-v 中会调用系统调用，参数将会位于 a0,...a5 寄存器中</span><br><span class="line"> ret # 返回，如果有返回值，将会位于 a0 寄存器中</span><br></pre></td></tr></table></figure><p>如果从系统调用返回之后，将会回到用户模式继续运行代码。代码返回时将会按照 <code>ra</code> 寄存器中的地址返回，也就是将 <code>ra</code> 中的数据直接 <code>copy</code> 到 <code>pc</code> 指针去。内核将会保留所有寄存器，除了 <code>a0</code> 寄存器，所以可以确定 <code>a0</code> 的值不会改变，可以直接返回</p><h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>这个函数会被 <code>usertrap</code> 函数调用，它将会调用一个函数指针数组中的对应的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"> <span class="comment">// 保存 a7 寄存器，也就是系统调用的号</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">  <span class="comment">// 调用对应的系统调用</span></span><br><span class="line">  <span class="comment">// 在 a0 寄存器中存储对应的返回值</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 打印错误信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    <span class="comment">// 保存返回值为 -1 表示出错</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="argraw"><a href="#argraw" class="headerlink" title="argraw"></a>argraw</h3><p>该函数是功能函数，这将被使用来获得用户进程的 trap frame 页面中存储的 <code>a</code> 寄存器的值，这个函数相当于是从寄存器中读取原数值</p><p>这个函数将被 <code>argint</code> 函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="argint"><a href="#argint" class="headerlink" title="argint"></a>argint</h3><p>这个函数直接调用 <code>argraw</code> 函数，将数据存储在第二个形参中，这个将数据转为一个 <code>int</code> 类型的变量，相当于是从寄存器中读取整数了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="argaddr"><a href="#argaddr" class="headerlink" title="argaddr"></a>argaddr</h3><p>这个函数直接将寄存器中的数据作为一个地址传入到第二个形参中，这里不需要检验地址是否合法，因为在 <code>copyin</code> 和 <code>copyout</code> 中将会进行检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="argstr"><a href="#argstr" class="headerlink" title="argstr"></a>argstr</h3><p>获取第 <code>n</code> 个寄存器中的字符串，存储到 <code>buf</code> 中，获取的最大字符串数量为 <code>max</code> ，如果不出错，那就返回获取到的字符串长度，否则返回 -1</p><p>函数中，首先从寄存器中获取该字符串的地址，然后根据地址来获取字符串，这里不会检验地址的合法性，因为在 <code>fetchstr</code> 中会做检验的，实际上它是直接调用 <code>copyinstr</code> 来获取字符串的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  argaddr(n, &amp;addr);</span><br><span class="line">  <span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="argfd"><a href="#argfd" class="headerlink" title="argfd"></a>argfd</h3><p>读取第 <code>n</code> 个寄存器中的数据，将其作为文件描述符返回，会检查其合法性，出错就返回 <code>-1</code> ，一切正常返回 <code>0</code></p><ul><li><code>n</code> 第 <code>n</code> 个寄存器的数据</li><li><code>pfd</code> 存储文件描述符 <code>pfd</code></li><li><code>pf</code> 存储对应文件的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">argfd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *pfd, <span class="keyword">struct</span> file **pf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  argint(n, &amp;fd);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f=myproc()-&gt;ofile[fd]) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pfd)</span><br><span class="line">    *pfd = fd;</span><br><span class="line">  <span class="keyword">if</span>(pf)</span><br><span class="line">    *pf = f;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fetchstr"><a href="#fetchstr" class="headerlink" title="fetchstr"></a>fetchstr</h3><p>从当前进程的页表中获取字符串，通过调用 <code>copyinstr</code> 来获取，获取成功返回字符串长度，否则返回 -1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fetchaddr"><a href="#fetchaddr" class="headerlink" title="fetchaddr"></a>fetchaddr</h3><p>从当前进程的 <code>addr</code> 的地址获取一个无符号 64 位整形，其实就是地址数据</p><p>成功返回 0，否则返回 -1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchaddr</span><span class="params">(uint64 addr, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 地址与数据是否溢出</span></span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= p-&gt;sz || addr+<span class="keyword">sizeof</span>(uint64) &gt; p-&gt;sz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 从地址拷贝</span></span><br><span class="line">  <span class="keyword">if</span>(copyin(p-&gt;pagetable, (<span class="type">char</span> *)ip, addr, <span class="keyword">sizeof</span>(*ip)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h2><p>这个系统调用将会调用 <code>growproc()</code> 函数，这个将会增加地址空间的大小</p><p>这个函数传入一个参数，如果是正的那就增长堆，如果是负的就缩小堆的大小，还可以是 0，这将会返回先前的内存的大小，实际上内存的大小就是最新的分配的地址。这个函数实际上会有一个传入的参数，该参数将会被保存在 <code>a0</code> 寄存器中，所以需要使用上述的 <code>argxxx</code> 函数来调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="growproc"><a href="#growproc" class="headerlink" title="growproc"></a>growproc</h3><p>扩大或者缩小 n 字节的用户内存，成功返回 0，否则返回 -1</p><p>在函数中，会判断 <code>n</code> 的数据，如果大于 0，就申请内存，并且映射到当前进程的页表中，如果小于 0，就取消分配的进程的页表的内存，如果是 0，就不做任何操作。最后将进程的内存大小更新为最新的内存大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  uint64 sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 来说，这个函数都会成功的，所以不需要检查</span></span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>这个系统调用用于创建进程，并且是唯一一个创建进程的方式，而且创建新的进程其实就是从 <code>initproc</code> 的进程直接复制过来，然后开始运行自己的代码。父进程调用该函数创建子进程，而且创建出的进程与父进程完全相同。父进程调用该系统调用时，会进入内核中进行处理，成功复制进程之后，父进程与子进程都会在某一个时刻返回，从内核态返回到用户态，并且会从 <code>fork</code> 函数中得到返回值。不同之处在于，如果调用失败，将会在父进程中返回 -1，并且没有子进程。如果成功在父进程中 <code>fork</code> 函数返回子进程的 id，而子进程返回 0。可以通过判断 <code>fork</code> 函数的返回值来确定当前处于父进程还是子进程，从而决定进程表现按着父进程来还是子进程。如果出现内存用完了不能继续分配内存，那就会创建进程失败</p><p>该函数执行的流程</p><ul><li><code>allocproc</code> ：寻找一个新的未使用的进程结构体，获取它并且对它进行初始化，会分配一个新的进程号到那个进程结构体中</li><li>复制虚拟内存空间：创建一个空的虚拟地址空间，然后添加对 trap frame page 和 trampoline page 页面的映射。所有父进程的虚拟地址空间中的内容将被复制到子进程的虚拟地址空间中，而且所有页面的权限都与父进程相同</li><li>初始化 <code>proc</code> 结构体：将初始化并且设置一些位于 <code>proc</code> 结构体中的一些变量<ul><li><code>sz</code> 虚拟地址空间中的字节数，也就是从 0 到堆的顶端</li><li><code>trapframe</code> 由于父进程进行系统调用 <code>fork</code> 函数会保存寄存器信息到 <code>trapframe</code> 中，包括 <code>pc</code> 寄存器，所以就是说从内核中返回时，子进程将也会返回到 <code>ecall</code> 的位置并且开始运行。而对于 <code>a0</code> 寄存器，在子进程中会将其置为 0，也就是在子进程中得到返回值为 0</li><li><code>name</code> 将会与父进程的 <code>name</code> 一致</li><li><code>ofile</code> 将会从父进程中复制所有父进程打开的的文件描述符。也就是在父进程中打开的文件也会在子进程中打开</li><li><code>cwd</code> 复制父进程的工作路径，子进程工作路径与父进程一致</li><li><code>parent</code> 将在子进程的结构体中设置 <code>parent</code> 的指针，并且将会指向父进程的 <code>proc</code> 结构体</li><li><code>state</code> 进程的状态将会被设置为 <code>RUNNABLE</code> 以接收内核的调度运行</li></ul></li><li>在父进程中返回子进程的 id 号</li></ul><p>系统调用会调用 <code>sys_fork</code> ，而 <code>sys_fork</code> 将会调用 <code>fork</code> 函数，并且 <code>sys_fork</code> 会返回 <code>fork</code> 返回的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"> <span class="comment">// 分配进程，并且返回新的进程的指针，并且在该函数中将会持有新的进程的锁</span></span><br><span class="line">  <span class="keyword">if</span> ((np = allocproc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 调用 uvmcopy 函数来复制父进程的虚拟地址空间到子进程中</span></span><br><span class="line"> <span class="comment">// 如果复制失败，就释放掉新的进程，然后返回 -1 表示失败</span></span><br><span class="line">  <span class="keyword">if</span> (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 会将所有东西都返回到空闲内存池中</span></span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  <span class="comment">// 复制 trap frame page 包括 pc 寄存器</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"> <span class="comment">// 这将导致在子进程中 fork 返回值为 0</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加打开的文件的描述符的引用次数，也就是子进程也会打开父进程的所有打开的文件</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  <span class="comment">// 复制当前工作路径</span></span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"> <span class="comment">// 复制父进程地址</span></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  <span class="comment">// 如果解开锁，在操作系统中很多事情都有可能发生，例如子进程可能会被杀死或者其它的事情</span></span><br><span class="line">  <span class="comment">// 所以如果在解开锁之后获取 pid 可能会得到错误的 id 号</span></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"> <span class="comment">// 这里释放锁是为了防止死锁，也就是当前获得进程锁时再去获的 wait 锁会导致死锁</span></span><br><span class="line"> <span class="comment">// 如下图所示</span></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="comment">// 当父进程的 proc 可以被访问时，需要持有 wait_lock</span></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line">  <span class="comment">// 指针指向父进程 proc</span></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line">  acquire(&amp;np-&gt;lock);</span><br><span class="line">  <span class="comment">// 设置进程状态</span></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Blog_ButterFly/2024/05/08/xv6-kernel%E4%B8%8A/1713974891816.png" alt="1713974891816.png"></p><p>在 <code>exit</code> 和 <code>wakeup</code> 函数中会发生持有 <code>wait_lock</code> 然后申请进程锁，这与 <code>fork</code> 函数会发生死锁情况，所以 <code>fork</code> 函数做出了让步，释放掉进程锁再获取 <code>wait_lock</code></p><h3 id="子进程的运行"><a href="#子进程的运行" class="headerlink" title="子进程的运行"></a>子进程的运行</h3><p>当子进程状态为 <code>RUNNABLE</code> 时，CPU 就会给它分配时间片来运行，子进程将会调用 <code>swtch</code> 来进行上下文切换，将内核的寄存器保存，并且加载该进程的寄存器，并且会加载 <code>ra</code> 寄存器。在 <code>swtch</code> 返回时，会返回到 <code>ra</code> 寄存器的地址处开始运行，而 <code>ra</code> 寄存器中保存的是函数 <code>forkret</code> 的地址，也就是程序在 <code>swtch</code> 之后会返回到 <code>forkret</code> 中去，在 <code>sp</code> 寄存器中保存栈的地址。在一般的流程中，从 <code>swtch</code> 函数返回之后应当是返回到 <code>yield</code> 函数中，然后进入 <code>usertrapret</code> 中，然后调用 <code>sret</code> 返回到用户模式中。一般的进程被调度之后的流程类似于 <code>scheduler()-&gt;swtch()-&gt;sched()-&gt;yield()-&gt;usertrap-&gt;usertrapret-&gt;userret-&gt;sret</code>但是对于一个还未运行过的程序是不行的，所以对于子进程来说需要一个初始化程序，就是 <code>forkret</code> 这个函数将会在 <code>allocproc</code> 中调用，在其中会设置 <code>p-&gt;context.ra=(uint64)forkret</code> 来指定第一次被调度的函数入口。调度器调度这个子进程时，就会进入 <code>forkret</code> 中并且开始运行</p><p>所以子函数调用流程就是 <code>scheduler()-&gt;swtch()-&gt;forkret()-&gt;usertrapret()-&gt;userret()-&gt;sret</code></p><h3 id="forkret-1"><a href="#forkret-1" class="headerlink" title="forkret"></a>forkret</h3><p>在这个代码中所作的就是解开进程锁，然后直接调用 <code>usertrapret</code> 函数。</p><p>会进行判断，也就是对于父进程（从 <code>initproc</code> 中 <code>fork</code> 来的进程）来说，会执行文件系统的初始化。而对于子系统，运行到这里时 <code>first</code> 已经置为 0，就不会再运行文件系统初始化了。况且子进程会对父进程中的所有内容进行复制，所以也不需要初始化文件系统</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 从调度程序出来之后，依旧是持有进程锁的</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>该函数用于结束一个进程，可以传入参数作为退出的状态，这将会返回到其它的进程。在 <code>linux/unix</code> 中，该状态参数为 <code>char</code> 类型的，而在 <code>xv6</code> 中，该状态量为 <code>int</code> 类型的。在 <code>linux/unix</code> 中，高位用于传递二外的信息给其它进程，例如导致进程结束的信号量等。但是在 <code>xv6</code> 中没有信号量，所以使用 <code>int</code> 类型的变量。但是不论是在 <code>linux/unix/xv6</code> 中，状态 0 表示成功返回。任何正数都被用来说明出错了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  <span class="built_in">exit</span>(n); <span class="comment">// 这里将永不会返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 初始化进程不会退出</span></span><br><span class="line">  <span class="keyword">if</span> (p == initproc)</span><br><span class="line">    panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line">  <span class="comment">// 关闭打开的所有文件描述符</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ofile[fd]) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">      fileclose(f);</span><br><span class="line">      <span class="comment">// 将结构体的文件描述符给设置为 NULL</span></span><br><span class="line">      p-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭当前工作目录</span></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  p-&gt;cwd = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 对父进程的操作需要持有 wait_lock，也就是 reparent 需要该锁</span></span><br><span class="line">  <span class="comment">// 对于下面的重新设置子进程的父进程和唤醒父进程不会取得任何进展，直到释放 wait_lock 锁 </span></span><br><span class="line">  <span class="comment">// 直到设置为 ZOMBIE 之后才会释放 wait_lock 之后，所以父进程一旦唤醒就会发现变成 ZOMBIE 的子进程</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line">  <span class="comment">// 将所有子进程的父进程设置为 initproc</span></span><br><span class="line">  reparent(p);</span><br><span class="line">  <span class="comment">// 唤醒父进程</span></span><br><span class="line">  wakeup(p-&gt;parent);</span><br><span class="line">  <span class="comment">// 对进程状态进行操作需要获得进程锁</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="comment">// 设置进程退出状态</span></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  <span class="comment">// 将进程设置为僵尸进程，父进程将会设置为 UNUSED，然后被回收</span></span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line">  <span class="comment">// 进入程序调度，不会返回，除非进程被设置为 RUNNABLE，但是是不可能返回的，也就是最后一条语句不可能执行</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当父进程等待子进程结束"><a href="#当父进程等待子进程结束" class="headerlink" title="当父进程等待子进程结束"></a>当父进程等待子进程结束</h3><ul><li>状态参数传入到父进程中</li><li>父进程被唤醒</li><li>父进程将会清理进程，也就是将子进程的 <code>proc</code> 结构体状态设为 <code>UNUSE</code> ，并且需要释放掉进程的数据结构</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>如果该进程没有父进程，或者父进程先退出不等待子进程退出，那么该子进程将会被冻结，进而变成僵尸进程 <code>ZOMBIE</code> ，并且停止运行程序，并且进程的数据结构还没有释放掉，淫威需要地方存储退出状态</li><li>当父进程一直等待，操作就会完成</li></ul><h3 id="如果父进程退出没有等待子进程结束"><a href="#如果父进程退出没有等待子进程结束" class="headerlink" title="如果父进程退出没有等待子进程结束"></a>如果父进程退出没有等待子进程结束</h3><ul><li>所有子进程将会重新把 <code>init</code> 进程作为父进程</li><li><code>init</code> 进程会在一个循环中等待，无论哪个子进程退出， <code>init</code> 进程都会收集其退出状态，允许僵尸进程退出</li></ul><h3 id="reparent"><a href="#reparent" class="headerlink" title="reparent"></a>reparent</h3><p>传递一个进程，将其所有子进程都重新设置为 <code>initproc</code> 的子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reparent</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (pp = proc; pp &lt; &amp;proc[NPROC]; pp++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;parent == p) &#123;</span><br><span class="line">      pp-&gt;parent = initproc;</span><br><span class="line">      <span class="comment">// 这里唤醒该进程是为了防止该进程处于等待子进程退出而进入 SLEEPING 状态，所以需要唤醒</span></span><br><span class="line">      wakeup(initproc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>等待其中一个子进程退出并且返回其进程 id 号。传入参数为地址，也就是将进程退出的状态写入这个地方</p><p>该函数执行的流程为</p><ul><li>找到一个僵尸子进程 <code>ZOMBIE</code><ul><li>获取退出状态</li><li>调用 <code>freeproc</code> 将该进程状态修改为 <code>UNUSED</code> ，然后释放对应进程的地址空间</li><li>返回进程 id 号</li></ul></li><li>如果没有找到<ul><li>进程将会进入 <code>sleep</code> 状态，而且唤醒条件是父进程的 <code>proc</code> 结构体的地址</li><li>当子进程退出时，必须唤醒父进程，唤醒的信号量是父进程的 <code>proc</code> 结构体的地址</li></ul></li><li>然后循环该进程，直到没有子进程了，就退出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 p;</span><br><span class="line">  <span class="comment">// 进程的地址默认被存储在 a0 寄存器中</span></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;p);</span><br><span class="line">  <span class="comment">// 返回退出的子进程的 id 号</span></span><br><span class="line">  <span class="keyword">return</span> wait(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(uint64 addr)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 等待进程需要持有 wait_lock</span></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (pp = proc; pp &lt; &amp;proc[NPROC]; pp++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pp-&gt;parent == p) &#123;</span><br><span class="line">        <span class="comment">// make sure the child isn&#x27;t still in exit() or swtch().</span></span><br><span class="line">        <span class="comment">// 获得锁，对进程操作需要获得锁，并且获得锁以保证进程不处于 exit 或者 swtch 中</span></span><br><span class="line">        acquire(&amp;pp-&gt;lock);</span><br><span class="line"></span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 寻找到一个 ZOMBIE 子进程</span></span><br><span class="line">        <span class="keyword">if</span> (pp-&gt;state == ZOMBIE) &#123;</span><br><span class="line">            pid = pp-&gt;pid;</span><br><span class="line">          <span class="comment">// 复制退出状态到地址 addr 中</span></span><br><span class="line">          <span class="keyword">if</span> (addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *) &amp;pp-&gt;xstate,</span><br><span class="line">                                   <span class="keyword">sizeof</span>(pp-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放锁，退出，实际上这个函数就只等待一个子进程的退出</span></span><br><span class="line">            release(&amp;pp-&gt;lock);</span><br><span class="line">            release(&amp;wait_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将进程状态设置为未使用，释放进程的地址空间，释放与之相关的数据结构等</span></span><br><span class="line">          freeproc(pp);</span><br><span class="line">          <span class="comment">// 释放进程锁以可使用该进程</span></span><br><span class="line">          release(&amp;pp-&gt;lock);</span><br><span class="line">          <span class="comment">// 释放 wait_lock</span></span><br><span class="line">          release(&amp;wait_lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;pp-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历之后未找到任何子进程，然后杀死该进程</span></span><br><span class="line">    <span class="keyword">if</span> (!havekids || killed(p)) &#123;</span><br><span class="line">      release(&amp;wait_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了子进程，但是在运行中，进入 sleep，进入之后会释放 wait_lock 以允许子进程进入 exit 获得该锁</span></span><br><span class="line">    <span class="comment">// 如果被唤醒，将立即获得 wait_lock</span></span><br><span class="line">    sleep(p, &amp;wait_lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>linux/unix</code> 中有个系统调用 <code>waitpid</code> 就是等待对应进程号的进程退出。而且不用进入 <code>sleep</code> 状态，可以直接返回</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>杀死对应 id 号的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;pid);</span><br><span class="line">  <span class="keyword">return</span> kill(pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">   <span class="comment">// 对进程结构体的内容做改变需要获得该进程的锁</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">       <span class="comment">// 将进程从 SLEEPING 状态拉出来，直接唤醒然后完成系统调用</span></span><br><span class="line">       <span class="comment">// 但是实际上直接这样操作会出问题，但是无论进程是因为什么进入 sleep 的，都会在退出系统调用之后进入到用户模式之前检查 killed 标志的</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有找到进程号的进程</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h2><h3 id="spinlock-1"><a href="#spinlock-1" class="headerlink" title="spinlock"></a>spinlock</h3><p>Spin Locks 自旋锁，在内存中只有一个字节来表示锁。如果锁是未持有的或者自由的，这个字为 0，否则为 1。这个锁在多线程经常被使用，可以被其它进程调用。所以自旋锁不能被长期占用。而且对于 <code>release</code> 和 <code>acquire</code> 操作必须成对在同一个内核中调用。</p><p>有四个可调用的方法。</p><ul><li><code>acquire(spinlock* lk)</code> 获取，就是等待自旋锁状态被释放，一旦获取锁就会将其置为 1，但是如果没有得到锁会一直不断循环来获得锁，直到获得为止，这个进程中不能够进入 <code>sleep</code> 状态，而且没有时间分配，所以相当于会堵死。</li><li><code>release(spinlock* lk)</code> 释放，就是简单的将自旋锁状态设置为 0</li><li><code>initlock(spinlock* lk, str)</code> 初始化锁</li><li><code>holding(spinlock* lk)</code> 当前进程是否持有锁</li></ul><p>当自旋锁的 <code>acquire</code> 和 <code>release</code> 之间需要 <code>sleep</code> （这是自旋锁无法解决的），就需要 <code>sleeplocks</code></p><h3 id="sleeplock"><a href="#sleeplock" class="headerlink" title="sleeplock"></a>sleeplock</h3><p>这是一种可以长期上锁的一个锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">  <span class="comment">// 用于保护这个锁的数据结构的，也就是用来保护这个锁内其它的数据的读写的</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="type">int</span> pid;           <span class="comment">// 获得该锁的进程的 id 号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个锁与自旋锁十分相似，也是有 <code>acquire</code> 和 <code>release</code> 的方法</p><p>有四个可调用的方法</p><ul><li><p><code>acquiresleep(sleeplock*)</code> 请求 <code>sleeplocks</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 对锁内数据修改需要获得自旋锁</span></span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="comment">// 退出 sleep 之后重新检查该锁的状态是否被释放</span></span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">   <span class="comment">// 如果锁已经被使用就进入睡眠来等待锁被释放</span></span><br><span class="line">   <span class="comment">// 当一个锁释放会使得所有等待该锁的进程中的其中一个获得锁并且开始运行</span></span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置锁的状态和持有该锁的进程</span></span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>releasesleep(sleeplock*)</code> 释放 <code>sleeplocks</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 获取锁，将锁释放并且调用 wakeup 函数，唤醒等待该锁的进程</span></span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>initsleep(sleeplock*, str)</code> 初始化 <code>sleeplocks</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 初始化其中的自旋锁</span></span><br><span class="line">  initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>; <span class="comment">// 初始化未被 hold</span></span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>; <span class="comment">// 未被持有所以初始化为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>holdingsleep(sleeplock*)</code> 当前进程是否持有 <code>sleeplocks</code> ，如果当前进程获得锁就返回 <code>true</code> 否则返回 <code>false</code> 。这个函数主要用来错误检查</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="comment">// 返回是否被当前进程所持有</span></span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习</title>
      <link href="/Blog_ButterFly/2024/04/17/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/Blog_ButterFly/2024/04/17/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言</p><ul><li><strong>Python 是解释型语言：</strong> 这意味着开发过程中没有了编译这个环节。类似于 <code>PHP</code> 和 <code>Perl</code> 语言</li><li><strong>Python 是交互式语言：</strong> 这意味着可以在终端中的 <code>Python</code> 提示符 <code>&gt;&gt;&gt;</code> 后直接执行代码</li><li><strong>Python 是面向对象语言:</strong> 这意味着 <code>Python</code> 支持面向对象的风格或代码封装在对象的编程技术</li><li><strong>Python 是初学者的语言：</strong> <code>Python</code> 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 <code>WWW</code> 浏览器再到游戏</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ol><li><p>安装依赖环境</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br></pre></td></tr></table></figure></li><li><p>下载python</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tgz</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p><p> 首先是创建安装目录 <code>/usr/local/python3.9</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /usr/local/python3.9</span><br></pre></td></tr></table></figure><p> 解压安装包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.9.0.tgz</span><br></pre></td></tr></table></figure><p> 进入解压后的目录，编译安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/python3.9</span><br></pre></td></tr></table></figure><p> 其中 <code>--prefix</code> 就是指定安装目录，如果没有指定安装目录，会在 <code>/usr/local/bin</code> 或 <code>/usr/local/lib</code> 目录下看到</p><p> 编译</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p> 安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p> 然后检查</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/python3.9/bin/python3.9</span><br></pre></td></tr></table></figure><p> 成功进入 <code>python</code> 的命令行就是安装完成了</p></li><li><p>配置环境变量</p><p> 在 <code>/etc/profile</code> 文件的最底下输入</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYTHON_HOME=/usr/local/python3.9</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PYTHON_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p> 然后更新环境变量</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p> 如果是上边安装目录没有指定，就不需要配置环境变量。因为默认安装的目录 <code>/usr/local/bin</code> 是在环境变量中的</p></li></ol><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>windows上安装会比较简单，一般来说可以直接下载 python 的安装包然后安装就好，或者可以下载 python 的源文件，然后将对应的 <code>bin</code> 目录添加导环境变量中就好</p><h1 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h1><ul><li><code>Number</code> 数字，不可变，是一个常量<ul><li><code>int</code> 整形，为长整型</li><li><code>float</code> 浮点数</li><li><code>bool</code> 布尔类型</li><li><code>complex</code> 复数类型 <code>1+2j</code></li></ul></li><li><code>String</code> 字符串，不可变<ul><li>python 中的 <code>&#39;</code> 与 <code>&quot;</code> 使用方法一致</li><li>使用三引号可以指定一个多行字符串</li><li>转义字符 <code>\</code></li><li>反斜杠可用作转义，使用 <code>r</code> 可使之不发生转义</li><li>字符串可以使用 <code>+</code> 连接在一起，使用 <code>*</code> 使得字符串重复</li><li>索引方式从前到后，或者是从后到前</li><li>字符串切片为 <code>str[start:end]</code> 表示切片范围 <code>[start, end)</code></li><li>字符串切片可以定义步长 <code>str[start:end:step]</code></li></ul></li><li><code>bool</code> 布尔类型<ul><li>只有 <code>True</code> 和 <code>False</code></li><li>布尔类型与其他类型比较时，会把 <code>True</code> 视为 1， <code>False</code> 视为 0</li></ul></li><li><code>List</code> 列表<ul><li>列表中元素可变</li><li>列表写在方括号内，元素之间逗号隔开 <code>l = [a, b, c]</code></li><li>和字符串类似，列表可被切片和索引</li><li>列表可以使用 <code>+</code> 进行拼接</li><li><code>l = []</code></li></ul></li><li><code>Tuple</code> 元组，是不可改变的列表<ul><li>元组中的元素不可改变</li><li>元组可以索引，也可以截取</li><li>元素写在小括号内，元素之间使用逗号隔开 <code>t = (a, b, c)</code></li><li>如果只有一个元素，需要在元素之后添加逗号 <code>t = (a, )</code></li><li>元组可以使用 <code>+</code> 操作符拼接</li><li><code>t = tuple()</code></li></ul></li><li><code>Set</code> 集合<ul><li>是一种无序并且可变的数据类型，用于存储唯一的元素，类似于 C++ 中的哈希表</li><li>元素不会重复，可以使用交集，并集，差集，异或等集合操作</li><li>使用大括号表示，元素之间用逗号分割 <code>s = &#123;a, b, c&#125;</code></li><li>空集合为 <code>s = set()</code></li></ul></li><li><code>Dictionary</code> 字典<ul><li>用大括号表示，是无序的键和值的集合，类似于 C++ 的哈希map</li><li>在字典中，键必须是唯一的</li><li>使用构造函数 <code>dict()</code> 可以直接从键值对序列中构建字典</li></ul></li><li><code>bytes</code><ul><li>是不可变的二进制序列</li><li>其中的元素类型是 <code>0~255</code> 之间的整数，不是 unicode 字符</li><li>支持许多操作和方法，如切片、拼接、查找、替换</li><li>是整数值，比较时需要使用相应的整数值</li></ul></li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul><li><code>int(x [, base])</code> 将 x 转为整数</li><li><code>float(x)</code> 将 x 转为浮点数</li><li><code>complex(real [, imag])</code> 创建一个复数，实数部分为 <code>real</code> ，虚数部分默认为 0</li><li><code>str(x)</code> 将 x 转为字符串</li><li><code>repr(x)</code> 将 x 转为字符串表达式</li><li><code>eval(str)</code> 用来计算在字符串中的有效 python 表达式，返回一个对象，这个对象名就是这个字符串的内容，需要提前定义</li><li><code>tuple(s)</code> 将序列 s 转为元组</li><li><code>list(s)</code> 将序列 s 转化为列表</li><li><code>set(s)</code> 转换为可变集合</li><li><code>dict(d)</code> 创建一个字典，其中 <code>d</code> 必须是 <code>(key, value)</code> 元组序列</li><li><code>frozenset(s)</code> 转为不可变的集合</li><li><code>chr(x)</code> 将一个整数转为字符</li><li><code>ord(x)</code> 将一个字符转为它的整数值</li><li><code>hex(x)</code> 将整数转为 16 进制</li><li><code>oct(x)</code> 将整数转为 8 进制</li><li>在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。两种不同类型的数据进行运算，较低数据类型就会转换为较高数据类型以避免数据丢失</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><code>and</code> 与 C 语言中的  <code>&amp;&amp;</code> 一致，先执行运算符之前的条件，如果是 <code>False</code> 直接返回，否则运算符之后的条件</li><li><code>or</code> 如果运算符之前为 <code>True</code> 直接返回，否则返回运算符之后的条件</li><li><code>not</code> 非</li></ul><h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><ul><li><code>in</code> 在指定的序列中返回 <code>True</code></li><li><code>not in</code> 不在指定的序列中返回 <code>False</code></li></ul><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><ul><li><code>is</code> 判断两个标识符是否引用自同一个对象</li><li><code>not is</code> 两个标识符是否不是引自同一个对象</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>(expressions…),</td></tr><tr><td>[expressions…], {key: value…}, {expressions…}</td><td>圆括号的表达式</td></tr><tr><td>x[index], x[index:index], x(arguments…), x.attribute</td><td>读取，切片，调用，属性引用</td></tr><tr><td>await x</td><td>await 表达式</td></tr><tr><td>**</td><td>乘方(指数)</td></tr><tr><td>+x, -x, ~x</td><td>正，负，按位非 NOT</td></tr><tr><td>*, @, /, //, %</td><td>乘，矩阵乘，除，整除，取余</td></tr><tr><td>+, -</td><td>加和减</td></tr><tr><td>&lt;&lt;, &gt;&gt;</td><td>移位</td></tr><tr><td>&amp;</td><td>按位与 AND</td></tr><tr><td>^</td><td>按位异或 XOR</td></tr><tr><td></td><td></td><td>按位或 OR</td></tr><tr><td>in,not in, is,is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==</td><td>比较运算，包括成员检测和标识号检测</td></tr><tr><td>not x</td><td>逻辑非 NOT</td></tr><tr><td>and</td><td>逻辑与 AND</td></tr><tr><td>or</td><td>逻辑或 OR</td></tr><tr><td>if — else</td><td>条件表达式</td></tr><tr><td>lambda</td><td>lambda 表达式</td></tr><tr><td>:=</td><td>赋值表达式</td></tr></tbody></table></div><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>元素在方括号内，并且元素之间用逗号分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [1, 2, 3, 4, 5]</span><br><span class="line">l = []</span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>类似于 C 语言中的数组，利用方括号访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(l[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>直接对列表中元素赋值就可以完成更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="comment"># l = [2, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用 <code>del</code> 语句删除列表元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>]</span><br><span class="line">l = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>使用 <code>+</code> 号运算符直接组合两个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = l + l</span><br><span class="line"><span class="comment"># l = [2, 3, 4, 5, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>在列表中可以包含其他列表，也就是列表的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll = [l, l]</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>需要引入 <code>operator</code> 模块中的 <code>eq</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">l1 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">l2 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">operator.eq(l1, l2)</span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul><li><code>append</code> 追加元素</li><li><code>count</code> 统计列表中某元素个数</li><li><code>extend</code> 在末尾一次性追加一个列表</li><li><code>index</code> 在列表中找出某个值第一个匹配项的索引位置</li><li><code>insert</code> 将对象插入列表中</li><li><code>pop</code> 移除列表中一个元素，默认为最后一个元素</li><li><code>remove</code> 移除列表中某个值的第一个匹配项</li><li><code>reverse</code> 反向列表</li><li><code>sort</code> 对列表中元素进行排序</li><li><code>clear</code> 清空列表</li><li><code>copy</code> 复制列表</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">l[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">ll = l + l</span><br><span class="line"><span class="built_in">print</span>(ll)</span><br><span class="line"></span><br><span class="line">l_l = [l, l]</span><br><span class="line"><span class="built_in">print</span>(l_l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">l1 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">l2 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">l3 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(operator.eq(l1, l2))</span><br><span class="line"><span class="built_in">print</span>(operator.eq(l2, l3))</span><br><span class="line"></span><br><span class="line">l.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l.count(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">l.extend(l1)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l.index(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">l.insert(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">l.pop()</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">l.remove(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">l.reverse()</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">l.sort()</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">l1 = l.copy()</span><br><span class="line"><span class="built_in">print</span>(l1)</span><br><span class="line"></span><br><span class="line">l.clear()</span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><ul><li><code>capitalize</code> 将字符串第一个字符转为大写</li><li><code>center</code> 返回一个指定宽度的字符串，其中间部分为调用函数的字符串，两边用第二个参数填充（字符）</li><li><code>count</code> 返回一个字符串出现的次数，能指定范围</li><li><code>bytes.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</code> Python3 中没有 <code>decode</code> 方法，可以使用 <code>bytes</code> 对象的 <code>decode()</code> 方法来解码给定的 <code>bytes</code> 对象，这个 <code>bytes</code> 对象可以由 <code>str.encode()</code> 来编码返回。</li><li><code>encode(encoding=&#39;UTF-8&#39;,errors=&#39;strict&#39;)</code> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</li><li><code>endswith(suffix, beg=0, end=len(string))</code> 检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False。</li><li><code>expandtabs(tabsize=8)</code> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8</li><li><code>find(str, beg=0, end=len(string))</code> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</li><li><code>index(str, beg=0, end=len(string))</code> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</li><li><code>isalnum()</code> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</li><li><code>isalpha()</code> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</li><li><code>isdigit()</code> 如果字符串只包含数字则返回 True 否则返回 False..</li><li><code>islower()</code> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</li><li><code>isnumeric()</code> 如果字符串中只包含数字字符，则返回 True，否则返回 False</li><li><code>isspace()</code> 如果字符串中只包含空白，则返回 True，否则返回 False.</li><li><code>istitle()</code> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</li><li><code>isupper()</code> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</li><li><code>join(seq)</code> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</li><li><code>len(string)</code> 返回字符串长度</li><li><code>ljust(width[, fillchar])</code> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</li><li><code>lower()</code> 转换字符串中所有大写字符为小写.</li><li><code>lstrip()</code> 截掉字符串左边的空格或指定字符。</li><li><code>maketrans()</code> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</li><li><code>max(str)</code> 返回字符串 str 中最大的字母。</li><li><code>min(str)</code> 返回字符串 str 中最小的字母。</li><li><code>replace(old, new [, max])</code> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</li><li><code>rfind(str, beg=0,end=len(string))</code> 类似于 find()函数，不过是从右边开始查找.</li><li><code>rindex( str, beg=0, end=len(string))</code> 类似于 index()，不过是从右边开始.</li><li><code>rjust(width,[, fillchar])</code> 返回一个原字符串右对齐,并使用 <code>fillchar(默认空格)</code> 填充至长度 width 的新字符串</li><li><code>rstrip()</code> 删除字符串末尾的空格或指定字符。</li><li><code>split(str=&quot;&quot;, num=string.count(str))</code> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</li><li><code>splitlines([keepends])</code> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</li><li><code>startswith(substr, beg=0,end=len(string))</code> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</li><li><code>strip([chars])</code> 在字符串上执行 lstrip()和 rstrip()</li><li><code>swapcase()</code> 将字符串中大写转换为小写，小写转换为大写</li><li><code>title()</code> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写</li><li><code>translate(table, deletechars=&quot;&quot;)</code> 根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</li><li><code>upper()</code> 转换字符串中的小写字母为大写</li><li><code>zfill (width)</code> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</li><li><code>isdecimal()</code> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组中的内容是不可变的</p><h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>使用小括号创建，要特别注意 0 或 1 个元素的元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t = (<span class="number">1</span>, )</span><br><span class="line">t = <span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure><h3 id="访问修改"><a href="#访问修改" class="headerlink" title="访问修改"></a>访问修改</h3><p>类似于列表的访问，直接使用中括号访问，直接赋值即可修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>元组不允许删除单个元素，只能删除整个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> t</span><br></pre></td></tr></table></figure><p>删除后再使用会报错</p><h3 id="内部函数-1"><a href="#内部函数-1" class="headerlink" title="内部函数"></a>内部函数</h3><ul><li><code>len</code> 获取元组元素个数</li><li><code>max</code> 获取元组中元素最大值</li><li><code>min</code> 获取元组元素最小值</li><li><code>tuple</code> 将可迭代系列转为元组</li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用大括号创建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d = &#123;key : val&#125;</span><br></pre></td></tr></table></figure><h3 id="访问修改-1"><a href="#访问修改-1" class="headerlink" title="访问修改"></a>访问修改</h3><p>把相应的键放入到方括号中来访问字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val = d[key]</span><br><span class="line">d[key] = val1</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>使用大括号创建，元素之间用逗号分隔，也可以使用函数创建集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, ...&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>add()</code> 为集合添加元素</li><li><code>clear()</code> 移除集合中的所有元素</li><li><code>copy()</code> 拷贝一个集合</li><li><code>difference()</code> 返回多个集合的差集</li><li><code>difference_update()</code> 移除集合中的元素，该元素在指定的集合也存在。</li><li><code>discard()</code> 删除集合中指定的元素</li><li><code>intersection()</code> 返回集合的交集</li><li><code>intersection_update()</code> 返回集合的交集。</li><li><code>isdisjoint()</code> 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</li><li><code>issubset()</code> 判断指定集合是否为该方法参数集合的子集。</li><li><code>issuperset()</code> 判断该方法的参数集合是否为指定集合的子集</li><li><code>pop()</code> 随机移除元素</li><li><code>remove()</code> 移除指定元素</li><li><code>symmetric_difference()</code> 返回两个集合中不重复的元素集合。</li><li><code>symmetric_difference_update()</code> 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</li><li><code>union()</code> 返回两个集合的并集</li><li><code>update()</code> 给集合添加元素</li><li><code>len()</code> 计算集合元素个数</li></ul><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p>默认情况下python的编码格式为 <code>UTF-8</code> ，所有字符串都是 <code>unicode</code> 字符串</p><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>可以通过下列指令查看当前 python 的所有保留字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyboard</span><br><span class="line">keyboard.kwlist</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以 <code>#</code> 开头</p><h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>在 python 中，通过缩进来表示代码块，所以 python 是缩进敏感的，缩进的长度是可变的，但是对于同一个代码块，缩进需要是相同的长度</p><p>python 中可以通过 <code>\</code> 来实现多行语句，在括号中的多行语句不需要使用反斜杠</p><h2 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>在同一行中使用多条语句，语句之间使用分号分割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h2><p>在 <code>print</code> 中的输出默认是换行的，如果要实现不换行，需要在打印的内容之后加上 <code>end=&quot; &quot;</code></p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在 python 中使用 <code>import</code> 或者是 <code>from...import</code> 来导入相应的模块</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>有两种表达形式</p><h3 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1:</span><br><span class="line"> <span class="built_in">print</span>(condition1)</span><br><span class="line"><span class="keyword">elif</span> condition2:</span><br><span class="line"> <span class="built_in">print</span>(condition2)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> <span class="built_in">print</span>(condition3)</span><br></pre></td></tr></table></figure><h3 id="match-case语句"><a href="#match-case语句" class="headerlink" title="match-case语句"></a>match-case语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> status:</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"> <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"> <span class="keyword">case</span> _:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;default&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><code>while</code> 循环语句有两种表达形式，一般形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line"> command</span><br></pre></td></tr></table></figure><p><code>while-else</code> 形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line"> command</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> command_else</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for</code> 循环有两种表达形式，一般形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line"> command</span><br></pre></td></tr></table></figure><p><code>for-else</code> 形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line"> command</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> command-<span class="keyword">else</span></span><br></pre></td></tr></table></figure><p>其中的 <code>items</code> 可以使用 <code>range()</code> 语句来实现类似于 C 语言中循环的效果</p><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>格式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br></pre></td></tr></table></figure><p>或者可以添加判断条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p>其中 <code>if condition</code> 可以过滤掉列表中不符合条件的值</p><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">dict_sqrt = &#123;key : sqrt(key) <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">list</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &#123; i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>)&#125;</span><br></pre></td></tr></table></figure><h3 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> condition )</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是 Python 最强大的功能之一，是访问元素集合的一种方式。迭代器是可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退</p><ul><li><p><code>iter()</code> 使用这个函数创建对应变量的迭代器</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"> <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure></li><li><p><code>next()</code> 使用该函数用于从集合的第一个元素向后不断地访问，只能前进，不能后退，相当于一个迭代器就是一个数组，每运行一次从中取出一个元素，一直到取完为止。对于上述的代码可以写作</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> <span class="keyword">try</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"> <span class="keyword">except</span> StopIteration:</span><br><span class="line">  sys.exit()</span><br></pre></td></tr></table></figure></li></ul><p><strong>创建迭代器类</strong></p><p>创建一个类作为迭代器需要在类中实现两个方法</p><ul><li><code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>next()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成</li><li><code>__next__()</code> 返回下一个迭代器的对象</li><li><code>StopIteration</code> 该异常用于标识迭代的完成，防止出现无限循环的情况。可以在 <code>__next__()</code> 方法中我们设置在完成指定循环次数之后就触发该异常来结束迭代</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mynumber</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> self.a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器函数。是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次返回所有结果，调用一个生成器函数，返回的是一个迭代器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">yield</span> n</span><br><span class="line">    n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">generator = count(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(generator))</span><br><span class="line">  <span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>python 中使用 <code>lambda</code> 关键字来创建匿名函数。 <code>lambda</code> 可以具有任意数量的参数，但只能有一个表达式，不需要使用 <code>def</code> 来定义完整的函数。用于编写简单的单行的函数</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><code>lambda</code> 函数是匿名的，没有函数名称</li><li><code>lambda</code> 通常只包含一行代码，适用于编写简单的函数</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> a, b : a + b</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = func(a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>是 python 中的一个高级功能，允许动态的修改函数或类的行为。是一种函数，接收一个函数作为参数，并且返回一个新的函数或修改原来的函数，修饰器语法使用 <code>@decorator_name</code> 来应用在函数或者方法上</p><p>python 中有一些内置装饰器可定义静态方法和类方法： <code>@staticmethod</code> 和 <code>@classmethod</code></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>允许在不修改原函数代码的基础上，动态的增加或修改函数的功能，装饰器本质上是一个接收函数作为输入并返回一个新的包装过后的函数的对象</p><p>当一个函数使用 <code>@decorator_name</code> 进行修饰时，会在函数生成之前就把该函数作为参数写入装饰器函数中，相当于一开始就是生成的就是最新的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">old_func</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_func</span>(<span class="params">oldfunc</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">newfunc</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">sum</span> = oldfunc(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> newfunc</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(old_func(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">new_func = decorator_func(old_func)</span><br><span class="line"><span class="built_in">print</span>(new_func(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">a, b, c</span>):</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>可以在函数的修饰装饰器后添加参数，并且在定义装饰器函数时需要外嵌一层用于获取参数，可以将这个参数在函数内使用，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">decorator_func1</span>(<span class="params">oldfunc</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">newfunc</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">      <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">sum</span> += oldfunc(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">return</span> newfunc</span><br><span class="line">  <span class="keyword">return</span> decorator_func1</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add3</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add3(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>生成一个装饰器类需要在函数内实现 <code>__call__</code> 方法，这个类接收一个函数作为参数，并且返回一个新的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorClass</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">    self.func = func</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">    result = self.func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> result + <span class="number">1</span></span><br><span class="line"><span class="meta">@DecoratorClass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add4</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>python 中可以把一些定义存放在其它文件夹中，然后导入该文件，这个文件被称为模块。但是需要注意的是，自己的文件名一定不能与第三方库的文件名一致，不然会有冲突错误</p><p>使用 <code>import</code> 语句导入模块，并且可以导入多个模块，语法为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2, ...]</span><br></pre></td></tr></table></figure><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><ol><li>命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间当中</li><li>每一个作用域都会有一个它对应的命名空间</li><li>全局命名空间，用来保存全局变量。函数命名空间用来保存函数中的变量</li><li>命名空间实际上就是一个字典，是一个专门用来存储变量的字典</li></ol><h3 id="locals"><a href="#locals" class="headerlink" title="locals()"></a>locals()</h3><p>获取当前作用域的命名空间</p><ol><li>在全局作用域中调用locals()则获取-全局命名空间</li><li>在函数作用域中调用locals()则获取-函数命名空间</li><li>它返回的是一个字典</li></ol><h3 id="globals"><a href="#globals" class="headerlink" title="globals()"></a>globals()</h3><p>可以用来在任意位置获取全局命名空间</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>使用 <code>open()</code> 函数来打开函数，语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>file</code> 必需，文件路径（相对或者绝对路径）</li><li><code>mode</code> 可选，文件打开模式</li><li><code>buffering</code> 设置缓冲</li><li><code>encoding</code> 一般使用utf8</li><li><code>errors</code> 报错级别</li><li><code>newline</code> 区分换行符</li><li><code>closefd</code> 传入的file参数类型</li><li><code>opener</code> 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符</li></ul><p>其中 <code>mode</code> 的参数有</p><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>文本模式 (默认)。</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td>b</td><td>二进制模式。</td></tr><tr><td>+</td><td>打开一个文件进行更新(可读可写)。</td></tr><tr><td>U</td><td>通用换行模式（Python 3 不支持）。</td></tr><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table></div><p>默认为文本模式，如果要以二进制模式打开，需要在对应的模式之后加上 <code>b</code></p><h3 id="文件方法"><a href="#文件方法" class="headerlink" title="文件方法"></a>文件方法</h3><ul><li><code>file.close()</code> 关闭文件。关闭后文件不能再进行读写操作</li><li><code>file.flush()</code> 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入</li><li><code>file.fileno()</code> 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如 <code>os</code> 模块的 <code>read</code> 方法等一些底层操作上</li><li><code>file.isatty()</code> 如果文件连接到一个终端设备返回 <code>True</code> ，否则返回 <code>False</code></li><li><code>file.next()</code> 返回文件下一行</li><li><code>file.read([size])</code> 从文件读取指定的字节数，如果未给定或为负则读取所有</li><li><code>file.readline([size])</code> 读取整行，包括 <code>\n</code> 字符</li><li><code>file.readlines([sizeint])</code> 读取所有行并返回列表，若给定 <code>sizeint&gt;0</code> ，返回总和大约为 <code>sizeint</code> 字节的行, 实际读取值可能比 <code>sizeint</code> 较大, 因为需要填充缓冲区</li><li><code>file.seek(offset[, whence])</code> 移动文件读取指针到指定位置</li><li><code>file.tell()</code> 返回文件当前位置</li><li><code>file.truncate([size])</code> 从文件的首行首字符开始截断，截断文件为 <code>size</code> 个字符，无 <code>size</code> 表示从当前位置截断。截断之后后面的所有字符被删除，其中 <code>windows</code> 系统下的换行代表2个字符大小</li><li><code>file.write(str)</code> 将字符串写入文件，返回的是写入的字符长度</li><li><code>file.writelines(sequence)</code> 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。在 Python 中，使用 <code>re</code> 模块来处理正则表达式。 <code>re</code> 模块提供了一组函数，允许在字符串中进行模式匹配、搜索和替换操作</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a><strong>re.match</strong></h3><p>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话， <code>match()</code> 就返回 <code>None</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(pattern, string, flags = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>pattern</code> 匹配的正则表达式</li><li><code>string</code> 要匹配的字符串</li><li><code>flags</code> 标志位，用于控制正则表达式的匹配方式</li></ul><p>可以使用 <code>group(num)</code> 或者 <code>groups()</code> 匹配对象函数来获取匹配表达式</p><ul><li><code>group(num=0)</code> 匹配的整个表达式的字符串， <code>group()</code> 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组</li><li><code>groups()</code> 返回一个包含所有小组字符串的元组，从 1 到所有的小组号</li></ul><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a><strong>re.search</strong></h3><p>用于扫描整个字符串，返回第一个成功匹配的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数与上述 <code>match</code> 一致</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>re.match</code> 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 <code>None</code> ，而 <code>re.search</code> 匹配整个字符串，直到找到一个匹配</p><h3 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h3><p>使用 <code>re.sub</code> 函数来替换字符串中的匹配项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count = <span class="number">0</span>, flags = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>pattern</code> : 正则中的模式字符串，必选</li><li><code>repl</code> : 替换的字符串，也可为一个函数，必选</li><li><code>string</code> : 要被查找替换的原始字符串，必选</li><li><code>count</code> : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配，可选</li><li><code>flags</code> : 编译时用的匹配模式，数字形式，可选</li></ul><p><strong>repl 函数</strong></p><p>可以传入参数，调用时默认传入参数就是祖匹配的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">matched</span>):</span><br><span class="line">    value = <span class="built_in">int</span>(matched.group(<span class="string">&#x27;value&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(value * <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">s = <span class="string">&#x27;A23G4HFD567&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, double, s))</span><br></pre></td></tr></table></figure><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 <code>match()</code> 和 <code>search()</code> 这两个函数使用。语法格式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(pattern[, flags])</span><br></pre></td></tr></table></figure><ul><li><code>pattern</code> : 一个字符串形式的正则表达式</li><li><code>flags</code> 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：<ul><li><code>re.IGNORECASE</code> 或 <code>re.I</code> 使匹配对大小写不敏感</li><li><code>re.L</code> 表示特殊字符集 <code>\w, \W, \b, \B, \s, \S</code> 依赖于当前环境</li><li><code>re.MULTILINE</code> 或 <code>re.M</code> 多行模式，改变 <code>^</code> 和 <code>$</code> 的行为，使它们匹配字符串的每一行的开头和结尾</li><li><code>re.DOTALL</code> 或 <code>re.S</code> 使 <code>.</code> 匹配包括换行符在内的任意字符</li><li><code>re.ASCII</code> 使 <code>\w, \W, \b, \B, \d, \D, \s, \S</code> 仅匹配 ASCII 字符</li><li><code>re.VERBOSE</code> 或 <code>re.X</code> 忽略空格和注释，可以更清晰地组织复杂的正则表达式</li><li>这些标志可以单独使用，也可以通过按位或 <code>|</code> 组合使用</li></ul></li></ul><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表，有两种表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.findall(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">pattern.findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>pattern</code> 匹配模式</li><li><code>string</code> 待匹配的字符串</li><li><code>pos</code> 可选参数，指定字符串的起始位置，默认为 0</li><li><code>endpos</code> 可选参数，指定字符串的结束位置，默认为字符串的长度</li></ul><h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a><strong>re.finditer</strong></h3><p>和 <code>findall</code> 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.finditer(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>pattern</code> 匹配的正则表达式</li><li><code>string</code> 要匹配的字符串。</li><li><code>flags</code> 标志位，用于控制正则表达式的匹配方式</li></ul><h3 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h3><p>按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li><code>pattern</code> 匹配的正则表达式</li><li><code>string</code> 要匹配的字符串</li><li><code>maxsplit</code> 分割次数，默认为 0，表示不限制次数。</li><li><code>flags</code> 标志位，用于控制正则表达式的匹配方式</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>正则表达式太多了，也很复杂，可以看看这个，讲的还是挺全的</p><p><a href="https://www.runoob.com/python3/python3-reg-expressions.html">Python3 正则表达式 | 菜鸟教程 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verilog基础语法</title>
      <link href="/Blog_ButterFly/2024/04/16/verilog%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/Blog_ButterFly/2024/04/16/verilog%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一种计算机硬件语言，是可以模拟计算机的一种仿真语言，语法上与 C 语言相似。本文主要是笔者为了学习《计算机组成原理》而去了解的一种语言</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>Verilog</code> 是一种硬件描述语言，用于数字电路的系统设计。可对算法级、门级、开关级等多种抽象设计层次进行建模</p><p>继承了C语言的多种操作符和结构，与另一种硬件描述语言 VHDL 相比，语法不是很严格，代码更加简洁，更容易上手</p><p><code>Verilog</code> 不仅定义了语法，还对语法结构都定义了清晰的仿真语义。因此， <code>Verilog</code> 编写的数字模型就能够使用 <code>Verilog</code> 仿真器进行验证</p><h3 id="Verilog-环境搭配"><a href="#Verilog-环境搭配" class="headerlink" title="Verilog 环境搭配"></a>Verilog 环境搭配</h3><p>在终端使用指令来安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install iverilog</span><br></pre></td></tr></table></figure><h3 id="配置-vscode"><a href="#配置-vscode" class="headerlink" title="配置 vscode"></a>配置 vscode</h3><p>安装插件</p><ul><li><code>waveTrace</code> 插件</li><li><code>verilog-HDL</code> 插件</li><li><code>Verilog Format</code> 插件</li></ul><p>配置</p><ol><li>在 <code>linux</code> 上安装 <code>ctags</code></li><li>找到 <code>ctags</code> 的安装路径，将其添加到 <code>vscode</code> 的设置 <code>Verilog&gt;ctags:Path</code> 中</li><li>将 <code>vscode</code> 中设置的 <code>Verilog&gt;linting:Liner</code> 设置为 <code>iverilog</code></li><li>在 <code>vscode</code> 的设置 <code>verilog&gt;linting&gt;iverilog:Arguments</code> 中填入 <code>-i</code> ，然后就配置完成了</li></ol><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>对于 <code>verilog</code> 语言，文件的后缀是 <code>.v</code> ，并且需要专有的编译器来进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iverilog xxx.v</span><br></pre></td></tr></table></figure><p>编译结束之后，会生成 <code>a.out</code> 文件，可以使用指令来指定输出的文件名称的。然后在终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>来运行</p><h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><p><code>Verilog</code> 采取从上到下的设计方法。需要先定义顶层模块功能，进而分析要构成顶层模块的必要子模块，然后进一步对各个模块进行分解设计，直到到达无法进一步分解的底层功能块。可以把一个较大的系统，细化为多个小系统</p><p><img src="/Blog_ButterFly/2024/04/16/verilog%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/vlg-design-method-1.png" alt="vlg-design-method-1.png"></p><h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><p>与 C 语言不同的是， <code>verilog</code> 使用 <code>` </code>（反引号）来代替了 C 语言中的 <code>#</code></p><ul><li><code>`define</code> 定义</li><li><code>`undef</code> 取消定义</li><li><code>`ifdef</code> 判断是否定义</li><li><code>`ifndef</code> 判断是否未定义</li><li><code>`include</code> 包含某个模块/文件</li><li><p><code>`timescale</code> 将时间单位与实际时间相关联。该指令用于定义时延、仿真的单位和精度，格式如下</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> time_unit / time_precision</span></span><br></pre></td></tr></table></figure><p>  其中</p><ul><li><code>time_unit</code> 表示时间的单位，由数字以及单位组成（s, ms, us, ns, ps, fs）。但是时间精度大小不能超过时间单位大小</li><li><code>time_precision</code> 表示时间的精度</li></ul></li><li><p><code>`default_nettype</code> 该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型，用法如下</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">default_nettype</span> wand </span></span><br></pre></td></tr></table></figure></li><li><p><code>resetall` 该编译器指令将所有的编译指令重新设置为缺省值，可以使得缺省连线类型为线网类型。加到模块最后时，可以将当前的 **</code>**timescale<code>取消防止进一步传递，只保证当前的 ``timescale</code> 在局部有效，避免 <code>`timescale</code> 的错误继承。</p></li><li><code>`celldefine</code> 将模块标记为单元模块，他们包含模块的定义</li><li><code>`endcelldefine</code> 结束单元模块</li><li><code>`unconnected_drive, **</code>**nounconnected_drive` 出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型总的上分两类</p><ul><li>线网类 <code>net</code> 类<ul><li><code>wire</code> 线型——最常用</li><li><code>wand</code> 线与</li><li><code>wor</code> 线或</li><li><code>tri</code> 三态</li><li><code>triand</code> 三态与</li><li><code>trior</code> 三态或</li><li><code>tri0</code> 下拉电阻</li><li><code>tri1</code> 上拉电阻</li><li><code>trireg</code> 电容性电网</li><li><code>supply0</code> 地</li><li><code>supply1</code> 电源</li></ul></li><li>变量类 <code>variable</code> 类<ul><li><code>reg</code> 寄存器类型——最常用</li><li><code>integer</code> 整型</li><li><code>real</code> 实型</li><li><code>time</code> 时间型</li><li><code>realtime</code> 实时时间型</li></ul></li></ul><p>因为连续赋值语句和过程赋值语句的激活特点不同，故而赋值目标特点也不同。前者不需要保存，后者需要保存，因此规定两种数据类型。 <code>net</code> 类用于连续赋值目标或者门原语的输出，且仿真时不需分配内存空间， <code>variable</code> 类用于过程赋值语句，且仿真时需要分配内存空间</p><p>将一个信号定义为 <code>net</code> 类型还是 <code>varibke</code> 类型，由以下两个方面决定</p><p><img src="/Blog_ButterFly/2024/04/16/verilog%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1713198541998.png" alt="1713198541998.png"></p><ol><li>对于端口信号来说， <code>input</code> 信号和 <code>inout</code> 信号必须定义为 <code>net</code> 类型的，而 <code>output</code> 信号可以是 <code>net</code> 类型也可以是 <code>varible</code> 类型，取决于如何赋值</li><li>使用何种赋值语句对该信号进行赋值。如果是连续赋值或者门原语句赋值或例化语句赋值，则定义为 <code>net</code> 型，如果是过程赋值则定义成 <code>varible</code> 型</li></ol><h3 id="线网wire"><a href="#线网wire" class="headerlink" title="线网wire"></a>线网wire</h3><p>表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动，如果没有驱动元件连接到线网类型，缺省一般为 <code>z</code></p><p>线网型还有其他数据类型，包括 <code>wand</code> ， <code>wor</code> ， <code>wri</code> ， <code>triand</code> ， <code>trior</code> ， <code>trireg</code> 等。这些数据类型用的频率不是很高</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> interput;</span><br></pre></td></tr></table></figure><h3 id="寄存器reg"><a href="#寄存器reg" class="headerlink" title="寄存器reg"></a>寄存器reg</h3><p>用来表示存储单元，会保持数据原有的值，直到被改写</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ref</span> rax;</span><br></pre></td></tr></table></figure><p>在 <code>always</code> 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 <code>wire</code> 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> rstn ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  rstn = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  #<span class="number">100</span>;</span><br><span class="line">  rstn = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>当位款大于 1 时， <code>wire</code> 或者 <code>reg</code> 可以声明为向量的形式，声明的形式为 <code>type[end:begin]</code> 其中是包含 <code>end</code> 和 <code>begin</code> 位的</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] num;    <span class="comment">//声明 8 位宽的寄存器 num</span></span><br></pre></td></tr></table></figure><p>对于上面的向量，我们可以指定某一位或若干相邻位，作为其他逻辑使用，使用的形式为 <code>data[begin:end]</code> 其中是包含 <code>end</code> 和 <code>begin</code> 位的</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">9</span>:<span class="number">0</span>] data_low = data[<span class="number">0</span>:<span class="number">9</span>] ;</span><br><span class="line">addr_temp[<span class="number">3</span>:<span class="number">2</span>] = addr[<span class="number">8</span>:<span class="number">7</span>] + <span class="number">1&#x27;b1</span> ;</span><br></pre></td></tr></table></figure><p><code>verilog</code> 支持指定位之后固定位宽的向量域选择访问</p><ul><li><code>[bit+:width]</code> 从起始 <code>bit</code> 位开始递增，位宽为 <code>width</code></li><li><code>[bit-:width]</code> 从起始 <code>bit</code> 开始递减，位宽为 <code>width</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = data1[<span class="number">31</span>-: <span class="number">8</span>] <span class="comment">// == data1[31, 24]</span></span><br><span class="line">a = data1[<span class="number">24</span>+: <span class="number">8</span>] <span class="comment">// == data1[31, 24]</span></span><br></pre></td></tr></table></figure><p>信号可以重新组合成新的向量，需要使用大括号</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>[<span class="number">31</span>: <span class="number">0</span>] data1, data2;</span><br><span class="line"><span class="keyword">assign</span> data1 = &#123;byte1[<span class="number">0</span>][<span class="number">7</span>: <span class="number">0</span>], data1[<span class="number">31</span>: <span class="number">8</span>]&#125;; <span class="comment">// 数据拼接</span></span><br><span class="line"><span class="keyword">assign</span> data2 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>使用 <code>integer</code> 表示。声明时不用指明位宽，位宽和编译器有关，一般为 <code>32bit</code>。 与 <code>reg</code> 的区别在于： <code>reg</code> 型变量为无符号数，而 <code>integer</code> 型变量为有符号数</p><p><code>integer</code> 可用来作为辅助信号</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> j;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; j = j + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="整数数值格式"><a href="#整数数值格式" class="headerlink" title="整数数值格式"></a>整数数值格式</h3><p>合法的数值格式有 4 种，包括十进制（d或D），十六进制（h或H），二进制（b或B），八进制（o或O），默认为十进制数据。数值可指明位宽，也可不指明</p><ul><li><p>无符号数表示格式为</p><blockquote><p>&lt;位宽&gt;’&lt;进制&gt;&lt;数字&gt;</p></blockquote></li><li><p>有符号数表示格式为，是用补码格式来表示的</p><blockquote><p>&lt;位宽&gt;’s&lt;进制&gt;&lt;数字&gt;</p></blockquote></li></ul><p>在数字的进制格式之前添加 <code>n&#39;</code> 来指明是 <code>n</code> 位的数据，其中可以在每八位中间添加下划线，以此来增强代码可读性</p><p>如果不指明位宽，一般会根据编译器自动分频位宽，常见的为 <code>32bit</code> ，通常在数值前加符号表示负号</p><p>可以使用实数表示，也就是用小数表示，可以使用科学计数法。</p><h3 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h3><p> 使用 <code>real</code> 来声明，可用十进制或者科学计数法表示，实数声明不能带有范围，默认位 0 ，如果实数数据赋值给整数，会将数据截断</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> data1;</span><br><span class="line"><span class="keyword">integer</span> data2;</span><br><span class="line">...</span><br><span class="line">data1 = <span class="number">1</span>e3;</span><br><span class="line">data1 = <span class="number">12</span><span class="variable">.13</span>;</span><br><span class="line">data2 = data1; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p><code>verilog</code> 使用特殊的时间寄存器 <code>time</code> 型变量，对仿真时间进行保存。宽度一般为 64 位，通过条用系统函数 <code>$time</code> 获取当前仿真时间</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span> current;</span><br><span class="line">...</span><br><span class="line">current = <span class="built_in">$time</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 <code>Verilog</code> 中允许声明 <code>reg</code> <code>wire</code> <code>integer</code> <code>time</code> <code>real</code> 及其向量类型的数组，数组中的每个元素都可以作为一个标量或者向量，以用样的方式来使用</p><p>声明的形式为 <code>data[end:begin]</code> 其中是包含 <code>end</code> 和 <code>begin</code> 的</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> num[<span class="number">7</span>:<span class="number">0</span>]</span><br><span class="line">num[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器变量就是一种寄存器数组，可用来描述 <code>RAM</code> 或 <code>ROM</code> 的行为，使用 <code>reg</code> 变量来声明</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> membit[<span class="number">0</span>: <span class="number">255</span>];</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] mem[<span class="number">0</span>: <span class="number">1023</span>]</span><br><span class="line">mem[<span class="number">511</span>] = <span class="number">8&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数用来表示常量，用关键字 <code>parameter</code> 声明，只能赋值一次</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> data = <span class="number">32</span>‘<span class="number">8</span>bbb_bbbb;</span><br></pre></td></tr></table></figure><p>当参数只在某个模块内调用，需要使用 <code>localparameter</code> 来声明</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串保存在 <code>reg</code> 类型中，每个字符占一个字节，所以寄存器变量的宽度应该足够大以不至于溢出</p><p>字符串是使用双引号包起来的字符队列，字符串不能多行书写，也不能包含回车符。实际上是把字符串作为字符的队列</p><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>有四种基本的值来表示硬件电路中的电平逻辑</p><ul><li>0：逻辑 0 或者假</li><li>1：逻辑 1 或者真</li><li>x 或 X：未知，意味着信号数值不确定，即在实际电路里，信号可能为 1，也可能为 0</li><li>z 或 Z：高阻，意味着信号处于高阻状态，常见于信号（input, reg）没有驱动时的逻辑结果。例如一个 <code>pad</code> 的 <code>input</code> 呈现高阻状态时，其逻辑值和上下拉的状态有关系。上拉则逻辑值为 1，下拉则为 0</li></ul><h3 id="逻辑值"><a href="#逻辑值" class="headerlink" title="逻辑值"></a>逻辑值</h3><ul><li><code>1</code> 逻辑 1，高电平，数字 1</li><li><code>0</code> 逻辑 0，低电平，数字 0</li><li><code>x</code> 不确定</li><li><code>z</code> 高阻态</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用 <code>//</code> 进行单行注释，使用 <code>/**/</code> 进行多行注释</p><h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><p>标识符（identifier）可以是任意一组字母，数字， <strong>$$`</strong> 符号和 <strong><code>_</code></strong> (下划线)符号的组合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者 `$$ 符开始。标识符是大小写敏感的。</p><p>关键字是 <code>verilog</code> 中预留的一些特殊标识符，关键字全部为小写</p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul><li><code>if(condition)...</code></li><li><code>if(condition)...else...</code></li><li><code>if(condition1)...else if(condition2)...</code></li><li><code>if(condition1)...else if(condition2)...else...</code></li></ul><p>需要注意的是，在使用 <code>if</code> 语句设计组合电路时，如果条件不完整，会综合出寄存器，有两种使条件完整的方法</p><ol><li>加 <code>else</code></li><li>设定初始值</li></ol><p>计算表达式 <code>condition</code> 可以是任意形式的表达式，条件表达式的结果只有 0 或 1，如果计算表达式的结果为 0，则条件表达式的值为 0，否则为 1</p><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><p>格式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line"><span class="number">1</span>: ...;</span><br><span class="line"><span class="number">2</span>: ...;</span><br><span class="line"><span class="keyword">default</span>:...</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure><p>与 C 语言类似，同时也可以没有 <code>default</code> 语句</p><h3 id="描述方式"><a href="#描述方式" class="headerlink" title="描述方式"></a>描述方式</h3><ul><li>结构化描述，全部用门原语和底层模块调用</li><li>数据流级描述，全部使用 <code>assign</code> 语句</li><li>行为级描述，全部使用 <code>always</code> 语句配合 <code>if</code> 和 <code>case</code> 语句</li><li>RTL 级别描述方式，数据流级+行为级，可综合</li></ul><p>而实际的描述是三种混合的</p><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><ul><li><p><code>$display</code> 使用方法和 C 语言中的 printf 函数非常类似，可以直接打印字符串，也可以在字符串中指定变量的格式对相关变量进行打印。如果没有指定变量的显示格式，变量值会根据在字符串的位置显示出来，相当于参与了字符串连接。</p><p>  如果没有指定格式，$display 默认显示是十进制。$displayb, $displayo, $displayh 显示格式分别为二进制、八进制、十六进制。同理也有 $writeb, $writeo, $writeh, $strobeb 等。</p><p>  下表是常用的格式说明</p></li><li><p><code>$write</code></p></li><li><code>$strobe</code></li><li><code>$monitor</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;This is a test.&quot;</span>);   <span class="comment">//直接打印字符串</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;This is a test number: %b.&quot;</span>, num); <span class="comment">//打印变量 num 为二进制格式</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;This is a test number: &quot;</span>, num, <span class="string">&quot;!!!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>连续赋值延时语句中的延时，用于控制任意操作数发生变化到语句左端赋予新值之间的时间延时，时延一般是不可综合的，寄存器的时延也是可以控制的，连续赋值时延分为三种</p><ul><li><p>普通赋值时延</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Z, A, B;</span><br><span class="line"><span class="keyword">assign</span> #<span class="number">10</span> Z = A &amp; B;</span><br></pre></td></tr></table></figure></li><li><p>隐式时延</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> A, B;</span><br><span class="line"><span class="keyword">wire</span> #<span class="number">10</span> Z = A &amp; B;</span><br></pre></td></tr></table></figure></li><li><p>声明时延</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> A, B;</span><br><span class="line"><span class="keyword">wire</span> #<span class="number">10</span> Z;</span><br><span class="line"><span class="keyword">assign</span> Z = A &amp; B;</span><br></pre></td></tr></table></figure></li></ul><p><strong>惯性时延</strong></p><p>对于上述的代码，当在延时的过程中， <code>A</code> 和 <code>B</code> 的值又发生了一次变化，那么计算的新值 <code>Z</code> 会取最新的 <code>A</code> 和 <code>B</code> 进行计算</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式由操作数和操作符构成，目的是根据操作符的意义得到一个计算结果，表达式可以在出现数值的任何地方使用，由于很多语法是与 C 语言几乎一致的，所以这里就只介绍一些没见过的</p><p>需要注意的是， <code>verilog</code> 中的逻辑值有三个状态 <code>0</code> 和 <code>1</code> ， <code>x</code> 。其中 <code>x</code> 就是不确定值</p><h3 id="等价运算符"><a href="#等价运算符" class="headerlink" title="等价运算符"></a>等价运算符</h3><ul><li><code>=</code></li><li><code>!=</code></li><li><code>===</code></li><li><code>!==</code></li></ul><p>对于后两个，它在对操作数进行比较时对某些位的不定值 <code>x</code> 和高阻值 <code>z</code> 也进行比较，两个操作数必需完全一致，其结果才是1，否则为0</p><p>算符常用于 <code>case</code> 表达式的判别,所以又称为”case等式运算符”</p><p>这四个等式运算符的优先级别是相同的</p><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul><li><code>&gt;&gt;</code> 左移</li><li><code>&lt;&lt;</code> 右移</li><li><code>&gt;&gt;&gt;</code> 算术左移</li><li><code>&lt;&lt;&lt;</code> 算术右移</li></ul><p><strong>注意</strong></p><ul><li>移位运算的操作数是一位或者多位二进制数</li><li>向左或者向右移动 <code>n</code> 位</li><li>只有对有符号数的算数右移自动补符号位，其它均补 0</li></ul><h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><ul><li><code>~</code> 按位取反</li><li><code>&amp;</code> 按位与</li><li><code>|</code>  或</li><li><code>^</code> 异或</li><li><code>^~</code> 或者 <code>~^</code> 同或</li></ul><p><strong>注意</strong></p><ol><li>按位运算的操作数是 1 位或者多位二进制数</li><li>如果操作数的位宽不同，位宽小的会自动在左端补 0</li><li>结果与操作数的位宽相同</li></ol><h3 id="缩减运算符"><a href="#缩减运算符" class="headerlink" title="缩减运算符"></a>缩减运算符</h3><ul><li><code>&amp;</code> 与</li><li><code>~&amp;</code> 与非</li><li><code>|</code>  或</li><li><code>~|</code> 或非</li><li><code>^</code> 异或</li><li><code>^~</code> 或者 <code>~^</code> 同或</li></ul><p><strong>注意</strong></p><ol><li>缩减运算符的操作数是 1 位或者多位二进制数</li><li>缩减运算符的操作数只有一个，将该数的各位自左至右进行逻辑运算，结果只有一位</li></ol><h3 id="拼接运算符"><a href="#拼接运算符" class="headerlink" title="拼接运算符"></a>拼接运算符</h3><p>使用 <code>&#123;&#125;</code> 进行运算符的拼接，可以将两个信号接在一起</p><h3 id="拼接复制运算符"><a href="#拼接复制运算符" class="headerlink" title="拼接复制运算符"></a>拼接复制运算符</h3><p>使用 <code>&#123;n&#123;&#125;&#125;</code> 运算符实现</p><p>可以将第二个括号内的操作数复制 <code>n</code> 次然后拼接</p><p>与上述拼接运算符可以组合使用，例如</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="number">2</span>&#123;B, C, D&#125;, E, F&#125;;</span><br></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name(端口列表);</span><br><span class="line">[端口信号声明];</span><br><span class="line">[参数声明];</span><br><span class="line">内部信号声明\底层模块或门源语调用\<span class="keyword">assign</span>语句\<span class="keyword">always</span>语句</span><br><span class="line"><span class="keyword">endmodule</span>;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>端口列表是指电路的输入，输出信号的名称列表，信号名由用户指定，中间用逗号隔开</li><li>端口信号声明是要说明端口信号的输入输出属性，信号的数据类型，以及信号的位宽。输入输出属性有 <code>input</code> ， <code>output</code> ， <code>inout</code> 三种，信号的数据类型通常用 <code>wire</code> 和 <code>reg</code> 两种，信号的位宽用 <code>[begin:end]</code> 表示。同一类信号之间用逗号隔开</li><li>参数声明需要说明参数的名称和初值</li><li>参数声明中，如果位宽不做说明，默认是 1 位</li><li>数据类型不做声明，默认是 <code>wire</code> 类型</li></ul><h3 id="assign语句"><a href="#assign语句" class="headerlink" title="assign语句"></a>assign语句</h3><p><code>assign</code> 语句称作连续赋值语句，基本格式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> dst = src;</span><br></pre></td></tr></table></figure><p>之所是是连续赋值语句，就是因为其总是处于激活状态，一旦 <code>src</code> 表达式中的操作数有更改，就会立即进行计算和赋值</p><p>赋值目标 <code>dst</code> 必须是 <code>wire</code> 类型的，表示电路之间的连线</p><h3 id="always语句块"><a href="#always语句块" class="headerlink" title="always语句块"></a>always语句块</h3><p><code>always</code> 称为过程块，基本格式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(敏感信号条件表)</span><br><span class="line"> 各类顺序语句</span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li><code>always</code> 语句本身不是单一的有意义的一条语句，而是和下面的语句一起构成一个语句块，所以叫做过程块。过程块中的赋值语句就叫做过程赋值语句</li><li>该语句块不是总处于激活的状态的，当满足激活条件才会执行，否则被挂起，挂起时该语句块不执行</li><li>赋值目标必须是 <code>reg</code> 类型的</li><li>激活条件由敏感信号条件表决定的，当敏感条件满足时，过程块激活。其中敏感条件有两种<ul><li>边沿敏感：<ul><li><code>posedge signalName</code> 信号上升沿到来</li><li><code>negedge signalName</code> 信号下降沿到来</li></ul></li><li>电平敏感<ul><li><code>(signalNameList)</code> 信号列表中任意一个信号有电平变化就会执行代码块，其中信号名之间用逗号或者 <code>or</code> 来隔开</li></ul></li></ul></li><li>在 <code>always</code> 中还可以使用 <code>if</code> ， <code>else</code> ， <code>for</code> 循环等语句</li></ul><h3 id="assign与always的区别"><a href="#assign与always的区别" class="headerlink" title="assign与always的区别"></a>assign与always的区别</h3><ul><li>连续赋值语句总是处于激活状态，只要有操作数变化就马上进行计算和赋值</li><li>过程赋值语句只有当激活该过程时，才会进行计算和赋值，如果该过程不被激活，即使操作数发生变化也不会计算和赋值</li><li><code>verilog</code> 规定 <code>assign</code> 中的赋值目标必须是 <code>wire</code> 类型，而且 <code>always</code> 语句中的赋值目标必须是 <code>reg</code> 类型的</li><li><code>always</code> 中还可以使用 <code>if</code> ， <code>else</code> ， <code>for</code> 循环等语句，但是 <code>assign</code> 不能使用</li><li><code>always</code> 中如果有多条语句必须使用 <code>begin</code> 和 <code>end</code> 包括起来，但是 <code>assign</code> 中没有</li></ul><h3 id="initial语句"><a href="#initial语句" class="headerlink" title="initial语句"></a>initial语句</h3><p>从 0 时刻开始执行，只执行一次，多个 <code>initial</code> 块之间是相互独立的，如果有多条语句，就需要使用 <code>begin</code> 和 <code>end</code> 包括起来。</p><p>理论上讲是不可综合的，多用于初始化和信号检测等， <code>initial</code> 中的语句是顺序执行的</p><h3 id="底层模块的调用"><a href="#底层模块的调用" class="headerlink" title="底层模块的调用"></a>底层模块的调用</h3><p>调用底层模块需要使用 <code>`include &quot;xx.v&quot;</code> 语句来调用，需要将对应的模块实例化，并且调用时实例化名称不能省略</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx a(ports);</span><br></pre></td></tr></table></figure><p>调用底层模块时，需要把对应的端口的输入输出填写，所以就需要端口映射，有两种方法</p><ul><li>端口名关联法（命名法）<ul><li><code>(.底层端口名1(外接信号名1), .底层端口名2(外接信号名2), ...)</code></li><li>不需要按照底层模块信号列表顺序书写</li></ul></li><li>位置关联法（顺序法）<ul><li><code>(外接口信号1, 外接口信号2)</code></li><li>必须严格按照底层模块端口信号列表顺序书写</li></ul></li></ul><h3 id="门原语调用"><a href="#门原语调用" class="headerlink" title="门原语调用"></a>门原语调用</h3><p><code>verilog</code> 中提供了已经设计好的门，称为门原语，一共有 12 个。</p><ol><li>这些门可以直接调用</li><li>与底层模块不一样的地方在于，调用时，实例名可以省略</li><li>端口连接只能采取顺序法，输出在前，输入在后。</li></ol><p><strong>普通门</strong></p><ul><li><code>and</code> 与</li><li><code>or</code> 或</li><li><code>xor</code> 异或</li><li><code>nand</code> 与非</li><li><code>nor</code> 或非</li><li><code>xnor</code> 同或</li></ul><p>使用方式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>(out, in1, in2);</span><br></pre></td></tr></table></figure><p>第一个是输出，其余是输入，系统输入数量不限</p><p><strong>非门和缓冲门</strong></p><ul><li><code>not</code> 非门</li><li><code>buf</code> 缓冲门</li></ul><p>其中使用方式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span>(out1, in);</span><br></pre></td></tr></table></figure><p>前面是输出，最后一个是输入，其中输出的数量不限制</p><p><strong>三态门</strong></p><ul><li><code>bufif1</code> 控制端 1 有效缓冲器</li><li><code>bufif0</code> 控制端 0 有效缓冲器</li><li><code>notif1</code> 控制端 1 有效非门</li><li><code>notif1</code> 控制端 0 有效非门</li></ul><p>使用方式都为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufif b1(out, in, ctrl);</span><br></pre></td></tr></table></figure><p>端口列表中，前面是输出，中间是输入，最后是使能端口，输出个数不限</p><h2 id="阻塞赋值和非阻塞赋值"><a href="#阻塞赋值和非阻塞赋值" class="headerlink" title="阻塞赋值和非阻塞赋值"></a>阻塞赋值和非阻塞赋值</h2><h3 id="阻塞赋值"><a href="#阻塞赋值" class="headerlink" title="阻塞赋值"></a>阻塞赋值</h3><p>使用 <code>=</code> 来表示阻塞赋值运算符，如下的例子</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data1 = a;</span><br><span class="line">data2 = a &amp; data1;</span><br><span class="line">data3 = data1 | data2;</span><br></pre></td></tr></table></figure><p>其中的运行顺序就是</p><ol><li>先计算 <code>a</code> 直接赋值给 <code>data1</code></li><li>计算 <code>a &amp; data1</code> 直接赋值给 <code>data2</code></li><li>计算 <code>data1 | data2</code> 直接赋值给 <code>data3</code></li></ol><h3 id="非阻塞赋值"><a href="#非阻塞赋值" class="headerlink" title="非阻塞赋值"></a>非阻塞赋值</h3><p>使用 <code>&lt;=</code> 来表示非阻塞运算符，对于上述的例子</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data1 &lt;= a;</span><br><span class="line">data2 &lt;= a &amp; data1;</span><br><span class="line">data3 &lt;= data1 | data2;</span><br></pre></td></tr></table></figure><p>其中运行顺序是</p><ol><li>先计算 <code>a</code> 不赋值</li><li>计算 <code>a &amp; data1</code> 不赋值</li><li>计算 <code>data1 | data2</code> 不赋值</li></ol><p>过程结束，然后进行赋值操作</p><ol><li>赋值给 <code>data1</code></li><li>赋值给 <code>data2</code></li><li>赋值给 <code>data3</code></li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>设计组合电路时，常使用阻塞赋值</li><li>设计时序电路时，常使用非阻塞赋值</li><li>但是并不绝对</li><li>不建议在 <code>always</code> 中混合使用阻塞赋值和非阻塞赋值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es基础</title>
      <link href="/Blog_ButterFly/2024/04/11/es%E5%9F%BA%E7%A1%80/"/>
      <url>/Blog_ButterFly/2024/04/11/es%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/Web.git">代码</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>es 与 js 的关系就是，前者是后者的规范，后者是前者的一种实现</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><p>nodejs 的下载安装与一般的软件无异，从官网找到并且下载安装就好</p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>需要使用镜像下载： <a href="https://npmmirror.com/">镜像地址</a></p><p>直接在终端执行下列命令就可完成安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://npmmirror.com/</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h3><p>特点</p><ul><li>声明的变量只在当前的代码块中有效</li><li>不满足变量提升，也就是必须在声明之后使用变量，不然会报错</li><li>不允许重复声明同一个变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 0;</span><br><span class="line">&#125;</span><br><span class="line">a = 1; // 报错</span><br></pre></td></tr></table></figure><h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>特点</p><ul><li>声明之后变量不可改变</li><li>声明时必须初始化</li><li>不满足变量提升，也就是必须在声明之后使用变量，不然会报错</li><li>只在当前的代码块中有效</li><li>不允许重复声明同一个变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = 1;</span><br><span class="line">a = 2; // 报错</span><br></pre></td></tr></table></figure><h3 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h3><p>解构可以用于对象，也可以很方便的将现有的对象的方法赋值到某个变量，对象的顺序没有要求，但是必须与属性同名才能得到正确的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;age, name&#125; = &#123;<span class="attr">name</span>:<span class="string">&quot;1&quot;</span>, <span class="attr">age</span>:<span class="number">10</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br></pre></td></tr></table></figure><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li>在 es6 中增加了字符串对 <code>unicode</code> 字符码的支持，可以在代码中使用 <code>\uxxx</code> 来表示一个字符<ul><li><code>unicode</code> 码即统一码，是计算机科学领域里的一项业界标准，包括字符集，编码方案等， <code>unicode</code> 是为了解决传统的字符编码方案的局限而产生的，为每种语言的每个字符都设定了统一并且唯一的二进制编码</li></ul></li><li>利用 <code>for...of</code> 语句实现字符串的遍历</li><li>模板字符串，是增强版的字符串，使用反引号 ` 标记，可以当作普通字符串使用，也可用来定义多行字符串，或者在字符串中嵌入变量</li><li><code>include()</code> 表示字符串中是否包含参数字符串，返回布尔值，支持第二个参数，表示开始搜索的位置，默认为0</li><li><code>srartsWith()</code> 返回布尔值，表示字符串是否以参数字符串开头，同上</li><li><code>endsWith()</code> 返回布尔值，表示字符串是否以参数字符串结尾，同上</li><li><code>repeat()</code> 返回一个由源字符串重复 <code>n</code> 次的字符串</li><li><code>padStart()</code> 如果不够指定长度，在头部补全</li><li><code>padEnd()</code> 如果不够指定长度，在尾部补全</li><li><code>trimStart()</code> 消除字符串头部的空格，返回新字符串，不改变源字符串</li><li><code>trimEnd()</code> 消除字符串头部的空格，同上</li><li><code>at()</code> 返回指定位置的字符，支持负索引</li></ul><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li>扩展运算符，三个点，将一个数组转为用逗号分割的参数序列<ul><li>将数组转为函数的参数，不需要再使用 <code>apply</code> 方法了</li><li>作为合并数组的新写法</li></ul></li><li><code>Array.from()</code> 用于将类数组转为真正的数组，常见类数组有三种<ul><li>arguments</li><li>元素集合</li><li>类似数组的对象，但是书写要求较高，有严格的标准</li></ul></li><li><code>Array.of()</code> 将一组数值转为数组</li></ul><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li>es6 允许再大括号内，直接写入变量和函数，作为对象的属性和方法，用于函数的返回值</li><li>属性名表达式，允许字面量定义对象，用表达式作为对象的属性名，就是把标达式放在括号内</li><li>对象的扩展运算符，三个点，相当于将对象展开</li></ul><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li>箭头函数，es6 允许使用箭头 <code>=&gt;</code> 定义函数<ul><li>箭头函数如果不需要参数或者需要多个参数，就使用一个圆括号代表参数部分</li><li>如果箭头函数的代码块部分多于一条语句，就使用大括号将它们括起来，使用 <code>return</code> 返回</li><li>箭头函数的作用就是简化回调函数</li><li>对于普通函数，内部的 <code>this</code> 指向函数运行时所在的对象，但是对于箭头函数，内部的 <code>this</code> 就是定义时上层作用域中的 <code>this</code> ，箭头函数没有自己的 <code>this</code> 只能调用上层的 <code>this</code></li></ul></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>es6 提供了新的数据结构 <code>Set</code> ，类似于数组，但是成员的数值是唯一的，没有重复的值</li><li><code>Set</code> 本身是一个构造函数，用来生成 <code>Set</code> 数据结构</li><li>通过 <code>add</code> 方法加入成员，而且 <code>Set</code> 不会添加重复的值</li><li>可以接收一个数组作为参数</li><li>可以用作数组去除重复项的方法</li><li>字符串去除重复字符</li><li>加入值时，数据类型不会发生转换，所以字符和数字是会分别的</li><li><code>size</code> 返回实例的成员总数</li><li><code>add()</code> 添加元素</li><li><code>delete()</code> 删除某个值，返回一个布尔值，表示删除操作是否成功</li><li><code>has()</code> 是否有某个元素</li><li><code>clear()</code> 清除所有元素</li></ul><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>是异步编程的一种解决办法， <code>Promise</code> 是一个对象，从它可以获取异步操作的消息</p><p>有三种 <code>promise</code> 状态，除了异步操作的结果，任何其他操作都无法改变这个状态，只有从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code> 的状态改变。只要处于 <code>fulfilled</code> 和 <code>rejected</code> ，状态就不会再变了即 <code>resolved</code></p><ul><li><code>pending</code> 进行中</li><li><code>fulfilled</code> 已成功</li><li><code>rejected</code> 已失败</li></ul><p><strong>缺点</strong></p><ul><li>无法取消 <code>Promise</code> ，一旦新建它就会立即执行，无法中途取消</li><li>如果不设置回调函数， <code>Promise</code> 内部抛出的错误，不会反应到外部</li><li>当处于 <code>pending</code> 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li></ul><p><strong>then方法</strong></p><ul><li>接收两个函数作为参数，第一个参数是 <code>Promise</code> 执行成功时的回调，第二个参数是 <code>Promise</code> 执行失败时的回调，两个函数只会有一个被调用</li><li>当事件队列的当前运行完成之前，回调函数永不会被调用，</li><li><code>then</code> 方法可以返回值作为下一个链式反应的值</li><li>当忘记返回值时，对应链条被打破，导致之后的链式反应与当前链式反应同时进行</li><li>大多数浏览器中不能终止的 <code>Promise</code> 链里的 <code>rejection</code> ，建议后面都跟上 <code>.catch(error =&gt; console.log(error));</code></li></ul><h3 id="Async函数"><a href="#Async函数" class="headerlink" title="Async函数"></a>Async函数</h3><p>使得异步操作更方便，可以把异步操作变为同步操作，但是需要使用 <code>await</code> 关键字来等待异步操作完成，以此来实现同步</p><h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><p><code>js</code> 中，生成实例对象的传统方法是通过构造函数来实现，在 <code>es6</code> 中引入了 <code>class</code> ，通过这个关键字可以定义类</p><ul><li>实例化需要使用 <code>new</code> 来实现</li><li>类不存在提升，也就是只能在声明之后使用</li></ul><p><strong>实例的属性</strong></p><p>是指类的对象实例可以调用的属性，一般就是在构造函数中所声明并且定义的属性</p><p><strong>静态方法</strong></p><p>所有在类中定义的方法都会被实例继承，但是对于 <code>static</code> 方法不会被实例继承，但是可以直接调用，而实例中却没有此方法，如果静态方法中包含 <code>this</code> 那这个就是指这个类，而不是实例</p><p><strong>静态属性</strong></p><p>就是 <code>class</code> 本身的属性，也就是 <code>Class.propname</code> ，这个可以在类之外定义，但是不会被实例继承</p><h3 id="module语法"><a href="#module语法" class="headerlink" title="module语法"></a>module语法</h3><p><code>js</code> 没有将一个大的程序拆分成一些相互有依赖关系的小文件，再用简单的方式拼接起来，但是在 <code>es6</code> 中引入了 <code>module</code> 方法来实现此功能</p><p>先通过 <code>export</code> 指令显示指定来自外部的代码，再通过 <code>import</code> 命令输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export var hello = &quot;hello&quot;;</span><br><span class="line">import&#123;hello&#125; form &quot;./hello.js&quot;;</span><br></pre></td></tr></table></figure><p>测试需要采用 <code>Nodejs</code> 的方式测试 <code>module</code> 语法</p><h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p><code>Generator</code> 函数有两个区分于普通函数的部分</p><ul><li>在 <code>function</code> 之后，函数名之前有个 <code>*</code></li><li>函数内部有 <code>yield</code> 表达式，用 <code>yield</code> 来定义函数内部的状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function *func() &#123;</span><br><span class="line">  console.log(&quot;one&quot;);</span><br><span class="line">  yield &#x27;1&#x27;;</span><br><span class="line">  console.log(&quot;two&quot;);</span><br><span class="line">  return &#x27;2&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行机制</strong></p><p>调用 <code>Generator</code> 函数和调用普通函数一样，在函数名后加上 <code>()</code> 即可，但是该函数不会像普通函数一样立即执行，而是返回一个指向内部状态的指针，所以要调用遍历器对象 <code>iterator</code> 的 <code>next</code> 方法，指针就会从函数头部或者上一次停下来的地方开始执行，类似于 <code>python</code> 中的生成器函数，每调用一次都会执行到下一个 <code>yield</code> 或者 <code>return</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.next(); // &#x27;one&#x27; value=&#x27;1&#x27;</span><br><span class="line">func.next(); // &#x27;two&#x27; value=&#x27;2&#x27;</span><br><span class="line">func.next(); // value=undefined</span><br></pre></td></tr></table></figure><p>需要注意的是，如果获取 <code>yield</code> 的值，那每一步 <code>yield</code> 之后，执行下一次这个参数会变成 <code>undefined</code> ，但是如果使用 <code>next</code> 传参的话，这个数据就会被附上值，总之有点复杂，可以直接看运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function *func() &#123;</span><br><span class="line">  console.log(&quot;one&quot;);</span><br><span class="line">  var x = yield &#x27;1&#x27;;</span><br><span class="line">  console.log(&quot;x = &quot; + x);</span><br><span class="line">  console.log(&quot;two&quot;);</span><br><span class="line">  return &#x27;2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">var f = func();</span><br><span class="line">console.log(f.next()); </span><br><span class="line">console.log(f.next());// x = undefined</span><br><span class="line">console.log(f.next());</span><br><span class="line"></span><br><span class="line">var f1 = func();</span><br><span class="line">console.log(f1.next(10)); </span><br><span class="line">console.log(f1.next(20)); // x = 20</span><br></pre></td></tr></table></figure><p>除了使用 <code>next</code> 遍历该函数，还可以使用 <code>for...of</code> 来实现遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f3 = func();</span><br><span class="line">for (var item of f3) &#123;</span><br><span class="line">  item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>return方法</strong></p><p>返回给定值，并且结束遍历 <code>Generator</code> 函数</p><p>提供参数时返回该参数，不提供参数时，返回 <code>undefined</code></p><p><strong>错误处理</strong></p><p>对于下列 <code>Generator</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var func2 = function* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(&#x27;catch inner&#x27;, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var f2 = func2();</span><br><span class="line">f2.next;</span><br><span class="line">try &#123;</span><br><span class="line">  f2.throw(&#x27;a&#x27;);</span><br><span class="line">  f2.throw(&#x27;b&#x27;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&#x27;catch outside&#x27;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历器对象会抛出两个错误，第一个被 <code>Generator</code> 函数内部捕获，另一个因为函数体内部的 <code>catch</code> 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 <code>Generator</code> 函数体，被函数体外的 <code>catch</code> 捕获</p><p><strong>yield*表达式</strong></p><p><code>yield*</code> 表达式表示 <code>yield</code> 返回一个遍历器对象，用于在 <code>Generator</code> 函数内部，调用另一个 <code>Generator</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* callee() &#123;</span><br><span class="line">  console.log(&#x27;callee: &#x27; + (yield));</span><br><span class="line">&#125;</span><br><span class="line">function* caller() &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    yield* callee();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reflext与Proxy"><a href="#Reflext与Proxy" class="headerlink" title="Reflext与Proxy"></a>Reflext与Proxy</h3><ul><li><code>Proxy</code> 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。 </li><li><code>Reflect</code> 可以用于获取目标对象的行为，它与 <code>Object</code> 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 <code>Proxy</code> 是对应的</li><li><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法是一一对应的。所以 <code>Proxy</code> 对象的方法可以通过调用 <code>Reflect</code> 对象的方法获取默认行为，然后进行额外操作</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>一个 <code>Proxy</code> 对象由两个部分组成： <code>target</code> 和 <code>handler</code> 。在通过 <code>Proxy</code> 构造函数生成实例对象时，需要提供这两个参数。 <code>target</code> 即目标对象， <code>handler</code> 是一个对象，声明了代理 <code>target</code> 的指定行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123;</span><br><span class="line">  name: &#x27;Tom&#x27;,</span><br><span class="line">  age: 24</span><br><span class="line">&#125;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get: function(target, key) &#123;</span><br><span class="line">    console.log(&#x27;getting &#x27;+key);</span><br><span class="line">    return target[key]; // 不是target.key</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(target, key, value) &#123;</span><br><span class="line">    console.log(&#x27;setting &#x27;+key);</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(target, handler)</span><br><span class="line">proxy.name</span><br><span class="line">proxy.age = 25 </span><br><span class="line">proxy.sex = &quot;man&quot;</span><br></pre></td></tr></table></figure><ul><li><code>target</code> 可以为空对象</li><li><code>handler</code> 对象也可以为空，相当于不设置拦截操作，直接访问目标对象</li><li>通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相影响</li></ul><p><strong>实例方法</strong></p><ul><li><code>get(target, propKey, receiver)</code> 用于 <code>target</code> 对象上的 <code>propKey</code> 的读取操作，而且 <code>get</code> 方法可以继承</li><li><code>set(target, propKey, value, receiver)</code> 用于拦截 <code>target</code> 对象上的 <code>propKey</code> 的赋值操作，如果目标对象自身的某个属性不可写且不可配置，那 <code>set</code> 方法将不起作用，第四个参数 <code>receiver</code> 表示原始操作行为所在对象，一般是 <code>Proxy</code> 实例本身，严格模式下， <code>set</code> 代理如果没有返回 <code>true</code> ，就会报错</li><li><code>apply(target, ctx, args)</code> 用于拦截函数的调用， <code>call</code> 和 <code>reply</code> 操作，而 <code>target</code> 表示目标对象， <code>ctx</code> 表示目标对象上下文， <code>args</code> 表示目标对象的参数数组</li><li><code>has(target, propKey)</code> 用于拦截 <code>HasProperty</code> 操作，即在判断 <code>target</code> 对象是否存在 <code>propKey</code> 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性，此方法不拦截 <code>for...in</code> 循环</li><li><code>construct(target, args)</code> 此方法用于拦截 <code>new</code> 指令，返回值必须为对象</li><li><code>deleteProperty(target, propKey)</code> 用于拦截 <code>delete</code> 操作，如果这个方法抛出错误或者返回 <code>false</code> ， <code>propKey</code> 属性就无法被 <code>delete</code> 命令删除</li><li><code>defineProperty(target, propKey, propDesc)</code> 用于拦截 <code>Object.definePro</code> 若目标对象不可扩展，增加目标对象上不存在的属性会报错；若属性不可写或不可配置，则不能改变这些属性</li><li><code>getOwnPropertyDescriptor(target, propKey)</code> 用于拦截 <code>Object.getOwnPropertyD()</code> 返回值为属性描述对象或者 <code>undefined</code></li><li><code>getPrototypeOf(target)</code> 主要用于拦截获取对象原型的操作，返回值必须是对象或者 <code>null</code> ，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf</code> 方法必须返回目标对象的原型对象，主要包括<ul><li><code>Object.prototype._proto_</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul></li><li><code>isExtensible(target)</code> 用于拦截 <code>Object.isExtensible</code> 操作，该方法只能返回布尔值，否则返回值会被自动转为布尔值，它的返回值必须与目标对象的isExtensible属性保持一致，否则会抛出错误</li><li><code>ownKeys(target)</code> 用于拦截对象自身属性的读取操作，方法返回的数组成员，只能是字符串或 Symbol 值，否则会报错。若目标对象中含有不可配置的属性，则必须将这些属性在结果中返回，否则就会报错。若目标对象不可扩展，则必须全部返回且只能返回目标对象包含的所有属性，不能包含不存在的属性，否则也会报错。主要包括<ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>or...in</code></li></ul></li><li><code>preventExtensions(target)</code> 拦截 <code>Object.preventExtensions</code> 操作。该方法必须返回一个布尔值，否则会自动转为布尔值</li><li><code>setPrototypeOf()</code> 主要用来拦截 <code>Object.setPrototypeOf</code> 方法。返回值必须为布尔值，否则会被自动转为布尔值。若目标对象不可扩展， <code>setPrototypeOf</code> 方法不得改变目标对象的原型</li><li><code>Proxy.revocable()</code> 用于返回一个可取消的 <code>Proxy</code> 实例</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>es6 中将 <code>Object</code> 的一些明显属于语言内部的方法移植到了 <code>Reflect</code> 对象上（当前某些方法会同时存在于 <code>Object</code> 和 <code>Reflect</code> 对象上），未来的新方法会只部署在 <code>Reflect</code> 对象上。 <code>Reflect</code> 对象对某些方法的返回结果进行了修改，使其更合理。 <code>Reflect</code> 对象使用函数的方式实现了 <code>Object</code> 的命令式操作</p><p><strong>静态方法</strong></p><ul><li><code>Reflect.get(target, name, receiver)</code> 查找并返回 <code>target</code> 对象的 <code>name</code> 属性</li><li><code>Reflect.set(target, name, value, receiver)</code> 将 <code>target</code> 的 <code>name</code> 属性设置为 <code>value</code> 。返回值为布尔值， <code>true</code> 表示修改成功，<code>false</code> 表示失败。当 <code>target</code> 为不存在的对象时，会报错</li><li><code>Reflect.has(obj, name)</code> 是 <code>name in obj</code> 指令的函数化，用于查找 <code>name</code> 属性在 <code>obj</code> 对象中是否存在。返回值为布尔值。如果 <code>obj</code> 不是对象则会报错 <code>TypeError</code></li><li><code>Reflect.deleteProperty(obj, property)</code> 是 <code>delete obj[property]</code> 的函数化，用于删除 <code>obj</code> 对象的 <code>property</code> 属性，返回值为布尔值。如果 <code>obj</code> 不是对象则会报错 <code>TypeError</code></li><li><code>Reflect.construct(obj, args)</code> 等同于 <code>new target(...args)</code></li><li><code>Reflect.getPrototypeOf(obj)</code> 用于读取 <code>obj</code> 的 <code>_proto_</code> 属性。在 <code>obj</code> 不是对象时不会像 <code>Object</code> 一样把 <code>obj</code> 转为对象，而是会报错</li><li><code>Reflect.setPrototypeOf(obj, newProto)</code> 用于设置目标对象的 <code>prototype</code></li><li><code>Reflect.apply(func, thisArg, args)</code> 等同于 <code>Function.prototype.apply.call(func, thisArg, args)</code> 。 <code>func</code> 表示目标函数， <code>thisArg</code> 表示目标函数绑定的 <code>this</code> 对象， <code>args</code> 表示目标函数调用时传入的参数列表，可以是数组或类似数组的对象。若目标函数无法调用，会抛出 <code>TypeError</code></li><li><code>Reflect.defineProperty(target, propertyKey, attributes)</code> 用于为目标对象定义属性。如果 <code>target</code> 不是对象，会抛出错误。</li><li><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code> 用于得到 <code>target</code> 对象的 <code>propertyKey</code> 属性的描述对象。在 <code>target</code> 不是对象时，会抛出错误表示参数非法，不会将非对象转换为对象</li><li><code>Reflect.isExtensible(target)</code> 用于判断 <code>target</code> 对象是否可扩展。返回值为布尔值。如果 <code>target</code> 参数不是对象，会抛出错误</li><li><code>Reflect.preventExtensions(target)</code> 用于让 <code>target</code> 对象变为不可扩展。如果 <code>target</code> 参数不是对象，会抛出错误</li><li><code>Reflect.ownKeys(target)</code> 用于返回 <code>target</code> 对象的所有属性，等同于 <code>Object.getOwnPropertyNames</code> 与 <code>Object.getOwnPropertySymbols</code> 之和</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础</title>
      <link href="/Blog_ButterFly/2024/04/11/js%E5%9F%BA%E7%A1%80/"/>
      <url>/Blog_ButterFly/2024/04/11/js%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/Web.git">代码</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>JavaScript</code> 是一种轻量级的脚本语言，所谓脚本语言就是指它不具备开发操作系统的能力，而只是用来编写控制其他大型应用程序的脚本。 <code>JavaScript</code> 是一种嵌入式语言，本身提供的核心语法不算很多，可用于 <code>html</code> 和 <code>web</code> ，更可广泛应用于服务器，PC等设备</p><p>类似于 C 语言，一行一行的执行，每一行就是一条语句</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>操控浏览器的能力</li><li>广泛的使用领域</li><li>易学</li></ul><h3 id="与ECMAScript-的关系"><a href="#与ECMAScript-的关系" class="headerlink" title="与ECMAScript 的关系"></a>与ECMAScript 的关系</h3><p><code>ECMAScript</code> 和 <code>JavaScript</code> 的关系，前者式后者的规格。后者是前者的一种实现</p><h2 id="将js引入到html文件中"><a href="#将js引入到html文件中" class="headerlink" title="将js引入到html文件中"></a>将js引入到html文件中</h2><h3 id="嵌入到文件中"><a href="#嵌入到文件中" class="headerlink" title="嵌入到文件中"></a>嵌入到文件中</h3><p>需要在 <code>&lt;body&gt;</code> 标签之内嵌入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> num = <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="引入独立js文件"><a href="#引入独立js文件" class="headerlink" title="引入独立js文件"></a>引入独立js文件</h3><p>要在 <code>script</code> 标签内定义 <code>type</code> 和 <code>src</code> 属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./语法.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>type</code> 表示引入文件类型</li><li><code>src</code> 文件的路径</li></ul><h3 id="引入网络来源文件"><a href="#引入网络来源文件" class="headerlink" title="引入网络来源文件"></a>引入网络来源文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中的 <code>src</code> 就是引入的 js 文件的网址，不需要指定 <code>type</code> 类型</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符指的是用来识别各种值的合法名称，最常见的标识符就是变量名，标识符是由字母，dollar符号，下划线和数字组成，不能以数字开头，中文是合法的标识符，可做变量名，不推荐</p><h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><p>在 js 中的保留关键字不能用作标识符</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>可以被赋值的标识符，类似于 C 语言</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>js 中代码的注释不会被引擎解释，有两种写法</p><ul><li>行注释 <code>//</code></li><li>块注释 <code>/*...*/</code></li><li>嵌入在 <code>html</code> 中的注释 <code>&lt;!--...--&gt;</code></li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>有多种输出方式</p><ul><li><code>alert(content)</code> 弹窗输出</li><li><code>document.write(content)</code> 文件写入</li><li><code>console.log(content)</code> 终端输出</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>原始数据类型<ul><li>数值</li><li>字符串</li><li>布尔值</li></ul></li><li>特殊值<ul><li>undefined</li><li>null</li></ul></li><li>合成类型<ul><li>对象</li></ul></li><li>新增类型<ul><li>Symbol</li><li>BigInt</li></ul></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>typeof运算符 可以检测数据类型，对于数据类型中， <code>null</code> 和 <code>undefined</code> 都可以表示没有，将一个变量做这两种赋值是没有区别的</li><li><code>+</code></li><li><code>-</code></li><li><code>*</code></li><li><code>/</code></li><li><code>%</code></li><li><code>++</code></li><li><code>--</code></li><li><code>=</code></li><li><code>+=</code></li><li><code>-=</code></li><li><code>*=</code></li><li><code>/=</code></li><li><code>%=</code></li><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>&lt;=</code></li><li><code>&gt;=</code></li><li><code>==</code></li><li><code>===</code> 严格相等</li><li><code>!=</code></li><li><code>!==</code> 严格不相等</li><li><code>!</code></li><li><code>&amp;&amp;</code></li><li><code>||</code></li></ul><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li><code>if</code></li><li><code>if...else if...else</code></li><li><code>switch...case...default</code></li></ul><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(condition) ? a : b;</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul><li><code>for</code></li><li><code>while()</code></li></ul><p>跳出循环的语句 <code>break</code> 中断循环， <code>continue</code> 终止此次循环，开启下次循环</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>由零个或多个放在双引号或者单引号之中的字符，单引号字符串内部可以使用双引号，双引号字符串内部可以使用单引号。对于双引号内部使用双引号和单引号内部使用单引号，必须使用转义 <code>\&#39;</code> 和 <code>\&quot;</code></p><p><strong>常用方法</strong></p><ul><li><code>length</code> 属性，返回字符串的长度</li><li><code>charAt()</code> 返回指定位置的字符</li><li><code>concat()</code> 用于连接两个字符串，返回一个新的字符串，不改变原字符串，可以接收多个字符串，如果参数不是字符串会将其转为字符串然后连接</li><li><code>substring()</code> 截取字符串，两个参数，第一个表示开始位置，第二个表示结束位置，不包括结束位置，默认是到末尾，会自动调换两和位置的顺序，保证小的在前，会把负数转为 0</li><li><code>substr()</code> 截取字符串，两个参数，第一个表示开始位置（从0开始），第二个表示截取长度，到结束为止。第一个参数为 0 意味着倒着计算字符的为止，第二个参数小于等于 0 返回空字符串</li><li><code>indexOf()</code> 用于确定一个字符串在另一个字符串中第一次出现的为止，返回结果是匹配开始的为止，如果返回 <code>-1</code> 表示没有匹配项，还可以接受第二个参数，表示从该位置向后匹配</li><li><code>trim()</code> 去除字符串两端的空格，返回新的字符串，不改变源字符串，去除的不仅仅是空格，还有换行，回车和制表符</li><li><code>split()</code> 按照某个字符来分割，就是以某个字符作为分割符，从字符串中找到该字符时将该字符作为分割符把字符串分割，如果分割字符为空，则返回源字符的每一个字符</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>是按照次序排列的一组值，每个值位置都有编号，整个数组用方括号表示，位置排列从 0 开始，这个数组是一个通用的数组，任何数据都可以被放入数组中</p><ul><li><code>length</code> 属性，返回数组的长度</li><li>遍历，可以使用 <code>for</code> 循环，或者是 <code>while</code> 循环，使用 <code>for(... in ...)</code> 进行循环</li><li><code>Array.isArray()</code> 返回一个布尔值，表示参数是否为数组，可以弥补 <code>typeof</code> 运算符的不足，这个方法不是数组的内部元素</li><li><code>push()</code> 用于在数组的末端添加一个或多个元素，并且返回添加新元素后的数组长度，该方法会改变原数组</li><li><code>pop()</code> 用于删除数组的最后一个元素，并且返回该元素</li><li><code>shift()</code> 用于删除数组的第一个元素，并且返回该元素，会改变原数组</li><li><code>unshift()</code> 用于向元素第一个位置添加元素，并且返回该数组的长度，会改变原数组，可以接收多个参数，这些参数都会添加到目标数组头部</li><li><code>join()</code> 指定参数作为分割符，将所有数组成员连接成为一个字符串，默认为逗号，对于数组中的数组，就使用逗号进行分割，如果数组成员时 <code>undefined</code> 或者 <code>null</code> 或者空位，会被转为空字符串</li><li><code>concat()</code> 用于多个数组的合并，将新数组的成员添加到原数组候补，并且返回一个新数组，原数组不变，也支持其它类型的值</li><li><code>reverse()</code> 用于颠倒原数组，返回改变后的数组，但是会改变原数组</li><li><code>indexOf()</code> 返回给定元素在数组中第一次出现的位置，如果没有出现则返回 <code>-1</code> ，可接受第二个参数，表示开始查找的位置</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>是一块能反复调用的代码块，使用 <code>function</code> 命令声明代码区块，就是一个函数 <code>function</code> 命令后面就是函数名，函数名之后是一对圆括号，里面是传入函数的参数，函数体放在打括号内，类似于C语言，但在小括号内的参数不需要添加参数类型</p><p>函数声明时，只需要将函数名和形参声明即可.</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象就是键值对，是一种无序的符合数据集合，声明类似于 <code>python</code> 中的字典</p><p>对象的每一个键名又称为属性，它的键值可以是任何数据类型</p><p>如果一个属性的值为函数，通常把这个属性称为方法，可以像调用函数一样调用</p><p>如果属性值还是一个对象，就形成了链式引用</p><h3 id="math对象"><a href="#math对象" class="headerlink" title="math对象"></a>math对象</h3><p>是 JS 的原生对象，提供各种数学功能</p><ul><li><code>Math.abs()</code> 返回绝对值</li><li><code>Math.max()</code> 返回最大值</li><li><code>Math.min()</code> 返回最小值</li><li><code>Math.floor()</code> 返回小于参数值的最大整数</li><li><code>Math.ceil()</code> 返回大于参数值的最小整数</li><li><code>Math.random()</code> 返回 0 到 1 之间的一个伪随机，可能等于 0，但一定小于 1</li></ul><h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><p><code>date</code> 是 <code>JavaScript</code> 原生的时间库，以1970年1月1日0点作为时间的零点，可以表示的时间范围是前后各一亿天</p><ul><li><code>Date.now()</code> 返回当前时间距离时间零点的毫秒数</li><li>时间戳，就是距离时间零点的秒数</li><li><code>Date.getTime()</code> 返回实例距离时间零点毫秒数</li><li><code>Date.getDate()</code> 返回实例对象对应每个月的几号</li><li><code>Date.getDay()</code> 返回实例星期几，周日为</li><li><code>Date.getYear()</code> 返回距离1900的年数</li><li><code>Date.getFullYear()</code> 返回四位的年份</li><li><code>Date.getMonth()</code> 返回月份</li><li><code>Date.getHours()</code> 返回小时</li><li><code>Date.getMilliseconds()</code> 返回毫秒</li><li><code>Date.getMinutes()</code> 返回分钟</li><li><code>Date.getSeconds()</code> 返回秒</li></ul><h3 id="js错误"><a href="#js错误" class="headerlink" title="js错误"></a>js错误</h3><ul><li>使用 <code>try</code> 语句测试代码块的错误</li><li>使用 <code>catch</code> 语句处理错误</li><li>使用 <code>throw</code> 创建自定义错误，相当于是抛出错误</li><li>使用 <code>finally</code> 语句在最后，无论上述是否触发错误，都会执行的语句</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="keyword">throw</span>(e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p><code>let</code> 声明的变量旨在当前代码块内有效</p><h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3><p><code>const</code> 声明的变量一旦声明，常量的值就不能改变</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>就是有时候会在变量声明之前使用，这时候不会报错，而变量的值为 <code>undefined</code></p><h2 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h2><p>dom是 <code>JavaScript</code> 操作网页的接口，是文档对象模型。作用是将网页转为一个 <code>JavaScript</code> 对象，从而使用脚本进行各种操作，比如对元素的增删改等</p><p>浏览器会根据 dom 模型，将结构化文档 <code>html</code> 解析成一系列的节点，再由这些节点组成一个树状结构 <code>dom tree</code> 。所有的节点和最终的树状结构都有对外的接口。</p><p>dom 就是一个接口规范，可以用各种语言实现，但是 dom 是 <code>JavaScript</code> 最常见的任务</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>dom 的最小组成单位为节点，文档的树形结构是不同的节点组成的，每个节点相当于是文档树的一片叶子，类型有 7 种，如下</p><ul><li><code>Document</code> 文档树的顶层节点</li><li><code>DocumentType</code> doctype标签</li><li><code>Element</code> 网页各种 html 标签</li><li><code>Attribute</code> 网页元素的属性</li><li><code>Text</code> 标签之间或标签包含的文本</li><li><code>Comment</code> 注释</li><li><code>DocumentFragment</code> 文档的片段</li></ul><h3 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h3><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。浏览器原生提供 <code>document</code> 节点，代表整个文档。除了根节点，其他节点都有如下三种层级关系</p><ul><li>父节点关系：直接的上级节点</li><li>子节点关系：直接的下级节点</li><li>同级节点关系：拥有同一个父节点的节点</li></ul><h3 id="Node-nodeType"><a href="#Node-nodeType" class="headerlink" title="Node.nodeType"></a>Node.nodeType</h3><div class="table-container"><table><thead><tr><th>Node类型</th><th>Named Constant</th></tr></thead><tbody><tr><td>1</td><td>ELEMENT_NODE</td></tr><tr><td>2</td><td>ATTRIBUTE_NODE</td></tr><tr><td>3</td><td>TEXT_NODE</td></tr><tr><td>4</td><td>CDATA_SECTION_NODE</td></tr><tr><td>5</td><td>ENTITY_REFERENCE_NODE</td></tr><tr><td>6</td><td>ENTITY_NODE</td></tr><tr><td>7</td><td>PROCESSING_INSTRUCTION_NODE</td></tr><tr><td>8</td><td>COMMENT_NODE</td></tr><tr><td>9</td><td>DOCUMENT_NODE</td></tr><tr><td>10</td><td>DOCUMENT_TYPE_NODE</td></tr><tr><td>11</td><td>DOCUMENT_FRAGMENT_NODE</td></tr><tr><td>12</td><td>NOTATION_NODE</td></tr></tbody></table></div><p>不同节点的 <code>nodeType</code> 属性值和对应的常量如下</p><ul><li><code>Document</code> 9</li><li><code>DocumentType</code> 1</li><li><code>Element</code> 2</li><li><code>Attribute</code> 3</li><li><code>DocumentFragment</code> 11</li></ul><h3 id="document-获取元素"><a href="#document-获取元素" class="headerlink" title="document 获取元素"></a>document 获取元素</h3><ul><li><code>getElementsByTagName()</code> 通过搜索 html 标签名返回符合条件的元素，返回值是一个类似数组对象的，如果没有匹配的元素，返回空集</li><li><code>getElementsByClassName()</code> 通过类名搜索，返回包含该类名的元素，元素的变化也会实时返回在结果中，参数可以是多个，通过空格分隔</li><li><code>getElementsByName()</code> 用于选择拥有 <code>name</code> 属性的 html 元素，返回一个类似数组的对象</li><li><code>getElementById()</code> 匹配指定 id 属性的元素节点，如果没有发现节点，返回 null</li><li><code>querySelector()</code> 接受一个 <code>css</code> 选择器作为参数返回匹配该选择器的元素节点，如果有多个返回第一个</li><li><code>querySelectorAll()</code> 接受一个 <code>css</code> 选择器作为参数返回匹配该选择器的元素节点，返回一个数组</li></ul><h3 id="document-创建元素"><a href="#document-创建元素" class="headerlink" title="document 创建元素"></a>document 创建元素</h3><ul><li><code>createElement()</code> 生成元素节点，并且返回该节点，参数是元素类型</li><li><code>createNextNode()</code> 用于生成文本节点，并且返回该节点，参数是文本节点的内容</li><li><code>createAttribute()</code> 生成一个新的属性节点，并且返回该节点</li></ul><h3 id="element-对象属性"><a href="#element-对象属性" class="headerlink" title="element 对象属性"></a>element 对象属性</h3><p><code>element</code> 对象对应于网页的 <code>html</code> 元素，每一个 <code>html</code> 元素都会被转化为一个 <code>element</code> 节点对象</p><ul><li><code>id</code> 属性返回指定元素的 <code>id</code> 属性，该属性可读写</li><li><code>className</code> 用于读写该元素节点的 <code>class</code> 属性，值是一个字符串，中间用空格隔开</li><li><code>classList</code> 有如下方法<ul><li><code>add()</code> 增加一个 <code>class</code></li><li><code>remove()</code> 移除一个 <code>class</code></li><li><code>contain()</code> 检查当前元素是否包含某个 <code>class</code></li><li><code>toggle()</code> 将某个 <code>class</code> 移入或移除当前元素</li></ul></li><li><code>innerHTML</code> 返回一个字符串，等于该元素包含的所有 <code>html</code> 代码，该属性可读写，用来设置节点的内容，能改写所有元素节点的内容，包括 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 元素</li><li><code>innerText</code> 与上述类似，不同的是该方法会直接渲染为字符串</li></ul><h3 id="element-获取元素位置"><a href="#element-获取元素位置" class="headerlink" title="element 获取元素位置"></a>element 获取元素位置</h3><ul><li><code>clientHeight</code> 获取元素高度，包括 <code>padding</code> 但是不包括 <code>border</code> 和 <code>margin</code> ，只对块级元素生效，如果有水平滚动条，需要减去水平滚动条的高度</li><li><code>clientWidth</code> 获取元宽度，同上</li><li><code>scrollHeight</code> 元素总高度，同上，但是包括溢出的不可见的内容</li><li><code>scrollWidth</code> 元素总宽度，同上</li><li><code>scrollLeft</code> 元素水平滚动条向右滚动的像素效果</li><li><code>scrollTop</code> 元素水平滚动条向下滚动的像素效果</li><li><code>offsetHeight</code> 元素的 CSS 垂直高度，包括元素本身的高度， <code>padding</code> 和 <code>border</code></li><li><code>offsetWidth</code> 元素的 CSS 垂直高度，同上</li><li><code>offsetLeft</code> 元素到定位父级左边界的间距</li><li><code>offsetTop</code> 元素到定位父级上边界的间距</li></ul><h3 id="CSS-操作"><a href="#CSS-操作" class="headerlink" title="CSS 操作"></a>CSS 操作</h3><p>操作 <code>CSS</code> 样式最简单的办法就是，对 <code>html</code> 元素的 <code>style</code> 属性进行操作，有三种操作方式</p><ul><li>使用 <code>setAttribute</code> 设置属性 <code>style</code> 的参数</li><li>使用元素节点的 <code>style</code> 属性进行设置</li><li>使用元素节点的 <code>style</code> 属性设置该属性的 <code>cssText</code> 进行设置样式</li></ul><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><ul><li><code>html</code> 事件处理，类似于按钮点击特效果</li><li><code>dom</code> 0级事件处理，其中 <code>html</code> 和 <code>js</code> 是分离的，但是无法添加多个事件</li><li><code>dom</code> 2级事件处理，其中 <code>html</code> 和 <code>js</code> 是分离的，可以添加多个事件</li></ul><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>鼠标事件指的是与鼠标相关的事件，具体</p><ul><li><code>click</code> 按下鼠标触发</li><li><code>dblclick</code> 在同一个元素上双击鼠标触发</li><li><code>mousedown</code> 按下鼠标时触发</li><li><code>mouseup</code> 释放鼠标时触发</li><li><code>mousemove</code> 鼠标在节点内部移动时触发，鼠标持续移动，该事件会持续触发</li><li><code>mouseseenter</code> 当鼠标进入一个节点时触发，进入子结点不会触发</li><li><code>mouseleave</code> 当鼠标离开一个节点时触发，离开父结点不会触发这个事件</li><li><code>mouseover</code> 鼠标进入一个节点时触发，进入子结点会再次触发</li><li><code>mouseout</code> 鼠标离开一个节点时触发，离开父结点也会触发</li><li><code>wheel</code> 滚动鼠标滚轮时触发</li></ul><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>一个事件发生以后，会产生一个事件对象，作为参数传给监听函数</p><p><strong>属性</strong></p><ul><li><code>Event.Target</code> 返回事件当前所在的节点</li><li><code>Event.type</code> 返回一个字符串，表示事件类型，事件类型是在生成事件时产生，该属性只读</li></ul><p><strong>方法</strong></p><ul><li><code>Event.preventDefault()</code> 取消浏览器对当前事件的默认行为</li><li><code>Event.stopPropagation()</code> 阻止事件在 <code>dom</code> 中继续传播，防止再次触发在别的节点上的监听函数，但是不包括在当前节点上的其它事件的监听函数，例如对于父子元素都有点击事件，当点击子元素时，父元素也会触发点击事件，这个方法能阻止子元素点击事件的扩散，以至于不会触发父元素的点击事件</li></ul><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>用户击打键盘触发主要有三个事件</p><ul><li><code>keydown</code> 按下键盘时触发</li><li><code>keypress</code> 按下有值的键时触发，也就是按下 <code>ctrl</code> ， <code>alt</code> 等无值的键不会触发，对于有值的键，先触发 <code>keydown</code> 再触发 <code>keypress</code></li><li><code>keyup</code> 松开键盘时触发的事件</li></ul><p><strong>event对象</strong></p><p><code>keyCode</code> 表示你所按下的按键的代码</p><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><p>是使用表单元素以及输入框元素可以监听的一系列事件</p><ul><li><code>input</code> 当 <code>&lt;input&gt;</code> ， <code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 的值发生变化时触发，对于复选框 <code>&lt;input type=checkbox&gt;</code> 或单选框 <code>&lt;input type=radio&gt;</code> ，当用户改变选项时，也会触发这个事件，每按下一次按键就会触发一次</li><li><code>select</code> 当 <code>&lt;select&gt;</code> 事件在 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> 中选中文本时触发</li><li><code>Change</code> 当 <code>&lt;input&gt;</code> ， <code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 的值发生变化时触发，但是只有当全部修改完之后才会触发</li><li><code>reset</code> 这是发生在表单对像上的，当表单重置时触发</li><li><code>submit</code> 这是发生在表单对象上的，当表单数据向服务器提交时触发，发生对象是 <code>&lt;form&gt;</code> 元素，而不是 <code>&lt;button&gt;</code> 元素</li></ul><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>由于事件会在冒泡阶段传递给父结点，因此可以把子结点的监听函数定义在父结点，由父结点的监听函数统一处理多个子元素的事件，这种方法就是代理</p><h3 id="定时器setTimeout"><a href="#定时器setTimeout" class="headerlink" title="定时器setTimeout"></a>定时器setTimeout</h3><p><code>js</code> 中提供定时执行代码的功能，叫做定时器，主要由 <code>setTimeout</code> 和 <code>setInterval</code> 两个函数完成，它们向任务队列中添加定时任务</p><ul><li><code>setTimeout</code> 用来指定某个函数或者某段代码，在多少毫秒之后运行，返回一个整数，表示定时器的编号，以后可以取消定时器，接收两个参数，第一个参数是将要推迟执行的函数名或者一段代码，第二个参数是推迟执行的毫秒数，只执行一次。还有就是如果回调函数是对象的方法，那么该函数使得方法内部 <code>this</code> 关键字指向全局环境，而不是定义时所在的那个对象</li><li><code>setInterval</code> 这个函数与上述定时器的函数几乎一致，唯一不同之处在于这个函数的定时器是循环执行无数次</li><li><code>clearTimeout(id)</code> 取消定时器，参数就是上述的定时器编号</li></ul><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖严格来说应该属于性能优化事件，对于高频的信息，处理不当会导致浏览器卡死，例如一个滚动条监听的例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>:<span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>:<span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">showTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;滚动条位置：&quot;</span> + scrollTop);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onscroll</span> = showTop;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一次滚动能产生好多条消息，执行频率太高了，会导致网页卡顿，有一种解决方式就是在第一次触发时，不立即执行函数，而是给一个期望值的定时器去执行，然后如果在这个期望值内没有发生触发滚动条件，那就执行函数，如果在这段时间内再次触发事件，那之前的计时取消，从新开始计时，从而保证短时间内多次触发只执行一次函数</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流也属于是性能优化的功能，对于上述的防抖，就会导致在规定的时间段内，不断触发滚动事件，只要不停止触发，理论上就永远不会输出当前距离顶部的位置</p><p>节流就是在某次触发之后，函数执行一次之后，在短时间内不会再次触发，过了一段事件之后才生效</p><p>对于防抖的常用场景</p><ul><li>搜索框 <code>input</code> 要支持实时搜索可以使用节流方案，或者实现输入间隔大于某个值之后就当作输入完成，然后开始搜索</li><li>页面 <code>resize</code> 事件，用于需要做页面适配的时候，根据最终呈现的情况进行 <code>dom</code> 渲染就可以了，一般会使用防抖，因为只需要判断最后一次的变化情况就可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue基础</title>
      <link href="/Blog_ButterFly/2024/04/11/vue%E5%9F%BA%E7%A1%80/"/>
      <url>/Blog_ButterFly/2024/04/11/vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/Web.git">代码</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>vue 是前端优秀框架，是一套用于构建用户界面的渐进式框架</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>简单</li><li>易学</li><li>…</li></ul><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><h3 id="使用命令行安装"><a href="#使用命令行安装" class="headerlink" title="使用命令行安装"></a>使用命令行安装</h3><p><code>vue cli</code> 是一个基于 <code>vue.js</code> 进行快速开发的完整系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>测试，在终端输入以下指令测试是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure><h3 id="一些功能"><a href="#一些功能" class="headerlink" title="一些功能"></a>一些功能</h3><p>使用下列指令打开一个 gui 界面来引导项目创建等一系列操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在终端使用下列指令创建一个项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create projectname</span><br></pre></td></tr></table></figure><p>输入之后需要使用上下按键来选择默认项目模板</p><p>可以选择手动选择，然后按照如下选择</p><p><img src="/Blog_ButterFly/2024/04/11/vue%E5%9F%BA%E7%A1%80/config.png" alt="config"></p><h3 id="文件目录说明"><a href="#文件目录说明" class="headerlink" title="文件目录说明"></a>文件目录说明</h3><div class="table-container"><table><thead><tr><th>目录/文件</th><th>说明</th></tr></thead><tbody><tr><td>build</td><td>项目构建(webpack)相关代码</td></tr><tr><td>config</td><td>配置目录，包括端口号等。初学可以使用默认的。</td></tr><tr><td>node_modules</td><td>npm 加载的项目依赖模块</td></tr><tr><td>src</td><td>这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：</td></tr><tr><td>assets</td><td>放置一些图片，如 logo 等，还可以放全局使用的 css 文件</td></tr><tr><td>components</td><td>目录里面放了一个组件文件，可以不用。</td></tr><tr><td>App.vue</td><td>项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</td></tr><tr><td>main.js</td><td>项目的核心文件。</td></tr><tr><td>index.css</td><td>样式文件。</td></tr><tr><td>static</td><td>静态资源目录，如图片、字体等。</td></tr><tr><td>public</td><td>公共资源目录。</td></tr><tr><td>test</td><td>初始测试目录，可删除</td></tr><tr><td>.xxxx文件</td><td>这些是一些配置文件，包括语法配置，git配置等。</td></tr><tr><td>index.html</td><td>首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td></tr><tr><td>package.json</td><td>项目配置文件。</td></tr><tr><td>README.md</td><td>项目的说明文档，markdown 格式</td></tr><tr><td>dist</td><td>使用 npm run build 命令打包后会生成该目录。</td></tr></tbody></table></div><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>数据绑定常见的形式就是使用 <code>Mustache</code> 双大括号的语法文本插值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>一般配合 <code>js</code> 中的 <code>data()</code> 设置数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;msg&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原始HTML"><a href="#原始HTML" class="headerlink" title="原始HTML"></a>原始HTML</h3><p>双大括号会将数据解释为普通文本，而非 <code>html</code> 代码，为了输出 <code>html</code> 就需要使用 <code>v-html</code> 指令</p><h3 id="attribute属性"><a href="#attribute属性" class="headerlink" title="attribute属性"></a>attribute属性</h3><p><code>Mustache</code> 语法不能再 <code>html</code> 属性中使用，但是可以使用 <code>v-bind</code> 指令。 <code>class</code> 与 <code>style</code> 是 <code>html</code> 元素的属性，用于设置元素的样式，我们可以用 <code>v-bind</code> 来设置样式属性。有两种写法，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;v-bind:&lt;/div&gt;</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;v-bind:&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>内联样式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;1&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--其中 activeColor:&quot;red&quot;, fontSize: 20--&gt;</span><br></pre></td></tr></table></figure><p>上述会被渲染为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color: red, fontSize: 20px&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内联样式还可指定多重值，提供一个包含多个值的数组，常用于提供多个带前缀的值，这样写只会渲染数组中最后一个被浏览器支持的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>组件上使用class属性</strong></p><p>当你在带有单个根元素的自定义组件上使用 class 属性时，这些 class 将被添加到该元素中。此元素上的现有 class 将不会被覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;newComponentName class=&quot;classC classD&quot;&gt;&lt;/newComponentName&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.component(&#x27;newComponentName&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;h1 class=&quot;classA classB&quot;&gt;这是一个新组件标题&lt;/h1&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最终渲染结果为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;classA classB classC classD&quot;</span>&gt;</span>这是一个新组件标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于带数据绑定的 <code>class</code> 也可使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;newComponentName :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/newComponentName&gt;</span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 为 <code>true</code> 时，最终渲染效果为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;classA classB active&quot;</span>&gt;</span>这是一个新组件标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果新的组件有多个根元素，需要定义哪些部分将接收这个类。可以使用 <code>$attrs</code> 组件属性执行此操作，可以用于传递组件属性和事件。下列的操作实际上就是继承原来的类属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;newComponentName class=&quot;classA&quot;&gt;&lt;/newComponentName&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.component(&#x27;newComponentName&#x27;, &#123;</span><br><span class="line">  template: `</span><br><span class="line">    &lt;p :class=&quot;$attrs.class&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;这是一个子组件&lt;/span&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最终渲染结果为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;classA&quot;</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是一个子组件<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用Js表达式"><a href="#使用Js表达式" class="headerlink" title="使用Js表达式"></a>使用Js表达式</h3><p><code>vue.js</code> 提供了完全的 js 表达式支持，使用双括号来表示使其被解析为 js 表达式。但是，双括号中只能包含单个表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 有效</span><br><span class="line">&#123;&#123;number + 1&#125;&#125;</span><br><span class="line">&#123;&#123;ok? &#x27;y&#x27; : &#x27;n&#x27;&#125;&#125;</span><br><span class="line"></span><br><span class="line">// 无效</span><br><span class="line">&#123;&#123;var a = 1&#125;&#125; //语句</span><br><span class="line">&#123;&#123;if(ok) &#123;return msg;&#125;&#125;&#125; // 流程控制语句也不会生效</span><br></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ul><li><code>v-if</code> 用于条件性的渲染一块内容，这块内容只会在指令的表达式返回 <code>true</code> 时渲染<ul><li>真正的条件渲染，会保证在切换过程中，条件块内的事件监听器和子组件适当的被销毁和重建</li><li>也是惰性的，如果在初始渲染时条件为假，那什么也不做，直到变为真才会做渲染</li></ul></li><li><code>v-else</code> 用于作为 <code>v-if</code> 的 <code>else</code> 块</li><li><code>v-show</code> 用于条件性展示元素的另一个选项<ul><li>不管初始条件是什么都会渲染元素，并且只是简单的基于 <code>css</code> 进行切换</li><li>一般来说 <code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销，所以如果需要非常频繁的切换则使用 <code>v-show</code> ，如果在运行中很少改变就使用 <code>v-if</code></li></ul></li></ul><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul><li><code>v-for</code> 把一个数组映射为一组元素，基于一个数组来渲染一个列表，指令需要使用 <code>item in items</code> 语法来实现</li><li>当 <code>vue</code> 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略，如果数据项的顺序被改变，vue 将不会移动 dom 元素来匹配数据项的顺序，而是就地更新每个元素，并且保证它们在每个索引位置正确渲染。为了给 vue 一个提示，以便它能够跟踪每个节点，从而重新排列现有元素，需要为每一项提供一个唯一的 <code>key</code> attribute</li></ul><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li>监听事件，可以使用 <code>v-on</code> 指令（可缩写为 <code>@</code> 符号）来监听 dom 事件，并且在触发事件时执行一些 <code>js</code> 指令</li><li>事件处理方法，很多事件处理逻辑会比较复杂，所以可以写为一个调用的方法名称</li><li>内联处理器中的方法，也可以称作事件传递函数</li></ul><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><ul><li><code>v-model</code> 指令在表单 <code>&lt;input&gt;</code> ， <code>&lt;textarea&gt;</code> 以及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定，它会根据空间类型自动选取正确的方法来更新元素。本质上不过是语法糖，负责监听用户输入事件来更新数据，并且完成一些特殊处理</li><li><code>.lazy</code> 修饰符， <code>v-model</code> 事件在每次 <code>input</code> 事件触发之后就进行数据同步，可以添加该修饰符，从而转为 <code>change</code> 事件之后进行同步</li><li><code>.trim</code> 修饰符，可以自动过滤用户输入的首尾空白字符</li></ul><h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><ul><li>单文件组件，单文件组件是一种特殊的文件格式，允许将 <code>vue</code> 组件中的模板，逻辑与样式封装在单个文件中</li><li>加载组件步骤<ul><li>引入组件 <code>import mycomponent from &#39;./components/mycomponent.vue&#39;; &#39;./components/mycomponent&#39;</code></li><li>挂载组件 <code>components: &#123;mycomponent&#125;</code></li><li>显示组件 <code>&lt;mycomponent/&gt;</code></li></ul></li><li>组件组织，通常一个应用会以一棵嵌套的组件树的形式来组织<br><img src="/Blog_ButterFly/2024/04/11/vue%E5%9F%BA%E7%A1%80/component_tree.png" alt="conponent_tree"></li></ul><h3 id="props组件交互"><a href="#props组件交互" class="headerlink" title="props组件交互"></a>props组件交互</h3><p>组件与组件之间是需要存在交互的，否则完全没关系，组件的意义就很小了，而 <code>props</code> 是可以在组件上注册的一些自定义 <code>attribute</code> ，传递的方向就是父组件传递到子组件</p><p><code>props</code> 传递的参数是没有类型限制的，但是传入数据为数组或者对象类型时，默认值时需要返回工厂模式，也就是定义一个返回一个空数组的函数</p><p><strong>使用方法</strong></p><ol><li><p>在调用组件的文件中声明需要传递的变量，写法与组件文件中一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;一个标题&quot;</span>,</span><br><span class="line">    age : <span class="number">10</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在加载组件时传入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;props_test :title=&quot;title&quot; :age=&quot;age&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>在组件中需要使用 <code>props</code> 声明变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;props_test&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type:String,</span><br><span class="line">      default:&quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default:0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="自定义事件组件交互"><a href="#自定义事件组件交互" class="headerlink" title="自定义事件组件交互"></a>自定义事件组件交互</h3><p>自定义事件可以在组件中反向传递数据， <code>prop</code> 可以将数据从父组件传递到子数组，对于反向操作，可以使用自定义事件实现</p><ul><li>使用 <code>this.$emit()</code> 函数，其中第一个参数是字符串，理论上是随便的，但是需要与弗组件中对应，第二个参数就是传递的数据</li></ul><p><strong>使用</strong></p><ol><li><p>首先在子组件中做定义一个按钮或者触发这个事件的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendHandle&quot;</span>&gt;</span>sendData<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并且定义函数 <code>sendHandle</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sendHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&quot;onEvent&quot;</span>, <span class="string">&quot;data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在父组件中加载该组件时，需要做如下的定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">props_test</span> @<span class="attr">onEvent</span>=<span class="string">&quot;getDataHandle&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意，这里的 <code>onEvent</code> 与第一步中的 <code>$emit()</code> 的第一个参数是对应的，需要一致。然后自定义收到消息的回调函数，这里的 <code>data</code> 就是上述 <code>$emit()</code> 函数的第二个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getDataHandle</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>每个组件在被创建时都要经过一系列初始化的过程，例如设置数据监听，编译模板，实例挂载到 dom 上等，这个过程会运行一些叫做生命周期钩子的函数，给了用户在不同阶段添加代码的功能</p><p>可以直接定义下面的函数，来实现在不同的阶段添加用户代码的功能</p><ul><li>创建时 <code>beforeCreate</code> <code>created</code></li><li>渲染时 <code>beforeMount</code> <code>mounted</code></li><li>更新时 <code>beforeUpdate</code> <code>updated</code></li><li>卸载时 <code>beforeUnmount</code> <code>unmounted</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css基础</title>
      <link href="/Blog_ButterFly/2024/04/08/css%E5%9F%BA%E7%A1%80/"/>
      <url>/Blog_ButterFly/2024/04/08/css%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/Web.git">代码</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSS 是层叠样式表，又叫级联样式表，后缀名为 <code>.css</code> ，用于是 <code>html</code> 中元素样式的定义</p><p>CSS 的主要作用是为了让网页具有美观一致的页面</p><h2 id="导入到html"><a href="#导入到html" class="headerlink" title="导入到html"></a>导入到html</h2><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>要使用内联样式，需要在相关标签内使用 <code>style</code> 属性，其中的 <code>style</code> 属性可以包含任何 CSS 属性</p><p>但是缺乏整体性和规划性，不利于维护，维护成本高</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background-color: green; color:red&quot;</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><p>当单个文档需要特殊样式时，就应该使用内部样式表，可以使用 <code>&lt;style&gt;</code> 标签在文档头部定义内部样式表</p><p>这使得单个页面内的 CSS 代码具有统一性和维护性，便于维护，但是在多个页面之间容易混乱</p><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><p>实际上是引入外部 <code>css</code> 文件作为不同网页的统一样式，可以实现通过改变一个文件来改变整体的样式，需要注意的是， <code>link</code> 标签在文档的头部才能引入，可以链接到样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>CSS 语法由两个主要部分构成，选择器以及一条或多条声明臭傻逼</p><ul><li>选择器：通常是需要改变样式的 <code>html</code> 元素</li><li>每条声明由一个属性和一个值组成<ul><li>属性：是希望设置的样式属性</li><li>值：就是属性的值，属性和值被冒号分开</li></ul></li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p><strong>全局选择器</strong></p><p>可以与任何元素匹配，优先级最低，一般做样式初始化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>元素选择器</strong></p><p>选择 <code>html</code> 文档中的元素，标签选择器，就是选择的是页面上的所有这种类型的标签，经常描述共性，无法描述某个元素的个性</p><p>所有的标签都可以是选择器，而且选择的所有这种类型的标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类选择器</strong></p><p>规定使用圆点来定义，针对希望的所有标签来使用，比较灵活，可以自己定义，优先级较高</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个类选择器可以被多种标签使用，类名不能以数字开头，同一个标签可以使用多个类选择器，用空格隔开</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;c1 c2&quot;</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>ID选择器</strong></p><p>针对某一个特定的标签来使用，只能使用一次，使用 <code>#</code> 来定义，需要注意的是，id 是唯一的，也就是一个标签只能有一个 id，并且不能是数字开头</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;h2id1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#h2id1</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合并选择器</strong></p><p>用于提取共同样式，减少重复代码</p><p>语法： <code>选择器1,选择器2...&#123;&#125;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>, <span class="selector-tag">b</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择器的优先级</strong></p><p>CSS 中权重用数字衡量</p><ul><li>元素选择器：1</li><li>class选择器：10</li><li>id选择器：100</li><li>内联样式选择器：1000</li></ul><p>优先级从高到低：内联样式选择器 &gt; id选择器 &gt; class选择器 &gt; 元素选择器</p><h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><ul><li><code>color</code> 字体颜色，有多种书写样式<ul><li>颜色名 <code>red</code></li><li>16进制表示 <code>#ff0000</code></li><li>rgb 表示rgb值 <code>rgb()</code> ，其中每个参数的取值范围是 <code>0~255</code></li><li>rgba 表示rgb值和透明度 <code>rgba()</code> ，透明度的取值范围是 <code>0~1</code></li></ul></li><li><code>font-size</code> 字体大小</li><li><code>font-weight</code> 字体宽度，设置文本的粗细<ul><li><code>bold</code> 定义粗体</li><li><code>bolder</code> 定义更粗的字体</li><li><code>lighter</code> 定义更细的字体</li><li><code>100~900</code> 定义由细到粗的字体 <code>400</code> 为默认， <code>700</code> 等同 <code>bold</code></li></ul></li><li><code>font-style</code> 指定字体样式<ul><li><code>normal</code> 默认值</li><li><code>italic</code> 斜体字</li></ul></li><li><code>font-family</code> 指定一个元素的字体，多个字体之间通过逗号隔开，如果每个字体名称包含空格，必须加上引号</li></ul><h3 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h3><ul><li><code>background-color</code> 设置背景颜色，</li><li><code>background-image</code> 设置背景图片，元素的背景是元素的总大小，包括填充和边界，默认情况下的 <code>background-image</code> 属性放在元素的左上角，如果图像不够大的话会在垂直方向和水平方向平铺图像，如果图像太大，超过元素大小，就显示图像左上角的部分</li><li><code>background-position</code> 设置背景图片显示位置</li><li><code>background-repeat</code> 设置背景图片如何填充<ul><li><code>repeat</code> 平铺</li><li><code>repeat-x</code> x 轴平铺</li><li><code>repeat-y</code> y 轴平铺</li><li><code>no-repeat</code> 不平铺</li></ul></li><li><code>background-size</code> 设置背景图片大小属性<ul><li><code>length</code> 设置背景图片的宽度和高度，第一个宽度，第二个高度，若只设置一个，另一个为 auto</li><li><code>percentage</code> 计算相对位置区域的百分比，第一个宽度，第二个高度，只设置一个另一个为 auto</li><li><code>cover</code> 保持图片纵横比并将图片缩放成完全覆盖背景区域的最小大小</li><li><code>contain</code> 保持图片横纵比并将图片缩放为合适背景定位区域的最大大小</li></ul></li><li><code>background-position</code> 设置背景图片的起始位置，默认为 <code>0%0%</code><ul><li><code>left</code> 左</li><li><code>center</code> 中</li><li><code>right</code> 右</li><li><code>top</code> 上</li><li><code>center</code> 中</li><li><code>bottom</code> 下</li><li><code>x%y%</code> 其中 <code>0%0%</code> 为左上角</li></ul></li></ul><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><ul><li><code>text-align</code> 指定元素文本的对齐方式<ul><li><code>left</code> 文本居左排列，为默认值</li><li><code>right</code> 文本居右</li><li><code>center</code> 文本居中</li></ul></li><li><code>text-decoration</code> 规定添加到文本的修饰，下划线，上划线，删除线等<ul><li><code>underline</code> 下划线</li><li><code>overline</code> 上划线</li><li><code>line-through</code> 删除线</li></ul></li><li><code>text-transform</code> 控制文本的大小写<ul><li><code>captialize</code> 每个单词开头大写</li><li><code>uppercase</code> 全部大写</li><li><code>lowercase</code> 全部小写</li></ul></li><li><code>text-indent</code> 定义文本块中首行文本缩进的多少</li></ul><h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><ul><li><code>border</code> 表格边框，有三个参数 线宽+线形+颜色</li><li><code>border-collapse</code> 定义表格边框是否被折叠成一个单一的边框或者隔开</li><li><code>width</code> 表格的宽度</li><li><code>height</code> 表格的高度</li><li><code>text-align</code> 设置表格文本对齐方式</li><li><code>padding</code> 表格填充，设置表格中内容距离边框的距离，一般使用 <code>td</code> 和 <code>th</code> 元素的填充属性</li><li><code>background-color</code> 背景颜色</li><li><code>color</code> 文本颜色</li></ul><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><p><strong>分类</strong></p><ul><li>后代选择器：选择被元素E包含的所有F元素中间空格隔开 <code>E F&#123;&#125;</code></li><li>子代选择器：选择作为 E 元素的直接子元素 F ，中间用 <code>&gt;</code> 符号， <code>E&gt;F&#123;&#125;</code></li><li>相邻兄弟选择器：选择紧跟在 E 元素之后的 F 元素，用加号表示，选择相邻的第一个兄弟元素，只能向下选择 <code>E+F&#123;&#125;</code></li><li>通用兄弟选择器：选择在元素 E 之后的所有 F 元素，作用于多个元素，用 <code>~</code> 隔开 <code>E~F&#123;&#125;</code></li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>所有的 <code>html</code> 元素可以看作是个盒子，在 <code>css</code> 中， <code>box model</code> 这一术语是在设计和布置时使用， <code>css</code> 盒模型本质上是一个盒子，封装周围的 <code>html</code> 元素，包括</p><ul><li><code>margin</code> 外边距，清除边框外的区域，外边距是透明的，距离窗体左上角的距离，第一个参数是上下，第二个是左右，默认上下与左右一致</li><li><code>border</code> 边框，围绕在内边距和内容外的边框，与表格的边框一致</li><li><code>padding</code> 内边框，清除内容周围的区域，内边距是透明的，实际上就是把原来贴着左上角的元素的周边给扩大了，有两个参数，第一个是上下，第二个是左右，默认上下与左右一致</li><li><code>content</code> 实际内容，盒子的内容，显示文本和图像</li></ul><p><img src="/Blog_ButterFly/2024/04/08/css%E5%9F%BA%E7%A1%80/1712402139588.png" alt="box model"></p><h3 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h3><p>是 CSS3 的一种新的布局方式，是一种当前页面需要适应不同的屏幕大小以及设备类型时，需要保证元素有恰当的布局方式，引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列，对齐和分配空白空间</p><p>由弹性容器和弹性子元素组成，弹性容器通过设置 <code>display</code> 属性值为 <code>flex</code> 将其定义为弹性容器，弹性容器内包含了一个或多个弹性子元素，弹性容器之外以及弹性元素之内都是正常渲染的，弹性容器只是定义了弹性子元素如何在弹性容器内布局</p><p><strong>container属性</strong></p><ul><li><code>display</code> 为 <code>flex</code> 开启弹性盒，子元素默认水平排列</li><li><code>flex-direction</code> 指定了弹性子元素在父容器中的位置<ul><li><code>row</code> 横向从左到右排列，左对齐，默认</li><li><code>row-reverse</code> 横向从右到左排列，右对齐</li><li><code>column</code> 纵向排列</li><li><code>column-reverse</code> 纵向从后往前排列</li></ul></li><li><code>justify-content</code> 内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴对齐<ul><li><code>flex-start</code> 弹性项目向行头紧挨着填充，默认值，第一个弹性项的 <code>main-start</code> 外边距边线被放置在该行的 <code>main-start</code> 边线，而后续弹性项依次水平排列</li><li><code>flex-end</code> 弹性项目向行尾紧挨着填充，第一个弹性项的 <code>main-end</code> 外边距边线被放置在该行的 <code>main-end</code> 的外边距边线上，后续弹性项依次水平摆放</li><li><code>center</code> 弹性项目居中紧挨着填充，若剩余自由空间是负的，会在两侧溢出</li></ul></li><li><code>align-items</code> 设置或检索弹性盒子元素在侧轴方向上的对齐<ul><li><code>flex-start</code> 弹性盒子元素的侧轴起始位置的边界紧靠该行侧轴的起始边界</li><li><code>flex-end</code> 弹性盒子元素的侧轴结束位置的边界紧靠该行侧轴的结束边界</li><li><code>center</code> 弹性盒子元素在该行的侧轴上居中放置，溢出也是两个方向</li></ul></li></ul><h3 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h3><ul><li><code>flex-grow</code> 根据弹性盒子所设置的扩展因子作为比率来分配剩余空间，默认为 0，也就是不会扩大，如果只有一个元素设置，那就按照扩展因子转化的百分比对其分配空间</li></ul><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>文档流是文档中可显示对象在排列时所占用的空间，例如块元素时从上到下放置，内联元素从左到右放置，标准流中限制太多导致很多方法实现不了</p><p><strong>高矮不齐，底边对齐</strong></p><p>对于文本元素与图片元素的对齐，使用段落标签无法对齐，只能使用 <code>&lt;span&gt;</code> 标签</p><p><strong>空白折叠现象</strong></p><p>无论写多少个空格，换行。tab等符号，都会折叠为一个空格</p><p><strong>元素无空隙</strong></p><p>想要元素之间无空隙，必须两个元素在同一行，并且中间无空隙</p><p><strong>脱离文档流</strong></p><p>使一个元素脱离文档流有三种方式</p><ul><li>浮动</li><li>绝对定位</li><li>固定定位</li></ul><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>增加一个浮层来定位， <code>float</code> 属性定义元素在那个方向浮动，任何元素都可以浮动</p><ul><li><code>left</code> 元素向左浮动</li><li><code>right</code> 元素向右浮动</li></ul><p><strong>原理</strong></p><ul><li>浮动之后使得元素脱离了文档流</li><li>浮动只有左右浮动，没有上下浮动</li><li>脱离文档流之后，元素相当于在页面上增加一个浮层来放置内容，可以理解为有两层界面，在原页面之上又有一个浮动层</li><li>当所有元素浮动时，会变成水平摆放，向左或者向右</li><li>当容器元素不足以横向摆放内容时，会在下一行摆放</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p><strong>缺点</strong></p><ul><li>浮动元素造成父元素高度塌陷</li><li>后续元素也会受到影响</li></ul><p><strong>方法</strong></p><ul><li>父元素设置高度，撑开元素本身</li><li>受影响的元素增加 <code>clear</code> 属性，清除影响</li><li><code>overflow</code> 清除浮动，在父级标签中加 <code>overflow:hidden</code> ，但是父级标签不能设置高度，针对父级塌陷</li><li>伪对象方式：如果有父级塌陷并且同级元素也受到了影响，可以使用为对象，也就是为父级添加标签伪类，设置空的内容，并且使用 <code>clear:both</code> 。并且这种情况下，父布局不能设置高度</li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p><code>position</code> 属性制定了元素的定位类型，一般来说如果出现了压盖的现象，那就是脱离了文档流</p><div class="table-container"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>relative</td><td>相对定位</td></tr><tr><td>absolue</td><td>绝对定位</td></tr><tr><td>fixed</td><td>固定定位</td></tr></tbody></table></div><p>其中绝对定位和固定定位会脱离文档流，设置完定位方式之后，可以使用以下四个方向来进行调整位置</p><ul><li><code>left</code></li><li><code>right</code></li><li><code>top</code></li><li><code>bottom</code></li></ul><p><strong>相对定位</strong></p><p>就是相对于屏幕的位置之后再根据其它布局的位置进行改变</p><p><strong>绝对位置</strong></p><p>就是相对于窗口的位置，会导致某些布局的重合</p><p><strong>固定位置</strong></p><p>固定在某一个位置，有点像固定位置，但是脱离了文档流，会随着页面的滚动一直停留在那个位置</p><p><strong>注意</strong></p><p>设置定位之后，相对定位和绝对定位是相对于具有定位的父级元素进行位置调整，会逐层往上找，直到找到具有定位的父层元素，或者直到文章顶层</p><p>可以使用语句 <code>margin: 0 auto</code> 实现左右居中</p><h3 id="Z-index"><a href="#Z-index" class="headerlink" title="Z-index"></a>Z-index</h3><p>设置元素的堆叠顺序，更高堆叠顺序的元素总是会处于更低的堆叠顺序的元素前面</p><h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><p><code>border-radius</code> 圆角，给任何元素添加圆角，可以使用以下规则</p><ul><li>四个值：左上+右上+右下+左下</li><li>三个值：左上+右上左下+右下</li><li>两个值：左上右下+右上左下</li><li>一个值：四个圆角相同</li></ul><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li><code>box-shadow</code> 向框内添加一个或者多个阴影</li><li><code>text-shadow</code> 给文字添加阴影</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow bulr color</span><br><span class="line">text-shadow: h-shadow v-shadow bulr color</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>h-shadow</code> 水平阴影位置，必选，正为向下</li><li><code>v-shadow</code> 垂直阴影位置，必选，正为向左</li><li><code>blur</code> 阴影的模糊距离，给阴影添加一个模糊效果，可选</li><li><code>color</code> 阴影的颜色，可选</li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>动画是元素从一种样式逐渐变化到另一种样式的效果，可以改变任意多的样式和任意多的次数，用百分比来规定变化发生的时间，或用 <code>from</code> 和 <code>to</code> 表示，等同于 <code>0%</code> 和 <code>100%</code> 。用 <code>@keyframes</code> 规则来创建动画</p><p>使用 <code>animation</code> 使用动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation</span>: name duration timing-function delay iteration-count direction</span><br></pre></td></tr></table></figure><ul><li><code>name</code> 动画名称</li><li><code>duration</code> 持续时间</li><li><code>timing-function</code> 设置动画速率<ul><li><code>ease</code> 逐渐变慢（默认）</li><li><code>linear</code> 匀速</li><li><code>ease-in</code> 加速</li><li><code>ease-out</code> 减速</li><li><code>ease-in-out</code> 先加速后减速</li></ul></li><li><code>delay</code> 设置动画开始时间（延时执行）</li><li><code>iteration-count</code> 循环次数， <code>infinite</code> 表示无限次</li><li><code>direction</code> 播放的方向<ul><li><code>normal</code> 表示向前播放</li><li><code>alternate</code> 动画在第偶数次向前播放，奇数次向后播放</li></ul></li><li><code>animation-play-state</code> 动画播放的状态， <code>running</code> 表示播放， <code>paused</code> 表示停止</li></ul><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>主要使得页面根据设备的大小，自动识别加载不同的样式</p><p><strong>设置meta标签</strong></p><p>使用设备的宽度作为视图宽度并且禁止初始的缩放，在 <code>&lt;head&gt;</code> 标签内加入这个 <code>meta</code> 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>width=device-width</code> 宽度等于当前设备宽度</li><li><code>initial-scale</code> 初始缩放比例，默认为 1</li><li><code>maximum-scale</code> 允许用户缩放到的最大比例</li><li><code>user-scalable</code> 用户是否可以手动缩放</li></ul><h3 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h3><p>CSS Sprite 就是 CSS 精灵图，是一种网页图片的应用处理方式，允许将一个页面所涉及到的所有零星图片都包含到一张大图上去</p><p><strong>优点</strong></p><ul><li>可以减少图片的字节</li><li>减少网页的 <code>http</code> 请求，从而提高网页性能</li></ul><p><strong>原理</strong></p><ul><li>通过 <code>background-image</code> 引入背景图片</li><li>通过 <code>background-position</code> 将背景图片移到需要的地方</li></ul><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p>可以使用字体图标来代替图片，以此来解决图片占用资源的问题</p><p><strong>优点</strong></p><ul><li>轻量性：加载速度快，减少 <code>http</code> 请求</li><li>灵活性：可以利用 <code>css</code> 设置大小颜色等属性</li><li>兼容性：网页字体支持所有现代浏览器</li></ul><p><strong>使用字体图标</strong></p><p>从阿里字体图标库下载字体图标，然后将其中除了 <code>demo</code> 的文件之外都移入项目中的 <code>font</code> 文件中，然后在 <code>css</code> 中使用。但是需要注意的是，给这个图标类设置字体图标大小会发现这个属性被覆盖掉了，所以可以再给它一个类名，然后给那个类名设置大小就可以了</p><h3 id="旋转缩放拉伸倾斜"><a href="#旋转缩放拉伸倾斜" class="headerlink" title="旋转缩放拉伸倾斜"></a>旋转缩放拉伸倾斜</h3><ul><li><code>translate()</code> 根据 x 轴和 y 轴给定的参数，从当前元素位置移动</li><li><code>rotate()</code> 绕 Z 轴旋转，负值表示逆时针</li><li><code>rotateX()</code> 绕 X 轴旋转</li><li><code>rotateY()</code> 绕 Y 轴旋转</li><li><code>scale()</code> 该元素向着某个方向缩放的比例，第一个参数为 x 轴，第二个参数为 y 轴</li><li><code>skew()</code> 包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜，从中有两个函数 <code>skewX()</code> 和 <code>skewY()</code> 表示在 X 轴和 Y 轴上的倾斜</li><li><code>matrix()</code> 方法有六个参数，包含 z 轴旋转，缩放，平移和倾斜</li><li><code>transform-origin</code> 设置旋转元素的基点属性</li></ul><h3 id="过渡属性"><a href="#过渡属性" class="headerlink" title="过渡属性"></a>过渡属性</h3><p>相当于是一种简单的动画</p><ul><li><code>transition</code> 简写属性，用于在一个属性中设置四个过渡属性</li><li><code>transition-property</code> 规定应用过渡的 CSS 属性的名称</li><li><code>transition-duration</code> 定义过渡效果花费的时间。默认是 0</li><li><code>transition-timing-function</code> 规定过渡效果的时间曲线。默认是 <code>ease</code></li><li><code>transition-delay</code> 规定过渡效果何时开始。默认是 0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html基础</title>
      <link href="/Blog_ButterFly/2024/04/08/html%E5%9F%BA%E7%A1%80/"/>
      <url>/Blog_ButterFly/2024/04/08/html%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/Web.git">代码</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>html 是一种描述网页的语言，是一种超文本标记语言，是一套标记标签，标签是被尖括号包围的关键字</p><p>html 需要有 <code>DOCTYPE</code> 的声明，是文档类型的缩写，声明位于文档最前面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><p>定义 html 文档，这个元素是一种声明文档为 html ，而且其他的元素必须包含在内，限定文档的开始和结束</p><h3 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h3><p>用于定义文档的头部，文档的头部描述了文档的各种属性和信息，包括文档的标题，在 web 中的位置以及其他和文档的关系等。大部分内容都不会被看到</p><h3 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h3><p>定义文档的主体，元素包含文档的所有内容，比如文本，图像等，会在页面中直接显示</p><h3 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h3><p>可以定义文档的标题，显示在浏览器窗口的标题栏或者状态栏上，是在 <code>head</code> 标签中必须要包含的标签， <code>title</code> 标签有利于 <code>SEO</code> 优化</p><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p>用来描述一个网页文档的属性，关键词等</p><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p>标题是通过 <code>&lt;h1&gt;~&lt;h6&gt;</code> 标签进行定义的，其中 <code>&lt;h1&gt;</code> 定义最大的标题， <code>&lt;h6&gt;</code> 定义最小的标题</p><p>其中生成标题的快捷键 <code>h$*1</code> ~ <code>h$*6</code></p><p>在标签中添加属性 <code>align=&quot;left|center|right&quot;</code> 默认为居左</p><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><p>段落是通过 <code>&lt;p&gt;</code> 标签定义的</p><p>标签中使用 <code>&lt;br&gt;</code> 进行换行，单标签</p><h3 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h3><p>水平线通过 <code>&lt;hr&gt;</code> 标签创建的，单标签</p><p><strong>属性</strong></p><ul><li><code>color</code> 颜色</li><li><code>width</code> 长度</li><li><code>size</code> 高度</li><li><code>align</code> 对齐方式 <code>left|center|right</code> 默认为 <code>center</code></li></ul><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><p>图片使用 <code>&lt;img&gt;</code> 标签定义，单标签</p><p><strong>属性</strong></p><ul><li><code>src</code> 图片路径</li><li><code>alt</code> 图像的替代文本，也就是图像不能正常显示时所显示的文字</li><li><code>title</code> 鼠标悬停在图像上时显示的提示</li><li><code>width</code> 规定图像的宽度</li><li><code>height</code> 规定图像的高度</li></ul><h3 id="超文本链接标签"><a href="#超文本链接标签" class="headerlink" title="超文本链接标签"></a>超文本链接标签</h3><p>使用 <code>&lt;a&gt;</code> 来设置超文本链接，超链接可以时一个字，一个词，也可以是一幅图，可以点击跳转到新的文档或者是当前文档的某一部分，可以在 <code>&lt;a&gt;</code> 标签的内部添加标题或者是图片来进行跳转</p><p><strong>属性</strong></p><ul><li><code>href</code> 用来描述链接的地址，一般来说，链接将以以下形式出现在浏览器中<ul><li>未访问过的：蓝色字体带下划线</li><li>访问过的，紫色字体带下划线</li><li>点击时，链接显示为红色带下划线</li></ul></li><li><code>target</code> 用来表示链接打开时的表现<ul><li><code>_parent</code> 在本页面打开</li><li><code>_blank</code> 在新页面打开</li><li><code>_self</code> 在本页面打开</li><li><code>_top</code> 在本页面打开</li></ul></li></ul><h3 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h3><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;em&gt;</code></td><td>定义着重文字</td></tr><tr><td><code>&lt;b&gt;</code></td><td>定义粗体</td></tr><tr><td><code>&lt;i&gt;</code></td><td>斜体</td></tr><tr><td><code>&lt;strong&gt;</code></td><td>加重语气</td></tr><tr><td><code>&lt;del&gt;</code></td><td>删除字</td></tr><tr><td><code>&lt;span&gt;</code></td><td>元素没有特定含义</td></tr></tbody></table></div><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>是一列项目，列表项目使用数字进行标记，有序列表用 <code>&lt;ol&gt;</code> 表示，其中的每个元素用 <code>&lt;li&gt;</code> 表示，列表是可以嵌套的。无序列表可以嵌套。生成的快捷键 <code>ol&gt;li*n</code> 这里的 <code>n</code> 表示生成几个元素</p><p><strong>属性</strong></p><ul><li><code>type</code> 属性，表示列表的显示类型<ul><li><code>1</code> 表示列表用数字标号</li><li><code>a</code> 表示列表用小写字母标号</li><li><code>A</code> 表示列表用大写字母标号</li><li><code>i</code> 表示列表用小写罗马数字标号</li><li><code>I</code> 表示列表用大写罗马数字标号</li></ul></li></ul><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表是一个项目的列表，项目使用醋圆点标记，用 <code>&lt;ul&gt;</code> 表示，其中每个元素用 <code>&lt;li&gt;</code> 表示，无序列表可以嵌套。生成的快捷键 <code>ul&gt;li*n</code> 这里的 <code>n</code> 表示生成几个元素</p><p><strong>属性</strong></p><ul><li><code>type</code> 表示列表的显示类型<ul><li><code>disc</code> 默认实心圆</li><li><code>circle</code> 空心圆</li><li><code>square</code> 小方块</li><li><code>none</code> 不显示</li></ul></li></ul><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p>使用 <code>&lt;dl&gt;</code> 属性表示定义列表，自定义列表不仅仅是一列项目，而是项目及其注释的组合，自定义列表以 <code>&lt;dl&gt;</code> 标签开始。每个自定义列表项以 <code>&lt;dt&gt;</code> 开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code> 开始</p><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p>表格用来展示数据非常方便简单，使用 <code>&lt;table&gt;</code> 标签表示，快捷生成 <code>table&gt;tr*m&gt;td*n&#123;content&#125;</code> 表示生成 m * n 的表格</p><p><strong>组成</strong></p><ul><li>行 <code>&lt;tr&gt;</code></li><li>列 <code>&lt;td&gt;</code></li><li>单元格</li></ul><p><strong>属性</strong></p><ul><li><code>border</code> 单个表格的边框</li><li><code>width</code> 单个表格宽度</li><li><code>height</code> 单个表格高度</li></ul><p><strong>单元格合并</strong></p><ul><li><code>colspan</code> 水平合并 保留左边，删除右边</li><li><code>rowspan</code> 垂直合并 保留上边，删除下边</li></ul><h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><p>在 web 网页中用来给用户填写信息，从而采集用户信息，是一个输入框，一个表单是由容器和控件组成的，一般应该包含用户填写信息的输入框，提交按钮，表单就是容器，能容纳各种各样的控件</p><p><strong>属性</strong></p><ul><li><code>action</code> 是服务器地址</li><li><code>name</code> 表单名称</li><li><code>method</code> 中 <code>get</code> 或 <code>post</code> 申请，是数据提交方式， <code>get</code> 提交的数据可以被 <code>url</code> 看到，但是 <code>post</code> 不能，一般 <code>get</code> 提交少数据， <code>post</code> 提交大数据</li></ul><p><strong>表单元素</strong></p><ul><li>表单标签</li><li>表单域 <code>&lt;input type=&quot;text&quot;&gt;</code></li><li>表单按钮 <code>&lt;input type=&quot;submit&quot;&gt;</code> 点击之后表单的内容会传递到另一个文件，表单的动作属性定义了目的文件的文件名</li><li>密码 <code>&lt;input type=&quot;password&quot;&gt;</code></li></ul><h3 id="块元素与内联元素"><a href="#块元素与内联元素" class="headerlink" title="块元素与内联元素"></a>块元素与内联元素</h3><p>在 HTML5 中。元素的分类为</p><ul><li>元数据型</li><li>区块型</li><li>标题型</li><li>文档流型</li><li>语句型</li><li>内嵌型</li><li>交互型</li></ul><p>元素不属于任何一种类型，被称为穿透的，元素属于不止一个类别，被称为混合的。上述的分类太细了，所以这里只说明块级元素与内联元素的区别</p><div class="table-container"><table><thead><tr><th>块级元素</th><th>内联元素</th></tr></thead><tbody><tr><td>块元素会在页面中单独占据一行</td><td>行内元素不会占据一行，只占自身大小</td></tr><tr><td>可以设置 width 和 height 属性</td><td>设置 width 与 height 元素无效</td></tr><tr><td>一般块级元素可以包含行内元素与其它块级元素</td><td>一般内联元素包含内联元素，但不包含块级元素</td></tr></tbody></table></div><p><strong>块级元素</strong></p><ul><li><code>&lt;div&gt;</code></li><li><code>&lt;form&gt;</code></li><li><code>&lt;h1&gt;~&lt;h6&gt;</code></li><li><code>&lt;hr&gt;</code></li><li><code>&lt;p&gt;</code></li><li><code>&lt;table&gt;</code></li><li><code>&lt;ul&gt;</code></li></ul><p><strong>内联元素</strong></p><ul><li><code>&lt;a&gt;</code></li><li><code>&lt;b&gt;</code></li><li><code>&lt;em&gt;</code></li><li><code>&lt;i&gt;</code></li><li><code>&lt;span&gt;</code></li><li><code>&lt;strong&gt;</code></li></ul><p><strong>行内块级元素</strong></p><ul><li><code>&lt;button&gt;</code></li><li><code>&lt;img&gt;</code></li><li><code>&lt;input&gt;</code></li></ul><h3 id="容器div标签"><a href="#容器div标签" class="headerlink" title="容器div标签"></a>容器div标签</h3><p>使用 <code>&lt;div&gt;</code> 表示，内部有 <code>id</code> 属性，用于定义 <code>div</code> 的类型</p><ul><li><code>header</code> 表示为头</li><li><code>nav</code> 表示导航栏</li><li><code>article</code> 文章</li><li><code>section</code> 章节属于 <code>article</code> 的子元素</li><li><code>silder</code> 侧边栏</li><li><code>footer</code> 脚部</li></ul><p><strong>替代div的一些标签</strong></p><ul><li><code>&lt;header&gt;</code> 头部</li><li><code>&lt;nav&gt;</code> 导航</li><li><code>&lt;section&gt;</code> 定义文档中的节，比如章节，页眉页脚等</li><li><code>&lt;aside&gt;</code> 侧边栏</li><li><code>&lt;footer&gt;</code> 脚部</li><li><code>&lt;article&gt;</code> 代表一个独立的完整的相关内容块</li></ul><h3 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h3><p>框架标签，可以使得再同一个浏览器窗口中显示不止一个页面，也就是网页嵌套</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;./image.html&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://seashore.top&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>seashore.top<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>src</code> 就是显示的另一个网页</li><li><code>width</code> 和 <code>height</code> 显示页面的大小</li><li><code>frameborder</code> 边框的线宽</li></ul><h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><p>在 <code>html</code> 中，某些字符是预留的，不能使用，所以必须在源码中使用字符实体来使用该标签，可以直接使用实体名称，也可以使用实体编号，但是有些浏览器对实体名称支持不很好</p><div class="table-container"><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>实体编号</th></tr></thead><tbody><tr><td></td><td>空格</td><td><code>&amp;nbsp;</code></td><td><code>&amp;#160;</code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&amp;lt;</code></td><td><code>&amp;#60;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&amp;gt;</code></td><td><code>&amp;#62;</code></td></tr><tr><td>&amp;</td><td>和号</td><td><code>&amp;amp;</code></td><td><code>&amp;#38;</code></td></tr><tr><td>“</td><td>引号</td><td><code>&amp;quot;</code></td><td><code>&amp;#34;</code></td></tr><tr><td>‘</td><td>撇号</td><td><code>&amp;apos;</code> (IE不支持)</td><td><code>&amp;#39;</code></td></tr><tr><td>￠</td><td>分</td><td><code>&amp;cent;</code></td><td><code>&amp;#162;</code></td></tr><tr><td>£</td><td>镑</td><td><code>&amp;pound;</code></td><td><code>&amp;#163;</code></td></tr><tr><td>¥</td><td>人民币/日元</td><td><code>&amp;yen;</code></td><td><code>&amp;#165;</code></td></tr><tr><td>€</td><td>欧元</td><td><code>&amp;euro;</code></td><td><code>&amp;#8364;</code></td></tr><tr><td>§</td><td>小节</td><td><code>&amp;sect;</code></td><td><code>&amp;#167;</code></td></tr><tr><td>©</td><td>版权</td><td><code>&amp;copy;</code></td><td><code>&amp;#169;</code></td></tr><tr><td>®</td><td>注册商标</td><td><code>&amp;reg;</code></td><td><code>&amp;#174;</code></td></tr><tr><td>™</td><td>商标</td><td><code>&amp;trade;</code></td><td><code>&amp;#8482;</code></td></tr><tr><td>×</td><td>乘号</td><td><code>&amp;times;</code></td><td><code>&amp;#215;</code></td></tr><tr><td>÷</td><td>除号</td><td><code>&amp;divide;</code></td><td><code>&amp;#247;</code></td></tr></tbody></table></div><h3 id="结合音标符"><a href="#结合音标符" class="headerlink" title="结合音标符"></a>结合音标符</h3><p>类似于上述的字符实体，这个是加到字母上的一个字形，变音符号可以出现在字母的上面和下面，或者字母里和字母之间，可以与字母，数字字符组合使用</p><div class="table-container"><table><thead><tr><th>音标符</th><th>字符</th><th>代码</th><th>输出结果</th></tr></thead><tbody><tr><td>̀</td><td>a</td><td><code>a&amp;#768;</code></td><td>à</td></tr><tr><td>́</td><td>a</td><td><code>a&amp;#769;</code></td><td>á</td></tr><tr><td>̂</td><td>a</td><td><code>a&amp;#770;</code></td><td>â</td></tr><tr><td>̃</td><td>a</td><td><code>a&amp;#771;</code></td><td>ã</td></tr><tr><td>̀</td><td>O</td><td><code>O&amp;#768;</code></td><td>Ò</td></tr><tr><td>́</td><td>O</td><td><code>O&amp;#769;</code></td><td>Ó</td></tr><tr><td>̂</td><td>O</td><td><code>O&amp;#770;</code></td><td>Ô</td></tr><tr><td>̃</td><td>O</td><td><code>O&amp;#771;</code></td><td>Õ</td></tr></tbody></table></div><h3 id="canvas元素"><a href="#canvas元素" class="headerlink" title="canvas元素"></a>canvas元素</h3><p><code>&lt;canvas&gt;</code> 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API</p><h3 id="新多媒体元素"><a href="#新多媒体元素" class="headerlink" title="新多媒体元素"></a>新多媒体元素</h3><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;audio&gt;</code></td><td>定义音频内容</td></tr><tr><td><code>&lt;video&gt;</code></td><td>定义视频（video 或者 movie）</td></tr><tr><td><code>&lt;source&gt;</code></td><td>定义多媒体资源 video 和 audio</td></tr><tr><td><code>&lt;embde&gt;</code></td><td>定义嵌入的内容，比如插件。</td></tr><tr><td><code>&lt;track&gt;</code></td><td>为诸如 video 和 audio 元素之类的媒介规定外部文本轨道。</td></tr></tbody></table></div><h3 id="新表单元素"><a href="#新表单元素" class="headerlink" title="新表单元素"></a>新表单元素</h3><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;datalist&gt;</code></td><td>定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。</td></tr><tr><td><code>&lt;keygen&gt;</code></td><td>规定用于表单的密钥对生成器字段。</td></tr><tr><td><code>&lt;output&gt;</code></td><td>定义不同类型的输出，比如脚本的输出。</td></tr></tbody></table></div><h3 id="新语义和结构元素"><a href="#新语义和结构元素" class="headerlink" title="新语义和结构元素"></a>新语义和结构元素</h3><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;article&gt;</code></td><td>定义页面独立的内容区域。</td></tr><tr><td><code>&lt;aside&gt;</code></td><td>定义页面的侧边栏内容。</td></tr><tr><td><code>&lt;bdi&gt;</code></td><td>允许您设置一段文本，使其脱离其父元素的文本方向设置。</td></tr><tr><td><code>&lt;command&gt;</code></td><td>定义命令按钮，比如单选按钮、复选框或按钮</td></tr><tr><td><code>&lt;details&gt;</code></td><td>用于描述文档或文档某个部分的细节</td></tr><tr><td><code>&lt;dialog&gt;</code></td><td>定义对话框，比如提示框</td></tr><tr><td><code>&lt;summary&gt;</code></td><td>标签包含 details 元素的标题</td></tr><tr><td><code>&lt;figure&gt;</code></td><td>规定独立的流内容（图像、图表、照片、代码等等）。</td></tr><tr><td><code>&lt;figcaption&gt;</code></td><td>定义 figure 元素的标题</td></tr><tr><td><code>&lt;footer&gt;</code></td><td>定义 section 或 document 的页脚。</td></tr><tr><td><code>&lt;header&gt;</code></td><td>定义了文档的头部区域</td></tr><tr><td><code>&lt;mark&gt;</code></td><td>定义带有记号的文本。</td></tr><tr><td><code>&lt;meter&gt;</code></td><td>定义度量衡。仅用于已知最大和最小值的度量。</td></tr><tr><td><code>&lt;nav&gt;</code></td><td>定义导航链接的部分。</td></tr><tr><td><code>&lt;progress&gt;</code></td><td>定义任何类型的任务的进度。</td></tr><tr><td><code>&lt;ruby&gt;</code></td><td>定义 ruby 注释（中文注音或字符）。</td></tr><tr><td><code>&lt;rt&gt;</code></td><td>定义字符（中文注音或字符）的解释或发音。</td></tr><tr><td><code>&lt;rp&gt;</code></td><td>在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。</td></tr><tr><td><code>&lt;section&gt;</code></td><td>定义文档中的节（section、区段）。</td></tr><tr><td><code>&lt;time&gt;</code></td><td>定义日期或时间。</td></tr><tr><td><code>&lt;wbr&gt;</code></td><td>规定在文本中的何处适合添加换行符。</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GTest使用</title>
      <link href="/Blog_ButterFly/2024/04/02/GTest%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/04/02/GTest%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在编写代码中有 <code>bug</code> 很常见，通过编写完备的<strong>单元测试</strong>，可以及时发现问题，并且在后续的代码改进中持续观测是否引入了新的 <code>bug</code> ，使用 <code>GTest</code> 是一个不错的选择</p><p><code>GTest</code> 可以用作代码的检测，一般来说可以搭配 <code>CTest</code> 来进行测试</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>就是对程序中最小的单元进行测试，最小的可测试单元可以是一个函数，一个调用过程，一个类等</p><p>对于 <code>C/C++</code> 来说，测试一般是一个函数，检测目标函数在所有可能的输入下，函数执行过程和输出是否符合预期</p><p>在测试功能中，每一个单元都是一个可执行文件，实现了 <code>main</code> 函数，所以要在 <code>CMakeLists.txt</code> 中使用 <code>add_test</code> 命令来添加测试用例</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>指的是对一项特定的任务进行测试，体现着测试方案，方法，技术和策略等，包括测试目标，环境，输入数据，步骤，预期结果和测试脚本等</p><p>对于上述单元测试，就是在不同输入下，目标函数的预期执行过程和输出，不同的情形可以有一个或者多个测试用例，编写测试用例<strong>尽量覆盖所有输入情况</strong>，特别是边界值，特殊值和异常</p><h2 id="GTest介绍"><a href="#GTest介绍" class="headerlink" title="GTest介绍"></a>GTest介绍</h2><p>是 Google 开源的一个跨平台的 <code>C++</code> 单元测试框架（ <code>Google Test</code> ），提供了非常丰富的测试断言、判断宏，便于开发者编写测试用例。</p><h2 id="GTest配置"><a href="#GTest配置" class="headerlink" title="GTest配置"></a>GTest配置</h2><p>下载地址 <a href="https://github.com/google/googletest">google-test</a></p><h3 id="安装——linux"><a href="#安装——linux" class="headerlink" title="安装——linux"></a>安装——linux</h3><p>在终端命令行中输入指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgtest-dev</span><br></pre></td></tr></table></figure><p>然后对应的源码会下载到 <code>/usr/src/</code> 文件夹</p><p>进入 <code>/usr/src/</code> 文件夹之后，会看到 <code>gtest</code> 文件夹，进入其中并且执行下列指令（在该文件夹下的操作需要有 <code>root</code> 权限）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir build</span><br><span class="line">cd build</span><br><span class="line">sudo cmake ..</span><br><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>执行结束之后，会在 <code>build</code> 文件夹下看到 <code>lib</code> 文件夹，里面是编译好的静态库文件，进入其中执行以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp libgtest*.a /usr/local/lib</span><br></pre></td></tr></table></figure><p>将静态库文件复制到 <code>lib</code> 目录下，之后就可以在项目中使用 <code>find_package</code> 来找到 <code>gtest</code> 并且使用 <code>target_link_libraries</code> 指令在项目中使用了</p><h3 id="配置——windows"><a href="#配置——windows" class="headerlink" title="配置——windows"></a>配置——windows</h3><p>在 <code>windows</code> 上的配置，可以直接将 <code>GTest</code> 添加到项目中。例如在根目录下新建一个文件夹为 <code>third_party</code> ，下载 <code>realse</code> 版本，并且解压</p><p>需要修改根目录 <code>CMakeLists.txt</code> 文件，使用指令 <code>add_subdirectory</code> 导入 <code>gtest</code> 到项目中，在开启单元测试时，添加 <code>gtest</code> 为子模块，并将对应的头文件路径添加进来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enable_testing()</span><br><span class="line">add_subdirectory(third_party/googletest-release-1.12.1)</span><br><span class="line">include_directories(third_party/googletest-release-1.12.1/googletest/include)</span><br></pre></td></tr></table></figure><p>此时执行 <code>cmake -B build</code> 可以看到构建目录下多了一个 <code>build/third_party/googletest-release-1.12.1</code> ，在构建的目录编译 <code>cmake</code> 之后会在构建的目录下的 <code>lib</code> 文件夹中生成四个库文件</p><ul><li><code>libgtest.a</code> 提供单元测试相关的功能</li><li><code>libgtest_main.a</code> 提供单元测试的主入口，只有链接该库，测试用例就会编译生成可执行文件</li><li><code>libgmock.a</code> 主要提供数据库交互，网络连接等方面的模拟测试</li><li><code>libgmock_main.a</code> 提供数据库交互，网络连接的主入口，只有链接该库，测试用例就会编译生成可执行文件</li></ul><h2 id="GTest语法"><a href="#GTest语法" class="headerlink" title="GTest语法"></a>GTest语法</h2><p><code>gtest</code> 中的断言分为两类</p><h3 id="ASSERT"><a href="#ASSERT" class="headerlink" title="ASSERT_*"></a><code>ASSERT_*</code></h3><p>如果检测出失败就直接退出当前函数</p><ul><li>条件判断<ul><li><code>ASSERT_TRUE(condition);</code>  判断条件是否为真</li><li><code>ASSERT_FALSE(condition);</code>  判断条件是否为假</li></ul></li><li>数值比较<ul><li><code>ASSERT_EQ(val1, val2);</code> 判断是否相等</li><li><code>ASSERT_NE(val1, val2);</code> 判断是否不相等</li><li><code>ASSERT_LT(val1, val2);</code> 判断是否小于</li><li><code>ASSERT_LE(val1, val2);</code> 判断是否小于等于</li><li><code>ASSERT_GT(val1, val2);</code> 判断是否大于</li><li><code>ASSERT_GE(val1, val2);</code> 判断是否大于等于</li></ul></li><li>字符串比较<ul><li><code>ASSERT_STREQ(str1,str2);</code> 判断字符串是否相等</li><li><code>ASSERT_STRNE(str1,str2);</code> 判断字符串是否相等</li><li><code>ASSERT_STRCASEEQ(str1,str2);</code> 判断字符串是否相等，忽视大小写</li><li><code>ASSERT_STRCASENESTREQ(str1,str2);</code> 判断字符串是否不相等，忽视大小写</li></ul></li></ul><h3 id="EXPECT"><a href="#EXPECT" class="headerlink" title="EXPECT_*"></a><code>EXPECT_*</code></h3><p>如果检测失败就发出提示，但是继续执行</p><ul><li>条件判断<ul><li><code>EXPECT_TRUE(condition);</code>  判断条件是否为真</li><li><code>EXPECT_FALSE(condition);</code>  判断条件是否为假</li></ul></li><li>数值比较<ul><li><code>EXPECT_EQ(val1, val2);</code> 判断是否相等</li><li><code>EXPECT_NE(val1, val2);</code> 判断是否不相等</li><li><code>EXPECT_LT(val1, val2);</code> 判断是否小于</li><li><code>EXPECT_LE(val1, val2);</code> 判断是否小于等于</li><li><code>EXPECT_GT(val1, val2);</code> 判断是否大于</li><li><code>EXPECT_GE(val1, val2);</code> 判断是否大于等于</li></ul></li><li>字符串比较<ul><li><code>EXPECT_STREQ(str1,str2);</code> 判断字符串是否相等</li><li><code>EXPECT_STRNE(str1,str2);</code> 判断字符串是否相等</li><li><code>EXPECT_STRCASEEQ(str1,str2);</code> 判断字符串是否相等，忽视大小写</li><li><code>EXPECT_STRCASENESTREQ(str1,str2);</code> 判断字符串是否不相等，忽视大小写</li></ul></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>需要注意的是，在测试项目中需要链接 <code>libgtest</code> ，如果在测试的程序中没有写 <code>main</code> 函数，就需要链接 <code>libgtest_main</code> </p><h3 id="编写测试用例-CMakeLists"><a href="#编写测试用例-CMakeLists" class="headerlink" title="编写测试用例 CMakeLists"></a>编写测试用例 CMakeLists</h3><p>在 <code>src</code> 文件夹下新建一个文件 <code>test.cpp</code> ，并且在其中写入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> _a, <span class="type">int</span> _b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _a + _b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_case_name, test_name) &#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(res, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在根目录下的 <code>CMakeLists.txt</code> 文件中继续写入下列内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(GTEST_LIB gtest gtest_main)</span><br><span class="line"></span><br><span class="line">add_executable(test src/test.cpp)</span><br><span class="line">target_link_libraries(test gtest gtest_main)</span><br><span class="line">add_test(NAME test COMMAND test)</span><br><span class="line">set(CTEST_OUPUT_ON_FAILURE TRUE)</span><br><span class="line">set(GTEST_COLOR TRUE)</span><br></pre></td></tr></table></figure><p>然后进行构建和编译，在根目录中输入如下指令完成构建和编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>然后就可以进行测试， <code>ctest</code> 执行测试</p><p><img src="/Blog_ButterFly/2024/04/02/GTest%E4%BD%BF%E7%94%A8/1712026397325.png" alt="1712026397325.png"></p><h3 id="编写测试程序-g"><a href="#编写测试程序-g" class="headerlink" title="编写测试程序 g++"></a>编写测试程序 g++</h3><p>直接新建源文件 <code>test.cpp</code> ，并且在其中写入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> _a, <span class="type">int</span> _b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _a + _b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_case_name, test_name) &#123;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="built_in">add</span>(<span class="number">10</span>, <span class="number">20</span>), <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="built_in">add</span>(<span class="number">12</span>, <span class="number">318</span>), <span class="number">330</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端执行下列指令，进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test1.cpp -lgtest -lpthread -lgtest_main</span><br></pre></td></tr></table></figure><p>然后运行生成的 <code>a.out</code> 文件，就可以看到测试结果了</p><p><img src="/Blog_ButterFly/2024/04/02/GTest%E4%BD%BF%E7%94%A8/1711853331118.png" alt="1711853331118.png"></p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> GTest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists编写</title>
      <link href="/Blog_ButterFly/2024/04/02/CMakeLists%E7%BC%96%E5%86%99/"/>
      <url>/Blog_ButterFly/2024/04/02/CMakeLists%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CMake是一个跨平台的构建系统，能自动生成各种平台和编译器的构建文件，相对于直接编写 <code>makefile</code> 文件，编写 <code>CMakeLists</code> 文件不需要考虑太多的文件之间的依赖关系，它可以自动帮你管理复杂项目的构建过程，检测依赖关系，生成目标文件，编译静态库和动态库等，减少手动管理的负担</p><p>可以看看这个知乎专题 <a href="https://www.zhihu.com/column/c_1369781372333240320">CMake实践应用专题 - 知乎 (zhihu.com)</a> ，下面的内容几乎都是从这里整理的</p><h2 id="CMake一般使用流程"><a href="#CMake一般使用流程" class="headerlink" title="CMake一般使用流程"></a>CMake<strong>一般使用流程</strong></h2><h3 id="生成构建系统"><a href="#生成构建系统" class="headerlink" title="生成构建系统"></a>生成构建系统</h3><p>通过 <code>cmake</code> 指令生成构建系统，可以在命令行中输入 <code>cmake --help</code> 来看到 <code>cmake</code> 指令支持的详细参数，常用参数如下</p><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-S</td><td>指定源文件根目录，该目录下必须包含 CMakeLists.txt 文件</td></tr><tr><td>-B</td><td>指定构建目录，构建生成的中间文件和目标文件的生成路径</td></tr><tr><td>-D</td><td>指定变量，格式为 -D <var> = <value>， -D 后的空格可省</value></var></td></tr></tbody></table></div><p>例如，使用当前目录为源文件目录，其中包含 <code>CMakeLists.txt</code> 文件，使用 <code>build</code> 目录作为构建目录，设定变量 <code>CMAKE_BUILD_TYPE</code> 为 <code>Debug</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug</span><br></pre></td></tr></table></figure><h3 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a>执行构建</h3><p>使用 <code>cmake --build [&lt;dir&gt; | --preset &lt;preset&gt;]</code> 进行构建</p><p>这里指定的目录就是生成构建系统时的指定的构建目录，常用的一些参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>—target</td><td>指定构建目标代替默认的构建目标，可以指定多个</td></tr><tr><td>—parallel / -j[<jobs>]</jobs></td><td>指定构建目标时使用的进程数</td></tr></tbody></table></div><h3 id="执行测试，安装或打包"><a href="#执行测试，安装或打包" class="headerlink" title="执行测试，安装或打包"></a>执行测试，安装或打包</h3><p>安装打包的内容可以看后面</p><p>测试主要是使用的 <code>gtest</code> 库，所以可以看看我的 <code>gtest</code> 使用的文章</p><h2 id="CMake基础语法"><a href="#CMake基础语法" class="headerlink" title="CMake基础语法"></a>CMake基础语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用 <code>#</code> 开头的行是注释行，会被忽略，块注释为 <code>#[[ ... ]]</code></p><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><p>使用 <code>set</code> 指令来<strong>定义变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(VALUE_NAME value)</span><br></pre></td></tr></table></figure><p>使用 <code>$</code> 来读取变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;VALUE_NAME&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>unset</code> 来取消设置变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset(VALUE_NAME)</span><br></pre></td></tr></table></figure><ol><li>如果要设置的变量值包含空格，需要使用双引号把整个或者 <code>\</code> 转义</li><li>如果设置多个值或者字符串值的中间有 <code>;</code> ，则保存成 <code>list</code> </li><li>变量可以被 <code>list</code> 命令操作，单个值的变量相当于只有一个元素的列表</li><li>在<code>if()</code>条件判断中可以简化为只用变量名</li></ol><h3 id="Cache变量"><a href="#Cache变量" class="headerlink" title="Cache变量"></a>Cache变量</h3><p>作用是为了提供用户配置选项，若未指定则使用默认值，使用如下方法设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</span><br></pre></td></tr></table></figure><p>使用 <code>$CACHE</code> 引用变量， <code>CACHE</code> 变量会被保存在构建目录下的 <code>CMakeCache.txt</code> 中，缓存之后是不变的的，除非重新配置</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>修改当前处理进程的环境变量，设置格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;])</span><br></pre></td></tr></table></figure><p>可以使用 <code>$ENV</code> 来引用环境变量</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(CONDITION1)</span><br><span class="line">...</span><br><span class="line">elseif(CONDITION2)</span><br><span class="line">...</span><br><span class="line">else()</span><br><span class="line">...</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>用于比较的语法</p><ol><li>字符串： <code>STREQUAL</code> ， <code>STRLESS</code> ， <code>STRGREATER</code></li><li>数值比较： <code>EQUAL</code> ， <code>LESS</code> ， <code>GREATER</code></li><li>布尔运算： <code>AND</code> ， <code>OR</code> ， <code>NOT</code></li><li>路径判断： <code>EXISTS</code> ， <code>IS_DIRECTORY</code> <strong>，</strong> <code>IS_ABSOLUTE</code></li><li>多个条件语句组合： <code>(cond1) AND (cond2 OR (cond3))</code></li><li>常量： <code>ON</code> ， <code>YES</code> ， <code>TRUE</code> ， <code>Y</code> 和非 0 值被视为 <code>True</code> ，对于 <code>0</code> ， <code>OFF</code> ， <code>NO</code> ， <code>FALSE</code> ， <code>N</code> ， <code>IGNORE</code> ，空字符串， <code>NOTFOUND</code> ，以及以 <code>-NOTFOUND</code> 结尾的字符串都被视为 <code>False</code></li></ol><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>类似于 <code>python</code> 中的循环语句的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(item IN LISTS items)</span><br><span class="line">...</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>可以自定义自己的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(FUNCTION_NAME arg1 arg2)</span><br><span class="line">...</span><br><span class="line">endfunction()</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">macro(MACRO_NAME arg1 arg2)</span><br><span class="line">...</span><br><span class="line">endmacro()</span><br></pre></td></tr></table></figure><h3 id="消息打印"><a href="#消息打印" class="headerlink" title="消息打印"></a>消息打印</h3><p>利用 <code>message</code> 指令来把信息打印出来，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message([&lt;mode&gt;] &quot;message text&quot; ... )</span><br></pre></td></tr></table></figure><p>其中 <code>mode</code> 的选值如下</p><ol><li>空或者是 <code>NOTICE</code> ：比较重要的信息</li><li><code>DEBUG</code> ：调试信息</li><li><code>STATUS</code> ：状态信息</li><li><code>WARNING</code> ： <code>cmake</code> 警告，不会打断进程</li><li><code>SEND_ERROR</code> ： <code>cmake</code> 错误，会继续执行，但是跳过生成构建系统</li><li><code>FATAL_ERROR</code> ： <code>cmake</code> 致命错误，会终止进程</li></ol><h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>设置多个值或者字符串值的中间有 <code>;</code> ，则保存成 <code>list</code> ， <code>list</code> 存在于 <code>cmake</code> 中，有很多子命令</p><ol><li><code>APPEND</code> 向列表中添加元素</li><li><code>LENGTH</code> 获取列表中元素的个数</li><li><code>JOIN</code> 将列表元素用指定的分隔符连接起来</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set(LIST A B)</span><br><span class="line">set(LIST A;B)</span><br><span class="line">set(LIST &quot;A;B&quot;)</span><br><span class="line">list(APPEND LIST &quot;C&quot;)</span><br><span class="line">list(LENGTH LIST LIST_LEN)</span><br><span class="line">list(JOIN LIST &quot;,&quot; LIST_SPLIT)</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><code>cmake</code> 的 <code>file</code> 命令支持的操作比较多，可以读写，创建或复制文件和目录，计算文件hash，下载文件，压缩文件等，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB_RECURSE ALLSRC src/*.c)</span><br></pre></td></tr></table></figure><p>其中 <code>GLOB_RECURSE</code> 表示执行递归查找，查找目录下的所有符合指定的正则表达式的文件</p><h3 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h3><p>使用 <code>execute_process</code> 指令可以执行一条或者顺序执行多条系统命令</p><p><code>execute_process(COMMAND bash &quot;-c&quot; &quot;git rev-parse --short HEAD&quot; OUTPUT_VARIABLE COMMIT_ID)</code></p><p>上述是获取当前仓库最新提交的 <code>commit</code> 的 <code>commit id</code></p><h3 id="设置项目和版本"><a href="#设置项目和版本" class="headerlink" title="设置项目和版本"></a>设置项目和版本</h3><p>如果需要在项目中<strong>标明版本号、Git的hash号、编译时间</strong>等信息，可以利用 <code>configure_file</code> 来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure_file(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>input</code> 输入文件，一般是以 <code>.h.in</code> 为后缀</li><li><code>output</code> 输出文件，一般是 <code>.h</code> 后缀</li><li><code>COPYONLY</code> 只拷贝文件，不进行任何变量替换，与 <code>NEWLINE_STYLE</code> 冲突（指定 <code>NEWLINE_STYLE</code> 之后无效）</li><li><code>ESCAPE_QUOTES</code> 避开所有反斜杠的转义</li><li><code>@ONLY</code> 限制变量替换，让其只替换被 <code>@VAR@</code> 引用的变量（那么 <code>$&#123;VAR&#125;</code> 格式的变量将不会被替换）。这在配置<code>$&#123;VAR&#125;</code>语法的脚本时是非常有用的</li><li><code>NEWLINE_STYLE</code> 指定输出文件中的新行格式。 <code>UNIX</code> 和 <code>LF</code> 的新行是 <code>\n</code>， <code>DOS</code> 和 <code>WIN32</code> 和 <code>CRLF</code> 的新行格式是 <code>\r\n</code>。这个选项在指定了 <code>COPYONLY</code> 选项时不能使用(无效)</li></ul><p>在 <code>cmake</code> 教程中对它的解释是将一个文件复制到另一个位置并且修改其内容，这里的修改并非是随意修改，而是<strong>将input文件复制到output文件，并在输入文件内容中的变量，替换引用为@VAR@或${VAR}的变量值。每个变量引用将替换为该变量的当前值，如果未定义该变量，则为空字符串，</strong>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(BUILD_Version 1)</span><br><span class="line"></span><br><span class="line">// input file</span><br><span class="line">#define BUILD_Version @BUILD_Version@</span><br><span class="line"></span><br><span class="line">// output file</span><br><span class="line">#define BUILD_Version 1</span><br></pre></td></tr></table></figure><p>在 <code>CMakeLists.txt</code> 文件中使用 <code>project</code> 指令可以指定版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project(ProjectName VERSION 1.0.0 LANGUAGES C CXX)</span><br></pre></td></tr></table></figure><p>其中第一个参数为项目名称，并且可以通过 <code>VERSION</code> 指定版本号，格式为 <code>major.minor.patch.tweak</code> 并且 <code>cmake</code> 会将对应的值分别赋给以下变量，如果没有将会是空字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSION</span><br><span class="line">PROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJOR</span><br><span class="line">PROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINOR</span><br><span class="line">PROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCH</span><br><span class="line">PROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK</span><br></pre></td></tr></table></figure><p>利用上述的 <code>configure_file</code> 命令可以配置自动生成版本头文件，将头文件版本号定义成对应的宏，或者定义为接口，便于了解当前版本</p><h3 id="指定编程语言版本"><a href="#指定编程语言版本" class="headerlink" title="指定编程语言版本"></a>指定编程语言版本</h3><p>可以使得在不同的机器上都能够有统一的编译，可以指定语言版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_STANDARD 99)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br></pre></td></tr></table></figure><p><code>CMAKE_</code> ， <code>_CMAKE</code> 或者是下划线开头后面加上任意 <code>cmake</code> 命令的变量名都是 <code>cmake</code> 保留的，都是 <code>cmake</code> 的内置变量，可以通过修改这些变量的值来配置 <code>cmake</code> 的构建</p><h3 id="配置编译选项"><a href="#配置编译选项" class="headerlink" title="配置编译选项"></a>配置编译选项</h3><p>通过指令 <code>add_compile_options</code> 指令可以为所有编译器配置编译选项，同时对多个编译器有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_compile_options(-g -Wall -Werror)</span><br></pre></td></tr></table></figure><p>通过设置变量 <code>CMAKE_C_FLAGS</code> 可以配置 C 编译器的编译选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -pipe -std=c99&quot;)</span><br></pre></td></tr></table></figure><p>而设置变量 <code>CMAKE_CXX_FLAGS</code> 可以配置 C++ 编译器的选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -pipe -std=c++11&quot;)</span><br></pre></td></tr></table></figure><h3 id="配置编译类型"><a href="#配置编译类型" class="headerlink" title="配置编译类型"></a>配置编译类型</h3><p>通过设置变量 <code>CMAKE_BUILD_TYPE</code> 来配置编译类型，可以设置为 <code>Debug</code> ， <code>Release</code> ， <code>RelWithDebInfo</code> ， <code>MinSizeRel</code> 等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_BUILD_TYPE Debug)</span><br></pre></td></tr></table></figure><p>也可以在执行 <code>cmake</code> 命令的时候通过参数 <code>-D</code> 来指定， <code>cmake</code> 会检查是否有对应编译类型的编译选项，如果有就将它的内容追加到其中</p><p>对于不同的编译类型可以设置不同的编译选项，比如对于 <code>Debug</code> 类型，开启调试信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS_DEBUG &quot;$&#123;CMAKE_C_FLAGS_DEBUG&#125; -g&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -g&quot;)</span><br></pre></td></tr></table></figure><h3 id="添加全局宏定义"><a href="#添加全局宏定义" class="headerlink" title="添加全局宏定义"></a>添加全局宏定义</h3><p>通过命令 <code>add_definitions</code> 可以添加全局的宏定义，在源代码中就可以通过判断不同的宏定义来实现相应的代码逻辑，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_definitions(-DDEBUG -DREAL_COOL_ENGINEER)</span><br></pre></td></tr></table></figure><h3 id="添加include目录"><a href="#添加include目录" class="headerlink" title="添加include目录"></a>添加include目录</h3><p>通过命令 <code>include_directories</code> 来设置头文件的搜索目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include_directories(.) # 表示所有的头文件</span><br><span class="line">include_directories(inc/)</span><br></pre></td></tr></table></figure><h3 id="编译目标文件"><a href="#编译目标文件" class="headerlink" title="编译目标文件"></a>编译目标文件</h3><p>一般来说，编译目标的类型一般有静态库，动态库和可执行文件，编写 <code>CMakeLists.txt</code> 主要包括两步</p><ul><li>编译：确定编译目标所需要的源文件</li><li>链接：确定链接的时候需要依赖的额外的库</li></ul><h3 id="编译生成库文件"><a href="#编译生成库文件" class="headerlink" title="编译生成库文件"></a>编译生成库文件</h3><p>将项目目录路径下的源文件编译为静态库，需要获取编译此静态库需要的文件列表，可以使用<code>set</code>命令，或者<code>file</code>命令来进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB_RECURSE FUNCTION_LIB_SRC /function/*.c)</span><br><span class="line"># set(FUNCTION_LIB_SRC /function/*.c)</span><br><span class="line">add_library(function_lib STATIC $&#123;FUNCTION_LIB_SRC &#125;)</span><br></pre></td></tr></table></figure><p>其中使用 <code>add_library</code> 指令编译名为 <code>function_lib</code> 的静态库，第二个参数表示库的类型， <code>STATIC</code> 表示静态链接库， <code>SHARED</code> 表示动态链接库</p><h3 id="编译可执行文件"><a href="#编译可执行文件" class="headerlink" title="编译可执行文件"></a>编译可执行文件</h3><p>通过 <code>add_executable</code> 命令来向构建系统中添加一个可执行构建目标，指定编译需要的源文件。但是对于可执行文件来说，有时候还会依赖其它的库则需要使用 <code>target_link_libraries</code> 命令来声明构建此可执行文件需要链接的库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo main.c)</span><br><span class="line">target_link_libraries(demo function_lib)</span><br></pre></td></tr></table></figure><h2 id="CMake模块化构建"><a href="#CMake模块化构建" class="headerlink" title="CMake模块化构建"></a>CMake模块化构建</h2><p><code>CMakeLists.txt</code> 是定义一个目录的构建系统，所谓的模块化构建是分别为每一个子模块目录编写一个 <code>CMakeLists.txt</code> 文件，并且在其上层目录中导入子目录构建系统生成对应的目标，以便在上层目录中使用</p><p>这里使用的是一个 <code>cmake</code> 模板的开源项目 <a href="https://gitee.com/RealCoolEngineer/cmake-template">cmake-template-gitee</a></p><p>在这个项目中，将 <code>math</code> 目录视为子模块，为其单独定义构建系统，而整个项目的编译依赖于 <code>math</code> 模块的编译结果来生成其它目标文件</p><h3 id="定义子目录的构建系统"><a href="#定义子目录的构建系统" class="headerlink" title="定义子目录的构建系统"></a>定义子目录的构建系统</h3><p>在需要构建的子目录下创建一个 <code>CMakeLists.txt</code> 文件，在其中写入的内容只需要<strong>编译构建库文件</strong>，以及针对对外提供的接口的功能进行测试就行</p><p>对于子目录，也有自己的 <code>project</code> 指令，同时可以指定自己的版本号</p><p><code>aux_source_directory</code> 可以搜索指定目录（第一个参数）下的所有源文件，将源文件的列表保存到指定的变量（第二个参数）</p><p>在 <code>src/math</code> 目录下新建  <code>CMakeLists.txt</code> 文件，写入内容，将其编译为一个静态链接库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project(CMakeTemplateMath VERSION 0.0.1 LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line">aux_source_directory(. MATH_SRC)</span><br><span class="line">message(&quot;MATH_SRC: $&#123;MATH_SRC&#125;&quot;)</span><br><span class="line"></span><br><span class="line">add_library(math STATIC $&#123;MATH_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="包含子目录"><a href="#包含子目录" class="headerlink" title="包含子目录"></a>包含子目录</h3><p>使用 <code>add_subdirectory</code> 命令可以包含一个子目录的构建系统，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><p>其中 </p><ol><li><code>dir</code> 就是需要包含的目标目录，该目录下必须存在一个 <code>CMakeLists.txt</code> 文件，一般相对于当前的 <code>CMakeLists.txt</code> 的目录路径，也可以是绝对路径</li><li><code>binary_dir</code> 是可选的参数，用于指定子构建系统输出文件的路径，相对于当前的 <code>binary_tree</code> ，也可以是绝对路径。如果 <code>dir</code> 是当前目录的子目录，那 <code>binary_dir</code> 是不做任何相对路径展开的 <code>dir</code> ，但是如果 <code>dir</code> 不是当前的子目录，必须指定 <code>binary_dir</code> ， 从而 <code>cmake</code> 才能确定文件的生成目录</li><li><code>EXCLUDE_FROM_ALL</code> 如果指定了，那子路径下的目标默认不会被包含到父路径的 ALL 目标里，并且也会被排除在工程文件之外，但是如果在父级项目显式声明依赖子目录的目标文件，那么对应的目标文件还是会被构建以满足父级项目的依赖需求</li></ol><p>可以在根目录下的 <code>CMakeLists.txt</code> 写入命令来链接编译的静态库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(src/c/math)</span><br><span class="line">add_executable(demo src/c/main.c)</span><br><span class="line">target_link_libraries(demo math)</span><br></pre></td></tr></table></figure><p>而且此时构建和编译的命令没有任何改变，依旧是在终端中输入 <code>cmake</code> 指令</p><h2 id="导入目标文件"><a href="#导入目标文件" class="headerlink" title="导入目标文件"></a>导入目标文件</h2><p>上述中所用的 <code>add_subdirectory</code> 方法实际上就是通过源文件来构建项目所依赖的目标文件，但是在 <code>cmake</code> 中也可以通过命令导入已经编译好的目标文件</p><h3 id="导入库文件"><a href="#导入库文件" class="headerlink" title="导入库文件"></a>导入库文件</h3><p>使用 <code>add_library</code> 指令可以通过指定 <code>IMPORTED</code> 选项表明是一个导入的库文件，通过 <code>set_property</code> 设置属性来指明路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_library(math STATIC IMPORTED)</span><br><span class="line">set_property(TARGET math PROPERTY </span><br><span class="line">IMPORTED_LOCATION &quot;./lib/libmath.a&quot;)</span><br></pre></td></tr></table></figure><p>也可以使用 <code>find_library</code> 命令来查找，比如在 <code>lib</code> 目录下查找 <code>math</code> 的 <code>Realse</code> 版本和 <code>Debug</code> 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_library(LIB_MATH_DEBUG mathd HINTS &quot;./lib&quot;)</span><br><span class="line">find_library(LIB_MATH_RELEASE math HINTS &quot;./lib&quot;)</span><br></pre></td></tr></table></figure><p>可以通过指令 <code>set_target_properties</code> 来设置不同的编译选项，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(math PROPERTIES</span><br><span class="line">  IMPORTED_LOCATION &quot;$&#123;LIB_MATH_RELEASE&#125;&quot;</span><br><span class="line">  IMPORTED_LOCATION_DEBUG &quot;$&#123;LIB_MATH_DEBUG&#125;&quot;</span><br><span class="line">  IMPORTED_CONFIGURATIONS &quot;RELEASE;DEBUG&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>导入之后，就可以将该库链接到其它目标上，但是导入该库的目标不能被 <code>install</code> </p><h3 id="导入可执行文件"><a href="#导入可执行文件" class="headerlink" title="导入可执行文件"></a>导入可执行文件</h3><p>在 <code>add_executable</code> 通过指定 <code>IMPORTED</code> 来指定可执行文件是外部导入的 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo IMPORTED)</span><br><span class="line">set_property(TARGET demo PROPERTY</span><br><span class="line">             IMPORTED_LOCATION &quot;./bin/demo&quot;)</span><br></pre></td></tr></table></figure><h2 id="库依赖"><a href="#库依赖" class="headerlink" title="库依赖"></a>库依赖</h2><p>主要是对于 <code>target_link_libraries</code> 命令的几个关键字，就是目标文件依赖项的使用范围，对于两个动态链接库 <code>[a.so](http://a.so)</code> 和 <code>b.so</code></p><ul><li><code>PRIVATE</code> 就是 <code>a</code> 使用了 <code>b</code> ，但是并不对外暴漏 <code>b</code> 的接口</li><li><code>INTERFACE</code> 就是 <code>a</code> 未使用 <code>b</code> ，但是对外暴漏 <code>b</code> 的接口</li><li><code>PUBLIC</code> 就是 <code>a</code> 使用了 <code>b</code> 并且对外暴漏 <code>b</code> 的接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(a PRIVATE/INTERFACE/PUBLIC b)</span><br><span class="line">target_include_directories(a PRIVATE/INTERFACE/PUBLIC b)</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="install指令"><a href="#install指令" class="headerlink" title="install指令"></a><strong>install指令</strong></h3><p>安装时使用 <code>install</code> 指令，用于指定一个项目的安装规则，命令格式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS &lt;target&gt;... [...])</span><br><span class="line"><span class="built_in">install</span>(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])</span><br><span class="line"><span class="built_in">install</span>(DIRECTORY &lt;dir&gt;... [...])</span><br><span class="line"><span class="built_in">install</span>(SCRIPT &lt;file&gt; [...])</span><br><span class="line"><span class="built_in">install</span>(CODE &lt;code&gt; [...])</span><br><span class="line"><span class="built_in">install</span>(EXPORT &lt;<span class="keyword">export</span>-name&gt; [...])</span><br></pre></td></tr></table></figure><p>可以看出 <code>install</code> 命令可以安装的目标类型为：构建目标、文件、程序、目录等，对应的关键字后面跟上对应要安装的目标，安装不同目标时有一些通用的关键字<br><strong>DESTINATION</strong></p><p>就是安装对象的目标安装路径，可以是绝对路径，也可以是相对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS function_lib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>TARGETS</code> 用于指定需要安装的目标</li><li><code>RUNTIME DESTINATION</code> 指定可执行文件的安装路径</li><li><code>LIBRARY DESTINATION</code> 指定共享库文件的安装路径</li><li><code>ARCHIVE DESTINATION</code> 指定静态库文件的安装路径</li></ul><p>如果指定 <code>CMAKE_INSTALL_PREFIX</code> 目录之后，那库文件将会被安装在对应目录下的 <code>lib</code> 文件夹中，可执行文件将会被安装在对应目录下的 <code>bin</code> 文件夹中，不同类型的目标文件安装到不同子目录。需要注意的是， <code>CMAKE_INSTALL_PREFIX</code> 在不同的系统上会有不同的默认值，使用时最好显式指定</p><p>头文件也可以使用上述的命令安装</p><p><strong>CONFIGURATIONS</strong></p><p>为不同的配置设置不同的安装规则，例如对于 <code>Debug</code> 和 <code>Release</code> 配置不同的安装路径，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS target</span><br><span class="line">        CONFIGURATIONS Debug</span><br><span class="line">        RUNTIME DESTINATION Debug/bin)</span><br><span class="line"><span class="built_in">install</span>(TARGETS target</span><br><span class="line">        CONFIGURATIONS Release</span><br><span class="line">        RUNTIME DESTINATION Release/bin)</span><br></pre></td></tr></table></figure><p><strong>PERMISSIONS</strong></p><p>设置安装目标权限，接受的是一个权限关键字列表，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS target</span><br><span class="line">        RUNTIME PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE)</span><br></pre></td></tr></table></figure><h3 id="安装构建目标"><a href="#安装构建目标" class="headerlink" title="安装构建目标"></a><strong>安装构建目标</strong></h3><p>安装一个构建好的目标，命令格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS function_lib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>完整的命令格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS targets... [EXPORT &lt;export-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>其中参数中的<code>TARGET</code>可以是很多种目标文件，最常见的是通过 <code>ADD_EXECUTABLE</code> 或者 <code>ADD_LIBRARY</code> 定义的目标文件，即可执行二进制，动态库，静态库</p><div class="table-container"><table><thead><tr><th>目标文件</th><th>内容</th><th>安装目录变量</th><th>默认安装文件夹</th></tr></thead><tbody><tr><td>ARCHIVE</td><td>静态库</td><td>${CMAKE_INSTALL_LIBDIR}</td><td>lib</td></tr><tr><td>LIBRARY</td><td>动态库</td><td>${CMAKE_INSTALL_LIBDIR}</td><td>lib</td></tr><tr><td>RUNTIME</td><td>可执行二进制文件</td><td>${CMAKE_INSTALL_BINDIR}</td><td>bin</td></tr><tr><td>PUBLIC_HEADER</td><td>与库关联的PUBLIC头文件</td><td>${CMAKE_INSTALL_INCLUDEDIR}</td><td>include</td></tr><tr><td>PRIVATE_HEADER</td><td>与库关联的PRIVATE头文件</td><td>${CMAKE_INSTALL_INCLUDEDIR}</td><td>include</td></tr></tbody></table></div><h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a><strong>安装目录</strong></h3><p>安装一个目录，一般用于将头文件安装到目标路径，实际中，一般将需要安装的头文件放在一个特定的目录下，然后直接安装整个目录，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install(DIRECTORY &quot;$&#123;PROJECT_SOURCE_DIR&#125;/include/&quot;</span><br><span class="line">      DESTINATION &quot;$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;)</span><br></pre></td></tr></table></figure><p>更加完整的命令格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS permissions...]])</span><br></pre></td></tr></table></figure><p><strong>TYPE/DESTINATION</strong></p><p>安装目录必须指定安装的目录类型 <code>TYPE</code> 或者安装的目标路径 <code>DESTINATION</code> ，但是不可以同时指定， <code>TYPE</code> 用于指定安装的目录中的文件类型，并且 <code>cmake</code> 会自动按照类型分配安装位置，不同类型对应的安装路径如下</p><div class="table-container"><table><thead><tr><th>TYPE类型</th><th>安装目录变量</th><th>默认安装文件夹</th></tr></thead><tbody><tr><td>BIN</td><td>${CMAKE_INSTALL_BINDIR}</td><td>bin</td></tr><tr><td>SBIN</td><td>${CMAKE_INSTALL_SBINDIR}</td><td>sbin</td></tr><tr><td>LIB</td><td>${CMAKE_INSTALL_LIBDIR}</td><td>lib</td></tr><tr><td>INCLUDE</td><td>${CMAKE_INSTALL_INCLUDEDIR}</td><td>include</td></tr><tr><td>SYSCONF</td><td>${CMAKE_INSTALL_SYSCONFDIR}</td><td>etc</td></tr><tr><td>SHAREDSTATE</td><td>${CMAKE_INSTALL_SHARESTATEDIR}</td><td>com</td></tr><tr><td>LOCALSTATE</td><td>${CMAKE_INSTALL_LOCALSTATEDIR}</td><td>var</td></tr><tr><td>RUNSTATE</td><td>${CMAKE_INSTALL_RUNSTATEDIR}</td><td>/run</td></tr><tr><td>DATA</td><td>${CMAKE_INSTALL_DATADIR}</td><td></td></tr><tr><td>INFO</td><td>${CMAKE_INSTALL_INFODIR}</td><td>/info</td></tr><tr><td>LOCALE</td><td>${CMAKE_INSTALL_LOCALEDIR}</td><td>/locale</td></tr><tr><td>MAN</td><td>${CMAKE_INSTALL_MANDIR}</td><td>/man</td></tr><tr><td>DOC</td><td>${CMAKE_INSTALL_DOCDIR}</td><td>/doc</td></tr></tbody></table></div><p>也可以选择使用 <code>DESTINATION</code> 显式指定安装目录</p><p><strong>FILES_MATCHING</strong></p><p>安装目录的时候默认会安装所有的文件，如果使用 <code>FILES_MATCHING</code> 关键字（在第一个 <code>PATTERN</code> 或者 <code>REGEX</code> 之前），则表示必须要满足对应的模式或者正则的文件才能被安装</p><p>例如，对于安装一个目录下的头文件，但是头文件与源文件混合，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install(DIRECTORY src/ DESTINATION include/</span><br><span class="line">        FILES_MATCHING PATTERN &quot;*.h&quot;)</span><br></pre></td></tr></table></figure><p><strong>PATTERN/REGEX</strong></p><ul><li><code>PATTERN</code> 文件名完全一致才会被安装</li><li><code>REGEX</code> 通过正则表达式匹配之后才会安装</li></ul><p>在这两个表达式后面还可以加上 <code>EXCLUDE</code> 表示反选，或者使用 <code>PERMISSIONS</code> 指定匹配的目标文件的权限</p><h3 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h3><p>与安装目录类似，命令格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install(&lt;FILES|PROGRAMS&gt; files...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br></pre></td></tr></table></figure><ul><li><code>FILE</code> 指的是文件的默认权限是一般文件</li><li><code>PROGRAMS</code> 指的是文件为可执行文件，默认有可执行权限</li></ul><h3 id="自定义安装脚本"><a href="#自定义安装脚本" class="headerlink" title="自定义安装脚本"></a>自定义安装脚本</h3><p>使用 <code>install</code> 命令可以在安装的时候执行自定义脚本，格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL] [...])</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>SCRIPT</code> 指定安装时需要执行的脚本</li><li><code>CODE</code> 指定的是 <code>cmake</code> 的指令，也就是在安装期间执行的 <code>cmake</code> 指令</li></ul><h3 id="执行安装"><a href="#执行安装" class="headerlink" title="执行安装"></a>执行安装</h3><p>在构建编译完成之后，执行命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target install</span><br></pre></td></tr></table></figure><p>针对 <code>make</code> 工具，安装的指令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p>在 <code>cmake-3.15</code> 之后，可以使用如下指令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --install . --prefix &quot;../output&quot;</span><br></pre></td></tr></table></figure><p>其中 <code>--install</code> 指定构建目录， <code>--prefix</code> 指定安装路径，指定之后会覆盖安装路径变量 <code>CMAKE_INSTALL_PREFIX</code></p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><h3 id="CPack"><a href="#CPack" class="headerlink" title="CPack"></a>CPack</h3><p>使用打包功能，需要先使用命令 <code>include(CPack)</code> 启用相关的功能，构建之后会在构建目录下生成两个 <code>cpack</code> 配置文件，<code>CPackConfig.cmake</code>和<code>CPackSourceConfig.cmake</code> ，分别对应着 <code>package</code> 和 <code>package_source</code></p><p>在执行构建编译之后使用 <code>cpack</code> 命令行工具进行打包安装。可以使用 <code>-G</code> 参数指定生成器，常用的为 <code>ZIP</code> ， <code>TGZ</code> ， <code>7Z</code> 等，也可以同时指定多种类型，利用 <code>CMake</code> 语法中的列表，在构建目录下使用如下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpack -G ZIP --config CPackConfig.cmake</span><br><span class="line">cpack -G ZIP --config CPackSourceConfig.cmake</span><br></pre></td></tr></table></figure><p>对于 <code>cmake</code> 指令，可以在构建目录下使用如下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target package</span><br><span class="line">cmake --build . --target package_source</span><br></pre></td></tr></table></figure><p>对于 <code>make</code> 工具，也可以使用命令 <code>make package</code> 或者 <code>make package_source</code> 进行打包安装</p><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>打包的内容就是 <code>install</code> 指令安装的内容，还需要设置一些变量</p><div class="table-container"><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>CPACK_GENERATOR</td><td>打包使用的工具</td></tr><tr><td>CPACK_OUTPUT_FILE_PREFIX</td><td>打包安装的路径前缀，如果是相对路径，那就是相对于构建路径</td></tr><tr><td>CPACK_INSTALL_PREFIX</td><td>打包压缩包的内部目录</td></tr><tr><td>CPACK_PACKAGE_FILE_NAME</td><td>打包压缩包的名称，由CPACK_PACKAGE_NAME，CPACK_PACKAGE_VERSION，CPACK_SYSTEM_NAME三部分构成</td></tr><tr><td>CPACK_SET_DESTDIR</td><td>如果没有 CPACK_SET_DESTDIR，CPack 使用 CPACK_PACKAGING_INSTALL_PREFIX 作为前缀，而设置 CPACK_SET_DESTDIR 后，CPack 将使用 CMAKE_INSTALL_PREFIX 作为前缀。</td></tr><tr><td>CPACK_OUTPUT_CONFIG_FILE</td><td>配置文件，默认为CPackConfig.cmake</td></tr><tr><td>CPACK_PACKAGE_VERSION</td><td>默认为项目版本号，默认值为 project 所设置的版本号，如果没有设置就是 cmake 的默认值</td></tr></tbody></table></div><p><code>cpack</code> 有一些参数是可以覆盖 <code>CMakeLists.txt</code> 中所设置的参数的，所以一般来说以上变量的设置在 <code>include(CPack)</code> 之前</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>实际上 <code>cmake</code> 的编译过程中的命令与 <code>gcc</code> 的编译过程是有关联的</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>可以使用下列指令定义一个宏定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_definitions(-Dname)</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>使用如下指令给编译过程添加编译选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_compile_options(-O0 -g ...)</span><br></pre></td></tr></table></figure><p>需要注意的是，因为CMake的构建目标必须是库或者可执行文件，并没有命令仅生成 <code>.o</code> 文件。如果使用生成器表达式的话，对于多个编译选项，需要使用双引号把生成器表达式括起来，且在选项之间使用分号隔开</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>使用如下指令来进行指定编译过程中的链接参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_link_options(-pthread ...)</span><br></pre></td></tr></table></figure><h2 id="合并静态库"><a href="#合并静态库" class="headerlink" title="合并静态库"></a>合并静态库</h2><h3 id="基于cmake"><a href="#基于cmake" class="headerlink" title="基于cmake"></a>基于cmake</h3><p><code>**add_custom_command</code>** </p><p>向目标添加规则，并通过执行命令生成输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT output1 [output2 ...]</span><br><span class="line">                   COMMAND command1 [ARGS] [args1...]</span><br><span class="line">                   [COMMAND command2 [ARGS] [args2...] ...]</span><br><span class="line">                   [MAIN_DEPENDENCY depend]</span><br><span class="line">                   [DEPENDS [depends...]]</span><br><span class="line">                   [BYPRODUCTS [files...]]</span><br><span class="line">                   [IMPLICIT_DEPENDS &lt;lang1&gt; depend1</span><br><span class="line">                                    [&lt;lang2&gt; depend2] ...]</span><br><span class="line">                   [WORKING_DIRECTORY dir]</span><br><span class="line">                   [COMMENT comment]</span><br><span class="line">                   [DEPFILE depfile]</span><br><span class="line">                   [JOB_POOL job_pool]</span><br><span class="line">                   [VERBATIM] [APPEND] [USES_TERMINAL]</span><br><span class="line">                   [COMMAND_EXPAND_LISTS])</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>OUTPUT：指定命令预期生成的输出文件。3.20版本以后，输出参数可使用一组受限的生成器表达式。</li><li>COMMAND：指定生成时要执行的命令行。</li><li>MAIN_DEPENDENCY：指定命令的主输入源文件。类似于DEPENDS。</li><li>DEPENDS：指定命令所依赖的文件。</li><li>BYPRODUCTS：指定命令预期生成的文件，但其修改时间可能比依赖项的新，也可能不比依赖项的新。</li><li>IMPLICIT_DEPENDS：请求扫描输入文件的隐式依赖项。此选项不能与DEPFILE选项同时指定。</li><li>WORKING_DIRECTORY：指定在何处执行命令。</li><li>COMMENT：指定在生成时执行命令之前显示的消息。</li><li>DEPFILE：指定保存自定义命令依赖项的depfile。它通常由自定义命令本身发出。仅当生成器支持此关键字时，才能使用此关键字。</li><li>JOB_POOL：为Ninja生成器指定一个池。</li><li>VERBATIM：对于构建工具，命令的所有参数都将被正确转义，以便被调用的命令接收到的每个参数不变。请注意，在add_custom_command甚至看到参数之前，CMake语言处理器仍然使用一级转义。建议使用VERBATIM，因为它可以保证正确的行为。如果不指定VERBATIM，则行为是依赖于平台的，因为CMake没有针对于特定工具中特殊字符的保护措施。</li><li>APPEND：将COMMAND和DEPENDS 附加到第一个指定输出的自定义命令。</li><li>USES_TERMINAL：如果可能，该命令将被授予直接访问终端的权限。</li><li>COMMAND_EXPAND_LISTS：命令参数中的列表将展开，包括使用生成器表达式创建的列表</li></ul><p><strong><code>add_custom_target</code></strong></p><p>在很多时候，需要在<code>cmake</code>中创建一些目标，如<code>clean</code>、<code>copy</code>等等，这就需要通过<code>add_custom_target</code>来指定。同时，<code>add_custom_command</code>可以用来完成对<code>add_custom_target</code>生成的<code>target</code>的补充</p><p>用于增加一个没有输出的目标，使得它总是被构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(Name [ALL] [command1 [args1...]]</span><br><span class="line">                  [COMMAND command2 [args2...] ...]</span><br><span class="line">                  [DEPENDS depend depend depend ... ]</span><br><span class="line">                  [BYPRODUCTS [files...]]</span><br><span class="line">                  [WORKING_DIRECTORY dir]</span><br><span class="line">                  [COMMENT comment]</span><br><span class="line">                  [JOB_POOL job_pool]</span><br><span class="line">                  [VERBATIM] [USES_TERMINAL]</span><br><span class="line">                  [COMMAND_EXPAND_LISTS]</span><br><span class="line">                  [SOURCES src1 [src2...]])</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>ALL：表明该目标会被添加到默认的构建目标，使得它每次都被运行</li><li>COMMAND：指定要在构建时执行的命令行；</li><li>DEPENDS：指定命令所依赖的文件；</li><li>COMMENT：在构建时执行命令之前显示给定消息；</li><li>WORKING_DIRECTORY：使用给定的当前工作目录执行命令。如果它是相对路径，它将相对于对应于当前源目录的构建树目录；</li><li>BYPRODUCTS：指定命令预期产生的文件。</li></ul><p><strong>具体流程</strong></p><ol><li><p>合并静态库</p><p> 利用 <code>add_custom_command</code> 配合 <code>add_custom_target</code> 命令，将 <code>liba.a</code> 和 <code>libb.a</code> 合并为 <code>libmerge.a</code></p><p> 对于 macos 系统中，在根目录下的 <code>CMakeLists.txt</code> 文件中写入</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT libmerge.a</span><br><span class="line">COMMAND libtool -static -o libmerge.a $&lt;TARGET_FILE:math&gt; $&lt;TARGET_FILE:nn&gt;</span><br><span class="line">DEPENDS a b)</span><br></pre></td></tr></table></figure><p> 对于其它系统中，在根目录下的 <code>CMakeLists.txt</code> 文件中写入</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT libmerge.a</span><br><span class="line">    COMMAND ar crsT libmerge.a $&lt;TARGET_FILE:math&gt; $&lt;TARGET_FILE:nn&gt;</span><br><span class="line">    DEPENDS a b)</span><br></pre></td></tr></table></figure><p> 还需要在后面添加一句，且必须得有</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(_merge ALL DEPENDS libmerge.a)</span><br></pre></td></tr></table></figure><p> 在合并静态库时，需要知道每个静态库的路径，在 <code>cmake</code> 中，目标静态库 <code>a</code> 的路径可以通过生成器表达式 <code>$&lt;TARGET_FILE:a&gt;</code> 获取</p><p> 如果使用 <code>find_library</code>  查找到的静态库，这时候就 <code>DEPENDS</code> 不需要加入 c ，如下</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_library(LIB_C c HINTS $&#123;SEARCH_PATH&#125;)</span><br></pre></td></tr></table></figure></li><li><p>导入合并的静态库</p><p> 把静态库导入，并且链接到可执行程序使用</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_library(merge STATIC IMPORTED GLOBAL)</span><br><span class="line">set_target_properties(merge PROPERTIES</span><br><span class="line">    IMPORTED_LOCATION $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/libmerge.a</span><br><span class="line">)</span><br><span class="line">add_executable(main src/c/main.c)</span><br><span class="line">target_link_libraries(main PRIVATE merge)</span><br></pre></td></tr></table></figure><p> 由于 <code>libmerge</code> 是由 <code>add_custom_command</code> 指定的输出，所以会标记为自动生成的文件 <code>GENERATED</code></p><p> 链接项目中依赖于导入的静态库文件 <code>merge</code> ，而对于 <code>merge</code> 被指定了 <code>IMPORTED_LOCATION</code> ，也就是被指定为自动生成的，所以 cmake 就会等待 <code>libmerge.a</code> 生成之后再进行链接</p></li></ol><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><ol><li><p>方法1</p><p> 先使用 <code>ar</code> 把静态库 <code>liba</code> 和 <code>libb</code> 拆解为多个 <code>.o</code> 文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar x liba.a</span><br><span class="line">ar x libb.a</span><br></pre></td></tr></table></figure><p> 再把所有的 <code>.o</code> 文件打包为一个静态库</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar crs libmerge.a *.o</span><br></pre></td></tr></table></figure><p> 其中</p><ul><li><code>x</code> 拆解静态库文件为其包含的内容</li><li><code>c</code> 封装 <code>.o</code> 文件为静态库文件</li><li><code>r</code> 覆盖同名库文件或者创建新的目标库文件</li><li><code>s</code> 相当于对结果执行一次 <code>ranlib</code> 为静态库的内容添加索引，以此提高访问效率</li></ul></li><li><p>方法2</p><p> 上述方法1中一个更简洁的表达</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar crsT libmerge.a liba.a libb.a</span><br></pre></td></tr></table></figure><p> 其中</p><ul><li><code>T</code> 表示将后续所有静态库中的 <code>.o</code> 文件打包到第一个参数指定的静态库文件中。如果不加该参数，得到的将会是后面几个 <code>.a</code> 文件的集合</li><li>可以使用 <code>ar -t</code> 查看打包的内容</li></ul></li><li><p>方法3</p><p> 使用 MRI 脚本，首先写一个 MRI 脚本， <code>merge.mri</code> ，写入如下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create libmerge.a</span><br><span class="line">addlib liba.a </span><br><span class="line">addlib libb.a</span><br><span class="line">save</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p> 然后使用命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -M &lt; merge.mri</span><br></pre></td></tr></table></figure></li><li><p>方法</p><p> 使用 <code>libtool</code> 命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libtool -static -o libmerge.a liba.a libb.a</span><br></pre></td></tr></table></figure></li></ol><p>上述方法中，方法1，4适用于macos，方法1，2，3均适用于linux</p><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>就是再 <code>cmake</code> 生成构建系统时根据不同配置动态生成特定的内容，着就依赖于不同的条件。生成器表达式的格式为 <code>$&lt;...&gt;</code> ，可以嵌套，可以在很多构建目标的属性设置和特定的 <code>cmake</code> 指令中，并且在生成构建系统时表达式被展开，所以不能通过解析配置 <code>CMakeLists.txt</code> 阶段的 <code>message</code> 指令打印</p><h3 id="布尔生成器表达式"><a href="#布尔生成器表达式" class="headerlink" title="布尔生成器表达式"></a>布尔生成器表达式</h3><p><strong>逻辑运算符</strong></p><ol><li><code>$&lt;BOOL:string&gt;</code> 如果字符串为空，0。不区分大小写的 <code>FALSE</code> ， <code>OFF</code> ， <code>N</code> ， <code>NO</code> ， <code>IGNORE</code> ， <code>NOTFOUND</code> 。或者区分大小写以 <code>-NOTFOUND</code> 结尾的字符串，则为 0，否则为 1</li><li><code>$&lt;AND:condition&gt;</code> 逻辑与， <code>condition</code> 是以逗号分割的条件列表</li><li><code>$&lt;OR:condition&gt;</code> 逻辑或</li><li><code>$&lt;NOT:condition&gt;</code> 逻辑非</li></ol><p><strong>字符串比较</strong></p><ol><li><code>$&lt;STREQUAL:str1, str2&gt;</code> 判断字符串是否相等</li><li><code>$&lt;EQUAL:val1, val2&gt;</code> 判断数值是否相等</li><li><code>$&lt;IN_LIST:str, list&gt;</code> 判断字符串是否在列表 <code>list</code> 中</li></ol><p><strong>变量查询</strong></p><ol><li><code>$&lt;TARGET_EXISTS:target&gt;</code> 判断目标是否存在</li><li><code>$&lt;CONFIG:cfg&gt;</code> 判断编译类型配置是否包含在 <code>cfg</code> 列表中，不区分大小写</li><li><code>$&lt;PLATFORM_ID:platform_ids&gt;</code> 判断cmake定义的平台ID是否包含在 <code>platform_ids</code> 列表中</li><li><code>$&lt;COMPILE_LANGUAGE:languages&gt;</code> 判断编译语言是否包含在 <code>languages</code> 列表中</li></ol><h3 id="字符串值生成器表达式"><a href="#字符串值生成器表达式" class="headerlink" title="字符串值生成器表达式"></a>字符串值生成器表达式</h3><p>使用生成表达式的目的是生成特殊的字符串</p><p><strong>条件表达式</strong></p><p>主要是两种格式</p><ol><li><code>$&lt;condition:true_string&gt;</code> 如果条件为真，则结果为 <code>true_string</code> ，否则为空</li><li><code>$&lt;IF:condition,str1,str2&gt;</code> 如果条件为真，结果为 <code>str1</code> ，否则 <code>str2</code></li></ol><p><strong>转义字符</strong></p><p>由于有些字符有特殊含义，可能需要转义，例如</p><ul><li><code>$&lt;COMMA&gt;</code> 表示 <code>,</code></li><li><code>$&lt;SEMICOLON&gt;</code> 表示 <code>;</code></li></ul><p><strong>字符串操作</strong></p><ul><li><code>$&lt;LOWER_CASE:string&gt;</code> 将字符串转为小写</li><li><code>$&lt;UPPER_CASE:string&gt;</code> 将字符串转为大写</li></ul><p><strong>获取变量值</strong></p><p>与上文中的变量查询很类似</p><ol><li><code>$&lt;CONFIG&gt;</code> 获取变量值</li><li><code>$&lt;CONFIG:cfgs&gt;</code> 判断是否存在于列表中</li></ol><p><strong>编译目标信息</strong></p><p>更多信息：<a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#target-dependent-queries">target-dependent-queries</a></p><p>编译目标：是指通过 <code>add_execuate()</code> 和 <code>add_library()</code> 指令生成的目标文件和库文件</p><ol><li><code>$&lt;TARGET_FILE:tgt&gt;</code> 获取编译目标 <code>tgt</code> 的文件路径</li><li><code>$&lt;TARGET_FILE_NAME:tgt&gt;</code> 获取编译目标的文件名</li><li><code>$&lt;TARGET_FILE_BASE_NAME:tgt&gt;</code> 获取编译目标的基础名字，也就是文件名去除前缀和扩展名</li></ol><h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><ol><li><p>通过输出到文件的方式，在 <code>cmake</code> 执行完之后检查是否符合预期</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GENERATE OUTPUT &quot;./ouput.txt&quot; CONTENT &quot;$&lt;$&lt;CONFIG:Debug&gt;:-g;-O0&gt;,$&lt;PLATFORM_ID&gt;\n&quot;)</span><br></pre></td></tr></table></figure><p> 执行完 <code>cmake</code> 之后在文件中得到生成器表达式的内容</p></li><li><p>添加一个自定义目标</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(gentest COMMAND $&#123;CMAKE_COMMAND&#125; -E echo &quot;\&quot;$&lt;$&lt;CONFIG:Debug&gt;:-g;-O0&gt;,$&lt;PLATFORM_ID&gt;\&quot;&quot;)</span><br></pre></td></tr></table></figure><p> 这里需要将双引号转义，以便确保生成器表达式展开之后为字符串</p><p> 在执行 <code>cmake</code> 之后，可以使用 <code>make gentest</code> 命令输出到生成器表达式的内容</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> C </tag>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile编写</title>
      <link href="/Blog_ButterFly/2024/04/02/makefile%E7%BC%96%E5%86%99/"/>
      <url>/Blog_ButterFly/2024/04/02/makefile%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章。Makefile执行之后所进行的操作是编译和链接，就是先将源文件编译为中间文件（object file），然后把大量的中间文件链接起来合成执行文件</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol><li>如果这个工程没有编译过，那么我们的所有源文件都要编译并被链接（按需）</li><li>如果这个工程某些源文件被修改，那只编译被修改的源文件，并链接目标程序</li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的源文件，并链接目标程序</li></ol><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target ...: prerequisites ...</span><br><span class="line">command</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><code>target</code> 目标文件，是命令执行后生成的目标，可以是 <code>Object File</code> ，也可以是执行问价，还可以是一个标签，类似于 <code>clean</code></li><li><code>prerequisites</code> 依赖，也就是生成目标文件所需要的文件或者是目标</li><li><code>command</code> <code>make</code> 需要执行的指令，可以是任意的 <code>shell</code> 指令</li></ul><h3 id="核心规则"><a href="#核心规则" class="headerlink" title="核心规则"></a>核心规则</h3><ul><li>target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中</li><li>如果prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</li></ul><h3 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h3><p>使用 <code>make</code> 清除所有生成的目标文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm target1 ...</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>makefile</code> 文件中的注释格式为 <code>#</code> </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target ...: prerequisites ... <span class="comment"># target1</span></span><br><span class="line">command</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在使用之前需要先安装 <code>make</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install make</span><br></pre></td></tr></table></figure><p>然后进入 <code>makefile</code> 文件就可以编辑了，但是需要注意，命名必须是 <code>makefile</code></p><p>注意在命令前一定需要 <code>tab</code> 键</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: hello.c complex.o</span></span><br><span class="line">gcc hello.c complex.o -o main</span><br><span class="line"></span><br><span class="line"><span class="section">complex.0: complex.c complex.h</span></span><br><span class="line">gcc -c complex.c -0 complex.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm main complex.o</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOB扰动观测器</title>
      <link href="/Blog_ButterFly/2024/03/30/DOB%E6%89%B0%E5%8A%A8%E8%A7%82%E6%B5%8B%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/30/DOB%E6%89%B0%E5%8A%A8%E8%A7%82%E6%B5%8B%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">GitHub - Luo25177/modelControl</a></p><h3 id="前言——一些用到的概念"><a href="#前言——一些用到的概念" class="headerlink" title="前言——一些用到的概念"></a>前言——一些用到的概念</h3><ul><li><p>最小相位系统：对于FIR系统（没有极点），如果系统函数的所有零点都位于单位圆内，则称该系统为最小相位系统。如果系统函数的所有零点都位于单位圆外，则称该系统为最大相位系统。如果一部分零点位于单位圆内，一部分零点位于单位圆外，则称该系统为混合相位系统或非最小相位系统。对于IIR系统（存在极点），如果系统函数的所有零点和极点都在单位圆内，则称该系统为最小相位系统。也就是相频特性 $\varphi(w)$ 在 $w=0$ 和 $w=\pi$ 之间经历的净相位变化为零</p></li><li><p>最小相位系统主要特性</p><ul><li>最小相位系统是因果且稳定的</li><li>其逆系统也是因果且稳定的</li><li>在所有具有相同幅频响应的零-极点系统中，最小相位系统的群时延最小</li></ul></li></ul><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>基本思想就是将外部扰动以及模型参数变化造成的实际模型与理想模型输出的差异统统等效为控制输入，即观测出等效干扰，在控制中引入等量的补偿，实现对干扰完全抑制。干扰观测器的基本思想，系统实际控制输入与计算输入（由系统标称模型计算得到）的差值，来得到扰动和不确定性的估计</p><h3 id="具体公式"><a href="#具体公式" class="headerlink" title="具体公式"></a>具体公式</h3><p><img src="/Blog_ButterFly/2024/03/30/DOB%E6%89%B0%E5%8A%A8%E8%A7%82%E6%B5%8B%E5%99%A8/20200701105527227.png" alt="20200701105527227.png"></p><p>图中的 $G_p(s)$ 为对象的传递函数， $\hat{d}$ 为等效干扰， $d$ 为观测干扰， $u$ 为控制输入。在图中可知，等效干扰的估计值为</p><script type="math/tex; mode=display">\hat{d}=(\varepsilon+d)G_p(s)G_p^{-1}(s)-\varepsilon=d</script><p>上述公式可以实现对干扰的准确估计和补偿，但是对于实际的物理系统，上述公式还存在着问题</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>通常情况下， $G_p(s)$ 的相对阶不为 0，物理上的逆不可实现</li><li>控制系统的传递函数的精确模型无法得到</li><li>考虑测量灶神给的影响，上述方法的控制性能将下降</li></ol><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对于上述问题的一个解决办法是在 $\hat{d}$ 之后串联一个低通滤波器，并且使用系统的理想模型的逆 $G_n^{-1}(s)$ 来替代 $G_p^{-1}$ ，得到下图控制系统，其中 $\xi$ 为观测噪声</p><p><img src="/Blog_ButterFly/2024/03/30/DOB%E6%89%B0%E5%8A%A8%E8%A7%82%E6%B5%8B%E5%99%A8/20200701150803836.png" alt="20200701150803836.png"></p><p>从图中可知</p><script type="math/tex; mode=display">\hat{d}=(\varepsilon+d)G_p(s)G_n^{-1}(s)Q(s)-\varepsilon Q(s)=d\\=\varepsilon(G_n^{-1}(s)Q(s)G_p(s)-Q(s))+d(G_n^{-1}Q(s)G_p(s)</script><p>则从 $u$ 到 $y$ 的传递函数为</p><script type="math/tex; mode=display">G_{uy}(s)=\frac{G_p(s)}{1-[Q(s)-G^{-1}_n(s)Q(s)G_p(s)]}=\frac{\frac{G_p(s)}{1-Q(s)}}{1+\frac{Q(s)}{G_n(s)}\frac{G_p(s)}{1-Q(s)}}</script><p>上述框图可等价为</p><p><img src="/Blog_ButterFly/2024/03/30/DOB%E6%89%B0%E5%8A%A8%E8%A7%82%E6%B5%8B%E5%99%A8/20200701155401429.png" alt="20200701155401429.png"></p><p>根据上图可以得到干扰观测器输入输出关系为</p><script type="math/tex; mode=display">y=G_{uy}u+G_{dy}d+G_{\xi y}\xi</script><p>其中</p><script type="math/tex; mode=display">G_{uy}(s)=\frac{G_p(s)G_n(s)}{G_n(s)-G_n(s)Q(s)+Q(s)G_p(s)}\\G_{dy}(s)=\frac{G_p(s)G_n(s)-Q(s)G_p(s)G_n(s)}{G_n(s)-G_n(s)Q(s)+Q(s)G_p(s)}\\G_{\xi y}(s)=\frac{G_p(s)Q(s)}{G_n(s)-G_n(s)Q(s)+Q(s)G_p(s)}</script><p>其中对 $Q(s)$ 需要很高的要求</p><ol><li>为使得 $Q(s)G_n^{-1}$ 正则， $Q(s)$ 的相对阶应不小于 $G_n(s)$ 的相对阶</li><li>$Q(s)$ 带宽的设计是在干扰观测器的鲁棒稳定性和干扰抑制能力之间的折中</li><li>在低频段 $Q(s)=1$ ，在高频段 $Q(s)=0$</li></ol><p>一般来说，实际系统的外部干扰和跟踪参考输入主要是低频信号，而测量噪声主要是在高频段，因此理想的 $Q(s)$ 是在低频时接近于 1，以保证 $G_{dy}(s)\rightarrow0$ ，从而抑制对象输入端干扰。同时 $Q(s)$ 在高频段应该接近于 0，以保证 $G_{\xi y}\rightarrow 0$ ，从而能够抑制对象输出端高频噪声，所以需要 $Q(s)$ 为一个低通滤波器</p><p>根据上述条件下，在低频段， $Q(s)\rightarrow 1$</p><script type="math/tex; mode=display">G_{uy}(s)=G_n(s)\\G_{dy}(s)=0\\G_{\xi y}(s)=1</script><p>也就是在低频段，干扰观测器仍使得实际对象的响应与名义模型的响应一致，可以实现对低频段的有效补偿，从而保证有良好的鲁棒性。上述中的 $G_{dy}=0$ 说明感染观测器对于 $Q(s)$ 频带内的低频干扰有完全的抑制能力。但是 $G_{\xi y}=1$ 说明干扰观测器对于低频测量噪声十分敏感，所以在使用中需要尽量减少观测中的低频噪声</p><p>在高频段， $Q(s)=0$</p><script type="math/tex; mode=display">G_{uy}(s)=G_p(s)\\G_{dy}(s)=G_p(s)\\G_{\xi y}(s)=0</script><p>上式说明在高频段中 $G_{\xi y}(s)=0$ 说明干扰观测器对测量噪声不敏感，可以实现对高频噪声的有效滤除，但对于对象参数的变动和外部干扰没有任何抑制作用，通过上述分析可见，采用地通滤波器 $Q(s)$ 设计可以实现对低频干扰信号的有效补偿和高频噪声的有效滤除</p><h3 id="鲁棒性分析"><a href="#鲁棒性分析" class="headerlink" title="鲁棒性分析"></a>鲁棒性分析</h3><p>通常来说被控对象的名义模型可以选择为二阶模型，而低通滤波器可以选择为如下形式</p><script type="math/tex; mode=display">Q(s)=\frac{3\tau s+1}{\tau^3 s^3+3\tau^2s^2+3\tau s+1}</script><p>其中 $\tau$ 为时间常数，则该低通滤波器的相对阶数为 2。上式中的滤波器的截止频率为 $w_c=\frac{1}{\tau}$ </p><p>低频下 $|Q(s)|\rightarrow 1$ ，高频下 $|Q(s)|\rightarrow 0$ ，因此干扰观测器的作用频率将正比于 $w_c$ ，但是不能任意减小 $\tau$ 以提高观测器的作用频率，是因为整个系统的鲁棒稳定性也将取决于 $\tau$ 。如果真实的被控对象的不确定性用乘性摄动来表示，也就是</p><script type="math/tex; mode=display">G_p(s)=G_n(s)(1+\Delta (s))</script><p>其中 $\Delta(s)$ 表示系统稳定性的乘性不确定性。根据小增益定理，干扰观测器的鲁棒稳定性条件为</p><script type="math/tex; mode=display">\lVert\Delta(s)Q(s)\rVert_\infty<1</script><p>通常系统的乘性不确定性在高频段增益较大，所以低通滤波器在高频段需要有较大的衰减，且带宽不能过大。所以<strong>低通滤波器的带宽需要在干扰观测器的抑制干扰能力与鲁棒稳定性之间进行折中</strong></p><h3 id="基于干扰观测器的闭环控制系统分析"><a href="#基于干扰观测器的闭环控制系统分析" class="headerlink" title="基于干扰观测器的闭环控制系统分析"></a>基于干扰观测器的闭环控制系统分析</h3><p><img src="/Blog_ButterFly/2024/03/30/DOB%E6%89%B0%E5%8A%A8%E8%A7%82%E6%B5%8B%E5%99%A8/v2-6d5f03f339e911df480c854f529985ed_720w.webp" alt="v2-6d5f03f339e911df480c854f529985ed_720w.webp"></p><p>通过采用干扰观测器，从控制输入 $u$ 到系统输出 $y$ 的传递函数可以近似为名义模型 $G_n(s)$ ，因此名义模型 $G_n(s)$ 可以设计外环控制器 $C(s)$ 以实现的控制性能</p><script type="math/tex; mode=display">G_{ry}(s)=\frac{C(s)G_p(s)G_n(s)}{G_n(s)(1+C(s)G_p(s))+(G_p(s)-G_n(s))Q(s)}\\G_{dy}(s)=\frac{G_p(s)G_n(s)-Q(s)G_p(s)G_n(s)}{G_n(s)(1+C(s)G_p(s))+(G_p(s)-G_n(s))Q(s)}\\G_{\xi y}(s)=\frac{G_p(s)(C(s)G_n(s)+Q(s))}{G_n(s)(1+C(s)G_p(s))+(G_p(s)-G_n(s))Q(s)}</script><p>则整个闭环系统的特征方程为</p><script type="math/tex; mode=display">G_n(s)(1+C(s)G_p(s))+(G_p(s)-G_n(s))Q(s)=0</script><p>当名义模型 $G_n(s)$ 与真实模型 $G_p(s)$ 之间不存在任何误差时，则上述中的特征方程为</p><script type="math/tex; mode=display">1+C(s)G_p(s)=0</script><p>与系统中不含干扰观测器内环时的特征方程一致，所以在名义模型与真实模型之间没有误差时，只要外环控制器 $C(s)$ 能够使系统稳定， 整个基于干扰观测器的闭环控制系统仍是稳定的，即干扰观测器内环不影响系统稳定性。</p><p>分析系统的鲁棒稳定性条件。假设真实被控对象具有乘性不确定性形式。若系统名义模型 $G_n(s)$ 为非最小相位系统， 且外环控制器 $C(s)$ 可以镇定 $G_n(s)$ ，则基于干扰观测器的整个闭环控制系统保持鲁棒稳定的充分条件是</p><script type="math/tex; mode=display">|\Delta(s)|<|\frac{1+C(s)G_n(s)}{Q(s)+C(s)G_n(s)}|</script><p>从上述条件可知，在低频段 $Q(s)\approx1$ ，应该满足 $|\Delta(s)|&lt;1$ ，要求低频段名义模型的建模误差不应过大，同时由于名义模型通常在高频段会有较大的不确定性，所以高频段 $Q(s)$ 的增益应尽量小</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/504256899">聊聊控制领域的干扰观测器(DOB) - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/xiaohejiaoyiya/article/details/104077561">【控制理论】干扰观测控制读书笔记（Disturbance Observer-Based on control)_干扰观测器里能带控制量吗-CSDN博客</a></p><p><a href="https://blog.csdn.net/jinpeng_cumt/article/details/107058723">非线性控制5——扰动观测器-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMU滤波</title>
      <link href="/Blog_ButterFly/2024/03/29/imu%E6%BB%A4%E6%B3%A2/"/>
      <url>/Blog_ButterFly/2024/03/29/imu%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h3><p><strong>二维</strong></p><script type="math/tex; mode=display">a=\begin{bmatrix}x_1\\y_1\end{bmatrix},b=\begin{bmatrix}x_2\\y_2\end{bmatrix}\\\Downarrow\\a\times b=x_1y_2-y_1x_2</script><p><strong>三维</strong></p><script type="math/tex; mode=display">a=\begin{bmatrix}x_1\\y_1\\z_1\end{bmatrix},b=\begin{bmatrix}x_2\\y_2\\z_2\end{bmatrix}\\\Downarrow\\a\times b=\begin{bmatrix}y_1z_2-z_1y_2\\z_1x_2-x_1z_2\\x_1y_2-y_1x_2\end{bmatrix}</script><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>是用三个角度表示物体的空间姿态，每个角度代表物体绕其一个固定轴的旋转量</p><ul><li><code>pitch</code> 俯仰角，一般来说向上转，也就是抬头为正</li><li><code>roll</code> 翻滚角，一般是向右侧倾倒为正</li><li><code>yaw</code> 航向角，一般是向右转为正</li></ul><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>对于三轴角度的旋转矩阵，如下</p><ul><li><p>绕 <code>x</code> 轴旋转</p><script type="math/tex; mode=display">  R_x(\theta)=\begin{bmatrix}1&0&0\\0&\cos\theta&-\sin\theta\\0&\sin\theta&\cos\theta\end{bmatrix}</script></li><li><p>绕 <code>y</code> 轴旋转</p><script type="math/tex; mode=display">  R_y(\gamma)=\begin{bmatrix}\cos\gamma&0&-\sin\gamma\\0&1&0\\\sin\gamma&0&\cos\gamma\end{bmatrix}</script></li><li><p>绕 <code>z</code> 轴旋转</p><script type="math/tex; mode=display">  R_z(\varphi)=\begin{bmatrix}\cos\varphi&-\sin\varphi&0\\\sin\varphi&\cos\varphi&0\\0&0&1\end{bmatrix}</script></li></ul><p>为了表示一个物体绕着三个轴的旋转，可以简单的将三个单轴的旋转矩阵相乘</p><script type="math/tex; mode=display">R=R_z(\varphi)R_y(\gamma)R_x(\theta)</script><p>得到</p><script type="math/tex; mode=display">R=\begin{bmatrix}\cos\gamma\cos\varphi&-cos\theta\sin\varphi-\cos\varphi\sin\gamma\sin\theta&\sin\varphi\sin\theta-\cos\varphi\cos\theta\sin\gamma\\\cos\gamma\sin\varphi&\cos\varphi\cos\theta-\sin\gamma\sin\varphi\sin\theta&-\cos\varphi\sin\theta-\cos\theta\sin\gamma\sin\varphi\\-\sin\gamma&\cos\gamma\sin\theta&\cos\gamma\cos\theta\end{bmatrix}</script><p>但是对于欧拉角的旋转，当任何一个坐标轴旋转角度为90度时，就会有两个轴的旋转动作起到对总体旋转结果相同的效果，这就被称为<strong>死锁</strong></p><h3 id="旋转矩阵与欧拉角"><a href="#旋转矩阵与欧拉角" class="headerlink" title="旋转矩阵与欧拉角"></a>旋转矩阵与欧拉角</h3><p>如上述公式，可以得到欧拉角与旋转矩阵的关系</p><script type="math/tex; mode=display">\gamma=-\arcsin R_{31}\\\theta=\arctan\frac{R_{32}}{R_{33}}\\\varphi=\arctan\frac{R_{21}}{R_{11}}</script><h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>也是一种姿态的表示，相较于欧拉角，计算更加简便，通过绕空间中的任意一个轴，旋转一定角度，就可以得到姿态角的朝向。与欧拉角和旋转矩阵相比，四元数在某些计算中具有优势，如插值和归一化。此外，四元数避免了所谓的“万向节锁，仅需要存储 4 个浮点数，比矩阵更加轻量，无论是求逆，串联操作，都比矩阵更快</p><p>四元数的表达式为</p><script type="math/tex; mode=display">q=q_0+q_1i+q_2j+q_3k</script><p>其中的虚向量满足</p><script type="math/tex; mode=display">i^2=j^2=k^2=ijk=-1</script><p>四元数可以理解为四维空间，三个虚部可理解为三维空间的三个正交基，而实部垂直于三维空间</p><p><strong>单位四元数</strong>是四维空间中一个超球上面的点，满足 $q_0^2+q_1^2+q_2^2+q_3^2=1$ ，而<strong>纯四元数</strong>是四维空间在 $w=0$ 时的一个子空间的点</p><p>单位四元数还有另一种表达公式</p><script type="math/tex; mode=display">q=\begin{bmatrix}\cos\frac{\theta}{2}&\sin\frac{\theta}{2}\vec{v}\end{bmatrix}</script><p><strong>共轭四元数</strong>指的是实部相同但是虚部相反的四元数，例如 $q$ 的共轭四元数为</p><script type="math/tex; mode=display">q^*=\begin{bmatrix}q_0&-q_1&-q_2&-q_3\end{bmatrix}</script><h3 id="四元数微分运算"><a href="#四元数微分运算" class="headerlink" title="四元数微分运算"></a>四元数微分运算</h3><p>四元数微分通常用下式表达</p><script type="math/tex; mode=display">\frac{dq}{dt}=0.5·q\otimes w</script><p>其中 $\otimes$ 是四元数乘法</p><p>展开这个四元数乘法，写作矩阵形式</p><script type="math/tex; mode=display">Q(q)=\begin{bmatrix}q_0&-q_1&-q_2&-q_3\\q_1&q_0&-q_3&q_2\\q_2&q_3&q_0&-q_1\\q_3&-q_2&q_1&q_0\end{bmatrix}</script><p>上述微分表达式可以写作</p><script type="math/tex; mode=display">\frac{dq}{dt}=0.5Q(q)\begin{bmatrix}0\\w_x\\w_y\\w_z\end{bmatrix}</script><p>上述四元数微分还有另一种表达方式</p><script type="math/tex; mode=display">\frac{dq}{dt}=0.5\begin{bmatrix}0&-w_x&-w_y&-w_z\\w_x&0&w_z&-w_y\\w_y&-w_z&0&w_x\\w_z&w_y&-w_x&0\end{bmatrix}q</script><h3 id="四元数与旋转矩阵"><a href="#四元数与旋转矩阵" class="headerlink" title="四元数与旋转矩阵"></a>四元数与旋转矩阵</h3><p>四元数与旋转矩阵之间可以相互转换</p><script type="math/tex; mode=display">R=\begin{bmatrix}1-2q_2^2-2q_3^2&2q_1q_2-2q_0q_3&2q_1q_3+2q_0q_2\\2q_1q_2+2q_0q_3&1-2q_1^2-2q_3^2&2q_2q_3-2q_0q_1\\2q_1q_3-2q_0q_2&2q_2q_3+2q_0q_1&1-2q_1^2-2q_2^2\end{bmatrix}</script><p>旋转矩阵需要九个参数，相比于四元数，参数量更多。但相比于四元数，旋转矩阵好处是更直观，代表着机体坐标系的三个轴的方向</p><h3 id="四元数与欧拉角"><a href="#四元数与欧拉角" class="headerlink" title="四元数与欧拉角"></a>四元数与欧拉角</h3><p>通过上述旋转矩阵，可以得到欧拉角表示下的四元数</p><script type="math/tex; mode=display">q=\begin{bmatrix}\cos\frac{\theta}{2}\cos\frac{\gamma}{2}\cos\frac{\varphi}{2}+\sin\frac{\theta}{2}\sin\frac{\gamma}{2}\sin\frac{\varphi}{2}\\\cos\frac{\theta}{2}\sin\frac{\gamma}{2}\cos\frac{\varphi}{2}+\sin\frac{\theta}{2}\cos\frac{\gamma}{2}\sin\frac{\varphi}{2}\\\cos\frac{\theta}{2}\cos\frac{\gamma}{2}\sin\frac{\varphi}{2}-\sin\frac{\theta}{2}\sin\frac{\gamma}{2}\cos\frac{\varphi}{2}\\\sin\frac{\theta}{2}\cos\frac{\gamma}{2}\cos\frac{\varphi}{2}-\cos\frac{\theta}{2}\sin\frac{\gamma}{2}\sin\frac{\varphi}{2}\end{bmatrix}</script><p><a href="https://quaternions.online/">欧拉角与四元数关系图</a></p><p>同理可以得到四元数表示下的欧拉角</p><script type="math/tex; mode=display">\begin{bmatrix}\theta\\\gamma\\\varphi\end{bmatrix}=\begin{bmatrix}\arctan\frac{2q_2q_3+2q_0q_1}{1-2q_1^2-2q_2^2}\\-\arcsin (2q_1q_3-2q_0q_2)\\\arctan\frac{2q_1q_2+2q_0q_3}{1-2q_2^2-2q_3^2}\end{bmatrix}</script><h3 id="四元数运算"><a href="#四元数运算" class="headerlink" title="四元数运算"></a>四元数运算</h3><p>对于四元数的叉乘，在 matlab 中是不支持四元数的叉乘的，所以就有了如下两种定义</p><script type="math/tex; mode=display">Q_1\otimes Q_2\\\Downarrow\\\begin{bmatrix}Q_1\end{bmatrix}_L· Q_2\\\Downarrow\\\begin{bmatrix}q_0&-q_1&-q_2&-q_3\\q_1&q_0&-q_3&q_2\\q_2&q_3&q_0&-q_1\\q_3&-q_2&q_1&q_0\end{bmatrix}·Q_2</script><script type="math/tex; mode=display">Q_1\otimes Q_2\\\Downarrow\\\begin{bmatrix}Q_2\end{bmatrix}_R· Q_1\\\Downarrow\\\begin{bmatrix}q_0&-q_1&-q_2&-q_3\\q_1&q_0&q_3&-q_2\\q_2&-q_3&q_0&q_1\\q_3&q_2&-q_1&q_0\end{bmatrix}·Q_1</script><h3 id="坐标系之间的映射"><a href="#坐标系之间的映射" class="headerlink" title="坐标系之间的映射"></a>坐标系之间的映射</h3><p>对于在 Earth 参考系下的任意一个向量</p><script type="math/tex; mode=display">^Ed=\begin{bmatrix}0&d_x&d_y&d_z\end{bmatrix}</script><p>在 Sensor 坐标系下通过传感器读出的数据为</p><script type="math/tex; mode=display">^Sd=^S_Eq^*\times {^Ed}\times {^S_Eq}</script><h2 id="Mahony滤波"><a href="#Mahony滤波" class="headerlink" title="Mahony滤波"></a>Mahony滤波</h2><p>这一部分参考于 <a href="https://zhuanlan.zhihu.com/p/654496867">陀螺仪姿态解算+mahony滤波算法（公式推导及其代码） - 知乎 (zhihu.com)</a></p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>只有角速度积分所得到的角度会漂移，需要有绝对真实的加速度去修正积分带来的误差，所以先将欧拉角的角速度得到四元数的角速度，然后积分得到当前四元数，再转化为欧拉角。</p><h3 id="根据四元数得到重力方向"><a href="#根据四元数得到重力方向" class="headerlink" title="根据四元数得到重力方向"></a>根据四元数得到重力方向</h3><script type="math/tex; mode=display">g_x=2(q_1q_3-q_0q_2)\\g_y=2(q_0q_1+q_2q_3)\\g_z=q_0q_0-q_1q_1-q_2q_2+q_3q_3</script><h3 id="计算积分带来的误差"><a href="#计算积分带来的误差" class="headerlink" title="计算积分带来的误差"></a>计算积分带来的误差</h3><p>根据上述可以得到仅有重力加速度的加速度矢量</p><script type="math/tex; mode=display">g=\begin{bmatrix}g_x\\g_y\\g_z\end{bmatrix}</script><p>并且我们可以根据角速度积分得到的欧拉角和加速度所计算出的加速度矢量</p><script type="math/tex; mode=display">a=\begin{bmatrix}a_x\\a_y\\a_z\end{bmatrix}</script><p>叉乘得到</p><script type="math/tex; mode=display">|a||g|\sin e=a\times g</script><p>小角度近似 $\sin\psi=\psi$ ，所以就是</p><script type="math/tex; mode=display">e=\frac{a\times g}{|a||g|}</script><p>这就能看出来积分得到的数据与真实数据之间的误差了</p><h3 id="PI控制器修正误差"><a href="#PI控制器修正误差" class="headerlink" title="PI控制器修正误差"></a>PI控制器修正误差</h3><p>PI控制器可以看作是一个低通滤波器，它用于整合加速度计的低频信息并与陀螺仪读数互补，从而实现互补滤波的效果</p><script type="math/tex; mode=display">\begin{bmatrix}\dot\theta\\\dot\gamma\\\dot\varphi\end{bmatrix}=\begin{bmatrix}\dot\theta\\\dot\gamma\\\dot\varphi\end{bmatrix}+k_p\begin{bmatrix}e_x\\e_y\\e_z\end{bmatrix}+k_i\begin{bmatrix}e_x\\e_y\\e_z\end{bmatrix}\triangle t</script><h3 id="得到当前四元数"><a href="#得到当前四元数" class="headerlink" title="得到当前四元数"></a>得到当前四元数</h3><p>由上述可知</p><script type="math/tex; mode=display">\frac{dq}{dt}=0.5\begin{bmatrix}0&-w_x&-w_y&-w_z\\w_x&0&w_z&-w_y\\w_y&-w_z&0&w_x\\w_z&w_y&-w_x&0\end{bmatrix}q</script><p>则有</p><script type="math/tex; mode=display">q_{k+1}=0.5\triangle t\begin{bmatrix}0&-w_x&-w_y&-w_z\\w_x&0&w_z&-w_y\\w_y&-w_z&0&w_x\\w_z&w_y&-w_x&0\end{bmatrix}q_k+q_k</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>根据上述公式，可以得到如下 C 代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DELTAT 0.005f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> q0;</span><br><span class="line">  <span class="type">float</span> q1;</span><br><span class="line">  <span class="type">float</span> q2;</span><br><span class="line">  <span class="type">float</span> q3;</span><br><span class="line">&#125; Quaternion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> roll;   <span class="comment">// x</span></span><br><span class="line">  <span class="type">float</span> pitch;  <span class="comment">// y</span></span><br><span class="line">  <span class="type">float</span> yaw;    <span class="comment">// z</span></span><br><span class="line">&#125; Euler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">  <span class="type">float</span> z;</span><br><span class="line">&#125; Acceleration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂定，需要调试才能确定</span></span><br><span class="line">Acceleration MahonyKp = &#123; <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">Acceleration MahonyKi = &#123; <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuaternionToEuler</span><span class="params">(Quaternion _q, Euler* _e)</span> &#123;</span><br><span class="line">  <span class="type">float</span> rolly = <span class="number">2</span> * _q.q2 * _q.q3 + <span class="number">2</span> * _q.q0 * _q.q1;</span><br><span class="line">  <span class="type">float</span> rollx = <span class="number">1</span> - <span class="number">2</span> * _q.q1 * _q.q1 - <span class="number">2</span> * _q.q2 * _q.q2;</span><br><span class="line">  _e-&gt;roll    = atan2f(rolly, rollx);</span><br><span class="line">  _e-&gt;pitch   = <span class="built_in">asin</span>(<span class="number">2</span> * _q.q1 * _q.q3 - <span class="number">2</span> * _q.q0 * _q.q2);</span><br><span class="line">  <span class="type">float</span> yawy  = <span class="number">2</span> * _q.q1 * _q.q2 + <span class="number">2</span> * _q.q0 * _q.q3;</span><br><span class="line">  <span class="type">float</span> yawx  = <span class="number">1</span> - <span class="number">2</span> * _q.q2 * _q.q2 - <span class="number">2</span> * _q.q3 * _q.q3;</span><br><span class="line">  _e-&gt;yaw     = atan2f(yawy, yawx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EulerToQuaternion</span><span class="params">(Euler _e, Quaternion* _q)</span> &#123;</span><br><span class="line">  <span class="type">float</span> cosRoll  = cosf(_e.roll / <span class="number">2</span>);</span><br><span class="line">  <span class="type">float</span> sinRoll  = sinf(_e.roll / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> cosPitch = cosf(_e.pitch / <span class="number">2</span>);</span><br><span class="line">  <span class="type">float</span> sinPitch = sinf(_e.pitch / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> cosYaw   = cosf(_e.yaw / <span class="number">2</span>);</span><br><span class="line">  <span class="type">float</span> sinYaw   = sinf(_e.yaw / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  _q-&gt;q0         = cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw;</span><br><span class="line">  _q-&gt;q1         = cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw;</span><br><span class="line">  _q-&gt;q2         = cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw;</span><br><span class="line">  _q-&gt;q3         = sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mahony</span><span class="params">(Acceleration _a, Euler* _e, Quaternion* _q, Euler _dote)</span> &#123;</span><br><span class="line">  <span class="type">float</span> anorm     = sqrtf(_a.x * _a.x + _a.y * _a.y + _a.z * _a.z);</span><br><span class="line">  _a.x           /= anorm;</span><br><span class="line">  _a.y           /= anorm;</span><br><span class="line">  _a.z           /= anorm;</span><br><span class="line"></span><br><span class="line">  Acceleration g  = &#123;</span><br><span class="line">    <span class="number">2</span> * (_q-&gt;q1 * _q-&gt;q3 - _q-&gt;q0 * _q-&gt;q2),</span><br><span class="line">    <span class="number">2</span> * (_q-&gt;q0 * _q-&gt;q1 + _q-&gt;q2 * _q-&gt;q3),</span><br><span class="line">    _q-&gt;q0 * _q-&gt;q0 - _q-&gt;q1 * _q-&gt;q1 - _q-&gt;q2 * _q-&gt;q2 + _q-&gt;q3 * _q-&gt;q3</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Acceleration err = &#123;</span><br><span class="line">    _a.y * g.z - _a.z * g.y,</span><br><span class="line">    _a.z * g.x - _a.x * g.z,</span><br><span class="line">    _a.x * g.y - _a.y * g.x,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  _dote.roll  += MahonyKp.x * err.x + MahonyKi.x * err.x * DELTAT;</span><br><span class="line">  _dote.pitch += MahonyKp.y * err.y + MahonyKi.y * err.y * DELTAT;</span><br><span class="line">  _dote.yaw   += MahonyKp.z * err.z + MahonyKi.z * err.z * DELTAT;</span><br><span class="line"></span><br><span class="line">  Quaternion qdot;</span><br><span class="line">  qdot.q0  = -_dote.roll * _q-&gt;q1 - _dote.pitch * _q-&gt;q2 - _dote.yaw * _q-&gt;q3;</span><br><span class="line">  qdot.q1  = _dote.roll * _q-&gt;q0 + _dote.yaw * _q-&gt;q2 - _dote.pitch * _q-&gt;q3;</span><br><span class="line">  qdot.q2  = _dote.pitch * _q-&gt;q0 - _dote.yaw * _q-&gt;q1 + _dote.roll * _q-&gt;q3;</span><br><span class="line">  qdot.q3  = _dote.yaw * _q-&gt;q0 + _dote.pitch * _q-&gt;q1 - _dote.roll * _q-&gt;q2;</span><br><span class="line"></span><br><span class="line">  _q-&gt;q0  += <span class="number">0.5</span> * DELTAT * qdot.q0;</span><br><span class="line">  _q-&gt;q1  += <span class="number">0.5</span> * DELTAT * qdot.q1;</span><br><span class="line">  _q-&gt;q2  += <span class="number">0.5</span> * DELTAT * qdot.q2;</span><br><span class="line">  _q-&gt;q3  += <span class="number">0.5</span> * DELTAT * qdot.q3;</span><br><span class="line"></span><br><span class="line">  QuaternionToEuler(*_q, _e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述的 Mahony 滤波算法实际上是基于就静止状态下的，只有在静止状态下才能使得机体的加速度 $a$ 是只有重力加速度反馈的，所以需要注意，当 $|a|$ 的大小不等于重力加速度时，置信度应该降低，对这一部分可以采用自适应的扩展卡尔曼滤波来做权重的分配</p><h2 id="Madgwick融合算法"><a href="#Madgwick融合算法" class="headerlink" title="Madgwick融合算法"></a><strong>Madgwick融合算法</strong></h2><p><img src="/Blog_ButterFly/2024/03/29/imu%E6%BB%A4%E6%B3%A2/v2-9ac058e63ce0e1bee5edf9069df0cb1d_720w.webp" alt="v2-9ac058e63ce0e1bee5edf9069df0cb1d_720w.webp"></p><p>通过陀螺仪的加速度初步计算传感器方向的偏移 $^S_Eq_{w,t}$ 然后通过对重力加速度和地磁这两个恒定量在传感器坐标系下的投影计算传感器方向的偏移 $^S_Eq_{\triangledown,t}$。最后通过互补滤波器融合 $^S_Eq_{w,t}$ 和 $^S_Eq_{\triangledown,t}$ 来得到一个更加可信的结果，此外还要矫正地磁计数据畸变和陀螺仪零点漂移。其中 $^S_Eq$ 表示坐标系 Earth 相对于坐标系 Sensor 的单位旋转四元数</p><h3 id="计算-S-Eq-w-t"><a href="#计算-S-Eq-w-t" class="headerlink" title="计算 $^S_Eq_{w,t}$"></a>计算 $^S_Eq_{w,t}$</h3><p>从陀螺仪中读取到的数据为</p><script type="math/tex; mode=display">^Sw_t=\begin{bmatrix}0&w_x&w_y&w_z\end{bmatrix}</script><p>地面参考系相对于传感器参考系的旋转可以由其四元数的导数对时间的积分获得，由上述可知</p><script type="math/tex; mode=display">{^S_Eq_{w,t}}={^S_E\hat{q}_{est,t-1}}+(\frac{1}{2}{^S_E\hat{q}_{est,t-1}}\otimes {^Sw_t})\triangle t={^S_E\hat{q}_{est,t-1}}+{^S_E\dot{q}_{w,t}}\triangle t</script><p>其中 ${^S_E\hat{q}_{est,t-1}}$ 是上一时刻的估计值，这个值就是根据角速度所 $^S_Eq_{w,t}$</p><h3 id="计算-S-Eq-triangledown-t"><a href="#计算-S-Eq-triangledown-t" class="headerlink" title="计算 $^S_Eq_{\triangledown,t}$"></a>计算 $^S_Eq_{\triangledown,t}$</h3><p>如果一个地球场的方向在地球框架内是已知的，那么在传感器框架内测量该场的方向就可以计算出传感器框架相对于地球框架的方向。然而，对于任何给定的测量，将不会有唯一的传感器方向解，相反，将有无限的解由所有这些方向表示，这些方向是通过将真实方向绕与场平行的轴旋转来实现的。</p><p>者是利用外部恒定的向量在各个角度的投影来估算传感器的位姿，在 IMU 中利用重力加速度，在 MARG 中同时利用重力加速度和地磁方向来计算。对于在 Earth 参考系下的任意一个向量</p><script type="math/tex; mode=display">^Ed=\begin{bmatrix}0&d_x&d_y&d_z\end{bmatrix}</script><p>在 Sensor 坐标系下通过传感器直接读出的数据为 $^Ss$ ，还有就是通过传感器所测量出的四元数转换之后所得到的向量为</p><script type="math/tex; mode=display">^Sd=^S_Eq^*\times {^Ed}\times {^S_Eq}</script><p>其中 $^S_Eq^*$ 为 ${^S_Eq}$ 的共轭四元数。但是这两者是通过不同的方式得到的，也就有了估计 $^S_Eq$ 的一个方法，就是构建目标函数</p><script type="math/tex; mode=display">\min f=^S_Eq^*\otimes {^Ed}\otimes {^S_Eq}-{^Ss}</script><p>使得 $f$ 取得最小值时的 $^S_Eq$ 就是最终结果（最优结果），优化算法可以使用梯度下降法，通过迭代公式来计算</p><script type="math/tex; mode=display">^S_Eq_{k+1}=^S_Eq_{k}-\mu \frac{\triangledown f}{\lVert\triangledown f\rVert}</script><p>其中 $u$ 就是学习率，而 $\triangledown f$ 就是 $f$ 的梯度。计算由目标函数及其雅克比定义的解曲面的梯度</p><script type="math/tex; mode=display">\triangledown f=J^T({^S_Eq_k,{^Ed}})f</script><p>其中</p><script type="math/tex; mode=display">J=\frac{\partial f}{\partial {^S_Eq_k}}</script><p>上述所得到的公式适用于空间中的任意一个方向的向量，太复杂了，不好求解，看其中的思路就是把叉乘的列向量扩展到了一个方阵，类似于上式中求解四元数的加速度的方程</p><p><img src="/Blog_ButterFly/2024/03/29/imu%E6%BB%A4%E6%B3%A2/1711678115108.png" alt="1711678115108.png"></p><p><img src="/Blog_ButterFly/2024/03/29/imu%E6%BB%A4%E6%B3%A2/1711678667170.png" alt="1711678667170.png"></p><p><strong>IMU</strong></p><p>如果使用的是 IMU ，那其中的 $^Ed$ 就是重力加速度向量 $\begin{bmatrix}0&amp;0&amp;0&amp;1\end{bmatrix}$</p><p>并且 $^Ss$ 就是 IMU 传感器所测出来的在 Sensor 坐标下的重力加速度的向量 $\begin{bmatrix}0&amp;a_x&amp;a_y&amp;a_z\end{bmatrix}$ ，带入上述公式可以得到</p><script type="math/tex; mode=display">f=\begin{bmatrix}2(q_2q_3-q_1q_3)-a_x\\2(q_1q_2+q_3q_4)-a_y\\2(\frac{1}{2}-q_2^2-q_3^2)-a_z\end{bmatrix}\\J=\begin{bmatrix}-2q_3&2q_4&-2q_1&2q_2\\2q_2&2q_1&2q_4&2q_3\\0&-4q_2&-4q_3&0\end{bmatrix}</script><p><strong>MARG</strong></p><p>如果使用的是 MARG，在考虑重力加速度的基础上还需要将当地的地磁传感器的读数考虑进来。</p><script type="math/tex; mode=display">^Ed=\begin{bmatrix}0&b_x&0&b_z\end{bmatrix}</script><p>这里是纯地磁传感器所得到的数据</p><script type="math/tex; mode=display">\\{^Sm}=\begin{bmatrix}0&m_x&m_y&m_z\end{bmatrix}</script><p>再与上述的加速度数据融合，也就是</p><script type="math/tex; mode=display">{^Sa}=\begin{bmatrix}0&a_x&a_y&a_z\end{bmatrix}</script><p>写作一个矩阵，就是</p><script type="math/tex; mode=display">f=\begin{bmatrix}f_g({^S_Eq,{^Sa}})\\f_d({^S_Eq,{^Ed},{^Sm}})\end{bmatrix}</script><p>对应的雅各比矩阵就是</p><script type="math/tex; mode=display">J=\begin{bmatrix}J^T_g({^S_Eq})\\J_d^T({^S_Eq},{^Ed})\end{bmatrix}</script><p>根据迭代公式</p><script type="math/tex; mode=display">^S_Eq_{\triangledown,t}={^S_E\hat{q}_{est,t-1}}-\mu_t \frac{\triangledown f}{\lVert\triangledown f\rVert}</script><p>其中</p><script type="math/tex; mode=display">\triangledown f=\left\{\begin{aligned}&J^T_g({^S_E\hat{q}_{est,t-1}})f_g({^S_E\hat{q}_{est,t-1}},{^Sa_t})\\&J^T({^S_E\hat{q}_{est,t-1}},{^E\hat{b}_t})f({^S_E\hat{q}_{est,t-1}},{^Sa_t},{^Eb_t},{^Sm_t})\end{aligned}\right.</script><p>学习率的选择需要满足</p><script type="math/tex; mode=display">\mu_t=\alpha \lVert{^S_E\dot q_{w,t}}\rVert\triangle t</script><p>其中 $\alpha&gt;1$ </p><h3 id="融合滤波算法"><a href="#融合滤波算法" class="headerlink" title="融合滤波算法"></a>融合滤波算法</h3><p>将上述中计算出的方向四元数 $^S_Eq_{w,t}$ 和 $^S_Eq_{\triangledown,t}$ 进行融合，可以估计得到传感器相对于地球坐标系的方向 $^S_Eq_{est,t}$ ，如下</p><script type="math/tex; mode=display">^S_Eq_{est,t}=\gamma q_{\triangledown,t}+(1-\gamma){^S_Eq_{w,t}}</script><p>其中 $0\leq \gamma\leq 1$ ，其中 $\gamma$ 的最优值可以定义为确保 $^S_Eq_{w,t}$ 的加权发散度等于 $^S_Eq_{\triangledown,t}$ 的加权收敛度。可以将 $\gamma$ 定义为如下公式</p><script type="math/tex; mode=display">(1-\gamma)\beta=\gamma\frac{\mu_t}{\Delta}\\\gamma=\frac{\beta}{\frac{\mu_t}{\Delta}+\beta}</script><p>假设上述中由 $\alpha$ 控制的 $^S_Eq_{\triangledown}$ 的收敛速度等于或大于实际方向变化速率，上述公式就保证了 $^S_Eq_{w,t}$ 和 $^S_Eq_{\triangledown,t}$ 的最优融合。</p><p>由上述可知 $\alpha$ 没有上界，如果 $\alpha$ 非常大时，那么上述公式中所定义的 $\mu_t$ 就非常大，那这个滤波也就简化了，这意味着 ${^S_E\hat{q}_{est,t-1}}$ 可以忽略不计，所以公式可以写作</p><script type="math/tex; mode=display">^S_Eq_{\triangledown,t}=-\mu_t \frac{\triangledown f}{\lVert\triangledown f\rVert}</script><p>相应的公式中的 $\gamma$ 也简化了，公式中的 $\beta$ 项可以忽略不计，因此可写作</p><script type="math/tex; mode=display">\gamma=\frac{\beta\Delta t}{\mu_t}</script><p>甚至可以假设 $\gamma=0$ 。将上述得到的带入融合滤波公式，可以得到</p><script type="math/tex; mode=display">^S_Eq_{est,t}=\gamma q_{\triangledown,t}+(1-\gamma){^S_Eq_{w,t}}\\=\frac{\beta\Delta t}{\mu_t}(-\mu_t \frac{\triangledown f}{\lVert\triangledown f\rVert})+(1-0)({^S_E\hat{q}_{est,t-1}}+{^S_E\dot{q}_{w,t}}\triangle t)\\={^S_E\hat{q}_{est,t-1}}+({^S_E\dot{q}_{w,t}}-\beta\frac{\triangledown f}{\lVert\triangledown f\rVert})\Delta t</script><p>上式就可以化简为</p><script type="math/tex; mode=display">^S_Eq_{est,t}={^S_E\hat{q}_{est,t-1}}+{^S_E\dot{q}_{est,t}}\Delta t</script><p>其中</p><script type="math/tex; mode=display">^S_E\dot{q}_{est,t}={^S_E}\dot{q}_{w,t}-\beta{^S_E\dot{\hat{q}}_{\varepsilon,t}}\\{^S_E\dot{\hat{q}}_{\varepsilon,t}}=\frac{\triangledown f}{\lVert\triangledown f\rVert}</script><p>可以看出，滤波器通过对估计的方向四元数导数 $^S_E\dot{q}_{est}$ 进行数值积分得到方向 $^S_E\dot{q}_{est}$ 。滤波器将其计算为陀螺仪测量方向变化率 $^S_E\dot{q}_{w}$ 。有了陀螺仪测量误差 $\beta$ ，然后再估计误差方向上减去从加速度计和磁力计测量计算得到的 ${^S_E\dot{\hat{q}}_{\varepsilon}}$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>由于 matlab 中并不支持四元数的叉乘，所以写了一个函数来实现四元数的叉乘</p><p>首先是四元数转化为方阵形式，根据上述的说明，有两种转化方式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">transR</span><span class="params">(q1)</span></span></span><br><span class="line">    res = [q1(<span class="number">1</span>) -q1(<span class="number">2</span>) -q1(<span class="number">3</span>) -q1(<span class="number">4</span>);</span><br><span class="line">           q1(<span class="number">2</span>) q1(<span class="number">1</span>) q1(<span class="number">4</span>) -q1(<span class="number">3</span>);</span><br><span class="line">           q1(<span class="number">3</span>) -q1(<span class="number">4</span>) q1(<span class="number">1</span>) q1(<span class="number">2</span>);</span><br><span class="line">           q1(<span class="number">4</span>) q1(<span class="number">3</span>) -q1(<span class="number">2</span>) q1(<span class="number">1</span>);];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">transL</span><span class="params">(q1)</span> </span></span><br><span class="line">    res = [q1(<span class="number">1</span>) -q1(<span class="number">2</span>) -q1(<span class="number">3</span>) -q1(<span class="number">4</span>);</span><br><span class="line">           q1(<span class="number">2</span>) q1(<span class="number">1</span>) -q1(<span class="number">4</span>) q1(<span class="number">3</span>);</span><br><span class="line">           q1(<span class="number">3</span>) q1(<span class="number">4</span>) q1(<span class="number">1</span>) -q1(<span class="number">2</span>);</span><br><span class="line">           q1(<span class="number">4</span>) -q1(<span class="number">3</span>) q1(<span class="number">2</span>) q1(<span class="number">1</span>);];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>所以此传感器的代码为（未加磁偏角）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">syms q1(t) q2(t) q3(t) q0(t) dx dy dz ax ay az bx bz mx my mz</span><br><span class="line"></span><br><span class="line">q = [q0(t) q1(t) q2(t) q3(t)]&#x27;;</span><br><span class="line">q_conj = [q0(t) -q1(t) -q2(t) -q3(t)]&#x27;;</span><br><span class="line">g = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]&#x27;;</span><br><span class="line">a = [<span class="number">0</span> ax ay az]&#x27;;</span><br><span class="line"></span><br><span class="line">fg = transR(q) * transL(q_conj) * g - a;</span><br><span class="line">fg = subs(fg, [<span class="built_in">conj</span>(ax), <span class="built_in">conj</span>(ay), <span class="built_in">conj</span>(az)], [ax, ay, az]);</span><br><span class="line">fg = subs(fg, [<span class="built_in">conj</span>(q0(t)), <span class="built_in">conj</span>(q1(t)), <span class="built_in">conj</span>(q2(t)), <span class="built_in">conj</span>(q3(t))], [q0(t), q1(t), q2(t), q3(t)]);</span><br><span class="line">fg = simplify(fg);</span><br><span class="line">Jg = jacobian(fg, [q0; q1; q2; q3]);</span><br><span class="line">Jg = simplify(Jg);</span><br><span class="line"></span><br><span class="line">b = [<span class="number">0</span> bx <span class="number">0</span> bz]&#x27;;</span><br><span class="line">m = [<span class="number">0</span> mx my mz]&#x27;;</span><br><span class="line"></span><br><span class="line">fb = transR(q) * transL(q_conj) * b - m;</span><br><span class="line">fb = subs(fb, [<span class="built_in">conj</span>(mx), <span class="built_in">conj</span>(my), <span class="built_in">conj</span>(mz)], [mx, my, mz]);</span><br><span class="line">fb = subs(fb, [<span class="built_in">conj</span>(bx), <span class="built_in">conj</span>(bz)], [bx, bz]);</span><br><span class="line">fb = subs(fb, [<span class="built_in">conj</span>(q0(t)), <span class="built_in">conj</span>(q1(t)), <span class="built_in">conj</span>(q2(t)), <span class="built_in">conj</span>(q3(t))], [q0(t), q1(t), q2(t), q3(t)]);</span><br><span class="line">fb = simplify(fb);</span><br><span class="line">Jb = jacobian(fb, [q0; q1; q2; q3]);</span><br><span class="line">Jb = simplify(Jb);</span><br><span class="line"></span><br><span class="line">Fg = Jg&#x27; * fg;</span><br><span class="line">Fg = subs(Fg, [<span class="built_in">conj</span>(ax), <span class="built_in">conj</span>(ay), <span class="built_in">conj</span>(az)], [ax, ay, az]);</span><br><span class="line">Fg = subs(Fg, [<span class="built_in">conj</span>(q0(t)), <span class="built_in">conj</span>(q1(t)), <span class="built_in">conj</span>(q2(t)), <span class="built_in">conj</span>(q3(t))], [q0(t), q1(t), q2(t), q3(t)]);</span><br><span class="line"></span><br><span class="line">Fb = [Jg&#x27;, Jb&#x27;] * [fg; fb];</span><br><span class="line">Fb = subs(Fb, [<span class="built_in">conj</span>(mx), <span class="built_in">conj</span>(my), <span class="built_in">conj</span>(mz)], [mx, my, mz]);</span><br><span class="line">Fb = subs(Fb, [<span class="built_in">conj</span>(bx), <span class="built_in">conj</span>(bz)], [bx, bz]);</span><br><span class="line">Fb = subs(Fb, [<span class="built_in">conj</span>(q0(t)), <span class="built_in">conj</span>(q1(t)), <span class="built_in">conj</span>(q2(t)), <span class="built_in">conj</span>(q3(t))], [q0(t), q1(t), q2(t), q3(t)]);</span><br><span class="line"></span><br><span class="line">Fgnorm = norm(Fg);</span><br><span class="line">Fbnorm = norm(Fb);</span><br><span class="line"></span><br><span class="line"><span class="built_in">beta</span> = <span class="number">1</span>;</span><br><span class="line">DeltaT = <span class="number">0.001</span>;</span><br><span class="line"></span><br><span class="line">syms w0 w1 w2 w3</span><br><span class="line">qw_dot = [w0 w1 w2 w3]&#x27;;</span><br><span class="line"></span><br><span class="line">q1 = q + (qw_dot  - <span class="built_in">beta</span> * Fg / Fgnorm) * DeltaT</span><br><span class="line">q2 = q + (qw_dot  - <span class="built_in">beta</span> * Fb / Fbnorm) * DeltaT</span><br></pre></td></tr></table></figure><p>其中 $Fg$ 和 $Fb$ 分别是在 IMU 和 MARG 条件下的 $\triangledown f$ ，最终得到的 $q_1$ 和 $q_2$ 就是该条件下滤波的最终结果</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
            <tag> imu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习</title>
      <link href="/Blog_ButterFly/2024/03/26/stm32%E5%AD%A6%E4%B9%A0/"/>
      <url>/Blog_ButterFly/2024/03/26/stm32%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="stm32f4内部的flash"><a href="#stm32f4内部的flash" class="headerlink" title="stm32f4内部的flash"></a>stm32f4内部的flash</h2><p>stm32芯片内部有一个flash存储器，主要用于存储编译之后烧录进来的代码，由于flash存储器的内容在掉电之后不会丢失，芯片重新上电复位之后内核可以从内部flash中加载代码并运行。</p><p>除了使用外部的工具（如下载器）读写内部FLASH外，STM32F4芯片在运行的时候，也能对自身的内部FLASH进行读写，因此，若内部FLASH存储了应用程序后还有剩余空间，我们可以把它像外部SPI-FLASH那样利用起来，存储一些程序运行时产生的需要掉电保存的数据。</p><p>由于访问内部FLASH比外部SPI-FLASH的速度快的多，所以在紧急状态下常常会使用内部FLASH存储关键记录；为了防止应用程序被抄袭，有的应用会禁止读写内部FLASH中的内容，或者在第一次运行时计算机机密信息并记录到某些区域，然后删除自身的部分加密代码，这些都涉及到内部FLASH的操作。</p><p>芯片内部存储的分区</p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><ul><li>介绍芯片时提到的flash的内存的大小都是指主存储器的大小，用于存放代码和数据常量（例如const类型的数据）。</li><li>主存储器分为<strong>256</strong>页，每页大小<strong>2KB</strong>，一共512KB。这个分页就是FLASH的存储扇区，与其他的FLASH一样，写入数据前要先按照页就是扇区进行擦除。</li><li>stm32f4的主存储器分为4个 16KB 扇区、1个 64KB 扇区和 7个 128KB 扇区</li><li><p>stm32的型号：STM32F4ZG</p><ul><li><p>G代表FLASH的大小</p><p>4表示16KB；       6表示32KB；      8表示64KB；      B表示128KB</p><p>C表示256KB；    E表示512KB；    F表示768KB；    <strong>G表示1024KB</strong></p></li></ul></li><li><p>闪存存储器接口寄存器</p><ul><li>用于控制闪存读写，是整个闪存模块的控制机构</li><li>在执行闪存写操作时，任何对闪存的读操作都是锁住总线，在写操作完成后，读操作才能正确进行；<strong>也就是说在进行写或者擦除操作时，不能进行数据或者代码的读取操作</strong>。</li></ul></li><li><p>内部FLASH写入过程</p><ol><li><p>解锁<br>由于内部FLASH空间主要存储的是应用程序。是非常关键的数据，为了防止误操作修改了这些内容，芯片复位后默认会给 FLASH 上锁，这个时候不再允许设置 FLASH 的控制寄存器，同时也不能修改 FLASH 中的内容。</p><p>所以对 FLASH 写入程序之前，需要先对其进行解锁操作。</p><ul><li>往 FLASH 密钥寄存器 FLASH_KEYR 中写入 KEY1=0x45670123</li><li>再往 FLASH 密钥寄存器 FLASH_KEYR 中写入 KEY2=0xCDEF89AB</li></ul></li><li><p>擦除扇区</p><p>在写入新的数据前，需要先擦除存储区域，STM32提供了<strong>扇区擦除指令</strong>和 <strong>整个FLASH擦除——批量擦除</strong>的指令，批量擦除指令仅针对主存储区。</p><p><strong>扇区擦除的过程</strong></p><ul><li>检查FLASH_SR状态寄存器的 “忙碌寄存器BSY” ，以确认当前未执行任何FLASH操作</li><li>在FLASH_CR寄存器中，将 “激活页擦除寄存器位PER” 置1</li><li>用FLASH_AR寄存器选择要擦除的页<br>将FLASH_CR控制寄存器中的 “开始擦除寄存器位STRT” 置1，开始擦除</li><li>等待BSY位被清零，表示擦除完成</li></ul></li><li><p>写入数据</p><p>擦除完毕后即可写入数据，写入数据的过程并不是仅仅使用指针指向地址赋值，赋值前还需要配置一系列的寄存器</p><ul><li>检查FLASH_SR状态寄存器中的BSY位，以确认当前未执行任何其他的内部FLASH操作</li><li>将FLASH_CR控制寄存器中 “激活编程寄存器位PG” 置1</li><li>向指定的FLASH存储器地址执行数据写入操作，每次只能以16位的方式写入</li><li>等待BSY位被清零时，表示写入成功</li></ul></li><li><p>查看工程的空间分布</p><p>由于内部FLASH本身存储有程序数据，若不是有意删除某段程序代码，一般不应该修改程序空间的内容，所以在使用内部FLASH存储其他数据前需要了解哪一些空间已经写入了程序代码，存储了程序代码的扇区都不应做任何的修改。通过查询应用程序编译时产生的 “*.map” 后缀文件，可以了解程序存储到了哪些区域。</p></li></ol></li></ul><ol><li><p><strong>系统存储器</strong></p><p> 系统存储器是STM32开发板出厂之前就已经使用的一块区域，用户是无法访问系统存储区的，主要是做串口下载程序的支持，以及USB、CAN等ISP烧录功能。（系统存储器主要是用来存放STM32F4的bootloader代码，此代码是出厂的时候就固化在STM32F4里面的，专门来给主存储器下载代码的）</p></li><li><p><strong>OTP区域</strong></p><p> <strong>一次性可编程区域</strong>，共528字节，被分成两部分，前面512个字节（32字节为1块，分成16块），可以用来存储一些用户数据（一次性的，写完一次，永远不可以擦除）后面16个字节，用于锁定对应块。</p></li><li><p><strong>选项字节区域</strong></p><p> 选项字节区域是用来配置FLASH的读写保护、待机/停机、软件/硬件看门狗功能。可以通过修改FLASH的选项控制<a href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&amp;spm=1001.2101.3001.7020">寄存器</a>进行修改。</p></li></ol><h2 id="鼎新图蓝牙使用"><a href="#鼎新图蓝牙使用" class="headerlink" title="鼎新图蓝牙使用"></a>鼎新图蓝牙使用</h2><ol><li>波特率，置低波特率为9600，置高为115200，其他波特率值只能用AT设置</li><li>密码，置低密码方式1=8888，置高默认密码0000</li><li>主从模式，置低为从设备，置高为主设备</li><li>距离class级别切换，置低class1设备，置高为class2设备</li><li>拨码有效，置低pio按键无效，置高有效</li><li>清零，置高保持5秒再置低<ul><li>数据模式置高5秒再复位-启动清零=模块做清楚地址码并重新搜索工作。</li><li>AT模式置高5秒再复位-启动清零+恢复=模块做彻底清零并恢复到出厂设置，并重新启动。</li></ul></li><li>主机切换连接至从机2，至低-时为当前从机，至高+为切换至另一个</li><li>AT/数据模式切换，置低数据模式，AT无效，置高AT状态，红灯亮起</li></ol><p>绿灯常亮为成功配对，若要清零，把5或8，和6一起置高，等五秒再置低<br><a href="https://item.taobao.com/item.htm?spm=2013.1.0.0.295235c1bQOm52&amp;id=35050036589&amp;qq-pf-to=pcqq.c2c">淘宝网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32f4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轮式底盘解算</title>
      <link href="/Blog_ButterFly/2024/03/26/%E8%BD%AE%E5%BC%8F%E5%BA%95%E7%9B%98%E8%A7%A3%E7%AE%97/"/>
      <url>/Blog_ButterFly/2024/03/26/%E8%BD%AE%E5%BC%8F%E5%BA%95%E7%9B%98%E8%A7%A3%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="四舵轮底盘控制"><a href="#四舵轮底盘控制" class="headerlink" title="四舵轮底盘控制"></a>四舵轮底盘控制</h2><p>四舵轮底盘就是由四个舵轮来控制底盘运动的，一般在进行速度分析时，会将底盘的整体运动映射到四个轮子的单独运动上去</p><p><img src="/Blog_ButterFly/2024/03/26/%E8%BD%AE%E5%BC%8F%E5%BA%95%E7%9B%98%E8%A7%A3%E7%AE%97/1711337895390.png" alt="1711337895390.png"></p><p>一般来说是将直角坐标的速度和角速度分别映射到轮子上，进行累加得到最终的结果</p><h3 id="直角坐标速度分析"><a href="#直角坐标速度分析" class="headerlink" title="直角坐标速度分析"></a>直角坐标速度分析</h3><p>直角坐标的速度分析相对来说比较简单，直接就是坐标平移，所以就是</p><script type="math/tex; mode=display">v_{ixx}=V_x\\v_{ixy}=0\\v_{iyx}=0\\v_{iyy}=V_y\\</script><p>其中 $v_{iyx}$ 就是机体的 $x$ 方向速度向轮子 $y$ 方向速度的映射</p><h3 id="角速度分析"><a href="#角速度分析" class="headerlink" title="角速度分析"></a>角速度分析</h3><p>角速度分析实际上就是把机体转动的角速度通过轮子的运动来实现，也就是</p><script type="math/tex; mode=display">v_{iw}=L_iw</script><p>再将其分解到直角坐标系中</p><script type="math/tex; mode=display">v_{ixw}=wL_i\cos(\varphi-90)\\v_{iyw}=wL_i\sin(\varphi-90)</script><p>其中 $v_{ixw}$ 就是机体角速度向轮子 $x$ 方向速度的映射</p><h3 id="最终速度"><a href="#最终速度" class="headerlink" title="最终速度"></a>最终速度</h3><p>最终两部分速度相加就是该轮子的速度</p><script type="math/tex; mode=display">v_{ix}=v_{ixx}+v_{ixy}+v_{ixw}\\v_{iy}=v_{iyx}+v_{iyy}+v_{iyw}</script><h3 id="舵角"><a href="#舵角" class="headerlink" title="舵角"></a>舵角</h3><p>得到最终的直角坐标速度之后，还需要得到舵角速度和总速度，主要是因为舵轮的驱动轮只能有一条直线上的速度，而舵角可以来调整这个速度的方向</p><script type="math/tex; mode=display">\theta_i=\arctan\frac{v_{ix}}{v_{iy}}</script><p>驱动轮速度</p><script type="math/tex; mode=display">v_i=\sqrt{v_{ix}^2+v_{iy}^2}</script><h3 id="最小舵转角"><a href="#最小舵转角" class="headerlink" title="最小舵转角"></a>最小舵转角</h3><p>在舵轮的舵角转动中，需要使得舵角转动按照转动最小的方向转动，以此来防止转动角度太大而导致车身偏斜</p><p>直接附上代码，这里就不再解释了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> angleDiff  = aimAngle - wheel-&gt;angleNow;    <span class="comment">// 转角（过程量）</span></span><br><span class="line"><span class="type">int</span>   temp       = <span class="built_in">floor</span>(angleDiff / PI + <span class="number">0.5f</span>);  <span class="comment">// 数形结合，左移1/2个单位，每转90度需要一次最小角反向，0.5即(PI/2)/PI</span></span><br><span class="line">wheel-&gt;angleSet += angleDiff - PI * temp + wheel-&gt;angleNow;</span><br><span class="line"><span class="keyword">if</span> (fabsf(wheel-&gt;angleSet) &gt; <span class="number">4</span> * PI)</span><br><span class="line">  wheel-&gt;angleSet -= sign(wheel-&gt;angleSet) * <span class="number">2</span> * PI;</span><br><span class="line">wheel-&gt;angleSetDeg = wheel-&gt;angleSet * RAD_TO_DEG;</span><br><span class="line"><span class="keyword">return</span> powf(<span class="number">-1.f</span>, temp); <span class="comment">// 返回舵轮的速度方向</span></span><br></pre></td></tr></table></figure><h2 id="四全向轮底盘控制"><a href="#四全向轮底盘控制" class="headerlink" title="四全向轮底盘控制"></a>四全向轮底盘控制</h2><p>四全向轮底盘控制是由四个全向轮控制的，只能控制轮子方向的速度而不能控制轮子垂直方向的速度，所以在分析时只考虑轮子方向的速度</p><p><img src="/Blog_ButterFly/2024/03/26/%E8%BD%AE%E5%BC%8F%E5%BA%95%E7%9B%98%E8%A7%A3%E7%AE%97/1711352877973.png" alt="1711352877973.png"></p><p>同四舵轮底盘一致，将直角坐标的速度和角速度分别映射到轮子上，进行累加得到最终的结果</p><h3 id="直角速度分析"><a href="#直角速度分析" class="headerlink" title="直角速度分析"></a>直角速度分析</h3><p>如图，轮子的直角坐标系的速度就是底盘的直角坐标系速度，所以可以得到</p><script type="math/tex; mode=display">v_{ixx}=V_x\\v_{ixy}=0\\v_{iyx}=0\\v_{iyy}=V_y\\</script><p>其中 $v_{iyx}$ 就是机体的 $x$ 方向速度向轮子 $y$ 方向速度的映射</p><h3 id="角速度分析-1"><a href="#角速度分析-1" class="headerlink" title="角速度分析"></a>角速度分析</h3><p>底盘的角速度映射到轮子的线速度可以得到</p><script type="math/tex; mode=display">v_{iw}=L_iw</script><p>一般来说，这里算出来的角速度方向会与舵轮轮子前进方向一致，当然也有将底盘安装为长方形的底盘，这时就将这个速度 $v_{iw}$ 与实际轮子前进方向的夹角定为 $\theta_i$</p><script type="math/tex; mode=display">v_{iw}=v_{iw}\cos\theta</script><h3 id="最终速度-1"><a href="#最终速度-1" class="headerlink" title="最终速度"></a>最终速度</h3><p>最终速度就是上述两个速度的和，并且需要映射到轮子前进方向上，所以</p><script type="math/tex; mode=display">v_i=v_{iw}+(v_{ixx}+v_{iyx})\cos\varphi+(v_{ixy}+v_{iyy})\sin\varphi</script><p>在垂直于轮子的方向上不考虑</p><h2 id="麦克纳姆轮控制"><a href="#麦克纳姆轮控制" class="headerlink" title="麦克纳姆轮控制"></a><strong>麦克纳姆轮控制</strong></h2><p><img src="/Blog_ButterFly/2024/03/26/%E8%BD%AE%E5%BC%8F%E5%BA%95%E7%9B%98%E8%A7%A3%E7%AE%97/1711415359359.png" alt="1711415359359.png"></p><p>首先先来说说麦克纳姆轮的特点：有辊子，并且辊子与轮子角度成 45 度角。而且对于自由的辊子来说，无法控制辊子转动方向的速度，所以只能控制沿着辊子方向的速度来控制轮子转动的速度了，所以也就是分析轮子时需要将速度映射到辊子方向上</p><h3 id="直角坐标速度分析-1"><a href="#直角坐标速度分析-1" class="headerlink" title="直角坐标速度分析"></a>直角坐标速度分析</h3><p>如图，轮子的直角坐标系的速度就是底盘的直角坐标系速度，所以可以得到</p><script type="math/tex; mode=display">v_{ixx}=V_x\\v_{ixy}=0\\v_{iyx}=0\\v_{iyy}=V_y\\</script><p>其中 $v_{iyx}$ 就是机体的 $x$ 方向速度向轮子 $y$ 方向速度的映射</p><h3 id="角速度分析-2"><a href="#角速度分析-2" class="headerlink" title="角速度分析"></a>角速度分析</h3><p>底盘的角速度映射到轮子的线速度可以得到</p><script type="math/tex; mode=display">v_{iw}=L_iw</script><h3 id="最终速度-2"><a href="#最终速度-2" class="headerlink" title="最终速度"></a>最终速度</h3><p>将上述速度映射到辊子方向上，可以得到</p><script type="math/tex; mode=display">v_{ig}=v_{iw}\cos\varphi+(v_{iyy}+v_{ixy})\sin\theta+(v_{ixx}+v_{iyx})\cos\theta</script><p>最终辊子方向上的速度映射到轮子转动方向，也就是</p><script type="math/tex; mode=display">v_{i}=\frac{v_{ig}}{\sin\theta}</script><p>最终得到的就是轮子需要转动的速度</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这个控制是根据笔者的想法推导出来的，并非是真实实验的结果，所以不一定正确，注意辨别</p><h2 id="三舵轮底盘控制"><a href="#三舵轮底盘控制" class="headerlink" title="三舵轮底盘控制"></a>三舵轮底盘控制</h2><p><img src="/Blog_ButterFly/2024/03/26/%E8%BD%AE%E5%BC%8F%E5%BA%95%E7%9B%98%E8%A7%A3%E7%AE%97/1711418298160.png" alt="1711418298160.png"></p><p>三舵轮底盘的控制与四舵轮底盘的控制相似，只是角速度的控制会不一致</p><h3 id="直角坐标速度分析-2"><a href="#直角坐标速度分析-2" class="headerlink" title="直角坐标速度分析"></a>直角坐标速度分析</h3><p>如图，轮子直角坐标速度与机体的直角坐标速度一致，也就是</p><script type="math/tex; mode=display">v_{ixx}=V_x\\v_{ixy}=0\\v_{iyx}=0\\v_{iyy}=V_y\\</script><h3 id="角速度分析-3"><a href="#角速度分析-3" class="headerlink" title="角速度分析"></a>角速度分析</h3><p>机体转动的角速度需要映射为轮子转动的线速度，也就是</p><script type="math/tex; mode=display">v_{iw}=L_iw</script><h3 id="最终速度-3"><a href="#最终速度-3" class="headerlink" title="最终速度"></a>最终速度</h3><p>将角速度映射到直角坐标上</p><script type="math/tex; mode=display">v_{ix}=v_{ixx}+v_{iyx}+v_{iw}\cos\varphi\\v_{iy}=v_{ixy}+v_{iyy}+v_{iw}\sin\varphi</script><p>驱动轮的速度</p><script type="math/tex; mode=display">v_i=\sqrt{v_{ix}^2+v_{iy}^2}</script><h3 id="舵角解算"><a href="#舵角解算" class="headerlink" title="舵角解算"></a>舵角解算</h3><script type="math/tex; mode=display">\theta_i=\arctan\frac{v_{iy}}{v_{ix}}</script><h2 id="三全向轮底盘控制"><a href="#三全向轮底盘控制" class="headerlink" title="三全向轮底盘控制"></a>三全向轮底盘控制</h2><p><img src="/Blog_ButterFly/2024/03/26/%E8%BD%AE%E5%BC%8F%E5%BA%95%E7%9B%98%E8%A7%A3%E7%AE%97/1711418298160.png" alt="1711418298160.png"></p><p>三全向轮与四全向轮的解算也很相似，只需要把所有的速度映射到轮子转动的方向就可以了</p><h3 id="直角坐标速度分析-3"><a href="#直角坐标速度分析-3" class="headerlink" title="直角坐标速度分析"></a>直角坐标速度分析</h3><p>如图，轮子直角坐标速度与机体的直角坐标速度一致，也就是</p><script type="math/tex; mode=display">v_{ixx}=V_x\\v_{ixy}=0\\v_{iyx}=0\\v_{iyy}=V_y\\</script><h3 id="角速度分析-4"><a href="#角速度分析-4" class="headerlink" title="角速度分析"></a>角速度分析</h3><p>机体转动的角速度需要映射为轮子转动的线速度，也就是</p><script type="math/tex; mode=display">v_{iw}=L_iw</script><h3 id="最终速度-4"><a href="#最终速度-4" class="headerlink" title="最终速度"></a>最终速度</h3><script type="math/tex; mode=display">v_i=v_{iw}+(v_{ixx}+v_{iyx})\cos\varphi+(v_{ixy}+v_{iyy})\sin\varphi</script>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>传感器</title>
      <link href="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="激光测距仪"><a href="#激光测距仪" class="headerlink" title="激光测距仪"></a>激光测距仪</h1><p>原理：距离大致是光速和往返时间的乘积的一半，就是测距仪和被测物体之间的距离<br>测量方法：实际是测量光传播的时间，用于远距离测量</p><h2 id="DT35"><a href="#DT35" class="headerlink" title="DT35"></a>DT35</h2><div class="table-container"><table><thead><tr><th>参数</th><th>数据</th></tr></thead><tbody><tr><td>测量范围</td><td>50~12000mm</td></tr><tr><td>分辨率</td><td>0.1mm</td></tr><tr><td>光源</td><td>红外线光源</td></tr><tr><td>激光等级</td><td>1</td></tr><tr><td>接口</td><td>IO-Link</td></tr><tr><td>功能</td><td>过程数据，参数设置，诊断</td></tr><tr><td>模拟输出端分辨率</td><td>12 bit</td></tr><tr><td>开关量输出</td><td>1x/2x反向脉冲：PNP/NPN(100mA)</td></tr><tr><td>温宽</td><td>-30～55</td></tr><tr><td>电压</td><td>12V～30V</td></tr><tr><td>多功能输入</td><td>1x4</td></tr><tr><td>滞后</td><td>0～11950mm</td></tr><tr><td>响应时间</td><td>2.5/6.5/12.5/24.5/96.5 ms</td></tr><tr><td>开关频率</td><td>333/100/50/25/6 Hz</td></tr><tr><td>输出时间</td><td>1/2/4/8/32 ms</td></tr><tr><td>纹波</td><td>≤5 Vpp</td></tr><tr><td>功耗</td><td>≤1.7 W</td></tr><tr><td>初始化时间</td><td>≤500 ms</td></tr><tr><td>预热时间</td><td>≤20分钟</td></tr><tr><td>重量</td><td>55g</td></tr></tbody></table></div><h2 id="DT50"><a href="#DT50" class="headerlink" title="DT50"></a>DT50</h2><div class="table-container"><table><thead><tr><th>参数</th><th>数据</th></tr></thead><tbody><tr><td>测量范围</td><td>15～10000mm</td></tr><tr><td>工作电压</td><td>0～10V</td></tr><tr><td>工作温度</td><td>-30～65</td></tr><tr><td>分辨率</td><td>1mm</td></tr><tr><td>响应时间</td><td>20/30 ms</td></tr><tr><td>输出比率</td><td>4 ms</td></tr><tr><td>激光大小</td><td>15x15(10m)</td></tr></tbody></table></div><h2 id="GG-C1200-P"><a href="#GG-C1200-P" class="headerlink" title="GG-C1200-P"></a>GG-C1200-P</h2><div class="table-container"><table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>测量中心距离</td><td>200mm</td></tr><tr><td>测量范围</td><td>+/-80mm</td></tr><tr><td>重复精度</td><td>200um</td></tr><tr><td>直线性</td><td>+/-0.2% F.S</td></tr><tr><td>温度特性</td><td>0.03% F.S.</td></tr><tr><td>电源电压</td><td>12～24V</td></tr><tr><td>最大流入电流</td><td>50 mA</td></tr><tr><td>控制输出</td><td></td></tr><tr><td>模拟量电压输出</td><td>0～5V</td></tr><tr><td>阻抗</td><td>100</td></tr><tr><td>模拟电流输出</td><td>4～20mA</td></tr><tr><td>阻抗</td><td>300</td></tr><tr><td>响应时间</td><td>1.5/5/10ms</td></tr></tbody></table></div><h1 id="陀螺仪"><a href="#陀螺仪" class="headerlink" title="陀螺仪"></a>陀螺仪</h1><h2 id="陀螺仪的标定"><a href="#陀螺仪的标定" class="headerlink" title="陀螺仪的标定"></a>陀螺仪的标定</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>就是对大量数据进行处理来得到一个最合理的积分系数，而且，在正转和反转时积分系数也不同</p><p>主要就是在多次测量下得到及分析数与输入角速度的拟合曲线</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>一个旋转物体的旋转轴所指的方向在不受外力影响时，是不会改变的。陀螺仪基本上就是运用物体在高速旋转时，角动量会很大，旋转轴会一直稳定指向一个方向的性质为依据，用它来保持一定的方向,人们根据这个道理，用它来保持方向。然后用多种方法读取轴所指示的方向，并自动将数据信号传给控制系统。</p><h3 id="机械陀螺仪"><a href="#机械陀螺仪" class="headerlink" title="机械陀螺仪"></a>机械陀螺仪</h3><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/060828381f30e924b899542e495c79061d950a7b592d.webp" alt="060828381f30e924b899542e495c79061d950a7b592d.webp"></p><p>以经典理学为基础，具有高速转动的转子或振动的部件。常见的机械陀螺仪有刚体转动陀螺仪、振动陀螺仪和半球谐振陀螺仪</p><p><strong>作用</strong></p><p>刚体转动陀螺仪是把高速旋转的刚体转子支承起来，使之获得转动自由度的一种装置，它可用来测量角位移或角速度；振动陀螺仪是利用振动叉旋转时的哥氏角加速度效应做成的测量角速度的装置；半球谐振陀螺仪则利用振动杯旋转时的哥氏加速度效应做成的测量角位移的装置。</p><h3 id="光纤陀螺仪"><a href="#光纤陀螺仪" class="headerlink" title="光纤陀螺仪"></a>光纤陀螺仪</h3><p>一种能够精确地确定运动物体方位的仪器，包括干涉式陀螺仪和谐振式陀螺仪两种<br>光纤陀螺仪与传统的机械陀螺仪相比，优点是全固态，没有旋转部件和摩擦部件，寿命长，动态范围大，瞬时启动，结构简单，尺寸小，重量轻。与激光陀螺仪相比，光纤陀螺仪没有闭锁问题，也不用在石英块精密加工出光路，成本相对较低。</p><p><strong>工作原理</strong></p><p><a href="https://www.bilibili.com/video/BV1Z3411h77k?spm_id_from=333.337.search-card.all.click&amp;t=1.5">工作原理视频</a><a href="https://www.vfe.ac.cn/Storage/uploads/201601/20160103155429_5732.jpg">工作原理图</a><a href="https://www.vfe.ac.cn/Storage/uploads/201601/20160103155456_4570.jpg">赛格尼克理论</a><br>依据赛格尼克理论：当光束在一个环形的通道中行进时，若环形通道本身具有一个转动速度，那么光线沿着通道转动方向行进所需要的时间要比沿着这个通道转动相反的方向行进所需要的时间要多。也就是说当光学环路转动时，在不同的行进方向上，光学环路的光程相对于环路在静止时的光程都会产生变化。利用光程的这种变化，检测出两条光路的相位差或干涉条纹的变化，就可以测出光路旋转角速度，这便是光纤陀螺仪的工作原理。</p><h3 id="激光陀螺仪"><a href="#激光陀螺仪" class="headerlink" title="激光陀螺仪"></a>激光陀螺仪</h3><p><strong>原理</strong></p><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/8d5494eef01f3a294f95d29d9b25bc315c607c07.webp" alt="8d5494eef01f3a294f95d29d9b25bc315c607c07.webp"></p><p>激光陀螺仪的原理是利用光程差来测量旋转角速度（Sagnac<br>效应）。在闭合光路中，由同一光源发出的沿顺时针方向和反时针方向传输的两束光和光干涉，利用检测相位差或干涉条纹的变化，就可以测出闭合光路旋转角速度。激光陀螺仪的基本元件是环形激光器，环形激光器由三角形或正方形的石英制成的闭合光路组成，内有一个或几个装有混合气体（氦氖气体）的管子，两个不透明的反射镜和一个半透明镜。用高频电源或直流电源激发混合气体，产生单色激光。为维持回路谐振，回路的周长应为光波波长的整数倍。用半透明镜将激光导出回路，经反射镜使两束相反传输的激光干涉，通过光电探测器和电路输入与输出角度成比例的数字信号</p><p><strong>特点</strong></p><p>激光陀螺仪没有旋转的转子部件，没有角动量，也不需要方向环框架，框架伺服机构，旋转轴承，导电环及力矩器和角度传感器等活动部件，结构简单，工作寿命长，维修方便，可靠性高，激光陀螺仪的平均无故障工作时间已达到九万小时以上<br>动态范围很宽，测得速率为±1500度每秒，最小敏感角速度小于±0.001度每小时一下，分辨率为/弧度秒数量级</p><p><strong>VG103PT与VG910</strong></p><div class="table-container"><table><thead><tr><th>项目</th><th>VG103PT</th><th>VG910</th></tr></thead><tbody><tr><td>测量范围</td><td>350/s</td><td>150/s</td></tr><tr><td>零偏稳定性</td><td>1度/h</td><td>2度/h</td></tr><tr><td>随机角度偏差</td><td>0.02 deg /√h</td><td>0.02 deg /√h</td></tr><tr><td>带宽</td><td>0～1kHZ</td><td>0～1kHZ</td></tr><tr><td>比例系数稳定(%)</td><td>0.02～0.04</td><td>0.02～0.04</td></tr><tr><td>比例系数</td><td>6 mV/deg/s</td><td>47 mV/deg/s</td></tr><tr><td>开启时间</td><td>0.02</td><td>0.1</td></tr><tr><td>功率</td><td>0.5</td><td>0.5</td></tr><tr><td>尺寸</td><td>63x63x21.8</td><td>82.3x82.3x19.5</td></tr><tr><td>重量</td><td>55</td><td>110</td></tr><tr><td>体积</td><td>7cl</td><td>10cl</td></tr><tr><td>工作温度</td><td>-40～70</td><td>-40~70</td></tr><tr><td>工作温度与输出电压</td><td>V(TS) = 0.5 + t°C/100</td><td>V(TS) = 0.5 + t°C/100</td></tr><tr><td>输出方式</td><td>模拟电压</td><td>模拟电压</td></tr></tbody></table></div><h2 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h2><h3 id="零偏和零漂"><a href="#零偏和零漂" class="headerlink" title="零偏和零漂"></a>零偏和零漂</h3><p>零偏是输入角速度为零(即陀螺静止)时陀螺仪的输出量，用规定时间内测得的输出量平均值对应的等效输入角速度表示，理想情况下为地球自转角速度的分量。零漂即为零偏稳定性，表示当输入角速率为零时，陀螺仪输出量围绕其零偏均值的离散程度，用规定时间内输出量的标准偏差对应的等效输入角速率表示。零漂是衡量FOG(光纤陀螺)精度的最重要、最基本的指标。产生零漂的主要因素是沿光纤分布的环境温度变化在光纤线圈内引入的非互易性相移误差。通常为了稳定零漂，常需要对IFOG进行温度控制或者温度补偿。另外偏振也会对零漂产生一定的影响，在IFOG中常采用偏振滤波和保偏光纤的方法消除偏振对零漂的影响。</p><h3 id="标度因数"><a href="#标度因数" class="headerlink" title="标度因数"></a>标度因数</h3><p>标度因数是陀螺仪输出量与输入角速率的比值，在坐标轴上可以用某一特定直线斜率表示，它是反映陀螺灵敏度的指标，其稳定性和精确性是陀螺仪的一项重要指标，综合反映了光纤陀螺的测试和拟合精度。标度因数的稳定性无量纲，通常用百万分比(ppm)表示。标度因数的误差主要来源于温度变化和光纤偏振态的不稳定性。</p><h3 id="随机游走系数"><a href="#随机游走系数" class="headerlink" title="随机游走系数"></a>随机游走系数</h3><p>表征光纤陀螺仪中角速度输出白噪声大小的一项技术指标，它反映的是光纤陀螺仪输出的角速度积分随时间积累的不确定性，因此也可称为角随机游走。随机游走系数反应了陀螺仪的研制水平，也反映了陀螺仪最小可检测的角速率。该误差主要来源于光子的随机自发辐射、光电探测器和数字电路引入的噪声和机械抖动。</p><h3 id="阈值和分辨率"><a href="#阈值和分辨率" class="headerlink" title="阈值和分辨率"></a>阈值和分辨率</h3><p>阈值表示光纤陀螺能感应的最小输入速率。分辨率表示陀螺仪在规定输入角速率下能感应的最小输入速率增量。阈值和分辨率都表征光纤陀螺仪的灵敏度。</p><h3 id="最大输入角速度"><a href="#最大输入角速度" class="headerlink" title="最大输入角速度"></a>最大输入角速度</h3><p>表示陀螺正、反方向输入速率的最大值，表征陀螺的动态范围，即光纤陀螺可感应的速率范围</p><h3 id="阈值"><a href="#阈值" class="headerlink" title="阈值"></a>阈值</h3><p>陀螺仪可以识别的最小的AD值</p><hr><h1 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h1><h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>根据已有的数据来预测之后状态<br>根据上一个位置信息来预测下一时刻的位置，并且最后通过传感器传入数据对预测信息做修正来得到这一时刻的位置信息，用于预测下一时刻的位置信息</p><h2 id="带通滤波"><a href="#带通滤波" class="headerlink" title="带通滤波"></a>带通滤波</h2><p>高频和低频都不能通过，只让一个频率范围内的波通过<br>带通滤波器中，进行两次声电转换，让在一定频率范围内的电波信号通过</p><h1 id="信号误差组成"><a href="#信号误差组成" class="headerlink" title="信号误差组成"></a>信号误差组成</h1><h2 id="量化噪声"><a href="#量化噪声" class="headerlink" title="量化噪声"></a>量化噪声</h2><p>一切量化操作所固有的噪声，是数字传感器必然出现的噪声；</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>通过AD采集把连续时间信号采集成离散信号的过程中，精度会损失，精度损失的大小和AD转换的<br>步长有关，步长越小，量化噪声越小。 解决：减少AD转化的步长</p><h2 id="角度随机游走-可忽略"><a href="#角度随机游走-可忽略" class="headerlink" title="角度随机游走 (可忽略)"></a>角度随机游走 (可忽略)</h2><h2 id="宽带角速率白噪声"><a href="#宽带角速率白噪声" class="headerlink" title="宽带角速率白噪声"></a>宽带角速率白噪声</h2><p>陀螺输出角速率是含噪声的，该噪声中的白噪声成分；</p><h2 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h2><p>计算姿态的本质是对角速率做积分，这必然会对噪声也做了积分。白噪声的积分并不是白噪声，而是一个马尔可夫过程，即当前时刻的误差是在上一时刻误差的基础上累加一个随机白噪声得到的。<br>角度误差中所含的马尔可夫性质的误差，称为角度随机游走</p><h2 id="角速率随机游走"><a href="#角速率随机游走" class="headerlink" title="角速率随机游走"></a>角速率随机游走</h2><p>与角度随机游走类似，角速率误差中所含的马尔可夫性质的误差，称为角速率随机游走。而这个马尔可夫性质的误差是由宽带角加速率白噪声累积的结果。</p><h2 id="零偏不稳定性噪声"><a href="#零偏不稳定性噪声" class="headerlink" title="零偏不稳定性噪声"></a>零偏不稳定性噪声</h2><h2 id="零偏"><a href="#零偏" class="headerlink" title="零偏"></a>零偏</h2><p>即常说的bias，一般不是一个固定参数，而是在一定范围内缓慢随机飘移。<br>解决：零点偏移量，即陀螺仪或加速度计输出中的常值偏移，其值并不是固定不变的，但我们可认为它在短时间内稳定。因此我们可以在陀螺仪板子每次上电时，获取陀螺仪输出作为零偏，并在这段时间内保证小车静止，以消除零偏带来的影响</p><h2 id="零偏不稳定性"><a href="#零偏不稳定性" class="headerlink" title="零偏不稳定性"></a>零偏不稳定性</h2><p>零偏随时间缓慢变化，其变化值无法预估，需要假定一个概率区间描述它有多大的可能性落在这个区间内。时间越长，区间越大。<br>零偏在较短时间内的比赛中几乎可以忽略不计。</p><h2 id="速率斜坡"><a href="#速率斜坡" class="headerlink" title="速率斜坡"></a>速率斜坡</h2><p>该误差是趋势性误差，而不是随机误差。<br>随机误差，是指你无法用确定性模型去拟合并消除它，最多只能用概率模型去描述它，这样得到的预测结果也<br>是概率性质的。<br>趋势性误差，是可以直接拟合消除的，在陀螺里产生这种误差最常见的原因是温度引起零位变化，可以通过温补来消除。<br>在机器人比赛3分钟时间内基本可以忽略，但是我认为应该直接在拟合时消除</p><h2 id="零偏重复性"><a href="#零偏重复性" class="headerlink" title="零偏重复性"></a>零偏重复性</h2><p>多次启动时，零偏不相等，因此会有一个重复性误差。在实际使用中，需要每次上电都重新估计一次。<br>Allan方差分析时，不包含对零偏重复性的分析。 在短时间内认为是固定的</p><hr><h1 id="yesense"><a href="#yesense" class="headerlink" title="yesense"></a>yesense</h1><h2 id="Yesense简介"><a href="#Yesense简介" class="headerlink" title="Yesense简介"></a>Yesense简介</h2><p>Yesense是一款小巧的九轴陀螺仪，九轴实际上是指三轴陀螺仪、三轴加速度计和三轴磁偏角，目前yesense只用于精度不高的场合或者提供辅助数据，如给安装在四足上提供偏航角和俯仰角信息，或者给主控提供加速度信息</p><h2 id="EULER角"><a href="#EULER角" class="headerlink" title="EULER角"></a>EULER角</h2><p>欧拉角是用来唯一地确定定点转动刚体位置的三个一组独立角参量，由章动角 $\theta$，进动角 $\psi$ 和自转角 $\varphi$ 组成。做出固定坐标系 OXYZ ，以及与刚体固连的坐标系 Oxyz ，在刚体产生转动时， Oxyz 与 OXYZ 会有一定的夹角， XOY 与 xOy 两个平面的交线ON。Ox 与 ON 的夹角为φ，OX 与 ON 的夹角为ψ，OZ 与 Oz 的夹角为θ。三个角的方向与位置如图所示：</p><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/962bd40735fae6cdfc54c75b0cb30f2442a70f23.webp" alt="962bd40735fae6cdfc54c75b0cb30f2442a70f23.webp"></p><p>若令 $Ox’y’z’$ 的原始位置重合于 Oxyz ，经过相继绕 Oz、ON 和 Oz’ 的三次转动 $Z(\psi),N(\theta),Z’(\varphi)$ 后，刚体将转到图示的任意位置（见刚体定点转动）。变换关系可写为：</p><script type="math/tex; mode=display">R(\psi,\theta,\varphi)=Z(\psi)N(\theta)Z'(\varphi)</script><p>式中 $R,Z’,N,Z$ 是转动算子，并可用矩阵表示如下：</p><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/5366d0160924ab181a879a8a31fae6cd7a890bfd.webp" alt="5366d0160924ab181a879a8a31fae6cd7a890bfd.webp"></p><p>刚体上任一点Q在两个坐标系中的坐标x、y、z和x’、y’、z’都可以通过矢径的模和方向余弦来表出。两组坐标之间有如下变换关系</p><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/fc1f4134970a304e41a0db47d5c8a786c8175c88.webp" alt="fc1f4134970a304e41a0db47d5c8a786c8175c88.webp"></p><h2 id="方向余弦"><a href="#方向余弦" class="headerlink" title="方向余弦"></a>方向余弦</h2><p>在解析几何里，一个向量的三个方向余弦分别是这向量与三个坐标轴之间的角度的余弦。<br>在机器人中，方向余弦可以是固定在机械上的Oxyz坐标轴的Ox，Oy，Oz，分别与规定的世界坐标轴OXYZ中的OX，OY,OZ之间的夹角的余弦值</p><h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><p>四元数是简单的超复数。 复数是由实数加上虚数单位 $i$ 组成，其中 $i^2=-1$<br>相似地，四元数都是由实数加上三个虚数单位 i、j和k<br>组成，而且它们有如下的关系：</p><script type="math/tex; mode=display">i^2=j^2=k^2= -1\\i^0=j^0=k^0=1</script><p>每个四元数都是 1、i、j 和 k 的线性组合，即是四元数一般可表示为 $a+bi+cj+dk$ ，其中a、b、c 、d是实数。</p><h2 id="yesense测量原理"><a href="#yesense测量原理" class="headerlink" title="yesense测量原理"></a>yesense测量原理</h2><h2 id="加速滤波及其转化"><a href="#加速滤波及其转化" class="headerlink" title="加速滤波及其转化"></a>加速滤波及其转化</h2><h1 id="IMU"><a href="#IMU" class="headerlink" title="IMU"></a>IMU</h1><p>IMU为惯性测量单元，惯性测量单元是测量物体三轴姿态角（或角速率）以及加速度的装置。一般的6轴IMU，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺，还有 9 轴的IMU，就是在6轴的基础上加上三轴磁传感器。加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，磁力计用卡尔曼或者互补滤波等算法为用户提供拥有绝对参考的俯仰角、横滚角和航向角，并以此解算出物体的姿态。</p><h2 id="加速度计工作原理"><a href="#加速度计工作原理" class="headerlink" title="加速度计工作原理"></a>加速度计工作原理</h2><p>加速度计的本质是检测力而非加速度，即加速度计的检测装置捕获的是引起加速度的惯性力，随后可利用牛顿第二定律获得加速度值。测量原理可以用一个简单的质量块、弹簧和指示计来表示。<br>种类：压电式，压阻式，电容式，伺服式</p><h2 id="IMU误差模型"><a href="#IMU误差模型" class="headerlink" title="IMU误差模型"></a>IMU误差模型</h2><p>加速度计和陀螺仪的误差可以分为：确定性误差，随机误差。确定性误差可以事先标定确定，包括：bias，scale等。随机误差通常假设噪声服从高斯分布，包括：高斯白噪声，bias随机游走等</p><h2 id="IMU性能指标"><a href="#IMU性能指标" class="headerlink" title="IMU性能指标"></a>IMU性能指标</h2><p><a href="https://static.sensorexpert.com.cn/upload/file/20200819/1597821869941193.jpg">影响IMU性能的主要因素</a></p><h2 id="加速度计影响"><a href="#加速度计影响" class="headerlink" title="加速度计影响"></a>加速度计影响</h2><p>主要是加速度计的精度和稳定性</p><h2 id="陀螺仪影响"><a href="#陀螺仪影响" class="headerlink" title="陀螺仪影响"></a>陀螺仪影响</h2><p>陀螺仪对IMU影响主要在精确度上</p><h2 id="温度影响"><a href="#温度影响" class="headerlink" title="温度影响"></a>温度影响</h2><p>惯性器件在温度发生变化时，精度会产生较大的差异</p><h2 id="IMU产品化影响"><a href="#IMU产品化影响" class="headerlink" title="IMU产品化影响"></a>IMU产品化影响</h2><p>信噪比降低和漂移大</p><hr><h1 id="码盘"><a href="#码盘" class="headerlink" title="码盘"></a>码盘</h1><p>就是一个增量编码器，<a href="https://baike.baidu.com/item/%E7%A0%81%E7%9B%98">码盘介绍</a>，码盘使用来检测运动的距离。编码器在码盘转动时会计录传出的脉冲数，根据接收到的脉冲数和每圈的脉冲数就可以算出转动的圈数，最后算出距离。</p><h2 id="轮径系数"><a href="#轮径系数" class="headerlink" title="轮径系数"></a><strong>轮径系数</strong></h2><p>轮径系数就是全向轮走过的距离 / 编码器值的增量<br>其实就是编码器增量为1时走过的距离</p><h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><p>简单来说是输出脉冲的计数器</p><h2 id="绝对式编码器"><a href="#绝对式编码器" class="headerlink" title="绝对式编码器"></a>绝对式编码器</h2><p>能直接给出与角位置相对应的数字码 <a href="https://bkimg.cdn.bcebos.com/pic/b7003af33a87e9501ce3ec781b385343fbf2b429?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto">绝对式码盘</a></p><p><strong>接触编码器</strong></p><p>它由编码盘、电刷和电路组成。图1是一个6位二进制编码器。编码盘按二进制码制成，与旋转轴固定在一起。码盘上有6条码道，每条码道上有许多扇形导电区（黑区）和不导电区（白区），全部导电区连在一起接到一个公共电源上。6个电刷沿一个固定的径向安装，分别与6条码道接触。每个电刷与一单根导线相连，输出6个电信号,其电平由码盘的位置控制。当电刷与导电区接触时，输出为“1”电平；与不导电区接触时，输出为“0”电平。码道越多精确度越高。</p><p><strong>光学编码器</strong></p><p>是依照光学和光电原理制成的器件。它由光源、码盘、光学系统及电路4部分组成。码盘是在不透明的基底上按二进制码制成明暗相间的码道，相当于接触编码器的导电区和不导电区。光线通过码盘由光电元件转换成相应的电信号。光学编码器的精度高于1/108，径向分度线的精度为<br>0.067弧秒。</p><h2 id="增量编码器"><a href="#增量编码器" class="headerlink" title="增量编码器"></a>增量编码器</h2><p>利用计算机系统将旋转码盘产生的脉冲增量针对某个技术进行加减，增量型编码器是直接利用光电转换原理输出三组方波脉冲A、B和Z相；AB两组脉冲相位相差90°，从而可以方便的判断出旋转方向，而Z相每转一个脉冲，用于基准点定位。</p><ol><li>增量型旋转编码器有分辨率的差异，使用每圈产生的脉冲数来计量，数目从6到5400或更高，脉冲数越多，分辨率越高；这是选型的重要依据之一。</li><li>增量型编码器通常有三路信号输出（差分有六路信号）：A,B和Z，一般采用TTL电平，A脉冲在前，B脉冲在后，A,B脉冲相差90度，每圈发出一个Z脉冲，可作为参考机械零位。一般利用A超前B或B超前A进行判向，我公司增量型编码器定义为轴端看编码器顺时针旋转为正转，A超前B为90°，反之逆时针旋转为反转B超前A为90°。也有不相同的，要看产品说明。</li><li>使用PLC采集数据，可选用高速计数模块；使用工控机采集数据，可选用高速计数板卡；使用单片机采集数据，建议选用带光电耦合器的输入端口。</li><li>建议B脉冲做顺向（前向）脉冲，A脉冲做逆向（后向）脉冲，Z原点零位脉冲。</li><li>在电子装置中设立计数栈。</li></ol><h1 id="stm32-正交编码模式"><a href="#stm32-正交编码模式" class="headerlink" title="stm32 正交编码模式"></a>stm32 正交编码模式</h1><p><a href="https://www.pianshen.com/source/905069031842339/">stm32正交编码模式</a></p><p>其实就是在输出脉冲时，输出两个相位差为 90 度的脉冲。A，B，当A比B领先90度时，此时记录为向上计数，当B比A领先90度时，记录为向下计数，还有一个脉冲Z，在每次0位发出，作为参考机械零位</p><h1 id="激光雷达tim561"><a href="#激光雷达tim561" class="headerlink" title="激光雷达tim561"></a>激光雷达tim561</h1><p>5表示雷达为测量型，6表示检测距离10米，1表示应用环境室外型。激光发射器发出激光脉冲，当激光碰到物体后，部分机光反射回激光接收器，通过计算发射和接收之间的时间差，可以计算出距离值。激光扫描器连续不断的发射激光脉冲，由旋转的光学构件将激光脉冲按照一定的角度间隔(角度分辨率)发射至扫描角度内的各个方向而形成一个二维的扫描面</p><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy84OTA5NjYvMjAxNzEyLzg5MDk2Ni0yMDE3MTIwMzEwNDMxMzQ0NC0xNDAxMDU5NTc3LnBuZw.png" alt="L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy84OTA5NjYvMjAxNzEyLzg5MDk2Ni0yMDE3MTIwMzEwNDMxMzQ0NC0xNDAxMDU5NTc3LnBuZw==.png"></p><p><strong>参数</strong></p><div class="table-container"><table><thead><tr><th>项目</th><th>激光雷达tim561</th></tr></thead><tbody><tr><td>扫描距离范围</td><td>0.05～10 m  通常在10%缓解时8米</td></tr><tr><td>扫描误差</td><td>静态：20mm 系统：+/-60mm 温度漂移0.5mm/度</td></tr><tr><td>角度范围</td><td>径向，孔径角270°，1°步进</td></tr><tr><td>精确度</td><td>0.33</td></tr><tr><td>扫描频率</td><td>15 Hz</td></tr><tr><td>回应时间</td><td>67 ms</td></tr><tr><td>频带宽度(扫描场平面度)</td><td>+/-3 度</td></tr><tr><td>最大功率</td><td>1.5W</td></tr><tr><td>工作温度</td><td>-25～50度</td></tr><tr><td>工作电压</td><td>9～28V</td></tr></tbody></table></div><hr><h1 id="齐次变换矩阵"><a href="#齐次变换矩阵" class="headerlink" title="齐次变换矩阵"></a>齐次变换矩阵</h1><p>空间中的位置是由一个矩阵描述， 描述姿态有9个参数，旋转矩阵3x3：旋转矩阵的逆和它的矩阵相等，旋转矩阵的模为1，单位正交阵，三个列向量都是单位向量，且两两垂直。三个列向量相当于是目标x,y,z轴上的单位向量在原来x,y,z坐标系中的向量表示。</p><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/%25E6%2597%258B%25E8%25BD%25AC%25E7%259F%25A9%25E9%2598%25B5.png" alt="旋转矩阵.png"></p><div class="table-container"><table><thead><tr><th>旋转矩阵绕X轴转A度</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>x</td></tr><tr><td>0</td><td>cosA</td><td>-sinA</td><td>y</td></tr><tr><td>0</td><td>sinA</td><td>cosA</td><td>z</td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>旋转矩阵绕Y轴转B度</td><td></td><td></td><td></td></tr><tr><td>cosB</td><td>0</td><td>sinB</td><td>x</td></tr><tr><td>0</td><td>1</td><td>0</td><td>y</td></tr><tr><td>-sinB</td><td>0</td><td>cosB</td><td>z</td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>旋转矩阵绕Z轴转C度</td><td></td><td></td><td></td></tr><tr><td>cosC</td><td>-sinC</td><td>0</td><td>x</td></tr><tr><td>sinC</td><td>cosC</td><td>0</td><td>y</td></tr><tr><td>0</td><td>0</td><td>1</td><td>z</td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div><p>A:绕x轴旋转的角度 x:B坐标原点相对于原坐标轴的x坐标</p><p>B:绕y轴旋转的角度 y:B坐标原点相对于原坐标轴的y坐标</p><p>C:绕z轴旋转的角度 z:B坐标原点相对于原坐标轴的z坐标</p><p>描述位置有3个参数 $\begin{bmatrix}x&amp;y&amp;z\end{bmatrix}$</p><h2 id="描述位姿"><a href="#描述位姿" class="headerlink" title="描述位姿"></a>描述位姿</h2><p>齐次变换矩阵 4x4 :前三列相当于是旋转矩阵，第四列是目标坐标系的原点相对于原来坐标系的坐标，第四行的元素是[0,0,0,1]</p><p>齐次坐标： $\begin{bmatrix}x&amp;y&amp;z\end{bmatrix}^T$</p><p>是用4X1的向量来表示三维坐标，方便运算。</p><h2 id="位置变换"><a href="#位置变换" class="headerlink" title="位置变换"></a>位置变换</h2><p><strong>平移坐标变换</strong></p><p>$P_A = P_B+ P_A^B$</p><p>相对A的位置等于相对于B的位置加上B相对于A的位置 </p><p><strong>旋转坐标变换</strong></p><p>$P_A= P_B*Rot$</p><p>相对于 A 的姿态矩阵等于相对于 B 的姿态 s 矩阵乘以旋转矩阵</p><h1 id="惯性导航"><a href="#惯性导航" class="headerlink" title="惯性导航"></a>惯性导航</h1><p>惯性导航(inertialnavigation)通过测量飞行器的加速度，并自动进行积分运算，获得飞行器瞬时速度和瞬时位置数据的技术。利用惯性元件（加速度计）来测量运载体本身的加速度，经过积分和运算得到速度和位置，从而达到对运载体导航定位的目的。组成惯性导航系统的设备都安装在运载体内，工作时不依赖外界信息，也不向外界辐射能量，不易受到干扰，是一种自主式导航系统。惯性导航系统通常由惯性测量装置、计算机、控制显示器等组成。惯性测量装置包括加速度计和陀螺仪，又称惯性测量单元。3个自由度陀螺仪用来测量运载体的3个转动运动；3个加速度计用来测量运载体的3个平移运动的加速度。计算机根据测得的加速度信号计算出运载体的速度和位置数据。</p><h2 id="累计误差"><a href="#累计误差" class="headerlink" title="累计误差"></a>累计误差</h2><p>因为在测量时如果产生了误差，那么在积分和时间累积之后，就会形成一个很大的偏差</p><h2 id="重定位的意义"><a href="#重定位的意义" class="headerlink" title="重定位的意义"></a>重定位的意义</h2><p>重定位就是在机器人运动一段时间后，再通过除惯性元件以外的测量元件来测定位置<br>DT照挡板，基座：就是用激光测距仪测定小车和固定的挡板或者固定的底座与小车之间的距离，来再次确定小车的位置<br>色标传感器照白线：场地中的白线都是画在确定的位置，可以大致确定小车的位置</p><h2 id="陀螺仪的相关误差"><a href="#陀螺仪的相关误差" class="headerlink" title="陀螺仪的相关误差"></a>陀螺仪的相关误差</h2><p>陀螺仪输出的是AD值，对AD值进行转换才能得到当前的角速度，进而积分得到角度，由于AD值与角速度成正比，只需要除以一个定值就可以，这个定值就是积分系数/标度因数</p><h2 id="标度因数的非线性误差"><a href="#标度因数的非线性误差" class="headerlink" title="标度因数的非线性误差"></a>标度因数的非线性误差</h2><p>陀螺仪的输出与输入的角度并不完全成正比，主要是因为标度因数的温漂，在计算角速度时一味的除以一个定值得到的数据是不准确的。</p><h2 id="标度因数的温漂"><a href="#标度因数的温漂" class="headerlink" title="标度因数的温漂"></a>标度因数的温漂</h2><p>相同的角速度下，陀螺仪的输出会随着温度的变化而降低，由于陀螺仪上电后内部温度会逐渐升高，所以相同输入下输出会升高。但是在比赛中，时间很短，温漂可以忽略</p><h1 id="spi总线"><a href="#spi总线" class="headerlink" title="spi总线"></a>spi总线</h1><p>SPI（serial peripheralinterface，串行外围设备接口）总线技术是Motorola公司推出的一种同步串行接口。它用于CPU与各种外围器件进行全双工、同步串行通讯。它只需四条线就可以完成MCU与各种外围器件的通讯</p><ul><li>串行时钟线(SCLK)</li><li>主机输入/从机输出数据线(MISO)</li><li>主机输出/从机输入数据线(MOSI)</li><li>低电平有效从机选择线(CS)</li></ul><p>当SPI工作时，在移位寄存器中的数据逐位从输出引脚（MOSI）输出（高位在前），同时从输入引脚（MISO）接收的数据逐位移到移位寄存器（高位在前）。发送一个字节后，从另一个外围器件接收的字节数据进入移位寄存器中。即完成一个字节数据传输的实质是两个器件寄存器内容的交换。主SPI的时钟信号（SCK）使传输同步。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>全双工；</li><li>采用主从模式的控制方式</li><li>数据传输时高位在前，低位在后</li><li>可以当作主机或从机工作；</li><li>提供频率可编程时钟；</li><li>发送结束中断标志；</li><li>写冲突保护；</li><li>总线竞争保护等</li><li>缺点：没有指定的流控制，没有应答机制确认是否接收到数据</li></ul><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul><li>SDO: 主设备数据输出，从设备数据输入</li><li>SDI：主设备数据输入，从设备数据输出</li><li>SCLK：时钟信号，由主设备产生</li><li>CS：从设备使能信号，由主设备控制SPI的主从结构其中CS是控制芯片是否被选中的，也就是说只有片选信号为预先规定的使能信号时</li></ul><h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p><img src="/Blog_ButterFly/2024/03/25/%E4%BC%A0%E6%84%9F%E5%99%A8/20210710111649406.png" alt="20210710111649406.png"></p><ul><li>CPOL = 0， CPHA = 0<br>SCK串行时钟线空闲是为低电平，数据在SCK时钟的上升沿被采样，数据在SCK时钟的下降沿切换</li><li>CPOL = 0， CPHA = 1<br>SCK串行时钟线空闲是为低电平，数据在SCK时钟的下降沿被采样，数据在SCK时钟的上升沿切换</li><li>CPOL = 1， CPHA = 0<br>SCK串行时钟线空闲是为高电平，数据在SCK时钟的下降沿被采样，数据在SCK时钟的上升沿切换</li><li>CPOL = 1， CPHA = 1<br>SCK串行时钟线空闲是为高电平，数据在SCK时钟的上升沿被采样，数据在SCK时钟的下降沿切换</li></ul><p>这4种模式分别由时钟极性(CPOL，Clock Polarity)和时钟相位(CPHA，ClockPhase)来定义，其中CPOL参数规定了SCK时钟信号空闲状态的电平，CPHA规定了数据是在SCK时钟的上升沿被采样还是下降沿被采样CPOL 规定初始相位 CPHA 规定采样时是向下还是向上</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros学习记录</title>
      <link href="/Blog_ButterFly/2024/03/24/ros%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/Blog_ButterFly/2024/03/24/ros%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h3><p>打开软件与更新，配置 ubuntu 的软件和更新，并且允许安装未经认证的软件</p><p>官方默认安装源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><p>清华的安装源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><p>中科大安装源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><h3 id="设置key"><a href="#设置key" class="headerlink" title="设置key"></a>设置key</h3><p>在终端中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><h3 id="安装ros"><a href="#安装ros" class="headerlink" title="安装ros"></a>安装ros</h3><p>首先需要更新源和 apt，终端中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>然后开始安装 ros，终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>在终端中输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="卸载指令"><a href="#卸载指令" class="headerlink" title="卸载指令"></a>卸载指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove ros-noetic-*</span><br></pre></td></tr></table></figure><h3 id="初始化-rosdep"><a href="#初始化-rosdep" class="headerlink" title="初始化 rosdep"></a>初始化 rosdep</h3><p>在命令行中输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><p>有些版本老的ros会报错，因为是缺少依赖，那就需要安装构建依赖</p><p>首先安装构建依赖的相关工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br><span class="line">sudo apt install python3-rosdep</span><br></pre></td></tr></table></figure><p>如果不是依赖的问题，就可以看看 <a href="http://www.autolabor.com.cn/book/ROSTutorials/chapter1/12-roskai-fa-gong-ju-an-zhuang/124-an-zhuang-ros.html">ros安装</a></p><h2 id="ros介绍"><a href="#ros介绍" class="headerlink" title="ros介绍"></a>ros介绍</h2><h3 id="ros的文件系统"><a href="#ros的文件系统" class="headerlink" title="ros的文件系统"></a>ros的文件系统</h3><p><img src="http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.jpg" alt></p><h3 id="ros的指令"><a href="#ros的指令" class="headerlink" title="ros的指令"></a>ros的指令</h3><p><strong>rosnode</strong>获取节点信息的指令</p><ul><li><code>rosnode ping</code> 测试到节点的连接状态</li><li><code>rosnode list</code> 列出活动节点</li><li><code>rosnode info</code> 打印节点信息</li><li><code>rosnode machine</code> 列出指定设备上节点</li><li><code>rosnode kill</code> 杀死某个节点</li><li><code>rosnode cleanup</code> 清除不可连接的节点</li></ul><p><strong>rostopic</strong>获取话题信息的指令</p><ul><li><code>rostopic bw</code> 显示主题使用的带宽</li><li><code>rostopic delay</code> 显示带有 header 的主题延迟</li><li><code>rostopic echo</code> 打印消息到屏幕</li><li><code>rostopic find</code> 根据类型查找主题</li><li><code>rostopic hz</code> 显示主题的发布频率</li><li><code>rostopic info</code> 显示主题相关信息</li><li><code>rostopic list</code> 显示所有活动状态下的主题</li><li><code>rostopic pub</code> 将数据发布到主题</li><li><code>rostopic type</code> 打印主题类型</li></ul><p><strong>rosmsg</strong>获取有关消息类型信息的指令</p><ul><li><code>rosmsg show</code> 显示消息描述</li><li><code>rosmsg info</code> 显示消息信息</li><li><code>rosmsg list</code> 列出所有消息</li><li><code>rosmsg md5</code> 显示 md5 加密后的消息</li><li><code>rosmsg package</code> 显示某个功能包下的所有消息</li><li><code>rosmsg packages</code> 列出包含消息的功能包</li></ul><p><strong>rosservice</strong>获取服务信息的指令</p><ul><li><code>rosservice args</code> 打印服务参数</li><li><code>rosservice call</code> 使用提供的参数调用服务</li><li><code>rosservice find</code> 按照服务类型查找服务</li><li><code>rosservice info</code> 打印有关服务的信息</li><li><code>rosservice list</code> 列出所有活动的服务</li><li><code>rosservice type</code> 打印服务类型</li><li><code>rosservice uri</code> 打印服务的 ROSRPC uri</li></ul><p><strong>rossrv</strong>显示有关服务类型信息的指令</p><ul><li><code>rossrv show</code> 显示服务消息详情</li><li><code>rossrv info</code> 显示服务消息相关信息</li><li><code>rossrv list</code> 列出所有服务信息</li><li><code>rossrv md5</code> 显示 md5 加密后的服务消息</li><li><code>rossrv package</code> 显示某个包下所有服务消息</li><li><code>rossrv packages</code> 显示包含服务消息的所有包</li></ul><p><strong>rosparam</strong>获取和设置参数信息的指令</p><ul><li><code>rosparam set</code> 设置参数</li><li><code>rosparam get</code> 获取参数</li><li><code>rosparam load</code> 从外部文件加载参数</li><li><code>rosparam dump</code> 将参数写出到外部文件</li><li><code>rosparam delete</code> 删除参数</li><li><code>rosparam list</code> 列出所有参数</li></ul><p><strong>设置命名空间和重映射</strong></p><p>在 <code>rosrun</code> 时的节点名称之后添加 <code>__ns:=namespace</code> 设置命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node __ns:=/xxx</span><br></pre></td></tr></table></figure><p>在 <code>rosrun</code> 时的节点名称之后添加 <code>__name:=newname</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node __name:=t1</span><br><span class="line">rosrun turtlesim turtlesim_node /turtlesim:=t1(不适用于python)</span><br></pre></td></tr></table></figure><p><strong>设置话题重映射</strong></p><p>rosrun名称重映射语法: rorun 包名 节点名 话题名:=新话题名称</p><p><strong>设置参数</strong></p><p>rosrun 包名 节点名称 _参数名:=参数值</p><h3 id="一些需要注意的"><a href="#一些需要注意的" class="headerlink" title="一些需要注意的"></a>一些需要注意的</h3><p>在每一种通信都需要依赖于 ros 的句柄，所以就是在实例化各种通信端之前都需要初始化一个句柄</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::NodeHandle nh;</span><br></pre></td></tr></table></figure><h2 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h2><p>话题操作基本思想就是创建两个节点，然后这两个节点需要有一致的话题，然后作为发布方会发送该话题的消息，而接收放就接收该话题的消息，以此实现通信</p><h3 id="发布方"><a href="#发布方" class="headerlink" title="发布方"></a>发布方</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化发布方，话题名称，保存的最大消息数</span></span><br><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 初始化消息</span></span><br><span class="line">std_msgs::String msg;</span><br><span class="line">msg.data = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"><span class="comment">// 发布话题</span></span><br><span class="line">pub.<span class="built_in">publish</span>(msg);</span><br></pre></td></tr></table></figure><h3 id="订阅方"><a href="#订阅方" class="headerlink" title="订阅方"></a>订阅方</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doMsg</span><span class="params">(<span class="type">const</span> std_msgs::String::ConstPtr&amp; msg_p)</span></span>;</span><br><span class="line"><span class="comment">// 初始化订阅方 话题名称，保存的最大消息数，绑定订阅回调函数</span></span><br><span class="line">ros::Subscriber sub = nh.<span class="built_in">subscribe</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>,doMsg);</span><br><span class="line"><span class="comment">// 循环接收消息</span></span><br><span class="line">ros::<span class="built_in">spin</span>();</span><br></pre></td></tr></table></figure><h3 id="自定义msg"><a href="#自定义msg" class="headerlink" title="自定义msg"></a>自定义msg</h3><p>msgs是一个文本文件，每一行分别是字段类型和字段名称</p><p>首先在功能包下新建 msg 目录，添加文件 <code>xxx.msg</code> xxx是自定义的名称，内容可以自定义，这里暂定为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint16 age</span><br></pre></td></tr></table></figure><p>在 <code>package.xml</code> 中添加编译依赖与执行依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>CMakeLists.txt</code> 编辑相关配置</p><ul><li>在 <code>find_package</code> 中添加 <code>message_generation</code> 与 <code>std_msgs</code></li><li>在 <code>add_message_files</code> 中添加 msg 文件 <code>xxx.msg</code></li><li>在 <code>generate_messages</code> 中添加 <code>std_msgs</code></li></ul><p>编译之后会生成一个头文件，位于 <code>\devel\include\包名\xxx.h</code> ，并且1需要配置该头文件的路径，然后就可以像 <code>std_msgs</code> 一样使用了</p><h2 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h2><p>ros 系统负责存储服务端和客户端的注册信息，并且匹配话题相同的服务端和客户端，并且建立连接，之后客户端请求，服务端响应</p><h3 id="自定义服务器"><a href="#自定义服务器" class="headerlink" title="自定义服务器"></a>自定义服务器</h3><p>功能包下新建 srv 目录，添加 <code>xxx.srv</code> 文件，内容为（根据自己需求来定义）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 客户端请求时发送的两个数据</span><br><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">---</span><br><span class="line"># 服务器响应发送的数据</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure><p>中间记得加 <code>---</code> 来做划分</p><p>编辑配置文件，在 <code>package.xml</code> 中添加编译依赖与执行依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>CMakeLists.txt</code> 中编辑相关配置</p><ul><li>在 <code>find_package</code> 中添加 <code>message_generation</code> 与 <code>std_msgs</code></li><li>在 <code>add_service_files</code> 中添加 msg 文件 <code>xxx.srv</code></li><li>在 <code>generate_messages</code> 中添加 <code>std_msgs</code></li></ul><p>编译之后会生成一个头文件，位于 <code>\devel\include\包名\xxx.h</code> ，并且1需要配置该头文件的路径，然后就可以作为头文件被引入使用了</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器响应回调函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doReq</span><span class="params">(demo03_server_client::AddInts::Request&amp; req,demo03_server_client::AddInts::Response&amp; resp)</span></span>;</span><br><span class="line"><span class="comment">// 初始化服务端 服务话题名称，接收到请求的回调函数</span></span><br><span class="line">ros::ServiceServer server = nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;AddInts&quot;</span>, doReq);</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建客户端对象</span></span><br><span class="line">ros::ServiceClient client = nh.<span class="built_in">serviceClient</span>&lt;demo03_server_client::AddInts&gt;(<span class="string">&quot;AddInts&quot;</span>);</span><br><span class="line"><span class="comment">// 等待服务器启动</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;AddInts&quot;</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">client.<span class="built_in">waitForExistence</span>();</span><br><span class="line"><span class="comment">// 发送请求的客户端数据</span></span><br><span class="line">demo03_server_client::AddInts ai;</span><br><span class="line"><span class="comment">// 发送请求,返回 bool 值，标记是否成功</span></span><br><span class="line"><span class="type">bool</span> flag = client.<span class="built_in">call</span>(ai);</span><br></pre></td></tr></table></figure><h2 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h2><p>有两种增删改查的参数操作</p><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">ros::NodeHandle::<span class="built_in">setParam</span>(key, value);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(key, value);</span><br></pre></td></tr></table></figure><h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>第一种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ros::NodeHandle::<span class="built_in">param</span>(key, default_value);</span><br><span class="line">ros::NodeHandle::<span class="built_in">getParam</span>(key, &amp;value);</span><br><span class="line">ros::NodeHandle::<span class="built_in">getParamCache</span>(key, &amp;value);</span><br><span class="line"><span class="comment">// 获取所有并且存放在vector中</span></span><br><span class="line">ros::NodeHandle::<span class="built_in">getParamNames</span>(std::vector&lt;std::string&gt;&amp;);</span><br><span class="line">ros::NodeHandle::<span class="built_in">hasParam</span>(key);</span><br><span class="line">ros::NodeHandle::<span class="built_in">searchParam</span>(key, &amp;value);</span><br></pre></td></tr></table></figure><p>第二种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::param::<span class="built_in">get</span>(key, &amp;value);</span><br><span class="line">ros::param::<span class="built_in">getCache</span>(key, &amp;value);</span><br><span class="line">ros::param::<span class="built_in">getParamNames</span>(std::vector&lt;std::string&gt;&amp;);</span><br><span class="line">ros::param::<span class="built_in">has</span>(key);</span><br><span class="line">ros::param::<span class="built_in">search</span>(key, &amp;value);```</span><br></pre></td></tr></table></figure><h3 id="删除参数"><a href="#删除参数" class="headerlink" title="删除参数"></a>删除参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::NodeHandle::<span class="built_in">deleteParam</span>(key);</span><br><span class="line">ros::param::<span class="built_in">del</span>(key);</span><br></pre></td></tr></table></figure><h2 id="动作action"><a href="#动作action" class="headerlink" title="动作action"></a>动作action</h2><p>类似于服务通信，并且在运行过程中服务端不断地向客户端反馈数据与状态</p><h3 id="自定义action消息"><a href="#自定义action消息" class="headerlink" title="自定义action消息"></a>自定义action消息</h3><p>需要在导入工程包的时候还要额外导入 <code>actionlib actionlib_msgs</code> 等文件，在功能包下新建 <code>action</code> 目录，新增 <code>xxx.action</code> 文件。</p><p><code>action</code> 文件内容由三部分组成</p><ol><li>请求目标值</li><li>最终响应结果</li><li>连续反馈</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#目标值</span><br><span class="line">int32 num</span><br><span class="line">---</span><br><span class="line">#最终结果</span><br><span class="line">int32 result</span><br><span class="line">---</span><br><span class="line">#连续反馈</span><br><span class="line">float64 progress_bar</span><br></pre></td></tr></table></figure><p>在 <code>CMakeLists.txt</code> 文件的 <code>add_action_files</code> 中添加 <code>xxx.action</code></p><p>编译之后会在工作空间内生成对应的头文件</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">actionlib::<span class="built_in">SimpleActionServer</span>(ros::NodeHandle n, </span><br><span class="line">                   std::string name, </span><br><span class="line">                   boost::function&lt;<span class="built_in">void</span> (<span class="type">const</span> demo01_action::AddIntsGoalConstPtr &amp;)&gt; execute_callback, </span><br><span class="line">                   <span class="type">bool</span> auto_start);</span><br><span class="line"><span class="comment">// 开始服务器</span></span><br><span class="line">server.<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">actionlib::SimpleActionClient&lt;demo01_action::AddIntsAction&gt; <span class="title">client</span><span class="params">(nh,<span class="string">&quot;addInts&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="comment">//等待服务启动</span></span><br><span class="line">client.<span class="built_in">waitForServer</span>();</span><br><span class="line"><span class="comment">// 目标值（也就是上述定义的action消息的数据</span></span><br><span class="line"><span class="comment">// 处理最终的反馈回调</span></span><br><span class="line"><span class="comment">// 服务器激活反馈回调</span></span><br><span class="line"><span class="comment">// 处理连续反馈回调</span></span><br><span class="line">client.<span class="built_in">sendGoal</span>(goal,&amp;done_cb,&amp;active_cb,&amp;feedback_cb);</span><br></pre></td></tr></table></figure><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a>launch文件</h2><p>launch 文件是一个 XML 格式的文件，可以启动本地和远程的多个节点，还可以在参数服务器上设置参数</p><p>可以使用一个 <code>launch</code> 文件就打开多个节点，提高 ROS 程序的启动效果</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>在功能包下添加 <code>launch</code> 目录，在目录下面新建 <code>xxx.launch</code> 文件，并且编辑文件</li><li>在命令行中输入指令 <code>roslaunch 包名 xxx.launch</code> 来调用 <code>launch</code> 文件，使用 <code>roslaunch</code> 指令时会自动打开 <code>roscore</code></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>由于 ros 是多进程的，所以不能保证 <code>launch</code> 文件中的节点的启动顺序</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong><code>launch</code> 标签</strong></p><p>是所有 <code>launch</code> 文件的根标签，充当其它标签的容器</p><p><strong><code>node</code> 标签属性</strong></p><ul><li><code>pkg=&quot;pkgname&quot;</code> 节点所属的包名</li><li><code>type=&quot;nodetype&quot;</code> 节点的类型</li><li><code>name=&quot;nodename&quot;</code> 节点名称</li><li><code>args=&quot;xxx&quot;</code> 参数可选，是传递给节点的参数</li><li><code>machine=&quot;machinename&quot;</code> 机器名称，在指定的机器上启动节点</li><li><code>respawn=&quot;true or false&quot;</code> 如果节点退出是否重新启动</li><li><code>respawn_delay=&quot;N&quot;</code> 如果上述 <code>respawn</code> 为 <code>true</code> 则延迟 <code>N</code> 秒后重启节点</li><li><code>required=&quot;true or false&quot;</code> 该节点是否必要，如果为 <code>true</code> 退出将杀死整个 <code>roslaunch</code></li><li><code>ns=&quot;xxx&quot;</code> 在指定命名空间中启动节点</li><li><code>clear_params=&quot;true or false&quot;</code> 再启动前，删除节点的私有空间的所有参数</li><li><code>output=&quot;log or screen&quot;</code> 日志发送的目标，发送到屏幕或者是文件</li></ul><p><strong><code>node</code> 子级标签</strong></p><ul><li><code>env</code> 环境变量设置</li><li><code>remap</code> 重映射节点名称</li><li><code>rosparam</code> 参数设置</li><li><code>param</code> 参数设置</li></ul><p><strong><code>include</code> 标签属性</strong></p><ul><li><code>file=&quot;$(find pkgname)/xxx/xxx.launch&quot;</code> 要包含的文件路径</li><li><code>ns=&quot;xxx&quot;</code> 在指定的命名空间导入文件，可不填</li></ul><p><strong><code>include</code> 子级标签</strong></p><ul><li><code>env</code> 环境变量设置</li><li><code>arg</code> 将参数传递给被包含的文件</li></ul><p><strong><code>remap</code> 标签</strong></p><p>用于话题重命名</p><ul><li><code>from=&quot;xxx&quot;</code> 原始话题名称</li><li><code>to=&quot;xxx&quot;</code> 重命名目标名称</li></ul><p><strong><code>param</code> 标签</strong></p><ul><li><code>name=&quot;namespace/paramname&quot;</code> 参数名称，可以包含命名空间</li><li><code>value=&quot;xxx&quot;</code> 可选参数，定义参数值，如果省略，必须指定外部文件作为参数来源</li><li><code>type=&quot;str or ...&quot;</code> 指定参数类型，如未指定， <code>roslaunch</code> 会尝试确定参数类型</li></ul><p><strong><code>rosparam</code> 标签</strong></p><ul><li><code>command=&quot;load or dump or delete&quot;</code> 可选，默认为 <code>load</code> ，加载，导出或者删除参数</li><li><code>file=&quot;$(find xxx)/xxx/xxx...&quot;</code> 加载或导出到的 <code>yaml</code> 文件</li><li><code>param=&quot;paramname&quot;</code> 参数名称</li><li><code>ns=&quot;namespace&quot;</code> 命名空间</li></ul><p><strong><code>group</code> 标签</strong></p><ul><li><code>ns=&quot;namespace&quot;</code> 可选，命名空间</li><li><code>clear_params=&quot;true or false&quot;</code> 可选，启动前是否删除组名称空间内部的所有参数</li><li>除了 <code>launch</code> 标签以外的标签都是它的子标签</li></ul><p><strong><code>arg</code> 标签</strong></p><ul><li><code>name=&quot;paramname&quot;</code> 参数名称</li><li><code>default=&quot;defaultvalue&quot;</code> 默认数值，可选</li><li><code>value=&quot;value&quot;</code> 数值，可选，不可与 <code>default</code> 并存</li><li><code>doc=&quot;description&quot;</code> 参数描述说明</li></ul><h2 id="其它的功能"><a href="#其它的功能" class="headerlink" title="其它的功能"></a>其它的功能</h2><h3 id="回旋函数"><a href="#回旋函数" class="headerlink" title="回旋函数"></a>回旋函数</h3><ul><li><code>spin()</code> 不断回旋，相当于 <code>while(1)</code></li><li><code>spinOnce()</code> 只回旋一次，没有循环，相当于顺序语句</li></ul><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p><strong>获取时刻</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Time right_now = ros::Time::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure><p><strong>持续时间</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::Duration <span class="title">du</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 设置一个持续时间 s，相当于 sleep 函数</span></span><br><span class="line">du.<span class="built_in">sleep</span>();</span><br></pre></td></tr></table></figure><p><strong>设置运行频率</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 指定频率</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  rate.<span class="built_in">sleep</span>(); <span class="comment">// 休眠，休眠时间 = 1 / 频率。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定时器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* \brief 创建一个定时器，按照指定频率调用回调函数。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* \param period 时间间隔</span></span><br><span class="line"><span class="comment">* \param callback 回调函数</span></span><br><span class="line"><span class="comment">* \param oneshot 如果设置为 true,只执行一次回调函数，设置为 false,就循环执行</span></span><br><span class="line"><span class="comment">* \param autostart 如果为true，返回已经启动的定时器,设置为 false，需要手动启动，默认为true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ros::Timer timer = nh.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>), doSomeThing, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">spin</span>(); <span class="comment">//必须 spin 否则程序跑完了且不会运行回调函数</span></span><br></pre></td></tr></table></figure><h3 id="重映射和命名空间"><a href="#重映射和命名空间" class="headerlink" title="重映射和命名空间"></a>重映射和命名空间</h3><p><strong>别名设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;zhangsan&quot;</span>,ros::init_options::AnonymousName);</span><br></pre></td></tr></table></figure><p><strong>命名空间</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; map;</span><br><span class="line">map[<span class="string">&quot;__ns&quot;</span>] = <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line">ros::<span class="built_in">init</span>(map,<span class="string">&quot;wangqiang&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="话题重映射"><a href="#话题重映射" class="headerlink" title="话题重映射"></a>话题重映射</h3><p>rosrun名称重映射语法: rorun 包名 节点名 话题名:=新话题名称</p><p>话题的名称与节点的命名空间，节点的名称是有一定关系的，话题名称分为三种类型</p><p><strong>全局</strong>，与节点命名空间平级，以 <code>/</code> 开头的节点名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;/chatter&quot;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>相对</strong>，与节点名称平级，以非 <code>/</code> 开头的节点名称来确定话题名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>私有</strong>，是节点名称的子级，以 <code>~</code> 开头的名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::NodeHandle <span class="title">nh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这些记录是我在学习 ros 时所记录下来的，可以看看赵老师所做的文档，写的很详细，很不错 <a href="http://www.autolabor.com.cn/book/ROSTutorials/di-5-zhang-ji-qi-ren-dao-hang/51-tfzuo-biao-bian-huan/512-jing-tai-zuo-biao-bian-huan.html">ros学习文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros2学习记录</title>
      <link href="/Blog_ButterFly/2024/03/24/ros2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/Blog_ButterFly/2024/03/24/ros2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ros2 跟 ros1 相差并不是非常大，但是毕竟是一个新的机器人操作系统，相比 ros1 来说强大的很多，总结就是</p><ul><li>节点干掉了 Master</li><li>通信换为了 DDS</li><li>核心概念没变化</li><li>编程难度上升</li></ul><h3 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h3><p>这是我自己的学习之后写的代码 <a href="https://github.com/Luo25177/ros2Work">github</a></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>需要注意在 <code>package.xml</code> 和 <code>CMakeLists.txt</code> 中声明所需要的依赖</p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="设置编码"><a href="#设置编码" class="headerlink" title="设置编码"></a>设置编码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install locales</span><br><span class="line">sudo locale-gen en_US en_US.UTF-8</span><br><span class="line">sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h3 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install curl gnupg lsb-release</span><br><span class="line">sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg</span><br><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p>上述第二条指令可能会报错“无法连接到raw.githubusercontent.com”，解决办法如下</p><ol><li>登录网站<a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a></li><li>将 <code>raw.githubusercontent.com</code> 在查询栏中搜索，可以看到域名对应的 ip 地址信息</li><li>将结果中的 ip 地址和域名拷贝到 <code>/etc/hosts</code> 文件中，（记得sudo）</li><li>保存退出之后就可以重新尝试第二条指令了</li></ol><h3 id="安装ros2"><a href="#安装ros2" class="headerlink" title="安装ros2"></a>安装ros2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install ros-humble-desktop</span><br></pre></td></tr></table></figure><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/humble/setup.bash</span><br><span class="line">echo &quot; source /opt/ros/humble/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>打开两个终端，分别运行如下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br><span class="line">ros2 run turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><h2 id="ros2的一些指令"><a href="#ros2的一些指令" class="headerlink" title="ros2的一些指令"></a>ros2的一些指令</h2><h3 id="运行节点程序"><a href="#运行节点程序" class="headerlink" title="运行节点程序"></a>运行节点程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run</span><br></pre></td></tr></table></figure><h3 id="查看节点信息"><a href="#查看节点信息" class="headerlink" title="查看节点信息"></a>查看节点信息</h3><p><strong>查看节点列表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node list</span><br></pre></td></tr></table></figure><p><strong>查看具体节点信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node info /turtlesim # 这里的turtlesim就是海龟节点</span><br></pre></td></tr></table></figure><h3 id="查看话题信息"><a href="#查看话题信息" class="headerlink" title="查看话题信息"></a>查看话题信息</h3><p><strong>查看话题列表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure><p><strong>利用echo指令查看话题中的消息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /turtle1/pose</span><br></pre></td></tr></table></figure><h3 id="发布话题消息"><a href="#发布话题消息" class="headerlink" title="发布话题消息"></a>发布话题消息</h3><p>在上述小海龟中可以发布话题消息控制小海龟运动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;&#123;linear: &#123;x: 2.0, y: 0.0, z: 0.0&#125;, angular: &#123;x: 0.0, y: 0.0, z: 1.8&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="发送服务请求"><a href="#发送服务请求" class="headerlink" title="发送服务请求"></a>发送服务请求</h3><p>还是在上述的小海龟中，其实小海龟里创建了服务器可以在用户端的请求之下可以产生一个新的海龟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 service call /spawn turtlesim/srv/Spawn &quot;&#123;x: 2, y: 2, theta: 0.2, name: &#x27;&#x27;&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="发送动作目标"><a href="#发送动作目标" class="headerlink" title="发送动作目标"></a>发送动作目标</h3><p>想要让海龟完成一个具体动作，比如转到指定角度，仿真器中提供的这个action可以帮上忙，通过命令行发送动作目标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute <span class="string">&quot;theta: 3&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="录制控制指令"><a href="#录制控制指令" class="headerlink" title="录制控制指令"></a>录制控制指令</h3><p>系统运行中参数太多，通过 <code>rosbag</code> 可以将数据录制与播放</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag record /turtle1/cmd_vel # 保存的具体的指令</span><br><span class="line">ros2 bag play rosbag2_2022_04_11-17_35_40/rosbag2_2022_04_11-17_35_40_0.db3 # 已经保存的录制的文件</span><br></pre></td></tr></table></figure><h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./dev_ws/src</span><br><span class="line">cd ./dev_ws/src</span><br></pre></td></tr></table></figure><h3 id="编译工作空间"><a href="#编译工作空间" class="headerlink" title="编译工作空间"></a>编译工作空间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-colcon-ros</span><br><span class="line">cd ..</span><br><span class="line">colcon build</span><br></pre></td></tr></table></figure><h3 id="设置运行环境变量"><a href="#设置运行环境变量" class="headerlink" title="设置运行环境变量"></a>设置运行环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source install/local_setup.sh # 仅在当前终端生效</span><br><span class="line">echo &quot;source $&#123;dev/install/local_setup.sh&quot; &gt;&gt; ~/.bashrc # 所有终端均生效</span><br></pre></td></tr></table></figure><h3 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type &lt;build-type&gt; &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>create 表示创建功能包</li><li>build-type 表示新创建的功能包是 C++ 还是 python 的，如果使用 C++，那这里就是 <code>ament_cmake</code> ，对于 python 就是 <code>ament_python</code></li><li>package_name 新建功能包的名字</li></ul><h2 id="创建自定义消息和服务"><a href="#创建自定义消息和服务" class="headerlink" title="创建自定义消息和服务"></a>创建自定义消息和服务</h2><p>很恶心的一点就是,自定义的消息或者是服务的名称编译结束之后会变得不一样，引用的时候就会出现一些奇怪的bug，例如:</p><p>AddTwoInt.srv -&gt; add_two_int.hpp &amp; AddTwoInt</p><p>编译结束之后需要调用的头文件名称会不太一样,变成上面那种格式,但是在函数中调用的时候依旧是原来的定义的文件名的格式</p><p>利用这条指令来查看自己是否创建完成消息或者服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface list</span><br></pre></td></tr></table></figure><p>文件名称中必须有大写字母，也就是最好使用<strong>驼峰式命名</strong>格式</p><p>文件中的数据类型必须声明位数，例如：<code>int64 int32 float32</code> 等</p><p>使用方需要注意包含特定的包</p><ol><li>CMakeLists.txt 中 <code>find_package</code></li><li>CMakeLists.txt 中 <code>ament_target_dependencies</code></li><li>package.xml 中 <code>&lt;depend&gt;interfaces&lt;/depend&gt;</code></li></ol><hr><h2 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h2><p>使用 <code>Publisher</code> 来发布话题消息</p><p>使用 <code>Subscription</code> 接受话题消息</p><p>需要注意的是</p><ol><li><code>publisher</code> 和 <code>subscription</code> 需要有相同的消息类型</li><li><code>publisher</code> 和 <code>subscription</code> 需要有相同的消息名称</li><li>话题通信是一种异步通信</li></ol><h3 id="命令行指令"><a href="#命令行指令" class="headerlink" title="命令行指令"></a>命令行指令</h3><ul><li><code>ros2 topic list</code> 查看话题列表</li><li><code>ros2 topic info &lt;topic_name&gt;</code> 查看话题信息</li><li><code>ros2 topic hz &lt;topic_name&gt;</code> 查看话题发布频率</li><li><code>ros2 topic bw &lt;topic_name&gt;</code> 查看话题传输带宽</li><li><code>ros2 topic echo &lt;topic_name&gt;</code> 查看话题数据</li><li><code>ros2 topic pub &lt;topic_name&gt; &lt;msg_type&gt; &lt;msg_data&gt;</code> 发布话题消息</li></ul><hr><h2 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h2><p>使用 <code>service</code> 作为服务器</p><p>使用 <code>client</code> 作为客户端</p><p>客户端可以向服务器发送请求和数据，需要自己创建自定义的消息类型和服务</p><p>对于同一个服务器可以有多个客户端</p><h3 id="命令行指令-1"><a href="#命令行指令-1" class="headerlink" title="命令行指令"></a>命令行指令</h3><ul><li><code>ros2 service list</code> 查看服务列表</li><li><code>ros2 service type &lt;service_name&gt;</code> 查看服务数据类型</li><li><code>ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;service_data&gt;</code> 发送服务请求</li></ul><hr><h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><p>一定一定要添加依賴 <code>rclcpp_action</code></p><p>其中 <code>actionserver</code> 比较复杂，需要应对多种信号来做处理</p><p><code>actionclient</code> 也比较复杂，需要定义一个 <code>option</code> 绑定多种函数，也不是很建议使用 <code>timer</code>，感觉会有点冲突？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(接受到消息) --&gt; B[goalhandler自定义判断条件] --&gt; C&#123;judgement&#125; --&gt; |符合条件|acceptedhandler --&gt; D(execute)</span><br><span class="line">C&#123;judgement&#125; --&gt; |不符合条件|REJECT --&gt; E(cancel)</span><br><span class="line">C(execute) --&gt; |client终止运行|E(cancel)</span><br></pre></td></tr></table></figure><p>动作的三个通信模块，有两个是服务，一个是话题，当客户端发送运动目标时，使用的是服务的请求调用，服务器端也会反馈一个应答，表示收到命令。动作的反馈过程，其实就是一个话题的周期发布，服务器端是发布者，客户端是订阅者</p><p>没错，动作是一种应用层的通信机制，其底层就是基于话题和服务来实现的</p><h3 id="自定义action接口"><a href="#自定义action接口" class="headerlink" title="自定义action接口"></a>自定义action接口</h3><p>通过在 <code>action</code> 文件夹下定义 <code>xxx.action</code> 文件，内部包含的内容类似于服务通信，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool enable # 定义动作的目标，表示动作开始的指令</span><br><span class="line">---</span><br><span class="line">bool finish # 定义动作的结果，表示是否成功执行</span><br><span class="line">---</span><br><span class="line">int32 state # 定义动作的反馈，表示当前执行到的位置</span><br></pre></td></tr></table></figure><p>在 <code>CMakeLists.txt</code> 的 <code>rosidl_generate_interfaces</code> 添加 <code>xxx.action</code> 的路径，然后编译生成对应的头文件</p><h3 id="命令行指令-2"><a href="#命令行指令-2" class="headerlink" title="命令行指令"></a>命令行指令</h3><ul><li><code>ros2 action list</code> 查看服务列表</li><li><code>ros2 action info &lt;action_name&gt;</code> 查看数据服务类型</li><li><code>ros2 action send_goal &lt;action_name&gt; &lt;action_type&gt; &lt;action_data&gt;</code> 发送服务请求</li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数实际上就是一个全局字典，相当于是所有 ros 线程公用的全局变量，所有节点都可以访问。如果其中一个节点对参数进行了修改，那其它的节点也会立即知道</p><h3 id="命令行指令-3"><a href="#命令行指令-3" class="headerlink" title="命令行指令"></a>命令行指令</h3><ul><li><code>ros2 param list</code> 查看列表参数</li><li><code>ros2 param describe nodename paramname</code> 获取某个参数的描述信息</li><li><code>ros2 param get nodename paramname</code> 查询某个参数的值</li><li><code>ros2 param set nodename paramname value</code> 修改某个参数的值</li></ul><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a>launch文件</h2><p>launch文件的核心目的就是启动节点，在命令行中输入各种参数，在 <code>launch</code> 文件中，可以进行配置。由于 ros2 中的 <code>launch</code> 文件是由 <code>python</code> 来描述的，所以可以使用 <code>python</code> 原有的编程功能</p><h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h2><h3 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h3><p>许多客户端连接到一个服务器，每次通信时，通信双方必须建立一条连接。当通信节点增多时，连接数也会增多。而且每个客户端都需要知道服务器的具体地址和所提供的服务，一旦服务器地址发生变化，所有客户端都会受到影响</p><h3 id="Broker模型"><a href="#Broker模型" class="headerlink" title="Broker模型"></a>Broker模型</h3><p>针对点对点模型进行了优化，由Broker集中处理所有人的请求，并进一步找到真正能响应该服务的角色。这样客户端就不用关心服务器的具体地址了。不过问题也很明显，Broker作为核心，它的处理速度会影响所有节点的效率，当系统规模增长到一定程度，Broker就会成为整个系统的性能瓶颈。更麻烦是，如果Broker发生异常，可能导致整个系统都无法正常运转。之前的ROS1系统，使用的就是类似这样的架构</p><h3 id="广播模型"><a href="#广播模型" class="headerlink" title="广播模型"></a>广播模型</h3><p>所有节点都可以在通道上广播消息，并且节点都可以收到消息。这个模型解决了服务器地址的问题，而且通信双方也不用单独建立连接，但是广播通道上的消息太多了，所有节点都必须关心每条消息，其实很多是和自己没有关系的</p><h3 id="DDS模型"><a href="#DDS模型" class="headerlink" title="DDS模型"></a>DDS模型</h3><p>以数据为中心，这种模型与广播模型有些类似，所有节点都可以在DataBus上发布和订阅消息。但它的先进之处在于，通信中包含了很多并行的通路，每个节点可以只关心自己感兴趣的消息，忽略不感兴趣的消息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ros2 相比于 ros1 来说，通讯上的实时性更好一点，并且 ros2 系统在应用和性能上只会比 ros1 更加强大</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> ros2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo制作引导页</title>
      <link href="/Blog_ButterFly/2024/03/23/Hexo%E5%88%B6%E4%BD%9C%E5%BC%95%E5%AF%BC%E9%A1%B5/"/>
      <url>/Blog_ButterFly/2024/03/23/Hexo%E5%88%B6%E4%BD%9C%E5%BC%95%E5%AF%BC%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一开始是看到了这个博客 <a href="https://cnhuazhu.top">花猪のBLOG</a>，大受震撼，但是这个博客所用的方法需要在 <code>ubuntu</code> 系统上建立一个服务器，还是挺复杂的，然后就看到了这篇文章 <a href="https://www.jianshu.com/p/80e0e1058bda">Hexo自定义页面做首页</a>，然后将两篇文章的内容作为参考，做出了我的效果，因此记录下来</p><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>假设你已经做好了一个网站，并且是基于 github 的，那么在 github 上新建一个仓库，名为 <code>Blog</code> 可以是其它名字，然后把你自己创建网站所用的 github 仓库清空，也就是 <code>xxx.github.io</code> ，这个后续会用来作为你的引导页的仓库</p><h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>然后在你已经做好的网站本地的站点配置文件中按照如下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://xxx.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/Blog/</span></span><br></pre></td></tr></table></figure><p>然后找到其中的 <code>deploy</code> 做出以下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/xxx/Blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span> <span class="comment"># 这里看你的仓库里有哪个分支了，尽量保证你的仓库内有一个分支</span></span><br></pre></td></tr></table></figure><p>对于你的主题内调用的本地的 <code>css</code> 和 <code>js</code> 文件，需要在前面加一个根目录。也就是上文中的 <code>root</code> ，按如下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/Blog/css/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/Blog/js/xxx.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>还有就是你的主题内使用的 <code>url(/img/xxx.png)</code> 之类的，也需要做出更改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">url(Blog/img/xxx.png)</span></span><br></pre></td></tr></table></figure><h2 id="重新部署你的博客"><a href="#重新部署你的博客" class="headerlink" title="重新部署你的博客"></a>重新部署你的博客</h2><p>直接在终端输入 <code>hexo g</code> 和 <code>hexo d</code> 完成部署，但是要注意把你之前的 <code>CNAME</code> 文件删除</p><h2 id="引导页配置"><a href="#引导页配置" class="headerlink" title="引导页配置"></a>引导页配置</h2><p>引导页的话可以去找一些开源的方案，当然一定要声明源码</p><p>我的话使用的是 Dimension 的一个项目，开源仓库为 <a href="https://github.com/nianbroken/Personal_Sakura_Guide_Page">github</a>，<a href="https://gitee.com/nianbroken/Personal_Sakura_Guide_Page">gitee</a>，非常漂亮，稍微修改就能用</p><p>然后将这个引导页跳转到你的网站的功能做好之后，就能部署到你的 github 上的 <code>xxx.github.io</code> 仓库中，然后就完成了</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctags使用</title>
      <link href="/Blog_ButterFly/2024/03/23/ctags%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/23/ctags%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在linux系统中安装只需要一行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ctags</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="终端中指令"><a href="#终端中指令" class="headerlink" title="终端中指令"></a>终端中指令</h3><p><strong>创建索引文件</strong></p><p>ctags 其它的指令使用的前提都是为操作的文件建立索引文件的基础上进行的，所以在使用 ctags 对文件进行检索之前，先执行命令如下指令来创建索引文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R .</span><br></pre></td></tr></table></figure><p>可以在该指令之后添加参数，参数具体说明看下述 ctags参数，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q /usr/include</span><br></pre></td></tr></table></figure><p>生成的tags文件所描述的符号信息都只针对当前项目源代码树中的文件，而不包含任何外部文件的符号信息，例如标准头文件（例如 <code>&lt;stdio.h&gt;&lt;stdlib.h&gt;</code> ）等，因此 <code>vim</code> 无法在外部头文件中找到符号</p><p><strong>利用 ctags 查找变量或者函数名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi –t variable_name/function_name</span><br></pre></td></tr></table></figure><p><strong>ctags参数</strong></p><ul><li><code>--list-maps</code> ctags可以根据文件的扩展名以及文件名的形式确定该文件是何种语言。用—list-maps查看默认情况下支持那些语言，每一种支持的语言支持的文件扩展名是什么</li><li><code>--list-kinds</code> 查看默认支持的所有语言可以识别的语法元素</li><li><code>--c++-kinds</code> ctags 可以识别很多元素，但并不会全部记录，可以控制 ctags 记录的语法元素的种类</li><li><code>--langmap</code> 可以指定ctags用特定语言的分析器来分析某种扩展名的文件或者名字符合特定模式的文件</li><li><code>-h</code> 用于指定一些其它后缀名的文件也是头文件</li><li><code>--fields</code> ctags 对语法元素的描述取决于语法元素的种类。可以在命令行中指定显示哪些描述，以哪种格式显示等<ul><li>i 表示如果有继承，标明父类</li><li>a 表示如果是类的成员，要标明其 <code>access</code> 属性 <code>public or private</code></li><li>S 表示如果是函数，要标明函数的 <code>signature</code></li><li>K 表示要显示的语法元素类型的全称</li><li>z 表示在显示语法元素的类型时，使用格式 <code>kind:type</code></li></ul></li><li><code>--extra</code> ctags 在记录成员函数时，默认情况下 tag 的名字只包括该函数的名字，不包括类名，这样很多不同类但同名的函数所对应的 <code>tag</code> 名字都一样。于是在 <code>vim</code> 中使用函数名来定位时就会出现很多选择，很麻烦。如果想用包括类名的函数全名进行定位，就得要求 ctags 记录全名</li><li><code>--exclude</code> 默认 ctags 是会扫描所有文件的，可以要求 ctags 不要扫描某些目录或文件</li></ul><h3 id="vim中常用指令"><a href="#vim中常用指令" class="headerlink" title="vim中常用指令"></a>vim中常用指令</h3><div class="table-container"><table><thead><tr><th>常用指令</th><th>作用</th></tr></thead><tbody><tr><td>ctrl+]</td><td>跳转到光标所在变量，宏，函数的定义处</td></tr><tr><td>ctrl+T</td><td>返回跳转前的位置</td></tr><tr><td>ctrl+W+]</td><td>分割当前窗口并且在新窗口中显示跳转到的定义</td></tr><tr><td>ctrl+O</td><td>返回之前的位置</td></tr><tr><td>:ts tags</td><td>列出所有匹配的标签</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctags </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-cpp</title>
      <link href="/Blog_ButterFly/2024/03/23/opencv-cpp/"/>
      <url>/Blog_ButterFly/2024/03/23/opencv-cpp/</url>
      
        <content type="html"><![CDATA[<ol><li><p>对像素点进行处理，保证rgb数值不超过范围</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stemp</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">255</span>)</span><br><span class="line">        a = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读入图像和想要实现的操作，实现相应的操作，例如灰度图，HSV图，LAC图等</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(cv::Mat image, <span class="type">const</span> std::string operate, <span class="type">int</span> light = <span class="number">0</span>, <span class="type">float</span> contrast = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    <span class="keyword">if</span> (operate == <span class="string">&quot;LAC&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="built_in">multiply</span>(image, cv::<span class="built_in">Scalar</span>(contrast, contrast, contrast), dst);</span><br><span class="line">        dst = dst + cv::<span class="built_in">Scalar</span>(light, light, light);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; image.cols; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; image.rows; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dst.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="built_in">stemp</span>(dst.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>]);</span><br><span class="line">                dst.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="built_in">stemp</span>(dst.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">                dst.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="built_in">stemp</span>(dst.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;change&quot;</span>, dst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (operate == <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cvtColor</span>(image, dst, cv::COLOR_GRAY2BGR);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;gray&quot;</span>, dst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (operate == <span class="string">&quot;HSV&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cvtColor</span>(image, dst, cv::COLOR_HSV2BGR);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;HSV&quot;</span>, dst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对图像亮度和对比度处理，主要是引用 <code>operate</code> 函数来实现，就是个 <code>createTrackBar</code> 的回调函数</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> light = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> contrast = <span class="number">50</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LightAndContrast</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat image = *((cv::Mat *)userdata);</span><br><span class="line">    <span class="type">float</span> i = (<span class="type">float</span>)contrast / <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">operate</span>(image, <span class="string">&quot;LAC&quot;</span>, <span class="number">2</span> * (light - <span class="number">50</span>), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>滚动条操作 创建一个关于亮度和对比度的滚动条</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tracking_bar</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;change&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;change&quot;</span>, image);</span><br><span class="line">    <span class="type">int</span> max = <span class="number">100</span>;</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;light&quot;</span>, <span class="string">&quot;change&quot;</span>, &amp;light, max, LightAndContrast, (<span class="type">void</span> *)(&amp;image));</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;ocntrast&quot;</span>, <span class="string">&quot;change&quot;</span>, &amp;contrast, max, LightAndContrast, (<span class="type">void</span> *)(&amp;image));</span><br><span class="line">    <span class="built_in">LightAndContrast</span>(<span class="number">0</span>, &amp;image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通道分离函数，主要是把图像的三个颜色通道分离</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">channel_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;cv::Mat&gt; mv;</span><br><span class="line">    <span class="built_in">split</span>(image, mv);</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    mv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    mv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">merge</span>(mv, dst); <span class="comment">// 图像和</span></span><br><span class="line">    <span class="type">int</span> from_to[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">mixChannels</span>(&amp;image, <span class="number">1</span>, &amp;dst, <span class="number">1</span>, from_to, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;change&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在图像上进行操作把范围内的颜色阈值给设为白色，其他的设为黑色</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inrange_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat HSV;</span><br><span class="line">    <span class="built_in">cvtColor</span>(image, HSV, cv::COLOR_RGB2HSV);</span><br><span class="line">    cv::Mat mask;</span><br><span class="line">    <span class="built_in">inRange</span>(HSV, cv::<span class="built_in">Scalar</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), mask);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>像素值统计，对图像的3个颜色通道上的r|g|b的最大值和最小值提取，并且找到所在位置。计算三个通道的均值和标准差</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pixel_statistic_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;cv::Mat&gt; mv;</span><br><span class="line">    <span class="built_in">split</span>(image, mv);</span><br><span class="line">    <span class="type">double</span> minv, maxv;</span><br><span class="line">    cv::Point minLoc, maxLoc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">minMaxLoc</span>(mv[i],      <span class="comment">// mv[]是表示单个通道的图像，可以是灰度图</span></span><br><span class="line">                  &amp;minv,      <span class="comment">// minv是通道的最小值</span></span><br><span class="line">                  &amp;maxv,      <span class="comment">// 通道的最大值</span></span><br><span class="line">                  &amp;minLoc,    <span class="comment">// 最小值的地址</span></span><br><span class="line">                  &amp;maxLoc,    <span class="comment">// 最大值的地址</span></span><br><span class="line">                  cv::<span class="built_in">Mat</span>()); <span class="comment">// 图像</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;个通道&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Max value&quot;</span> &lt;&lt; maxv &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Min value&quot;</span> &lt;&lt; minv &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Max location&quot;</span> &lt;&lt; maxLoc &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Min Location&quot;</span> &lt;&lt; minLoc &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat mean, stddev;</span><br><span class="line">    <span class="built_in">meanStdDev</span>(image, mean, stddev); <span class="comment">//</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;means&quot;</span> &lt;&lt; mean &lt;&lt; <span class="string">&quot;\nstddev:&quot;</span> &lt;&lt; stddev &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在图像上绘制</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Rect rect; <span class="comment">//绘制矩形</span></span><br><span class="line">    rect.x = <span class="number">200</span>;  <span class="comment">//矩形开始的位置，左上角，屏幕左上角为0，0</span></span><br><span class="line">    rect.y = <span class="number">200</span>;</span><br><span class="line">    rect.width = <span class="number">100</span>; <span class="comment">// 矩形的高度和宽度</span></span><br><span class="line">    rect.height = <span class="number">100</span>;</span><br><span class="line">    cv::Mat bg = cv::Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(bg, rect, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">circle</span>(bg, cv::<span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">100</span>), <span class="number">15</span>, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">line</span>(bg, cv::<span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">100</span>), cv::<span class="built_in">Point</span>(<span class="number">200</span>, <span class="number">200</span>), cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, cv::LINE_AA, <span class="number">0</span>); <span class="comment">// LINE_AA 反锯齿</span></span><br><span class="line">    cv::RotatedRect rrt;</span><br><span class="line">    rrt.center = cv::<span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">    rrt.size = cv::<span class="built_in">Size</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    rrt.angle = <span class="number">90.0</span>;</span><br><span class="line">    cv::<span class="built_in">ellipse</span>(bg, rrt, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::<span class="built_in">addWeighted</span>(image, <span class="number">0.7</span>, bg, <span class="number">0.3</span>, <span class="number">0</span>, dst); <span class="comment">// 两张图片按照权重比叠加</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;deal&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>随机绘制直线</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">random_draw</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat canvas = cv::Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">    <span class="type">int</span> w = image.cols;</span><br><span class="line">    <span class="type">int</span> h = image.rows;</span><br><span class="line">    <span class="function">cv::RNG <span class="title">RNG</span><span class="params">(<span class="number">12345</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c = cv::<span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> x1 = RNG.<span class="built_in">uniform</span>(<span class="number">0</span>, w);</span><br><span class="line">        <span class="type">int</span> y1 = RNG.<span class="built_in">uniform</span>(<span class="number">0</span>, h);</span><br><span class="line">        <span class="type">int</span> x2 = RNG.<span class="built_in">uniform</span>(<span class="number">0</span>, w);</span><br><span class="line">        <span class="type">int</span> y2 = RNG.<span class="built_in">uniform</span>(<span class="number">0</span>, h);</span><br><span class="line">        <span class="comment">// canvas = cv::Scalar(0, 0, 0);   // 每次只显示一条线</span></span><br><span class="line">        cv::<span class="built_in">line</span>(canvas, cv::<span class="built_in">Point</span>(x1, y1), cv::<span class="built_in">Point</span>(x2, y2), cv::<span class="built_in">Scalar</span>(RNG.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), RNG.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), RNG.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>)), <span class="number">1</span>, cv::LINE_AA, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;random_line&quot;</span>, canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绘制多边形，并且填充</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">polying_draw</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat canvas = cv::Mat::<span class="built_in">zeros</span>(cv::<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line">    <span class="type">int</span> w = <span class="number">512</span>;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">512</span>;</span><br><span class="line">    <span class="function">cv::RNG <span class="title">rng</span><span class="params">(<span class="number">12345</span>)</span></span>;</span><br><span class="line">    <span class="function">cv::Point <span class="title">p1</span><span class="params">(rng.uniform(<span class="number">0</span>, w), rng.uniform(<span class="number">0</span>, h))</span></span>;</span><br><span class="line">    <span class="function">cv::Point <span class="title">p2</span><span class="params">(rng.uniform(<span class="number">0</span>, w), rng.uniform(<span class="number">0</span>, h))</span></span>;</span><br><span class="line">    <span class="function">cv::Point <span class="title">p3</span><span class="params">(rng.uniform(<span class="number">0</span>, w), rng.uniform(<span class="number">0</span>, h))</span></span>;</span><br><span class="line">    <span class="function">cv::Point <span class="title">p4</span><span class="params">(rng.uniform(<span class="number">0</span>, w), rng.uniform(<span class="number">0</span>, h))</span></span>;</span><br><span class="line">    <span class="function">cv::Point <span class="title">p5</span><span class="params">(rng.uniform(<span class="number">0</span>, w), rng.uniform(<span class="number">0</span>, h))</span></span>;</span><br><span class="line">    std::vector&lt;cv::Point&gt; pts;</span><br><span class="line">    pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    <span class="comment">// polylines(canvas, pts, true, cv::Scalar(0, 0, 255), 1, cv::LINE_AA, 0);</span></span><br><span class="line">    <span class="comment">// cv::fillPoly(canvas, pts, cv::Scalar(255, 255, 0), 8, 0);</span></span><br><span class="line">    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;</span><br><span class="line">    contours.<span class="built_in">push_back</span>(pts);</span><br><span class="line">    cv::<span class="built_in">drawContours</span>(canvas, contours, <span class="number">-1</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;draw&quot;</span>, canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像的像素逻辑操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bitwise_demo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat m2 = cv::Mat::<span class="built_in">zeros</span>(cv::<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line">    cv::Mat m1 = cv::Mat::<span class="built_in">zeros</span>(cv::<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line">    cv::Mat dst_and;</span><br><span class="line">    cv::Mat dst_or;</span><br><span class="line">    cv::Mat dst_not;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(m1, cv::<span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>), cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>, cv::LINE_8, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(m2, cv::<span class="built_in">Rect</span>(<span class="number">150</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">80</span>), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, cv::LINE_8, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;m1&quot;</span>, m1);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;m2&quot;</span>, m2);</span><br><span class="line">    cv::<span class="built_in">bitwise_and</span>(m1, m2, dst_and);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;and&quot;</span>, dst_and);</span><br><span class="line">    cv::<span class="built_in">bitwise_or</span>(m1, m2, dst_or);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;or&quot;</span>, dst_or);</span><br><span class="line">    cv::<span class="built_in">bitwise_not</span>(m1, dst_not);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;not&quot;</span>, dst_not);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>鼠标操作，在图像上绘制矩形，并且把矩形内的图像展示出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Point <span class="title">sp</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">cv::Point <span class="title">ep</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">cv::Mat temp;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_draw</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span> *userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat image = *((cv::Mat *)userdata);</span><br><span class="line">    <span class="keyword">if</span> (event == cv::EVENT_LBUTTONDOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        sp.x = x;</span><br><span class="line">        sp.y = y;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;start point&quot;</span> &lt;&lt; sp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event == cv::EVENT_LBUTTONUP)</span><br><span class="line">    &#123;</span><br><span class="line">        ep.x = x;</span><br><span class="line">        ep.y = y;</span><br><span class="line">        <span class="type">int</span> dx = ep.x - sp.x;</span><br><span class="line">        <span class="type">int</span> dy = ep.y - sp.y;</span><br><span class="line">        <span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::<span class="built_in">rectangle</span>(image, cv::<span class="built_in">Rect</span>(sp.x, sp.y, dx, dy), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, cv::LINE_8, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// temp = image.clone();</span></span><br><span class="line">        &#125;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;mouse&quot;</span>, image);</span><br><span class="line">        sp.x = <span class="number">-1</span>;</span><br><span class="line">        sp.y = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event == cv::EVENT_MOUSEMOVE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp.x &gt; <span class="number">0</span> &amp;&amp; sp.y &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ep.x = x;</span><br><span class="line">            ep.y = y;</span><br><span class="line">            <span class="type">int</span> dx = ep.x - sp.x;</span><br><span class="line">            <span class="type">int</span> dy = ep.y - sp.y;</span><br><span class="line">            <span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.<span class="built_in">copyTo</span>(image);</span><br><span class="line">                cv::<span class="built_in">rectangle</span>(image, cv::<span class="built_in">Rect</span>(sp.x, sp.y, dx, dy), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, cv::LINE_8, <span class="number">0</span>);</span><br><span class="line">                cv::<span class="built_in">imshow</span>(<span class="string">&quot;mouse&quot;</span>, image);</span><br><span class="line">                temp.<span class="built_in">copyTo</span>(image);</span><br><span class="line">                cv::<span class="built_in">imshow</span>(<span class="string">&quot;ROI&quot;</span>, <span class="built_in">image</span>(cv::<span class="built_in">Rect</span>(sp.x, sp.y, dx, dy)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像归一化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">norm_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    image.<span class="built_in">convertTo</span>(image, CV_32F);                     <span class="comment">// 变为float类型</span></span><br><span class="line">    std::cout &lt;&lt; image.<span class="built_in">type</span>() &lt;&lt; std::endl;             <span class="comment">// CV_8UC3 ：16</span></span><br><span class="line">    cv::<span class="built_in">normalize</span>(image, dst, <span class="number">1.0</span>, <span class="number">0</span>, cv::NORM_MINMAX); <span class="comment">// 把图像用最大最小值来归一化</span></span><br><span class="line">    std::cout &lt;&lt; dst.<span class="built_in">type</span>() &lt;&lt; std::endl;               <span class="comment">// CV_32F : 21</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;normalize&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像缩放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat zoomin, zoomout;</span><br><span class="line">    <span class="type">int</span> h = image.rows;</span><br><span class="line">    <span class="type">int</span> w = image.cols;</span><br><span class="line">    cv::<span class="built_in">resize</span>(image, zoomin, cv::<span class="built_in">Size</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);</span><br><span class="line">    cv::<span class="built_in">resize</span>(image, zoomout, cv::<span class="built_in">Size</span>(w * <span class="number">2</span>, h * <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;min&quot;</span>, zoomout);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;mout&quot;</span>, zoomout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>图像的翻转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    <span class="comment">// cv::flip(image, dst, 0); // 上下翻转</span></span><br><span class="line">    <span class="comment">// cv::flip(image, dst, 1); // 左右翻转</span></span><br><span class="line">    cv::<span class="built_in">flip</span>(image, dst, <span class="number">-1</span>); <span class="comment">// 对角线翻转</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;0&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像的插值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_demo</span><span class="params">(cv::Mat &amp;image)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像的旋转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst, M;</span><br><span class="line">    <span class="type">int</span> h = image.rows;</span><br><span class="line">    <span class="type">int</span> w = image.cols;</span><br><span class="line">    M = cv::<span class="built_in">getRotationMatrix2D</span>(cv::<span class="built_in">Point2f</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">60</span>, <span class="number">1.0</span>); <span class="comment">// 根据旋转角度获得旋转矩阵</span></span><br><span class="line">    <span class="type">double</span> cos = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="type">double</span> sin = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> neww = cos * w + sin * h;</span><br><span class="line">    <span class="type">int</span> newh = sin * w + cos * h;</span><br><span class="line">    M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) = M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) + (neww / <span class="number">2</span> - w / <span class="number">2</span>);</span><br><span class="line">    M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) = M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) + (newh / <span class="number">2</span> - h / <span class="number">2</span>);</span><br><span class="line">    cv::<span class="built_in">warpAffine</span>(image, dst, M, cv::<span class="built_in">Size</span>(neww, newh), cv::INTER_LINEAR, <span class="number">0</span>, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>)); <span class="comment">// 旋转图像，并且决定旋转后图像的底色</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;rotation&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>视频读取和处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">video_demo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">capture</span><span class="params">(<span class="string">&quot;../image/empty.mp4&quot;</span>)</span></span>;            <span class="comment">// 捕获视频文件，0表示读取摄像头数据，可以是视频文件地址</span></span><br><span class="line">    <span class="type">int</span> frame_width = capture.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_WIDTH);   <span class="comment">// 视频的宽度</span></span><br><span class="line">    <span class="type">int</span> frame_height = capture.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_HEIGHT); <span class="comment">// 视频的高度</span></span><br><span class="line">    <span class="type">int</span> count = capture.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_COUNT);         <span class="comment">// 视频的帧数</span></span><br><span class="line">    <span class="type">double</span> fps = capture.<span class="built_in">get</span>(cv::CAP_PROP_FPS);                <span class="comment">// 视频的fps</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;width     &quot;</span> &lt;&lt; frame_width &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;height     &quot;</span> &lt;&lt; frame_height &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;count     &quot;</span> &lt;&lt; count &lt;&lt; std::endl; <span class="comment">// 读取摄像头数据时，count为-1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fps     &quot;</span> &lt;&lt; fps &lt;&lt; std::endl;</span><br><span class="line">    cv::Mat frame;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        capture.<span class="built_in">read</span>(frame); <span class="comment">// 将视频文件的图片读入frame中，可以对每一帧视频处理</span></span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;frame&quot;</span>, frame);</span><br><span class="line">        <span class="built_in">operate</span>(frame, <span class="string">&quot;HSV&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> c = cv::<span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">cv::VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;../image/1.mp4&quot;</span>, capture.get(cv::CAP_PROP_FOURCC), fps, cv::Size(frame_width, frame_height), <span class="literal">true</span>)</span></span>;</span><br><span class="line">    capture.<span class="built_in">release</span>();</span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三通道直方图，三个通道分别的直方图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showHistogram</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 三通道分离</span></span><br><span class="line">    std::vector&lt;cv::Mat&gt; bgr_plane;</span><br><span class="line">    cv::<span class="built_in">split</span>(image, bgr_plane);</span><br><span class="line">    <span class="comment">// 定义参数变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channels[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bins[<span class="number">1</span>] = &#123;<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="type">float</span> hranges[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">255</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> *ranges[<span class="number">1</span>] = &#123;hranges&#125;;</span><br><span class="line">    cv::Mat b_hist; <span class="comment">// 结果</span></span><br><span class="line">    cv::Mat g_hist;</span><br><span class="line">    cv::Mat r_hist;</span><br><span class="line">    <span class="comment">// 计算机三个通道的直方图</span></span><br><span class="line">    cv::<span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>, cv::<span class="built_in">Mat</span>(), b_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line">    cv::<span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>, cv::<span class="built_in">Mat</span>(), g_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line">    cv::<span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">2</span>], <span class="number">1</span>, <span class="number">0</span>, cv::<span class="built_in">Mat</span>(), r_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line">    <span class="type">int</span> hist_w = <span class="number">512</span>;</span><br><span class="line">    <span class="type">int</span> hist_h = <span class="number">400</span>;</span><br><span class="line">    <span class="type">int</span> bin_w = <span class="built_in">cvRound</span>((<span class="type">double</span>)hist_w / bins[<span class="number">0</span>]);</span><br><span class="line">    cv::Mat histImage = cv::Mat::<span class="built_in">zeros</span>(hist_h, hist_w, CV_8UC3);</span><br><span class="line">    <span class="comment">// 归一化直方图数据</span></span><br><span class="line">    cv::<span class="built_in">normalize</span>(b_hist, b_hist, <span class="number">0</span>, histImage.rows, cv::NORM_MINMAX, <span class="number">-1</span>, cv::<span class="built_in">Mat</span>());</span><br><span class="line">    cv::<span class="built_in">normalize</span>(g_hist, g_hist, <span class="number">0</span>, histImage.rows, cv::NORM_MINMAX, <span class="number">-1</span>, cv::<span class="built_in">Mat</span>());</span><br><span class="line">    cv::<span class="built_in">normalize</span>(r_hist, r_hist, <span class="number">0</span>, histImage.rows, cv::NORM_MINMAX, <span class="number">-1</span>, cv::<span class="built_in">Mat</span>());</span><br><span class="line">    <span class="comment">// 绘制直方图曲线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bins[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">line</span>(histImage, cv::<span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">             cv::<span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, cv::LINE_AA, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">line</span>(histImage, cv::<span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">             cv::<span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, cv::LINE_AA, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">line</span>(histImage, cv::<span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">             cv::<span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, cv::LINE_AA, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;HISTOGRAM&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;HISTOGRAM&quot;</span>, histImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>灰度图像的像素直方图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_gray_histogram</span><span class="params">(cv::Mat image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channels[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bins[<span class="number">1</span>] = &#123;<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="type">float</span> hranges[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">255</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> *ranges[<span class="number">1</span>] = &#123;hranges&#125;;</span><br><span class="line">    cv::Mat gray_hist; <span class="comment">// 结果</span></span><br><span class="line">    cv::<span class="built_in">calcHist</span>(&amp;image, <span class="number">1</span>, <span class="number">0</span>, cv::<span class="built_in">Mat</span>(), gray_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line">    <span class="type">int</span> hist_w = <span class="number">512</span>;</span><br><span class="line">    <span class="type">int</span> hist_h = <span class="number">400</span>;</span><br><span class="line">    <span class="type">int</span> bin_w = <span class="built_in">cvRound</span>((<span class="type">double</span>)hist_w / bins[<span class="number">0</span>]);</span><br><span class="line">    cv::Mat grayImage = cv::Mat::<span class="built_in">zeros</span>(hist_h, hist_w, CV_8UC3);</span><br><span class="line">    cv::<span class="built_in">normalize</span>(gray_hist, gray_hist, <span class="number">0</span>, grayImage.rows, cv::NORM_MINMAX, <span class="number">-1</span>, cv::<span class="built_in">Mat</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bins[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">line</span>(grayImage, cv::<span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(gray_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">             cv::<span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(gray_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>, cv::LINE_AA, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;HISTOGRAM&quot;</span>, grayImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像的二维直方图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_2D_Histogram</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat hsv, hs_hist;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, hsv, cv::COLOR_BGR2HSV);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;HSV&quot;</span>, hsv);</span><br><span class="line">    <span class="type">int</span> hbins = <span class="number">30</span>, sbins = <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> hist_bins[] = &#123;hbins, sbins&#125;;</span><br><span class="line">    <span class="type">float</span> h_range[] = &#123;<span class="number">0</span>, <span class="number">180</span>&#125;;</span><br><span class="line">    <span class="type">float</span> s_range[] = &#123;<span class="number">0</span>, <span class="number">256</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> *hs_ranges[] = &#123;h_range, s_range&#125;;</span><br><span class="line">    <span class="type">int</span> hs_channels[] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cv::<span class="built_in">calcHist</span>(&amp;hsv, <span class="number">1</span>, hs_channels, cv::<span class="built_in">Mat</span>(), hs_hist, <span class="number">2</span>, hist_bins, hs_ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">double</span> maxVal = <span class="number">0</span>;</span><br><span class="line">    cv::<span class="built_in">minMaxLoc</span>(hs_hist, <span class="number">0</span>, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> scale = <span class="number">10</span>;</span><br><span class="line">    cv::Mat hist2d_image = cv::Mat::<span class="built_in">zeros</span>(sbins * scale, hbins * scale, CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; hbins; h++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; sbins; s++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> binVal = hs_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(h, s);</span><br><span class="line">            <span class="type">int</span> intensity = <span class="built_in">cvRound</span>(binVal * <span class="number">255</span> / maxVal);</span><br><span class="line">            cv::<span class="built_in">rectangle</span>(hist2d_image, cv::<span class="built_in">Point</span>(h * scale, s * scale),</span><br><span class="line">                          cv::<span class="built_in">Point</span>((h + <span class="number">1</span>) * scale - <span class="number">1</span>, (s + <span class="number">1</span>) * scale - <span class="number">1</span>), cv::Scalar::<span class="built_in">all</span>(intensity), <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;H_S image&quot;</span>, hist2d_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像的均衡化，并且输出图像的直方图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">histogram_eq</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat gray, dst;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, gray, cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::<span class="built_in">equalizeHist</span>(gray, dst);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;gray&quot;</span>, gray);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;equ&quot;</span>, dst);</span><br><span class="line">    <span class="built_in">show_gray_histogram</span>(gray);</span><br><span class="line">    <span class="built_in">show_gray_histogram</span>(dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像卷积，均值滤波</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">blur_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::<span class="built_in">blur</span>(image, dst, cv::<span class="built_in">Size</span>(<span class="number">15</span>, <span class="number">15</span>), cv::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Blur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高斯模糊，高斯滤波</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gaussian_Blur</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::<span class="built_in">GaussianBlur</span>(image, dst, cv::<span class="built_in">Size</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="number">15</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;GaussianBlur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高斯双边模糊，就是对图像的某些特点隐藏，某些特点不隐藏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bifilter_demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::<span class="built_in">bilateralFilter</span>(image, dst, <span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;bifilter&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现图片的自动打码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Mosaic</span><span class="params">(cv::Mat image, std::vector&lt;cv::Rect&gt; &amp;area)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (area.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未读取到区域 &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">10</span>;</span><br><span class="line">    cv::Mat dst = image;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; area.<span class="built_in">size</span>(); t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = area[t].<span class="built_in">tl</span>().x;</span><br><span class="line">        <span class="type">int</span> y = area[t].<span class="built_in">tl</span>().y;</span><br><span class="line">        <span class="type">int</span> width = area[t].width;</span><br><span class="line">        <span class="type">int</span> height = area[t].height;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; y &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; width &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; height &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = y; i &lt; y + height; i += step)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = x; j &lt; x + width; j += step)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> m = i; m &lt; step + i; m++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> n = j; n &lt; step + j; n++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            dst.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(m, n)[c] = image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[c];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cv::imshow(&quot;MOSAIC&quot;, dst);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>马赛克的测试函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMosaic</span><span class="params">(cv::Mat image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;cv::Rect&gt; face;</span><br><span class="line">    face.<span class="built_in">push_back</span>(cv::<span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;未读取到区域 &quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// face.push_back(cv::Rect(300, 300, 200, 200));</span></span><br><span class="line">    <span class="built_in">Mosaic</span>(image, face);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动人脸目标检测</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">areademo</span><span class="params">(cv::Mat image)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     std::string file = <span class="string">&quot;../haarcascade_frontalface_default.xml&quot;</span>;</span><br><span class="line">     <span class="comment">// 创建人脸检测</span></span><br><span class="line">     cv::CascadeClassifier object;</span><br><span class="line">     object.<span class="built_in">load</span>(file);</span><br><span class="line">     std::vector&lt;cv::Rect&gt; face;</span><br><span class="line">     object.<span class="built_in">detectMultiScale</span>(image, face, <span class="number">1.1</span>, <span class="number">5</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">area_retangle</span>(image, face))</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// cv::imshow(&quot;face_mosaic&quot;, image);</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>在指定的区域画框</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">area_retangle</span><span class="params">(cv::Mat image, std::vector&lt;cv::Rect&gt; &amp;area)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (area.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未读取到区域 &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; area.<span class="built_in">size</span>(); t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1 = area[t].<span class="built_in">tl</span>().x;</span><br><span class="line">        <span class="type">int</span> y1 = area[t].<span class="built_in">tl</span>().y;</span><br><span class="line">        <span class="type">int</span> width = area[t].width;</span><br><span class="line">        <span class="type">int</span> height = area[t].height;</span><br><span class="line">        <span class="type">int</span> x2 = x1 + width;</span><br><span class="line">        <span class="type">int</span> y2 = y1 + width;</span><br><span class="line">        cv::<span class="built_in">rectangle</span>(image, cv::<span class="built_in">Rect</span>(x1, y1, width, height), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, cv::LINE_8, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;face&quot;</span>, image);</span><br><span class="line">    <span class="comment">// while (cv::waitKey(0) != 27)</span></span><br><span class="line">    <span class="comment">// ;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>颜色风格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorMap_Demo</span><span class="params">(cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> colorMap[] = &#123;</span><br><span class="line">        cv::COLORMAP_AUTUMN,</span><br><span class="line">        cv::COLORMAP_BONE,</span><br><span class="line">        cv::COLORMAP_JET,</span><br><span class="line">        cv::COLORMAP_WINTER,</span><br><span class="line">        cv::COLORMAP_RAINBOW,</span><br><span class="line">        cv::COLORMAP_OCEAN,</span><br><span class="line">        cv::COLORMAP_SUMMER,</span><br><span class="line">        cv::COLORMAP_SPRING,</span><br><span class="line">        cv::COLORMAP_COOL,</span><br><span class="line">        cv::COLORMAP_HSV,</span><br><span class="line">        cv::COLORMAP_PINK,</span><br><span class="line">        cv::COLORMAP_HOT,</span><br><span class="line">        cv::COLORMAP_PARULA,</span><br><span class="line">        cv::COLORMAP_MAGMA,</span><br><span class="line">        cv::COLORMAP_INFERNO,</span><br><span class="line">        cv::COLORMAP_PLASMA,</span><br><span class="line">        cv::COLORMAP_VIRIDIS,</span><br><span class="line">        cv::COLORMAP_CIVIDIS,</span><br><span class="line">        cv::COLORMAP_TWILIGHT,</span><br><span class="line">        cv::COLORMAP_TWILIGHT_SHIFTED,</span><br><span class="line">        cv::COLORMAP_TURBO,</span><br><span class="line">        cv::COLORMAP_DEEPGREEN&#125;;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> c = cv::<span class="built_in">waitKey</span>(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cv::<span class="built_in">applyColorMap</span>(image, dst, colorMap[index % <span class="number">21</span>]);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;style&quot;</span>, dst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础</title>
      <link href="/Blog_ButterFly/2024/03/23/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/Blog_ButterFly/2024/03/23/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>用于对 C 语言代码进行编写，一般来说使用的是 <code>vscode</code> 或者是 <code>vs</code> ， <code>devc++</code> 之类的，还有在终端上可以直接使用的 <code>vim</code> 之类的编辑器。编辑器的类型无关紧要，主要是用于编写 C 语言代码</p><h3 id="编译器-1"><a href="#编译器-1" class="headerlink" title="编译器"></a>编译器</h3><p>各种编程语言写完之后都不可能直接运行，而是需要编译器来把代码编译成电脑能识别的语言——机器语言，是二进制语言，只有 0 和 1 组成。所以编译的过程相当于是翻译，把 C 代码给翻译成机器代码了。</p><p>最常用的就是 GNU 的 C/C++编译器，mingw 中实际上就是 GNU 的编译器</p><p>在 GNU 中的编译指令为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -o b.exe <span class="comment">// windows为.exe后缀</span></span><br><span class="line">gcc a.c -o b.out <span class="comment">// linux为.out后缀</span></span><br></pre></td></tr></table></figure><h2 id="C语言程序结构"><a href="#C语言程序结构" class="headerlink" title="C语言程序结构"></a>C语言程序结构</h2><p>C程序主要包括下列指令</p><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>就是文件上部以 <code>#</code> 开头的指令，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>预处理指令会在预编译的时候就把对应文件中的代码复制过来，预编译指令为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o b.i</span><br></pre></td></tr></table></figure><p>之后打开 <code>b.i</code> 文件将会看到文件中不仅有 <code>a.c</code> 中的内容，也有 <code>stdio.h</code> 中的内容</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 <code>main()</code> ，所有简单的程序都可以定义其他额外的函数。可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由自己决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。函数是需要声明的，函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>就是在函数中或者全局声明的用于存储数据的东西。声明在函数外的是全局变量，而声明在函数内的是局部变量。还有一种静态变量，变量的寿命是整个程序，只有程序结束之后才会释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">// 全局</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>; <span class="comment">// 局部</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>; <span class="comment">// 静态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>在 C 语言中有多种语句，可以分为不同的类型</p><ul><li><p>表达式语句，由表达式加上分号组成</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>标签语句，用于 <code>goto</code> 语句，允许程序跳转到标签指定的位置，只能在函数内部使用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">end:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环语句，包括 <code>while</code> ， <code>for</code> ， <code>do-while</code> 等</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(Conditions) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(; Conditions; ) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">&#125;<span class="keyword">while</span>(Conditions);</span><br></pre></td></tr></table></figure></li><li><p>复合语句，用花括号括起来的多条语句，函数定义或者 <code>if-else</code> 语句块</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>跳转语句，如 <code>break</code> ， <code>continue</code> ， <code>return</code> 等，用于控制程序的流程</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择语句，如 <code>switch</code> 语句，根据不同条件执行不同的代码块</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(condition) &#123;</span><br><span class="line"><span class="keyword">case</span> condition1:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;condition1&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> condtion2:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;condition2&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数调用语句，由函数调用加上分号组成</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func();</span><br></pre></td></tr></table></figure></li><li><p>空语句，仅由分号组成</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>位数</th><th>字节数</th><th>解释</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>1</td><td>有符号字符</td></tr><tr><td>unsigned char</td><td>8</td><td>1</td><td>无符号字符</td></tr><tr><td>short</td><td>16</td><td>2</td><td>短整型</td></tr><tr><td>unsigned short</td><td>16</td><td>2</td><td>无符号短整型</td></tr><tr><td>int</td><td>32</td><td>4</td><td>整形</td></tr><tr><td>unsigned int</td><td>32</td><td>4</td><td>无符号整形</td></tr><tr><td>float</td><td>32</td><td>4</td><td>单精度浮点数</td></tr><tr><td>long</td><td>64</td><td>8</td><td>长整型</td></tr><tr><td>unsigned long</td><td>64</td><td>8</td><td>无符号长整型</td></tr><tr><td>double</td><td>64</td><td>8</td><td>双精度浮点数</td></tr></tbody></table></div><p>还有一些特殊的类型 <code>void</code> 的类型，表示没有可用的值，并且函数的返回值有些也是 <code>void</code> 的类型，也就是返回值为空。不同位数的CPU上同一种数据类型大小也不一样，例如在 8 位CPU上的 int 类型就是 8 位，32 位CPU上 int 类型就是 32</p><p>位，但是 64 位CPU上 int 类型是 32 位是沿用的 32 位CPU上的设定</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型在不同位数的 CPU 上是不同的</p><div class="table-container"><table><thead><tr><th>CPU位数</th><th>指针大小 byte</th></tr></thead><tbody><tr><td>8</td><td>1</td></tr><tr><td>16</td><td>2</td></tr><tr><td>32</td><td>4</td></tr><tr><td>64</td><td>8</td></tr></tbody></table></div><p>指针是指向了一块内存，内存中存放的就是一个变量（或者其他东西）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">void</span> (*a)() = func;</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是固定值，在程序执行期间<strong>不会改变</strong>。这些固定的值，又叫做字面量。常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。常量就像是常规的变量，只不过常量的值在定义后不能进行修改。常量可以直接在代码中使用，也可以通过定义常量来使用。除了立即数之外，还有 <code>const</code> 类型修饰的变量都是常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的定义一般都需要给定大小，要么直接是给定值，要么给定大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]; <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> a[]; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure><p>而且定义数组的时候数组的大小必须是一个常量值，也就是不可改变的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[size]; <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[size]; <span class="comment">// √</span></span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>C语言中的一种用于存储不同类型数据项的变量，相当于一个大包裹，里面有多种自己定义的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="type">float</span> x;</span><br><span class="line"><span class="type">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> <span class="title">complex</span> =</span> &#123;</span><br><span class="line">.x = <span class="number">1</span>,</span><br><span class="line">.y = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> <span class="title">complex1</span> =</span> &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> <span class="title">complex2</span>;</span></span><br><span class="line">complex2.x = <span class="number">1</span>;</span><br><span class="line">complex2.y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体内存分配原则</p><ul><li>原则一：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始</li><li>原则二： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍</li></ul><p>对于结构体中会分配很多实际上用不到的内存，所以可以在项目中使用 <code>#pragma pack(n)</code> 的宏定义来使得结构体能够分配正好大小的内存（其中 n 是自定义的一个数字，表示程序中分配内存对齐方式），但是这样写会导致程序运行效率下降，为了避免内存被不充分的使用，所以在定义结构体时尽量的使小的数据类型在前面。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。定义一个枚举类型，需要使用 <strong>enum</strong> 关键字，后面跟着枚举类型的名称，以及用大括号 <strong>{}</strong> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 <strong>0</strong> 开始递增。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span> &#123;</span></span><br><span class="line">Monday = <span class="number">1</span>,</span><br><span class="line">Tuesday,</span><br><span class="line">Wednesday,</span><br><span class="line">Thursday,</span><br><span class="line">Friday,</span><br><span class="line">Saturday,</span><br><span class="line">Sunday</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>顾名思义，就是一个内部所有变量都使用同一块内存的数据，并且以内存最大的数据的大小来作为它的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">&#125;; <span class="comment">// size: 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> i[<span class="number">10</span>];</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">&#125;; <span class="comment">// size: 40</span></span><br></pre></td></tr></table></figure><p>在内存中的存储方式是这样的</p><p><img src="/Blog_ButterFly/2024/03/23/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/20200919203628581.png" alt="20200919203628581.png"></p><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>C/C++ 语言的位域是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数，而整个结构体的大小也是与其中成员所占的大小有关的。整个位域相当于是占用着原来大小的空间，只使用其中的几位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">10</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以定义某几位使用，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> : <span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域也遵循结构体内存分配原则，但是在位域内部元素类型一致时，如果所占用的位数少于元素类型时，位域所占的内存的大小只有一个元素类型的大小。所以在位域的使用中，各个成员的类型最好保持一致，以此来达到节省内存空间的目的</p><p>在位域的使用中要时刻注意其中元素的有效位，有效位是从第一个元素开始，从低位到高位（大端模式的话是从高位到低位）依次分配有效位。例如，对于上述 <code>struct A</code> 中 <code>a</code> 的有效位是 <code>0~9</code> ，而 <code>b</code> 的有效位是 <code>10~19</code> ，而最终位域的输出就是由这些有效位组成的。</p><h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><p>C 语言中可以定义数据的存储类型，这个存储类型决定了该变量/函数的存储位置，生命周期和作用域，这些说明符放在它们的修饰类型之前</p><h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>是所有局部变量默认的存储类，定义在函数中的变量默认为 <code>auto</code> 存储类，这意味着它们将在函数开始时被创建，在函数结束时销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p>用于定义存储在寄存器中而不是 RAM 中的局部变量，这就意味着变量的最大尺寸等于寄存器的大小，并且不能对它取地址（没有内存地址）。但是这种类型的数据访问速度更快。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><h3 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h3><p>存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。具有以下特点</p><ul><li>使用 <code>static</code> 修饰局部变量可以在函数调用之间保持局部变量的值</li><li><code>static</code> 修饰符也可以应用于全局变量。当 <code>static</code> 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中</li><li>静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">a++;</span><br><span class="line">b++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, b, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">func();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h3><p>用于定义在其它文件中声明的全局变量或者函数， <code>extern</code> 关键字意味着所修饰的变量并没有分配内存，而是在项目的其它文件中已经分配内存，这时候编译器就会自己去找所定义的那个变量。如果没找到就会报错。</p><h2 id="C语言宏定义"><a href="#C语言宏定义" class="headerlink" title="C语言宏定义"></a>C语言宏定义</h2><h3 id="define"><a href="#define" class="headerlink" title="#define"></a><code>#define</code></h3><p>定义宏，在预编译处理之后，相当于把代码中涉及到定义的部分直接替换为所定义的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> abs(x) ((x) &gt; 0) ? (x) : -(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> b = a; <span class="comment">// b = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="include"><a href="#include" class="headerlink" title="#include"></a><code>#include</code></h3><p>包含一个源代码文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="undef"><a href="#undef" class="headerlink" title="#undef"></a><code>#undef</code></h3><p>取消已定义的宏，不仅仅是取消已经定义的宏定义，甚至定义的一些数据类型都能够取消定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a 1</span></span><br><span class="line"><span class="type">int</span> b = a;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> a</span></span><br><span class="line"><span class="type">int</span> c = a; <span class="comment">// 报错，未定义a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ifdef"><a href="#ifdef" class="headerlink" title="#ifdef"></a><code>#ifdef</code></h3><p>如果宏已经定义，为真，会运行与 <code>#else</code> 或 <code>#elif</code> 或 <code>#endif</code> 之间的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> A</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a><code>#ifndef</code></h3><p>与上述的 <code>#ifdef</code> 正好相反，如果宏未定义，为真</p><h3 id="if"><a href="#if" class="headerlink" title="#if"></a><code>#if</code></h3><p>与 <code>if</code> 判断语句一致，但是可以应用到函数之外</p><h3 id="else"><a href="#else" class="headerlink" title="#else"></a><code>#else</code></h3><p>相当于 <code>else</code></p><h3 id="elif"><a href="#elif" class="headerlink" title="#elif"></a><code>#elif</code></h3><p>相当于 <code>else if</code></p><h3 id="endif"><a href="#endif" class="headerlink" title="#endif"></a><code>#endif</code></h3><p>结束一个判断宏定义的标志，而且使用 <code>#if</code> ， <code>#ifdef</code> ， <code>#ifndef</code> 都需要调用这个</p><h3 id="error"><a href="#error" class="headerlink" title="#error"></a><code>#error</code></h3><p>作用是编译程序时，只要遇到 <code>#error</code> 就会生成一个编译错误提示消息，并停止编译</p><h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a><code>#pragma</code></h3><p>使用标准化方法，向编译器发布特殊的命令到编译器中，比较常用的两个</p><ul><li><code>#pragma pack(n)</code> 表示项目中以 <code>n</code> 个字节对齐的方式存储</li><li><code>#pragma once</code> 表示该文件只编译一次</li></ul><h2 id="C语言内存分配"><a href="#C语言内存分配" class="headerlink" title="C语言内存分配"></a>C语言内存分配</h2><h3 id="void-malloc-size-t-size"><a href="#void-malloc-size-t-size" class="headerlink" title="void *malloc(size_t size)"></a><code>void *malloc(size_t size)</code></h3><p>分配指定大小的内存，并且返回一个 <code>void</code> 指针，如果 <code>size</code> 为0，那就返回一个 <code>NULL</code> ，或者返回一个可以之后被 <code>free</code> 释放掉的指针</p><h3 id="void-free-void-ptr"><a href="#void-free-void-ptr" class="headerlink" title="void free(void* ptr)"></a><code>void free(void* ptr)</code></h3><p>释放内存，如果这个指针是通过 <code>malloc，realloc，calloc</code> 创建出来的就可以成功的释放掉，如果在之前已经调用过 <code>free()</code> 函数释放掉内存了，就会出现 <code>undefined behavior</code> 错误，如果指针是空的，不会做任何事</p><h3 id="void-calloc-size-t-nmemb-size-t-size"><a href="#void-calloc-size-t-nmemb-size-t-size" class="headerlink" title="void *calloc(size_t nmemb, size_t size)"></a><code>void *calloc(size_t nmemb, size_t size)</code></h3><p>为 <code>nmemb</code> 大小的元素申请一组内存并且返回内存指针，并且内存已经初始化为0，如果 <code>nmemb</code> 大小为 0，要么返回一个空指针，要么返回一个可以被 <code>free</code> 掉的指针，如果 <code>nmemb * size</code> 整数溢出，将会返回 <code>error</code> ，相比之下， <code>malloc</code>将不会发现整数溢出，结果就是一个不正确的内存将会被分配</p><h3 id="void-realloc-void-ptr-size-t-size"><a href="#void-realloc-void-ptr-size-t-size" class="headerlink" title="void *realloc(void *ptr, size_t size)"></a><code>void *realloc(void *ptr, size_t size)</code></h3><p>改变已经分配的内存大小为 <code>size</code> ，而且 <code>old memory</code> 中的内容将会被拷贝到新的内存中，不论两个内存大小如何，都只复制最小的那一块内存。如果新的内存更大，额外的内存将不会被初始化，如果 <code>ptr</code> 是空指针，函数会和 <code>malloc</code> 一致，如果 <code>size=0</code> ，这个函数将会与free一致，除非 <code>ptr</code> 为空指针，否则必须是由 <code>malloc, calloc, realloc</code> 生成的指针，如果指针指向的区域被移动了，指针将会被释放掉</p><h3 id="void-reallocarray-void-ptr-size-t-nmemb-size-t-size"><a href="#void-reallocarray-void-ptr-size-t-nmemb-size-t-size" class="headerlink" title="void *reallocarray(void *ptr, size_t nmemb, size_t size)"></a><code>void *reallocarray(void *ptr, size_t nmemb, size_t size)</code></h3><p>与 <code>calloc</code> 很像，可以重新为指针分配一块 <code>nmemb * size</code> 大小的内存，这个对于整数溢出也是安全的</p><h2 id="typedef-关键字"><a href="#typedef-关键字" class="headerlink" title="typedef 关键字"></a>typedef 关键字</h2><p>相当于是别名，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line">uint a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125; A;</span><br></pre></td></tr></table></figure><h3 id="typedef-与-define"><a href="#typedef-与-define" class="headerlink" title="typedef 与 #define"></a><code>typedef</code> 与 <code>#define</code></h3><ul><li><code>typedef</code> 仅限于为类型定义符号名称， <code>#define</code> 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 <code>ONE</code>。</li><li><code>typedef</code> 是由编译器执行解释的， <code>#define</code> 语句是由预编译器进行处理的</li></ul><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>C 语言中可以定义可变参数的函数，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> argc, ...)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中，最后一个参数写为省略号，并且省略号之前的那个参数是  <code>int</code> 类型，代表将要传递的可变参数的总数。这个功能位于 <code>stdarg.h</code> 头文件中，该文件提供了实现可变参数功能的函数和宏，具体步骤</p><ul><li>定义一个函数，最后一个参数为省略号，省略号前可以设置自定义函数</li><li>在函数中创建一个 <code>va_list</code> 变量，该类型是在 <code>stdarg.h</code> 头文件中定义的</li><li>使用 <code>int</code> 参数和 <code>va_start()</code> 宏来初始化 <code>va_list</code> 变量为一个参数列表，宏 <code>va_start()</code> 是在 <code>stdarg.h</code> 中定义的</li><li>使用 <code>va_arg()</code> 宏和 <code>va_list</code> 变量来访问参数列表中的每一项</li><li>使用宏 <code>va_end()</code> 来清理赋予 <code>va_list</code> 变量的内存</li></ul><h3 id="比较常用的宏"><a href="#比较常用的宏" class="headerlink" title="比较常用的宏"></a>比较常用的宏</h3><ul><li><p><code>void va_start(va_list ap, last)</code></p><p>  该函数对于后续使用 <code>va_arg()</code> 和 <code>va_end()</code> 函数有着重要关系，这个函数必须首先被调用，参数last是变量参数列表之前的最后一个参数的名称，也就是说，调用函数需要知道其类型的最后一个参数。</p></li><li><p>因为参数的地址也许会在 <code>va_start()</code> 宏中被使用，它不应该被声明为寄存器变量，或者作为一个方法或者是一个数组类型</p></li><li><p><code>type va_arg(va_list ap, type)</code></p><p>  <code>va_arg</code> 宏定义扩大为一个在调用中有着类型和数据的表达式，这个参数  <code>ap</code> 是被 <code>va_start</code> 初始化过的参数，每次调用 <code>va_arg</code> 修改 <code>ap</code> ，导致下一次调用返回下一个参数。参数type是指定的类型名，因此只需在 <code>type</code> 后面加上 <code>*</code> ，就可以获得指向具有指定类型的对象的指针的类型。</p><p>  在 <code>va_start()</code> 宏之后第一次使用该函数返回最后一个参数的后面一个参数，成功的调用函数返回参数保留的数据</p><p>  如果没有下一个参数了，或者如果类型与当前的下一个参数类型不兼容（根据默认参数增加）会产生随机的错误</p><p>  如果 <code>ap</code> 被传递给使用 <code>va_arg(ap,type)</code> 的函数，则在该函数返回后， <code>ap</code> 是未定义的。</p></li><li><p><code>void va_end(va_list ap)</code></p><p>  每一次调用 <code>va_start</code> 必须通过一个正确的调用 <code>va_end</code> 来与之相匹配在相同的函数中。调用 <code>va_end(ap)</code> 之后变量 <code>ap</code> 将会是未定义的。对于多次遍历，可以只调用一次 <code>va_start</code> 和 <code>va_end</code></p></li><li><p><code>void va_copy(va_list dest, va_list src)</code></p><p>  函数从 <code>src</code> 处复制可变参数列表到 <code>dest</code> 中，这个行为就像是调用了 <code>va_start(dest)</code> 并且利用相同的参数列表，并且与 <code>src</code> 有着相同的调用次数，与 <code>src</code> 到达相同的状态。</p><p>  一个很明显的实现是将 <code>va_list</code> 作为一个指向可变参数的堆栈帧的一个指针。</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>求解多个数的平均数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> num, ...)</span> &#123;</span><br><span class="line">va_list valist;</span><br><span class="line"><span class="type">float</span> sum = <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">va_start(valist, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">sum += va_arg(valist, <span class="type">float</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum / num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>在 C 语言中， <code>main</code> 函数一般的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">const</span> <span class="type">char</span>* enp)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第三个参数一般用不到，而且不需要用户自己去输入，是程序运行时使用的环境变量。第一个参数和第二个参数都是命令行输入参数，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, argv[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在命令行中运行这个程序时输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// windows 中 编译默认输出文件名为 a.exe</span></span><br><span class="line">./a.exe test1 test2</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">./a.exe text1 test2</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux 中 编译默认输出文件名为 a.out</span></span><br><span class="line">./a.out test1 test2</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">./a.out text1 test2</span><br></pre></td></tr></table></figure><p>可见输入的参数数目是包括程序运行的程序名称的</p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>在 C 语言的运算中，数据类型不同的话会进行自动的类型转换，转换的方向如图</p><p><img src="/Blog_ButterFly/2024/03/23/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/usual_arithmetic_conversion.png" alt="usual_arithmetic_conversion.png"></p><p>一般是由低到高转换的</p><p>但是在赋值操作和强制类型转换时可以不符合这样的方向，但是会造成一些精度上的丢失，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line"><span class="type">float</span> b = a; <span class="comment">// 有些编译器会报警告(vs)，截断导致精度丢失</span></span><br><span class="line"><span class="type">int</span> c = b; <span class="comment">// 截断导致精度丢失</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d = (<span class="type">int</span>) a; <span class="comment">// 不会报警告，但是精度丢失</span></span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件打开"><a href="#文件打开" class="headerlink" title="文件打开"></a>文件打开</h3><p><code>FILE *fopen(const char *filename, const char *mode);</code></p><p>其中的 <code>mode</code> 为</p><div class="table-container"><table><thead><tr><th>mode</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>打开一个已有的文本文件，允许读取文件</td></tr><tr><td>w</td><td>打开文件（不存在则创建），允许写入文件，并且从头开始写入</td></tr><tr><td>a</td><td>打开文件（不存在则创建），允许写入文件，并且以追加的方式继续写</td></tr><tr><td>r+</td><td>打开一个文本文件，允许读写文件</td></tr><tr><td>w+</td><td>打开文件（不存在则创建），允许读写文件，并且从头开始写入</td></tr><tr><td>a+</td><td>打开文件（不存在则创建），允许读写文件，并且以追加的方式继续写</td></tr></tbody></table></div><p>对于二进制文件需要在对应的 <code>mode</code> 的末尾加上字母 <code>b</code></p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>打开文件操作结束之后，需要关闭文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></table></figure><p>成功关闭返回 0，否则返回 <code>EOF</code> 。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。 <code>EOF</code> 是一个定义在头文件 <code>stdio.h</code> 中的常量。</p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>第一个函数是把字符写入 <code>fp</code> 所指向的输出流。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <code>EOF</code>。</p><p>第二个函数是把字符串写入 <code>fp</code> 所指向的输出流。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <code>EOF</code></p><p>第三个也是把字符串写入 <code>fp</code> 所指向的输出流。</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE * fp )</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>第一个函数是从 <code>fp</code> 所指向的输入流中读取一个字符，返回值是读取的字符，发生错误就返回 <code>EOF</code></p><p>第二个函数是从 <code>fp</code> 所指向的输入流中读取 <code>n-1</code> 个字符，返回值是读取的字符，发生错误就返回 <code>EOF</code> 。会把读取到的字符串复制到缓冲区 <code>buf</code> ，并且在最后追加一个 <code>null</code> 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 <code>\n</code> 或文件的末尾 <code>EOF</code>，则只会返回读取到的字符，包括换行符。</p><p>第三个函数是从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取</p><h3 id="二进制-I-O-函数"><a href="#二进制-I-O-函数" class="headerlink" title="二进制 I/O 函数"></a>二进制 I/O 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br><span class="line">              </span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br></pre></td></tr></table></figure><p>上面两个函数用于二进制输入和输出</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在 <code>linux</code> 系统中由其它的文件操作的函数，例如</p><ul><li><p><code>void stat(const char * filename, struct stat *statbuf)</code></p><p>  函数的返回是通过文件名查找到的状态信息，当文件名是一个符号链接时，stat返回的是该链接所指向的文件信息，位于 <code>sys/stat.h</code> 中</p></li></ul><h2 id="C语言实现模板"><a href="#C语言实现模板" class="headerlink" title="C语言实现模板"></a>C语言实现模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(T) T max_##T (T x, T y)&#123;\</span></span><br><span class="line"><span class="meta">  return ((x &gt; y) ? (x) : (y));&#125;</span></span><br><span class="line"></span><br><span class="line">MAX(<span class="type">int</span>)</span><br><span class="line">MAX(<span class="type">char</span>)</span><br><span class="line">MAX(<span class="type">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR(T) typedef struct STR##T&#123;T val;&#125;STR##T;</span></span><br><span class="line"></span><br><span class="line">STR(<span class="type">int</span>) <span class="comment">// 必须提前定义，相当于是把一个结构体多次定义为不同类型的</span></span><br><span class="line">STR(<span class="type">char</span>)</span><br><span class="line">STR(<span class="type">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max(T) max_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Str(T) STR##T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, Max(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Max(<span class="type">int</span>)(<span class="number">3</span>, <span class="number">10</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, Max(<span class="type">float</span>)(<span class="number">1.4</span>, <span class="number">12.3</span>));</span><br><span class="line">  Str(<span class="type">int</span>) a;</span><br><span class="line">  a.val = <span class="number">199</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C语言中的弱定义"><a href="#C语言中的弱定义" class="headerlink" title="C语言中的弱定义"></a>C语言中的弱定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弱定义，如果在程序中有别的强定义就直接覆盖掉</span></span><br><span class="line">__attribute__((weak)) <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强定义，以下两个是一致的</span></span><br><span class="line">__attribute__((strong)) <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>若定义允许同一个函数名在不同的文件中都有定义，但是这些定义不能同时出现在同一个文件中，并且只能有一个强定义，其它都是弱定义</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ButterFly解决公式显示问题</title>
      <link href="/Blog_ButterFly/2024/03/22/ButterFly%E8%A7%A3%E5%86%B3%E5%85%AC%E5%BC%8F%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/Blog_ButterFly/2024/03/22/ButterFly%E8%A7%A3%E5%86%B3%E5%85%AC%E5%BC%8F%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="公式渲染"><a href="#公式渲染" class="headerlink" title="公式渲染"></a>公式渲染</h2><p>首先需要换一个渲染器，要先把安装的渲染器卸载，然后安装 <code>hexo-renderer-markdown-it-katex</code> ，在根目录打开终端输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it-katex --save</span><br></pre></td></tr></table></figure><p>然后在站点配置文件添加下列内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果在之前配置过 <code>MathJax</code> 的话，在主题配置文件中找到，并修改为如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># KaTeX</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后刷新预览就可以看到效果了</p><h2 id="公式过长"><a href="#公式过长" class="headerlink" title="公式过长"></a>公式过长</h2><p>上述完成公式渲染之后，会出现公式过长超过页面的效果，查找了很多都没有处理这种问题的，偶然间看到有处理 <code>NexT</code> 主题中的公式过长的效果的，说是对于公示的渲染是有一个特定的标签的，然后就开始了我的探索</p><h3 id="查找解决方向"><a href="#查找解决方向" class="headerlink" title="查找解决方向"></a>查找解决方向</h3><p>首先打开自己的博客，打开一篇带有公式渲染的博客，然后右键打开检查，然后找到公式块</p><p><img src="/Blog_ButterFly/2024/03/22/ButterFly%E8%A7%A3%E5%86%B3%E5%85%AC%E5%BC%8F%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/1.png" alt="1.png"></p><p>然后就发现，当给 <code>katex-display</code> 添加图中属性之后，公式块中就出现了滑动条，并且公式也不再超出页面了，找到目标了</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>新建文件 <code>themes\butterfly\source\css\formuladisplay.css</code> 并且在文件中写入下列内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.katex-display</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">  <span class="attribute">overflow-y</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开主题配置文件，在 <code>inject</code> 的 <code>head</code> 处添加对该文件的引用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/gongshidisplay.css&quot;&gt;</span></span><br></pre></td></tr></table></figure><p>最后刷新预览就可以看到效果了。当然这中寻找问题的方法是之前在学爬虫的时候学到的方法，让我这个几乎不懂网站前端的人也能把网页做好</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ButterFly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo加载动画</title>
      <link href="/Blog_ButterFly/2024/03/22/Hexo%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
      <url>/Blog_ButterFly/2024/03/22/Hexo%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hexo 默认是没有加载动画的，偶然在做博客时看到了这个教程，在此基础上做了一些小改动，效果很不错，所以记录下来</p><p>原文链接： <a href="https://cnhuazhu.top/butterfly/2021/02/25/Hexo%E9%AD%94%E6%94%B9/Hexo%E7%AB%99%E7%82%B9%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E4%BF%AE%E6%94%B9%EF%BC%88%E9%BD%BF%E8%BD%AE%E6%95%88%E6%9E%9C%EF%BC%89/">Hexo站点加载动画修改</a></p><h2 id="加载动画设置"><a href="#加载动画设置" class="headerlink" title="加载动画设置"></a>加载动画设置</h2><h3 id="创建js文件"><a href="#创建js文件" class="headerlink" title="创建js文件"></a>创建js文件</h3><p>在 <code>themes\butterfly\layout\includes\loading</code> 文件夹下创建一个名为 <code>loading.ejs</code> 的文件，并且写入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.<span class="property">preloader</span>.<span class="property">enable</span>) &#123; %&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;loader&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &lt;% if(theme.preloader.layout == &#x27;gear&#x27; ) &#123;%&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer_box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;loader_overlay&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;loader_cogs&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;loader_cogs__top&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;top_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;top_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;top_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;top_hole&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;loader_cogs__left&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left_hole&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;loader_cogs__bottom&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;bottom_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;bottom_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;bottom_part&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;bottom_hole&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &lt;% &#125; else if(theme.preloader.layout == &#x27;spinner-box&#x27;) &#123; %&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loading-left-bg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loading-right-bg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;spinner-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;configure-border-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;configure-core&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;configure-border-2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;configure-core&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loading-word&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> endLoading = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;auto&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;loader&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;loading&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>,endLoading);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="主题配置文件修改"><a href="#主题配置文件修改" class="headerlink" title="主题配置文件修改"></a>主题配置文件修改</h3><p>打开主题配置文件，在 <code>inject</code> 的 <code>head</code> 处引入两个 <code>css</code> 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://gcore.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css&quot;</span> <span class="string">&gt;</span> <span class="comment"># spinner-box风格样式文件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://gcore.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css&quot;</span> <span class="string">&gt;</span> <span class="comment"># gear风格样式文件</span></span><br></pre></td></tr></table></figure><p>将代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">preloader:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">gear</span> <span class="comment"># gear, spinner-box 两种样式可选</span></span><br></pre></td></tr></table></figure><h3 id="修改-layout-文件"><a href="#修改-layout-文件" class="headerlink" title="修改 layout 文件"></a>修改 layout 文件</h3><p>打开 <code>\themes\butterfly\layout\includes\layout.pug</code> 文件，将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if theme.preloader</span><br><span class="line">  !=partial(&#x27;includes/loading/loading&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if theme.preloader</span><br><span class="line">  !=partial(&#x27;includes/loading/loaded.ejs&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo动态效果</title>
      <link href="/Blog_ButterFly/2024/03/22/Hexo%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C/"/>
      <url>/Blog_ButterFly/2024/03/22/Hexo%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="雪花动态效果"><a href="#雪花动态效果" class="headerlink" title="雪花动态效果"></a>雪花动态效果</h2><p>在做 <code>ButterFly</code> 美化过程中，看到了这个博客，漫天飘落的雪花效果很不错，所以记录一下</p><p>原文： <a href="https://cnhuazhu.top/butterfly/2021/02/24/Hexo%E9%AD%94%E6%94%B9/Hexo%E6%B7%BB%E5%8A%A0%E9%9B%AA%E8%8A%B1%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C%E8%83%8C%E6%99%AF/">Hexo添加雪花动态效果背景</a></p><h3 id="添加雪花动态效果"><a href="#添加雪花动态效果" class="headerlink" title="添加雪花动态效果"></a>添加雪花动态效果</h3><p>首先在 <code>\themes\butterfly\source\js</code> 目录下新建一个文件 <code>snowflake.js</code> ，然后将下列内容写入文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">  <span class="comment">// 移动端不显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;canvas id=&quot;snow&quot; style=&quot;position:fixed;top:0;left:0;width:100%;height:100%;z-index:100;pointer-events:none&quot;&gt;&lt;/canvas&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span> &amp;&amp; (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> e = &#123;</span><br><span class="line">        <span class="attr">flakeCount</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="attr">minDist</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&quot;255, 255, 255&quot;</span>,</span><br><span class="line">        <span class="attr">size</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">speed</span>: <span class="number">.5</span>,</span><br><span class="line">        <span class="attr">opacity</span>: <span class="number">.2</span>,</span><br><span class="line">        <span class="attr">stepsize</span>: <span class="number">.5</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> t = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">mozRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">msRequestAnimationFrame</span> || <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(e, <span class="number">1e3</span> / <span class="number">60</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> = t;</span><br><span class="line">    <span class="keyword">const</span> i = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;snow&quot;</span>), </span><br><span class="line">    n = i.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>), </span><br><span class="line">    o = e.<span class="property">flakeCount</span>;</span><br><span class="line">    <span class="keyword">let</span> a = -<span class="number">100</span>, </span><br><span class="line">    d = -<span class="number">100</span>, </span><br><span class="line">    s = [];</span><br><span class="line">    i.<span class="property">width</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">    i.<span class="property">height</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">h</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        n.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, i.<span class="property">width</span>, i.<span class="property">height</span>);</span><br><span class="line">        <span class="keyword">const</span> r = e.<span class="property">minDist</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> t = <span class="number">0</span>; t &lt; o; t++) &#123;</span><br><span class="line">            <span class="keyword">let</span> o = s[t];</span><br><span class="line">            <span class="keyword">const</span> h = a, </span><br><span class="line">            w = d, </span><br><span class="line">            m = o.<span class="property">x</span>, </span><br><span class="line">            c = o.<span class="property">y</span>, </span><br><span class="line">            p = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((h - m) * (h - m) + (w - c) * (w - c));</span><br><span class="line">            <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">                <span class="keyword">const</span> e = (h - m) / p, </span><br><span class="line">                t = (w - c) / p, </span><br><span class="line">                i = r / (p * p) / <span class="number">2</span>;</span><br><span class="line">                o.<span class="property">velX</span> -= i * e,</span><br><span class="line">                o.<span class="property">velY</span> -= i * t</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                o.<span class="property">velX</span> *= <span class="number">.98</span>,</span><br><span class="line">                o.<span class="property">velY</span> &lt; o.<span class="property">speed</span> &amp;&amp; o.<span class="property">speed</span> - o.<span class="property">velY</span> &gt; <span class="number">.01</span> &amp;&amp; (o.<span class="property">velY</span> += <span class="number">.01</span> * (o.<span class="property">speed</span> - o.<span class="property">velY</span>)),</span><br><span class="line">                o.<span class="property">velX</span> += <span class="title class_">Math</span>.<span class="title function_">cos</span>(o.<span class="property">step</span> += <span class="number">.05</span>) * o.<span class="property">stepSize</span>;</span><br><span class="line">            n.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(&quot;</span> + e.<span class="property">color</span> + <span class="string">&quot;, &quot;</span> + o.<span class="property">opacity</span> + <span class="string">&quot;)&quot;</span>,</span><br><span class="line">            o.<span class="property">y</span> += o.<span class="property">velY</span>,</span><br><span class="line">            o.<span class="property">x</span> += o.<span class="property">velX</span>,</span><br><span class="line">            (o.<span class="property">y</span> &gt;= i.<span class="property">height</span> || o.<span class="property">y</span> &lt;= <span class="number">0</span>) &amp;&amp; <span class="title function_">l</span>(o),</span><br><span class="line">            (o.<span class="property">x</span> &gt;= i.<span class="property">width</span> || o.<span class="property">x</span> &lt;= <span class="number">0</span>) &amp;&amp; <span class="title function_">l</span>(o),</span><br><span class="line">            n.<span class="title function_">beginPath</span>(),</span><br><span class="line">            n.<span class="title function_">arc</span>(o.<span class="property">x</span>, o.<span class="property">y</span>, o.<span class="property">size</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>),</span><br><span class="line">            n.<span class="title function_">fill</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">t</span>(h)</span><br><span class="line">    &#125;</span><br><span class="line">      , l = <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        e.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * i.<span class="property">width</span>),</span><br><span class="line">        e.<span class="property">y</span> = <span class="number">0</span>,</span><br><span class="line">        e.<span class="property">size</span> = <span class="number">3</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() + <span class="number">2</span>,</span><br><span class="line">        e.<span class="property">speed</span> = <span class="number">1</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() + <span class="number">.5</span>,</span><br><span class="line">        e.<span class="property">velY</span> = e.<span class="property">speed</span>,</span><br><span class="line">        e.<span class="property">velX</span> = <span class="number">0</span>,</span><br><span class="line">        e.<span class="property">opacity</span> = <span class="number">.5</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() + <span class="number">.3</span></span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, (<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        a = e.<span class="property">clientX</span>,</span><br><span class="line">        d = e.<span class="property">clientY</span></span><br><span class="line">    &#125;</span><br><span class="line">    )),</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        i.<span class="property">width</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">        i.<span class="property">height</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br><span class="line">    &#125;</span><br><span class="line">    )),</span><br><span class="line">    (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> t = <span class="number">0</span>; t &lt; o; t++) &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * i.<span class="property">width</span>)</span><br><span class="line">              , n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * i.<span class="property">height</span>)</span><br><span class="line">              , o = <span class="number">3</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() + e.<span class="property">size</span></span><br><span class="line">              , a = <span class="number">1</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() + e.<span class="property">speed</span></span><br><span class="line">              , d = <span class="number">.5</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() + e.<span class="property">opacity</span>;</span><br><span class="line">            s.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">speed</span>: a,</span><br><span class="line">                <span class="attr">velX</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">velY</span>: a,</span><br><span class="line">                <span class="attr">x</span>: t,</span><br><span class="line">                <span class="attr">y</span>: n,</span><br><span class="line">                <span class="attr">size</span>: o,</span><br><span class="line">                <span class="attr">stepSize</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>() / <span class="number">30</span> * e.<span class="property">stepsize</span>,</span><br><span class="line">                <span class="attr">step</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">angle</span>: <span class="number">180</span>,</span><br><span class="line">                <span class="attr">opacity</span>: d</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">h</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    )()</span><br><span class="line">  &#125;</span><br><span class="line">  )();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主题配置文件中，查找并且修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/snowflake.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>也就是在 <code>bottom</code> 中添加一行 <code>- &lt;script src=&quot;/js/snowflake.js&quot;&gt;&lt;/script&gt;</code> 代码就可以了</p><h2 id="樱花动态效果"><a href="#樱花动态效果" class="headerlink" title="樱花动态效果"></a>樱花动态效果</h2><p>原文链接： <a href="https://cnhuazhu.top/butterfly/2021/02/19/Hexo%E9%AD%94%E6%94%B9/Hexo%E6%B7%BB%E5%8A%A0%E6%A8%B1%E8%8A%B1%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C%E8%83%8C%E6%99%AF/">Hexo添加樱花动态效果背景</a></p><h3 id="添加樱花动态效果"><a href="#添加樱花动态效果" class="headerlink" title="添加樱花动态效果"></a>添加樱花动态效果</h3><p>创建文件 <code>\themes\butterfly\source\js\sakura.js</code> ，并且添加如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stop, staticx;</span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUgAAAEwCAYAAADVZeifAAAACXBIWXMAAACYAAAAmAGiyIKYAAAHG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBSaWdodHM9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9yaWdodHMvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcFJpZ2h0czpNYXJrZWQ9IkZhbHNlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NDFDMjQxQjYyNjIwNjgxMTgwODNEMjE2MDAzOTU1NDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozNDVjOWViOC04NDc4LTFkNDctOGRjMi0yZDkyOGNhYTYxZWQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE4LTA1LTA5VDE0OjQ5OjM3KzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjEyMjVlZWE3LTEyY2QtMTY0NC04ZDAzLWFjOTE2ZTAxZDQ1YyIgc3RSZWY6ZG9jdW1lbnRJRD0idXVpZDoxRDIwNUFGNjZCRDlFNTExOUM5REMwMzg2RjlEQjFGNyIvPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphYmMzNjIzMy1hOWNkLWNiNDQtODViYi0zZTgyMjEwYmIxMjYiIHN0RXZ0OndoZW49IjIwMTgtMDUtMDlUMTQ6NTE6MjUrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE4IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiBzdEV2dDp3aGVuPSIyMDE4LTA1LTA5VDE0OjUxOjI1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+XCpBoAAApBxJREFUeNrs/cmSI8u2LIipLnMHosnc59Z7jyxhjSg1oggn/EWO+SP8B34JhRyWCItk1at7786MBnBbWoNlZm4OOLrIvc8+t45bCjIQjibQuKuvTlUpCdva1ra2ta3zZdtHsK1tbWtbG0Bua1vb2tYGkNva1ra2tQHktra1rW1tALmtbW1rWxtAbmtb29rWBpDb2ta2trUB5La2ta1tbQC5rW1ta1sbQG5rW9va1gaQ29rWtra1AeS2trWtbW1rA8htbWtb29oAclvb2ta2NoDc1ra2ta0NILe1rW1tawPIbW1rW9vaAHJb29rWtjaA3Na2trWtDSC3ta1tbWsDyG1ta1vb2gByW9va1rY2gNzWtra1rW1tALmtbW1rWxtAbmtb29rWBpDb2ta2trUB5La2ta1tbQC5rW1ta1sbQG5rW9va1gaQ29rWtra1AeS2trWtbW0Aua1tbWtbG0Bua1vb2tY/3xr+o7+Bf/2//z/+1OfPAIgJErGbMj7M8fue+O1A7LLjcxyw+5hwZMbgQnLgKIftRsgMyYUjBYNhOn6AADiMOGDCyIQBCflwwNEdw24HHA5AzhjHJxyQwZTADLgmHJPhDRnfjo6PlPHbNOJDGZgEZsIgOAHPR/yPwxv+28MONOBghIEAiXce8LkzuAG/vRP7o+EzAcMRyNlxoJByxj4T/8su4+UgPE3A++jg5yfe/lvD73/b4eVfM17/zfE//y3h6UjsJ8f/9N8m/Of/Cnz/d0cegHES/t///Q7HHfG/+/8JT0fABGQTzIEkYMyGf/0vBh8N3/99wv/rP/1/sDs6/i//+t8DZhCATOFwzPj4/R3/MhkOmPBz/47dB+CY8LZ/w/NnQh4cu88dppSRU4abQwbQCRPhdDx/PCGbI9f7JLXbRfHpYw+n4MOkPAAUSacBmfv30f/rf+f+8m+GpyPw8Zrhl0IMAmK5KgAOWCY4Ib6r8pO+/hiV/5c/LyyVe6g8TnH5P/3f/q8bwv2zA+TfZ7HtvKbY4ScCOxCU4EaYE04hxb0hOYgEATAJTsGYkP2IQQBocAkkAGMBQcdgA47HA3aMg0cQkhmOGRhEZAMoIpdDhiREQYzXJQBDSQwygFGLdwET2/3c2luLx9fXzjhKk4hs8QTmsd2OAiHkIR4wZmFKxNMRGI7C5xPxt3+Lv+0GvL47/r/fBgBCJpAcYPwVAICbsPsE/v0VSJl49if8+/C/IEMwCIQBcCQLUBeBlOOFi4K5wanyGcgAiPEe5XSApInJsllCQkAVQNFStpTcUjoakxtNZqJIwtIx2XigpUyaG2xSdvPj9/+aPy3zoORuorKVD7OCoZfLxAUgMhegrEBYf1p8x2pYdxUKITVEXIBhewFit21bG0D+HWoQDgJwiERSAF622CFNgpsh5YypHPck4S7YEEcjQQhAsoRj/ixARHiBOVpAhsthNkCKPZwCvNvTB1Ugi7/dnpunr9mQYJjoGGWLOooVUAcDbAWV6CleN9sxJwzOeE/lczgakQ4OkzCNhBuwOwo/n+M+u4Pwsbd4dQLciJefwvR/CLDsgyWVP+SMxx0HgSCe8h7/037CwY7YY1cPeyQzwAxe3j9FeBKSwOf3p7Q7cuQ7d0oYCbPkifvDnqaULNvOhAE0c7p2ACEbTBwIjhCMYIJhAJggWICsMuQTnEdCB7m/7f6rv2XLb2781ITP6bdpSgcrgNhFhTqJChnv9eGosILijKAnCIvlxQsQbwC5AeTfM4IkACdhHtHUlBTxjYSjEYMATxHGEQyQK5GFlZ3daOWsLxgjyiphYAMVJIv9XsIC9xgHg4HIDFBzUxyM5QCUShxBYifDwYSXErlkCkmEkaAcEDFRERUKmCxA0ARMiIN5EHBIcT2JkapPgmVhShHRjZOQU5xExqPw43uNQCOqffp0iEAegDShe9Nz4DUcK6Aa9nmACLylT+ynXYlwC4CbYWLGHoTJzFxj8rTfH8ZnE14pfqP4Ctke0EBoEG0gMJLcK3J2Lx9XIrFz2kjBIhSvpx9NgI6QPgR/B/Qu6YNIo8kHTpYcU0IWcRw+NJ9HIoAjIAroTja/FhWeRIblUoGQHShSZV9J3A7bDSD/jil2xHQgiOTCNJRoToISW9rYsi2tnMZZ7ieHwSINhSJyYyBc7N8J7hmkAS7IAhgFYRRxNGFww2SOEQm5/e2IVZ3AToY3HiEMEfGWtJkIQGRJgfsIEuU1wAzKGUmEM0oHgwMYo3aWJuG4B3IidlNJlQnYFJ/JNMxvfXcUxqNw2AHjJxalgPbpuDAchePOsJsGJAz4Mb7jPx2/zyUAAPsUibbD0+v77nlwvEJ4pfEbHN9o9h20AEnoWcQe5FgvRrIU6wSjCRzNbIRAQBmug9wPcv+A9A66RR4vp7vk7hIyQTc3pckwCjo+C26atIj3r4PhalSIdSBswFeAsAEiojyjRGAgfGQ5LRBRTdjWBpB/F2ic910i9r1oHnQ1vpoml9splFSZ7XkC/AxZ7V5wCAMY4ZviEDMLgByGVEDTYSQkxyji04BnByY49khz8bBEgBkBkP9ucSBaV9+K9DRenxuQLeqC9TnqfZ3AWHJit7IBBmYgHQU8AXkE+AGYRxS5c4AufO6Ap/d4CB14+hA+98Tr74LXskWLeuNV7Y7A5154+knsfI8fw0d/WjIAw+uwG7lLT7T8QscLhb8B/AbxVcI30r6J/E7yReArpReSexhHGEeAVivEIBNrBUWYIP/UlN/o/i53wN3hzHBM5UWCJheY4cwwy0lJOEKi++dTdqUOIS80TuZwv1z3C1FhD4g1KjQ0AFyAoZWovfyhRYq/rQ0g/z4gyZq/IpXTfyYxOqJpYRGZycqODUDuYBoiNS6NmkSDKyOVWqXkAIeIIl1wd1hKyIdPjGNt1EQEeSwR5E8DkgyfzC2lriktSp1y5ylSWyqaQl2xoDaacgHI9h47gFRJ+02R0gNAAiEwABJAHuMPDpOQzcBJSBn4fDK8/MzwFK/l5V34t78ZYHMzCTWYKwXO3Qfw/h349jux0w7/y+7f4HASHEzpaWB64WivML0y41mO7yC+B0DiheR3AN9p9h3CK4QXCi8AX5H4DHJHlWoHlAMUNcl1gPs7MsiELKNzQgaZReS4rwQgR9GYmcQEV3bQkTnZu3Y05fyEI7y8rXujQs2NHdQSiUWKrH0PhoASAwgLxrfnyIiGliKjadu3tQHk32upprGtURN1O2SWRg1hU9QFkUsTptQRo/tNTCU6nKYJYzl8MoQdAJiBk8PlGC1hUmnBqEal0egZakMFbMEHu2OwrgSDIeqMQ9c3NtROdjwyW3SAWdPs2jcuzzeUjj0AmBMTiXSIDnNOhEod8rADcIiGy/ue+M/lL7oRr2+O//9/SS3qHnwZmTuF/Yfwb/9ZSJ7sv3x8p/yZlnZ7s+HVYP9C2t8A+4aBz3A8EfwO4G8k/ybhO8hvAL4B/BvEVwLfALwAeIH4VEJ2h3SE6x3SO+QfpFPQEbIRwo6uSWY7yI9AGgmMyvkIcgA50JjgHEEOFAY6Bk5INJl2BubrjRMuosI5Rdae0EmKXKcJILXHm6sBKaVF/RGurUGzAeRfC5Nexm/MgamOwCgiqADN2qgpoz4EvKS50ahJLXIKkPNlJ7uApTpYLt2Z+LvluKpZcWaN8ro8vkSVgwxHCs9eRnvK7cYAdbQ6ZAC+swSjJYIUHENJ6VVGdI5G2NEjrR5YGjXA23O82vEg/PitSzMNeH4XpgRMI8AM7HNL4xlRnWhZ9t/9D3gaNDz/H//tvzxZGp990Ctov8HSfwbtPwH2G42vAJ8B/Bbb8DfIvpN4AfgC4hniC4AR4gBglJQgOOSfdP0EPcN9kvMIMtFsiHOBEpgGAiZnYsTAiZCJTIASYANMBnmCmQmeIA12QMInjWU0oQGXz40zJEI7LFPkRMhWokKP/SoATw1UI9LUIgI9LQWBceLa1gaQf5dlAHKNwkr9Owk4lu4t5ZBx0XwgCLjXqnzbgdkQyBsaqTRqWhWfAZju5a/WbYzu+ABiStGVzgwQy2T721agdSfDkRkx+CNMc5INenRUss3znZlzJ9tLFJmc8DKuZCIwGGzKSEchjwZPMf9Yu7fjUTiOpVFTXs/uIPvb756ePmT7AwgyARgH8WV0vg6y1+T2Yjb8liz9N0rDd5l9S7TfSuT4n0H7TzT7DeQLYDsAz2B6BflMYF/qi0NpeZeOdE1bBbgTriTCYJYAGKUksv6eKCVQJiiRGkQNoCUQA+GDkBLgAwYlMg0gkkEDMAwpY0xHHc2RwZPGyVh+TwgwPI0Kc9lHSorMRdSpeZi8gqHmUiYsTlK5wLkb4WkDyA0g/6JKpJMYSif7EzO4tC5wqQVaS7GWjRqQIC1mHjG0TraBoAWo9o0aszEaNXUApetk77Ih07HDUEqkpQ1T7r9TwrtN8KlEjCxRbN+oKSMp9HJQ1eiSbI0aMUoHqZQOWDrZ2gF5IMZPlXonbJxg338XRRikJHBH4uX//P/ML0jpGbRXks8mfjOkvxntO5L9zWz4jTb8N0zpPyGlb6Q9C/YK8jst/Q3kd4A7gClCdMb+a8b5xNNNcdaB+DZuVUYFDAMcCcYBsARggDSUKsYAVyIxKvuRRESgwAhwonGQ5QGZOwAThR2TJhsxjsDgUx4+/xs7+rNpngo4AcNpJSos6fHNqLAAbE4xUuY2/+zvvKXZG0D+5SuVs/rMDomzd40ya51IcsASpEIFhJCY4HKk0qxwCKmM4sEFV4z6ZJ+Q0q7UIR1GQ9aEQYZPAs9u+BimBYbXCHIisHNDLiwTw3mjxrpO9pBxdlT27JpMRK1UMaRtk0MJOOwN40e2//SveXg62n50e/6XH3pS4p4Yni3ba5L9C2m/Uek3Mr0AfKHZNzL9C8jfMNg32PAd5DeZ/UZL30R7htmOiXvQ9rUBTVr5cNkiqPa61b3D2qwGoUhLCXII0NOoqCPumHiUcwQ0wG1E0g7EBGCMuiMGug2QBrmPzDiIHAAMoAYyJQMSpGEEh4MVNmUuJZK+cdJHhX2N8hQMLU5W2UpU2IGhuomFuRYJMKul3zWT2dYGkH/n+LFSDlm6hsJkjPGW0pCwfEo5VJthrBGb0TB5xoCumUMAaaYcjmnAYTqU7nZEmQMNDmAsqbFhnXJYj46xDMNlRM0UXce6drLFZSe7giJKpgpUiuPcyXYDhk/x+aenl5++e/7g0+j2bEzfEu03o73S+ULwBbDvNPsbLf2NKX2D2Uu5vIL2HcbfmIZvMPuGZM8wvsDsqTRFDMlIszLmwnlWc65ZtGHyGh/DS4W2lTe8zICnAe4DrKTMZgniyKwjqAGmJNcAq80YT8hIck9wGSkTUjIyRVVYKSJaJINScqTxmBNM2bwUiqUrUWFEhEolRbY5TZZhmSarn4EszRmfh9G9AGpO1kB1WxtA/l0B0k872Q5MKcI18wDI4QhMiWXULiiHaEPlbNxqz3OjRpVewplyyDQuKIf9wWU6jfQ0N2G610sQA6JRM2ruZLNUJU872T3l0MrQuiNqnUcDMsRxorl24/P/7Pv//f/ozyBeYOnV0vDNLP1Gpt9g9g3kE2ivMH6Dpd8wDL8hpW80vsLsGcZXpHJfS68kn2C2gzHBzFCH560Dxu4zmqPIOts0b2ojRLWhYdZ6IDGFj1ZzFDxF+J4S5ImUyd1gTCUFTyQTzJMcieSAXMBRiQGSyaCo/KWjp0xnPVedNk6WtcIZDE+jwqhNFhAsoFgJNW6lLpwMuYIp59Es1Kh1WxtA/r1hMvrOAZCpKNO0up/ZYgh6QTnEspONQuhgNyvMtoPPB39POWx8aUUkN1mkzo16eEI5FImxNGqoITrPIeew6GT3jZqpNmoATCUqHR1042hmuwTuTXjmgO9M9s2Mr6R9o9k3DMN3JPtOS99APsPSC82+I9lvGNJvsPQdZi+MKDHqkSk9wzjAaCyt/Dpu1MqK5Gl42803laICT0QjyvuPOcHCdnJHNGAsmjXuibJSK1WCEF1rIkE00VNoXdAgJgJJ8ZEnSoOSBiolSQNTSiYNhog+RUxrjZOzFPk0KtQ8XF6jQt+xpNlzvVGljlxPoOYqDR6169vaAPLvn2KjU7tx4DCUtFkq2++jHAIGyWFIFyiHgplFo4ZWGjVapxxS2LcBoNJDL42avQw/LEMeZYHcQX0cUGyNGpsbNZRcTjBDu72npxeMLzbaa4omyyuZvtHsN5KvoL0i2SstfUeyfynp8zONLyC/YUi/IdlvTOkVtBeQe5IDzAYYU4sEO3BbhLu12cE5bZ5BspxMvBuuNLaTT2OXKNJsmgFSIpkUnE6L35XgSKIMYoJ8IBlda5bGTulNCxpgliANMB8BO0ApUT6kbImUvX/nQgptnmOMhgxPokIZMaWICltkyXlf6zvcdMHc599PwXDLrjeA/CtX7SgndTxkYQZPLaXRYh4yaIOlxRCMGnfQUmvUNMqhA64TyqELSoKRIYsm4pPAixsOKeOpoxzWRk1QDhMmO8QsZn2Na5TDMr5EIhk5PCENL459Srvn0exvTOk7LX1jslcwvdL4Cto3pBI9WnSckdJvNLZaI81eo76YvpEstcX409FgYddUWUZXC0mcpuZhC5qINPPHu43dvFUB0FrQcxjkA+QDwSRwgJDgSjAOFEYJRzgToKF0vaPLHcdLuc4EMoE0kAOMiWZmE5MdkXiEcYTbpEXjRIz6YB4rGJ5EhZjrln1UOF/O+lEzAHtXm9wCyA0g/8pGDYqSD4r02Th1jRpFo6YBkgtMaKl4pRxmTaVRE3VHcACNsCy4hJQGTIcPjIzmjVI0ZhzCrlAOq7pPTzn0bvRo9FSkttY72RBwHIRjgo0TxidPz8PA55TshUwvNHvlkH4zS39DgF13YYhDmH2LdDkAEuQ3kC8lWnyC2UjaGKjcNVWkReS4TJuxLKrWcSl2qKD+ffeqOZ0ihs/RKI0xhOU0CKkOiUseMmcOA5noPihAb4CYKCaZDYAKmHpEvuIAs5Hyg8xGmI3GNI5HH3cfPn1KftwRXrQsaxe6jwpbp9sjyrWabnfzszqNCl2LSLQ1fFhS+cEi1t3WBpB/9+ixUuhOKYclovREpOM8OmOIiI9cUg5DG/LQmimqrBkGBFbKobyqPtY0PFg2qaMcLnDg5LhIMRY+Uw5rdAtgkNnLgUP6tOF5sv3A9C1Z+s3S8MqUXkh7jXqifceQvsMsmixM30C+wvgK8htSeiH5rTRkvpfbngAOJAmjtWix6zjXmmKNaJvAQz803wPpXFxdnrUUz9X6NewjzWXXO05UMsBGSCNcx4gUbQS0g/sEcgI5wmyEYwS1I5QV23cwTnBOJOu2PYEsINNsGvKQn96P+Zjgb//ZcprYGicBgL6MCCsl9TRF1gyGfVSo0vDRYJGKr4z/bGsDyL8kgmxipyVKi8ZGZUIE5TD4yx3l0NXogbVRQ1oLlAgid5TDFg0VdsxMOZxfR22keO2Ol0ZNTzms0dUow4GOZw9Gt4MmID35sN8d+ZxqpJjSb0zjbxxS7TTXkZzfmNJvsPQadcUWQb7C7HvUIUtaXSLGYJ90tUXyvLi4YIYQ6IByrvXqvKjGC8U2dpVilU+tpuOpfFjugJkRGuW+gyHTLUueg96ECVImmSXlKNsyI2jzU8AzXULcJmSILjED5jRNyZV3U/KXn9nfPvRBufrGyXpUWHjWJ3xqWVAR887K6A9XGz3WcbzNN7GKDSD/Qpis4rlDbdSMNX32og15QjnUFcqhO5g4n/g519tUBqPdc6TSRRuyNnJqJzsJmOgYZI1y6F1cupPhwyYgJ9t5SkTaJeNLYnrhzl4taojfYKk0VNILaS8FAF+R7BtS+h6pdNlGey2/RzptfCK5g1lapMEATnL7lQinn6w/AfhirXAeWhXw8/qZnQBph43tk6c3ewtAA4CnUqrNJF1kjujRIoRXqPqAnGBWwNK9gOZUznnRYyMdNAc9w+B0aH9E/tu/Kr+9+lEzvT5q0bk0V3yuJsRMZKTHbkXG7OQz6wGwB0V2Cj7asusNIP/SGiTqzFmk1VWlJmlGBCLP0l41XSwNnBrZWaEcsnwNHkUwGAsYJsHSCeUQYQDmcOwq5XAyTCaMLYWtaucRNO2VeKQncngelJ5pw0tKqTZXXsg5GsQwfGdKtab4DNoLkn2D2d+i3sgy5M3XEjGGlBhhTXGjfUxcDfRaCl3nWQwz0J1OVGu2mJgbTDYDXzoJx9RHp/GZN8ohu46GEZANkO9Bc8AzaBOoDMKjIMiQOKsgWPkwpIPI7ScoEi4iB5Aym5lrUt7/nqfPQZ6TJssnUWGaxSrWUmSqsLRWokSsRKGN+SRujewNIP8xVqMclpojywFAzLYF9QCt9UMWyqEVyqEtKIcxGM1JrZOd8xEp7Zp1A0lkBaPm3YBnGY6cFplnsXYwN/LZx6fvenrGwG9mwWYpIFi6z/bCxG+gvZYI8ltJoV9gfIbFSA8s7kOzVwD7Uo9LbXrbeAEI+0YLunpi1502Ow8S+yutR8MFcAo6p6csOj5YgCWWQEkQO6iLBJeXDGACmRURY+hE1u3ABDBqlrIR1A7gRNok00TDbsx+fHrD9Pbd8uGbCcLVFPmeqLAHwrO3j3Ppu21tAPn3jyJLSpQ0Uw73uQjjJoKFctgyJPcYncMsLZaYcPTphHLIpk6e5dilAdPxs1EOM4SRhiOEQdEdPaUcgjAmSwlpN5JPNvAbad9Ya4fkK0qUWBoqLzD7VmqPpRljESEanyP9DjsDGF/Aop7DhQrHEhA5lyPmkIjz9M5ippHLuqL6dPvk9xMcpDpFJMxNn/aArs6rOvJTRY2NkGigxgB8ZJBHEDuQE8Bo3AQY7kBWwAwbB3CkcZRzB+IIsylE5tNIYGfExGncPR95PE4+fRimlNF8jf6IqLCnltJLXdznz2VbG0D+3VfrZFfRB5872dGoCSOq44Jy6G2HtmLb2iiH5T5tjLu5HAo0a5TDM7DWMtjyoBymIY27RD6b2XMRh/ge9D/7RvKlpcelpkizVyS8wtIrLH2PWUeWYW97QeJrqHenl7Au6LLeKsWGrhlzFsydjuU02t9y8PviGel2e7Y1d7qm1VyILN+DV0Xuyl2y+DKlAbCR9AFmO8EngCMzR1kBQnEEeJRspDTCtFPSERk7Jkwi9nTPgE/FnWeitMPAPDqm17fJkVxTQvC0L0WF5ReufA5trLOPOisYllFPT8S027jYG0D+hRFk7UnX6mFSiOdWl8PJUjBeOINH72zXLLZoHeT2CuE8mRMMgOUJIFXKYTYVN0Ifnrh/5pBezNIrYw7xpUSKdfzmhbRvAF9h+AZLLzP9j9+Q0jekcjvtOSJIfgP4XCInsAcq8nK9se9anwAie5Ds0+/TGuXiOVdS9v6uNtcYAwwLCFbZotoeVjdyZARgpuwjyD2gieSoKB9kyjKArLBoyCHxWy5uOWZ2zEuLusSGWWB8KXSHAb4/mPBD+v27Phor9EpU2INhBULT/Bm7ET6iSfp6whmne1sbQP5lKXbTdsRMOawuh30kdY/LoVpbZ6Yc1vk+L3ax7jlYN61+WcRzRXyY8zXvxmEYnxKGV6bgPAP2EmISjHojUBkwpdGCOvQdQ93G11DcwbfClnkR8EyzZwCpAZCwmk7fcWa5L2rsgXIBnKdpNpflxh5IF4SbWUC2DlbLrEz1lNCLGmC2j06ZZkNqoa8IYhYYK3VKQTPfvmj4EIGMQax2Mnki8+5Af/7wfNj7wa14KXaZQANC74oTVgBwDBEUH9CJU8yPpUfcSg9bXubtWN0A8q9OtcNhCUlx1OXSlGlJX601VkrfCeXQgRn8aAvKIYvFgmvuZI/DALqCUUMiy/HkRgC7JxueacMrWSLASKVfCLwUEPxeosbCcLHXoqzzjU2CLH6PemM0aEjuEPqHJ5HahaLgSTFiFehqHH62eQU8yfWI8fLZa/X5iE4+7EShe+Z7awQoSF7a3oI89HRi3CdH8E8HmNs2WgYxgdrDFHOVhuICzgnME4H9IOSnT005MWvQlKYKvWWkp6j0TEPRgExdQ6ebHaMDqdIKs5rqz2nJZVsbQP7ljRp0LoFT8WcxlEaNF23Iely7Qna/iUlUvvU55TDm9RS86zRgmt6DEyNvquAC0rNsHDi8KKUXtHlG+4ZQ2SlyZEV2DGVMJwa7X1qjxkKyDAwhW6SWUu/CyuDkzZ+2y09T7AZyXZTG7raODdNG4XtBitOU+xqAXsJmXkEKzlqYsBApDqYTCShSbbMM+QSzHeWThGPpWGcQI2g70CeQR5K7YNRogjiCGgnsREwghpmVo3Fw2+0/NHFPPz7Da91QaaW7XaPJrPaTroUv9ql5Ysdu3w7UDSD/ARo1JUK00smuHO1shOXiKV2sCrIcAzsPmEI5nK5RDov9gjT7ljhE0tLTsHsysxdZegHthWTrQkcEaOHqx0inafY9utB8IdMrUv97F0HGY8e+C3yxccKVSG8BZNbV/dCJTixT7kXz5ioYnozqXIs411g4beZydu/pRTMQJcORKHVIcoK4I3UUORGYRI4gpnafUIkbFaLrE4gjYBOJUcQuuuOaSB5Ndtxljdkx/XiVW52uLN40lmd1cKtakDinIZ6CIRfSaZw52tvaAPKvadQAPeWQjqa6bRKOZhgVZl81nawmXrXmGOm01ZnFmG9slMMyDK04gIOAEY8fPA1DGp4xpG9geo5h79qd5rfSkAnQrCl2cKWDAYMuqmSpSSa+lLnIpwhh1wDn2jYsGttL5e9+5OYEKC81b26B5KXXsjA/6wbDy3fULILMolzRasZR02AEvSlAkVMBvSOAEcQYGj3sxoBahLiDFCNAsB2gwtu2oCiaRkA7unKk2j69f/rEo2T5clS4PA9xtlhozZslGHpRIs+77TjdAPIvhsnwoTEM7kgSDmVqBPKmvFNtEFpXeiYglqeZgbBu9drAqdqQlXKYM4dhGJiGZ6ThG9MQqTLw2mqIQKH/pVdCRZiWryC+weqYj9VI8VsnYPuKiJjGRbh1Jz4uDmNqCZK6kvOuNG/OQPJiyn3ltdWZSz9piplDnfBDWFUUcKwkd6cBGIE6D1l+kkeA8zbDEc49SC8d7glmR7jvC1jGdsOEzBxtlJwJ5HGCf/s3Tp9ppiGupchtTrIAYT84HgrlgO/QLBrax7YVIjeA/MtrkF0SlzyuT12jpkrg991GnVAORcDKrGOl0Dm8MWrC5RBIw2gwjmm3e0EaXsPyFKW22NLpnh/9ihpVlq513IbXIlz7isqeIZ9o3M8E8T5BXQO2C+IRutSn0QozRg8UDnUmc3b6Gshz5K6iwejEMNpAO3UuylsRMpBogHEHVaaMjgj2UDBsGj2RXpo3s8BFNHWmMvw6hdhF5XnT4XTA8tM7nvKLNCUdZyAErPiYz4IVRbNzDMk7txNBI3UfE+fHbGsDyH8YxKw87GzAmJeS/wvKoQNMbJRDVZdDz0iaxXNHFGUeF9xz2j+/7DkML7DU6IEgvoP2CvC5a768wvgbwDnt7uuLxhgIJ56RUhkI53DWjOkaKOuh2uXq7Hz1iv9oHyZWoLKV5s1a9ElejmJ5GuWrWGRrZtAUqbgFolQQrq8h1G1HsIBidKy9ux68a1dwtWdwzIXYlGH0xuUuEmmwlAFOnPLOsk37g46UT5aL9m+JCqN5M4/znEaFvTf2ormDUoPcIsgNIP8hokiiyEfkuVGTo5OtRNh0QjksNgs95dBgOGqmHNYok8k4piGNaffEIYU2YwhEvBZ/6W9zlMiQJwNLBGnfQMQ22jPIb0ypmGgFU4ZRb9xdjgZXLFV5IfVt7L5LIzxYkaY5AUlcS+d5IejklUbOaWNmQVcJ/ndhOHXacUFBdAPoBtoOVqTOqAKMjPEdZybtKPqudLOjgSMbI/G1ifQRxCgxapXhwR12ssQ4HDlOxun9VUesRYX9V2KnJwGe8LUFTw4fHJ62Ls0GkH/xuko5LC6HScCxWTkXymE5SGfKYSqUQzTKoQAmS6Ol4cnSEGM4xm8QX4uvdIkWESk2AijJ2pCxlmaTpcaYwiYhHmv7JiPUj+rwJBLkJYZMB0Z+oeh1rX64FkneYh1eUgVae23dnUktM/MEMBtkRYzYS0Rpc/rPVIRFpKRozIwkByQOoQKkncyOSBopHlWoiNHZxgjwACAFKGIs9d0MsyPkExIzpMnc9uNR+Z3KVDHOxAkrBh3rprxEN4cPOQCxgqI5VBwqt7UB5F8eQVbKocpIT4BhoRy645gGjNVfmlpoQ85DJmod61nFkUZyZ2l8YhpeYYVPXaJFNh41OhC0l07l+3uxO4gh8Jpip3AgLAerLWt8p9YHvCOFxUK/sfeROcNE/YlfxAIQT8d65hdXbW6logvpAOhBpIkRn/iubCZ8SiRlIwyjpFAYN02QTRCiW610hLiDFOmzsBMsQ17qjZhozIJN8LyL+iUUabjnQZaf35Q/XvUZNPK5BinTDIJddOjmjcpawkeYE2lKSNmQctoO0g0g//oUu8magUgufFaXQyxrQ+oyO501GaJjrXAZtKe026dhfMUwvIDptYsOq5rOa6UPkqWDDb5Eio0XgK80fgfTS5Esey2jQK+IjqytR3q4PHR9rdzYOtUn4KhL5lFdmn2JSrhIv3kHOHYAeVKTa7NYrnn+0dTKruEu2LhN85sTUeZ+UmvYBKI6pEwhS6UWaa66Pc50RY08OtlBIqSKOvnMxAndJ+T9IU3TPk+fTz7l8bgAxUVUWJg35gZza2AYF2sSaNvaAPIfDC1nl8PcXA6FUNPyNlAemKBqP9odlobJJ9sPL3sbdt8xDNFpZhn2BkrXGt/mSBKRTgNl3KfYrLINfL8Go4ZhhQDu7qJYPCJ4cDev+s7nuxXFrgnytlopz9N/aT5bEUAimHMrj7S/Ue7DaqpVO9tWJ/stIkSVOmTxD8SsQp5BTbWjXTrWRR4t5iIJTTI7AspwTlDVkfRxEHYvH3b8/PbpP//24Smz2MTaIipM2WCeELfPJYaqi6lSQyU3Js0GkP8gUWQ9GBvlMAG7Y2nUcHY5TPVYlYNIRcNHcDjHYZfM0pMNu1em4RuQvgF4IYpeIxAdaFhEiOQrYK+lKfNalL1fmSK1jm53BUd7KjJlt6PC0/usCVGcguKicX1aT7wkNtEB1K0Zx9XIdm2SWkuwXESf9W/5PPKjlaiVWvjoFM1IIIulNDGRnBRd6bEoHO1ozPI2EjQWDvskaRfzkxoBG2m+A+woaAyQ1L4qmSdhennf+TTiMOSkNFmLFNE1Ymrnmtap02MDxQ0g/wHXrMVYhFClMOwCYS54MlhxOURxOcwusKj/JIHZOI7j/gnD+NpYL80Eq7BegjIY+o1FiKIo8lR71dqMCRuEVLQcgeewL30AHO850IRVIIxSAWbb1VvqPfdEoLzyurjyuk/GgNqoUKcRWcewUJoz9Jmb3eYnuYxKCaSgH2Iq4rpTaL+HwjiJ4GQXaTQVNXJAuejdldS6EAhpcRYtRWk69fJjh/Ew6v3Fj2U4do4KEeImVUVq/QvhSclhWxtA/oURZNOGZIx5mxcwLLWtnIjxEATdefylb9SkYbd7Kt4v6SXmF/FcGDABkORzEY94otkTyKcSMbYLw02w3GbxO7CH2XBTBecRYDytPV7CO115XKvx6f5UfK0Jsxjb6cDx7KEl6gqD8Koc0qjYdQ4ovpvz+ZpOAZMQRgjPBCXWVgpV/gjn1L4PaRWhKFQKoYlMZZzLqRD0cKeihjhm+XGStOPxelTIJpnXAPehesa2NoD8O8BkjUas1CEnq6M/wpGz3L/OFBmQOKQnDOMzhCeATySfQAS4oV7nHrQnxvYKkPvycwZN4xOMzzTW+4wXI8YzrcV7osaTIfCT6FG6cL9rKfc5nK2MDHH9PRjvfOm9M4SKnWy4UM7q5mi2XI1N0/4O+lpkgrAvJkNFOBcOMxQdSQ/JTjljLAGKAcYio1Z/0ilJpEOMmiTcQU6JmJ4n5o8xu6g8fwbF5eK0KYXzkQFtEeQGkP9INci6i6aCG9mAsUnrn1AOBcidwzDuOe6foPwE8Bmw8jOiRViAJsBnEjVafAIQ95nB8gnWRZSw5wBVcE2k9zoonk6F6xzoFpHfnbJkZ2bQddDpWk59X6Tb61JcfHg/62mITlpPOaxeNdWeQZ2orrMMlQcmKhwc90ghmkshy92RKmumMGrkEySnNAEaIeygdJS0AzxHJ5zHYOxwB6RQ/Uk8DoZx0DRNzA4mXYoKtdgHefVr2dYGkH8tWrLrZBeAJBQuh4U1MzqQzEhLe9rwBOkJwhNoBfgUUWMAYWyjngtQ7su2JxBPjIhxD+Kp+FI/wdI+6HEFfR4p3J+msTrpYtwY2VlV4lmjFN5VCL0PHMmVSPNarVKlzGEsNgy589U+oRuiu94MvwofUCKdOxknJAsZNGmibFRSKP84dtGx1g7QEdIEYEdogjBJOsIVohhmpeONEQyfmx0sS8c8UVMnhHceHZ7Ul0UCmyfNBpD/eFFk7WTXRk0Rz7WgHGYL+4RkaWTa7WGpRIn2BHBPtNR5P6fZ2JWO6K7wgvfRNcUeZjuQeyQr221fHPkSfrWj2RcT9Ug4ogduuqNzdNqEIdfvwJO6JK5Ekb14BZfgR2cwbIQyN1ll0Agli3YMPRRGwpU7xHGFidKk0CuZypjPBCiLHt3qiCqPMWBuE6ESbTK3pg6UBTlhnkTfHZWnYXJPJedfqKDXRlPvrU1shoYbQP5DrUWjxkPZJxo1oTnoyTAegUMyaBjsWWnEYPui2B3gZngqPtO7th0FCAMw42K19lhA0Qpg0vaI+44Pz3vwxhjP4x/I1Vrlw6+HNyJHPlBH7SNNI5AtZrl7S9iyrbf3jT5LQBeLwK6QEsE9oMzEo2A7Vt9sY0bmBHkmkVXqklFv9OhsU2WbHJSzno0IIZkAaaDpRaY3TJ9ucNkMiMBS1acGwEmcDb62tQHkXx1BqmvUpFKHPDTKoTAl1mkSM3EH2r6lywX4iC6tZkmnWaLLmGOMNLs1ZSy61i215nOJLtOXQOgWOJ42YLQEPOlK3fIesLr4Oy6o93AdPM/ENFaA1oN2qJo+O8NeFyp9EsyptJe5SYtZRJrHXCQtABNMwLAHsoMUphDlgXtUMkXCS2fdPQDQoj2DuJQPrzPPiYF2FWEnH5h8T/rbqEOmWn/cOjBMiJ+zS/hWhNwA8h8sxe4ph+ooh3Wa91nDSKUn0BrYRW3RajpdfscTWNwEaxMm/GXKOE9cgmfNSifcL5TA7wXEe1LtVXC8kguf1h9P/bFPX9OqVezaS+f1qPEaTbKl1/PraWZZsJB2rNlA0eFkituoMEqbtccK/yk63gS0K6QpaHAieNBOZJfMm64d4YAcromQwz1LyARzKJBjAjDBUAbQ46fRxh25m3TMWT6NMMw0bJW2uWMqFh0bOG4A+Y8Jlc3EK3bQyYB9Lmf03TBEGpyekCLyK9HiC/uZxuIjQ5b7lJlHptLEKVFjzDxiX67vL36XjwDjGUPm/gNt0aC59LgL5cPrjZcr4HitVolrf6uOJ6JjzljURtrrLypFVjjZjjbqQ5TRxdo9T6RgI1xOYBI0gtgh40hpJ8dU5idHACPoY2nYjNGw0RDbWTxtNACFpWMYAe6MnF6AacoH/7Sjq8WJzfyj+alb+betDSD/gaLIGiSx2bzmcsMoJRuG6FqHx/QeQp1ZrHXIaNCgNF/M9rUpQ2tD37sKiESpTQJj0Nh+sSuzNrt4mlqfDHpLK4+/ixlza9ToCqrySgR670fApYDunKYzxnhaYDin2oTHPKOV8aRUHucRFNKYxDQAGEmNiu9lh6yJxhHwSW4jgVHCDtIx5lQ1wRXsHARoAtgXm/QJQBYwkbYbwEnK0xEfbkEuREKCgTAWWKRFOcA2gNwA8h9uFRMvX7gccnSOGNK+RHq7SKWxh7iLg0HRfY665J5QgGMZEI/HcNcAFK2bXZ+TFwGHJ3XBa3XFS2m0n9NjzqJFfaEBczNy5PUI9FdKCD0tEaUeWecdK+HFBPqsGxnzkQZZGbQxQVMZFzKBwgCkndwnShOYJtAnuU9AyjTV2ccJ0qRo0ITIBZSLj01QEUNQPsMQXW6ji/DBzJ+y54Hm7MBQRrgx9jnDNii+AeQ/VgRZlRwr5TA5cEwCmEYwBZhJT3O0aE8kS7OmMGWMzzGAXJkxFg2ZiBqfYfZEoDZnngt4jlebFOgpkV9Io3+VR32j5ngznb4FhsbHQbOfyyzAyPJcKu6SoXbGAnzsZiDLeUIxRM5kwc7xQsFh3pE2KTxpJpBOs6yoPZbh8RjnobsQoz+5FDWn+KrowfVGBjGRFkBpdHLIrwccPwb/zKlojZ7MqVrYr29rA8h/pBX5mpMYSh1yhCUbUpl3tKdCHXwGbE+zfakxPjcWTEodMNY6oz0h8Zm0+b7RvHmOOtVpGZRXE1VV0PA75hUvAKBuWbHeDZzCXfOPi0j4D4gmyeUQfN9EKr6vKCK66lPwWoP00GhsdcrUE4VSAn1PegYti8pw7MOIQxPEDCGLmMpw+B4qTRpoV8QsolZp2JE8hlsiM82OSBjT8Lwz/8xZ05QU6XUCYcUJc2NibwD5D1uDrCuJ6bc87Gcwq6wYhsJOFaGoTZiIEJ9BvsR1vlZzLsaIT+lWl851FPQXbBleAged9DUvpcXSn/8p3RMxPqrecylKvHeUqXc3NBYaYh+SYaZJ1qaNGaDcGY7NlgiiDTGwr0ziKCuRI0LlB9KR4C5Sa2RJRxA7gsX3JgbNy8B51CeNGYk7GDOGNO0nTfspTMSKTBAiDFULcv+2HZobQP4joqUIe9W4DwFbe4Y6Yy3wmSygSQT4mT0jxTaWn61RY71ARTBuYqRnNq3mIynyqUDF2u8rXtX3l2EvRJe90RTvONvwESfFC6/hEkieqpV396vU0LaN8/OEgpu6Jk83azlbnoM0KnMEfQKwD+Xx4q0tZbhCNDcEdZ3QMcCwptUMMI1tU6TXlklGqk1mI48ZyO/5cOizBj74UW1rA8i/WxSplmYPg7E0WIT9TBG0ffhP2x7GPRP3SGkP2B5WWDRmu5kxgx1phWbIXYx9cFd1rXhvSrkGDg/nYV9kwdxMq08Ebe8N0/mYoMWq4O7C0kHLKLcqkPcMG6F0h1WMvkpXuzZ15s+WHNIAZ4jhSjlSawWLxqIG2eYeiX00aJABHEuDLsNKoyaAMaLICp5mu2Q22dtxIgsNkdVJZwPIDSD/QWHSgDSkFNEfuINxT7MdaDskq6M6e7JQDYNPvWNKMzAad4TtQOwa3xqoNMT0JWB8NI3mWp2yalpWa9o7sbM1jHkZ9b4kqvGF2gdPJsd7kKzvuc5F0os1RklcC1cb5mGlES5fpbFTHW87NQ6zEcl3yB4ptWOS5xj1gaLOGJeJqKM+2CG8tUcE72AE609O7THSjsbjmIYj5Idea4PaAHIDyH/ICBI2wHahqMOSInMPS/saHbLOMtZo0orARAx+72gFOIsoBYAAV+OeKEIUD4Kh1sDxFqjpNNqcQ0498jwXwYz3RYf31BxvDoavxKsNEM/rlqTmURmvwGjFilWAF3YNZtpigNMchRYBIIMwyriDa4JppDBA5SdUZlgxgRyg8MsGkOKnxhJRhpd28HkSFD8lDQOYMBWieP06pPVG2rY2gPwLAZID0xApdNrDsGcKYIyOtdWZxT0shWdJ4pw+G4eWRofwRJ193MGwK+A43AuKvxRN9pqPq/Pj/PMaOuSvF9F4DnoXn/I0Cu4iTJKhCVlR1LumjSMUfur8pDSfRBbVAhvoGgAfBA7wAnQqP6kBYgrwU4rvWAlCApliOl2p/NUymEQrKrwGJpMmyiep6vVK2PrYG0D+dWDYFeQ1p4+WjCMtjUgWF9oA4xjgZ9XgaYQVsCMHoPwkRgL19qHwqseiCj4ATOCJOu8jlcNTJsw15syqWvgVHvYlZfJTIy3cEQF+iRXz+G1nJdhe7d0Qw9+Nb118bNgJ1KYaPWJm13hRK2/lhyInTiQYE91NNKNkCoBLpS5DiEbQQFLu1kqJhEVxWzMwtt9BDoNp+jT/OPjSqGxLsjeA/ItCxWkAfIwJm927h0iumTGlAWkYkAL0aBxBG2EcCyAmsl5HEUrFDiw83SpQgHJbjHiMxa41PRoU6FKkeEuxZxVBrmznZdsE3hzVeSCVvicNP7mdVx4X5ly87o1TGzRFeYRC4WHrZHCcMQ95irphY2nyGFLkbOBgIK2oYaQicGyAjMYKoFYiyfgJDfU+BVwHGBOGXfJ0mEArehobOG4A+ffAQi41Wi0BBziOuwQfDGkqFLUJhHGHZDukQhlkAb6oHwXgFQHccmmWoQCLKG67rT52BLhjPP7XyLVfzrhOGjN3p7+88Tt+mT5+Czx5x99r7oY1NWi+NCuCwU1jt+hEOtbl1RbMzBBPA0vKzAJ6YJrBjgXwPLaLA6VB7kOAoyLLqD+BYU7R02jD7pjH4VgkNFone1sbQP6xZS9eEK3uliGMPlnECmQkiB1SKkK3KOM5AXyo3OngU4/dyM6+AiKJuRaJrvZYQZNXmGPSdSy8Gj1ekDKTfg18O8vXuQTY6UX20mP1g+8z8YfNxPA1K9sSPXZVxw4IOxvbM+/sApSmog1ZIshqs7MAyJgcJ5hgSJJGOo6CD6XGOBY7hgG0AEFogDCQHKTSqFFr0ARARkaRICUKw8jBIHn0kTaA3ADyF6PC0+t34UBT6FeR+AM0kLQ0YEi7ovK9Y9QNd4sLuSOxn9PnqsbD9jgQI8wWAEnw60o9a3XDi8PfXALm4ml0OQLVSV5+Zs71B5y57gXpC1Yt7L+8CyB5cUeRgn0IzN40laZoRPBYeuoiAjQbP5qIaNEHuI2UDjAkRmNmiGgSg4SBYhJLFGnZICa6EsTQxJ3rltaiUiE5xAFmyDmMa7VpQm4A+WCK/Idkc4rOJeUNA0amMcAxOtBRY8S+ixR3MIvtZmNLrc0GgANrysSqB9jqlQPjerr5JrsDXGu3XRwKPwFFnYeDelS+rOLkNQXwRdj+i8C49hx1XOfK61sC64qxWKs9ls0dSBKaQdDURYroxn2slzwiYEmUQSpjOrWu6AmA0d0AJXoy0Q1uBriF900YLcDNBI/naPVLkEZzIWE6HsGNib0B5B8YFX6lIkcBYwYSaGZWO9Q90M21ImAgNLRu9HzbSNYuNUMgFYxmjWEHcQcrvtbXIqCLDZcLmo6n97klcnsRhGrNYaWux2vK4Q8yYK7dfmV+kvfc/+SxrWnTK483OmEAYz0zUjOaVnzkqUZmD7gSaR6gFl3qBJcBiapGN9HxNkZDx1TVMQxW5KJsblGrXI+fTAkKVd+tgb0BZPcG/s7voA5Q2OQYLaV5DKcAnjCC6tPkWdKs2ioUx0IBT5T2MDyXbVXt5xnEc6k73QRD3QOO9wLrCtjpUpf3KjCuRYg36H+PjOzcy0rUHRRGnYIkTmwjsBCl6BBxlkqrVUyd2EzMNxlESgrZHclAFRsuWknkQ1ySMe6D2sQJDmupenO5LVL0xGFIPljxscWfGyVsALmta2l2MgJmI20oplpVrYcBbGG+9QyEYo9gz6xKPuQLwBfAXsr9Q9ACKD419sx4vuER0NaltHuOYG7XKq+A5EMp96Wi4C997idAJ6yn7F9J17lSp23beSKHdgKcpuUMJbCsSc7fA+GWSJnkBi+D34YEZyJkmoEwle//jDnTmjRAbeiUcR8bOOwM8jAP29YGkH8JPgoY05CQdk+0IaTLtJAvewaKbmOA5p5W1Xj4VMy1omFjnJXBg01T2DYcFuhSDzZeBrbFMf4IFXAVYR8tcXwBCPkFIHs0erw3vV7ch3NTB7boSuuEU77obosnNcyz8wVb53nuQg8dGI5lznEGR2ko87ED5P32erFGPwQGmiVNPgnaypAbQP5lywDbFwHbJ0j7rimzbyl1a9hUr+syMA6OIV6BodALB7BrzLDOx50cuZcGtE/51l8uHOhO1HxQoeLB2uHN7V9t6twKaO00NT4X0uBC/af8Ts5Ne52re/cKPyUljrEdMIGNUhiRYwVQ1rlJWLGGteiEy0p3qBhzK81VH4cEunubpNrWBpB/fs2x1sRn/2VDSkEFlAojJlgysZPTQCaalaYNE2gh+wwayaCRkWUouLgvRWXKVg9jPhjp3dJxvJom8wFQvXHbvdasX603XhCiWE3L7wFldrYUXAHW03lNzEDZmuF9CHmqOVlmuCkyOtp1XKcMjKr8XHzdbShTi9NhdCPLrJkXnrhhom/1xw0g/xQoLPtVB4ZsvvJRfspAolk545ezeJjKtR29zqhJhBnLfYNeRrGMZ3B+DIJjrQKY/Bpj5o8f7tAV7NXt9NpOo7A/MJ0mb9+NvBtYr95+OrzOlQ+9NHfOt+NUBINoTyMJjIFa95i3JCGSgYrtxCyYAe5xCoV1NWUS8jKWK8BlFGgubVXIDSB/JSyctbhXgFAUvOxh6lhoMXRBErQQFKgRISsoVtCLCFFIhWdbo8WhCBeMUTdSAi0Vb5lyPz02p3Ft0Plsu9aBULeB8XrN8YKT4iPp8D3p9DVg5BfHh8g7ouprn/MMknM0WbnoPI9mibC89Fbu5Dw42g2kspyxFyk1SroNwj24CiqD6xIJYcj4k60zNoD8326KjCUYegHDyhI79XCqwNiuG81gg1TmG9l3EzH0Iz8QhmL6XpV5BoEDIzVPqCl4KbwTLFqAN470K6Hi8qYbPtdn2++tN57pg11Opx+NGB+sL/KR57p3jrSf1TxLtbl8rtNJgf57WB/SVzG/nOV2GkUHlPt8ShYgiY3DqFhF7LFPe+IOwxA6P0cD8nFLszeAvJYir0eFqiUbroBff8x3B5PIJmYwZJjYgGyUOHKuPRZJMo6k1WHwrkPJgf2wONBJoDVhitvptc4P8NU5yNUBcF4AO8xNilMwuUgb5IoSz+m2B6M6PQBsuNF3+cqUEU8+5C+m6GcBec+o0QnALd/n7DfLk+InSRpNDkIl3fYyLG5R1yYH2n4H7HdhR7utDSAjQ12PCtu5+VJUuJDbZwFPzqDYgSMgmhfmy6z8XJkzvTx+6jrTPasmGjhWbouIMYEYCKujGnb3kXcPg+ZWqtiGn3GiIM4rEavujE7u6SzrHHAeALaH8O+ujjgvn4luTBEsyjenJ63ZZpYldSak+GmVHWOxzRHy5aDRRLkZVIbHi2aajISMoUOJMmAOg5HcDxS5dbE3gIx1HJcp8mlxmheiQnRAqH57N6ZBAKmoSJvLQvCspdKJxjTLWC3GdEpUiQSL+iNtTqeL1NUQ4MiQ14/n5FVQPEv3tLR17g/GPqpbOYjPUsirh5TuRCWtp6fXRn7uif5Wosi7qYRfHiBf4VaudbYXpmOYudv9/qTF37NyojR6EG+KmTUZ0kAsjyNoRnoR5ymm1yajF+YNW/sw6pIpmaaJG9dwA8h5t+VJinwSlaxFhOJJSFBEpM0FK/oDptn8aKKQHBYAaKns5DHH2BTBm0J4iRyt/R56joWvzSJYYZzT686p8CwK5LVj90KD4ZKd66Vo8lFfmVtAdJVeyMfCwXsbMw9NJz0CIPfRLBdNlr5hc16LtK4OWZy2C32QNBiIXFzDWFNoI1yRSjsMFg1Bqj4WRiKBljrtoW1tANkD5bWocN7RKcA8GomnQMgTycIWLAikONCsT5lDXKLWGFvKXRR4qPn2XsgCqhYLJaLkWNRZ/rjT/urICW/PP+pe2s0VsLiHT303mF3zkuHjdcIvf8KXBukxa1+e1mD7z9JOuYow0AymBIGwAoSOUPThDHwwhTQakYSSkgtGIUGWGIrk/aiZxQGwoeQGkADyMNxMkXsgbNRZ4YxxIK6DTXIlkDtBA6WhjeXM4DgCGJt0mTQuQJClo92zZsCui91Jml0DKd4ZMX7l2OdKREqe1wm/0rj4EhXxzsfoDpDmpajwkVoq7wRPXa5Hxv5pkKWoM2IeFu91Ho0JXsbGWHxoiKo8Ps/gAjXKjG2EGcyU86Z5tgFkLLdo+FEFDNEBoS5HhdeODXV1S/OJgAXIteaMauQ3G2+BdXsFvXkUqHa40XFv5/pjHBiXAO6s06uLL5h9HXIBdDitgy2FFewKcNyTxv5BPOqz90RexMA/Bowvdfj5hcc/9Ak08kDQCWmwwqxRFwkGOLL9nEE0tVTd0bTtY04SxLSN+WwAWdbT8Twq7Hdd8fZxeP1go4E2AJYgjFKbf0yd5mPqQHFu0MxjPgvQnB/TUnTe9QJ1JeO7dbgu5pD14AdxAzOkP/6AvJZeX3xdj6TVp/Oc94Kj7svAL/9ZFuZURH8qHOsZFFmHvsvJrvpWnEvhVtXezuZVBhzp3AByA8go7+jBqPCBIEcAYSmBqZgkoShCl2gxmi61ez2Uxk0vPNHVK2v90cYSPVbHwvRYoKIl6i/k9blus3Dtg5BWZiVX/rBuRGePguRaNLvaqeb1RtXNCPfRbvUDe8c1kY+T5vb8aTbB21rADAa2Y/4ioxvOLpVe/7wXX3yVIaLlTTN3A8gvR4VXoKAOkTvisiMY9aLqIseRxgp01dq1gKLNzZdeJTy8sUvE2SLHoUuV+Hj6ttJ51pXHPDIzeZaW4yaQPYota4rjIq+PJf5qTfOPqH8uPi9bfkDsPzeenzSk5dxEhIg1mmQbEq9CAIboXMeJKWYd1aXntTZZapJSMYkQaLOq77b+2QHyUTCsd6+kLqEMl+O81O6CJXBUrTHS0gx0HNFqiJyFTsnOxlPWakPzdjuPDPRARrfWkOHSJfAMYO7kG6/1Gppg7B0D6GvVQi6UkC5yp+8Gx2sR62ogrMeemFfS7TUOum7UPU6mCBimg31qXT4dUqYY41EXPc71x46euGDicI5LCZqBoHKeNnTbAPL+qFAnoLh22NTj2CTICIrE1DyNizhplSsDQJiExFm6qqn7FJv5viBfo0VbKPl8hRN3j0DFPbKNq7YC10B2BZTWbBZOwfFugDulOGKdHdlTIi+Bl+6oT34Jmb9Yt7l8X56dmYoMRciZuYAOMpuquc+WOL04iMXsubtv6LYB5BIHBCBzmSpfih+s7VMsx7Ha9O5hHLH7PMIMJlZA88Q4PacuEizyZEyFDdFGNQTYkqfdUqOTbXdENLoNkjc72NeA9e763BdrjJcaLpcYPmtR4d0iu3du/MPTdD12xz7gLkXI9rpcVRCX89kr2DSEF7k5XiiJOpMl2++f8wZvG0DiwPuiwqYt1YFhm4sIBYD2oB/jC/afR+Pk0b1m6DRKlbFQ5xlhbGl3qz+WGqSlpbshRzCUxFl52v1efrXWt5L7drOLPB3z+VLEswaouCNqvAaMV8DxV0aD+IvRIHm5pnpt21dwUme/Fi72EiVrs3px0psp3IRbFH1IwJqlrOYsoLowpqZfsa0NIJG7E2kfFTatUVRAzFHJlhpAzjvtfDCYVIWaDY4EFukyVNWdWaWH4A7V55rdIDg4kph9sVGvY8fZ7XBYrQmsAcDpAX1Bv1H3pOE9uko3gOYXOtO883638OxeaiAfiHLXOvlfiW4vPXYxd7oMgVnGcjo6Q1ghigyd8bIne7FwDXL36Q67/GvdmE8VDMKWYm8ACQCJpylyiQyltl/VfUtLg86L2LH/PNBypQpyrBauNNsBCN8Zsxn8gF340mBPYA8rBlzEvt2/XcceAay8O51ezEKuN1x0K6I5HeW5ysZZYc18RYX7RmPmLNW8P2e+oXN2B1heGsDnF+rBa6UA6kQhafESy47JdTk6dc2Y5rsQE0FyoRfJbT/bexDhkvKWYW8ACWDHY4sKy+n0fjA8jagAOA1Pb5+jkPYweyqgtouLdqAVUNSumHPtYWHa1UWHBTzbTGQqqfUsiXb+p3EzT66jPLpR/bo1C4k7WTtfSalv1R1X73sniN2FXbz/5hO5u19aC7C7cPJZloytT3xQxyCFogXZCeqqbicj2jx5N2xpE2snG1sXewPISIn95NDnHQWibla3tmbUthHwofKrq64j4/cdemZMa7hYKIWH7Fk1dK/d6jR3wUHQbrdpz7rJt7UJL+LqqljFhbGgPxg077ZD+EPAsRmAX3+AVj7TSxMBX0fL5d9YNsy4SAeqsk+Z/xG7HZlGmLMIWbCNCVVVn8rL6XdgiUyJrfa0rX9ugLwnKqyKugsgXMPMODCsqPDOIraVI1tNucjEBnizswhqx7tuJQkjgyXGfrznygtYi8wYrnUV1E4aCGemh6fNnUuKPmu/X/0cb0WCvI1n/IWvc7XWqMdS6z9zXfp8z8evoj8YquBVAr9IniHEcOmEifQQk2qRI0m6OH/tZKMq1hkgS3bUBpAbQK4dOeJ5VHjxroxR7sL+EoHkIkWr6Uox5uIcAVZV6AKYpBGsoz7N9rUOlbPnZkc0ao+hRnnRlRxxqi94r+nUQxHiHSn4nZj5kMTZ3f7W/PPB8F7q5EWlcb/6RkPbWTXUbj41JZCs8va92s/SETMAc75NRUKNSjAzsw0gN4AEil8WT/jJK5hZTszhT3MlvpEPQNsxh9nUvamGJ4KpU+cJebPmca2hVwwXMYRgbk3NT10L7ykJ4Ob4SK1irT7naqNGjxUF76xD8lfS1EugxDsB/HbH506Au6d+eSGj5ok82pmKSnUshAXf2sIopPqlCwZ4YV3V7QrFHyBhJiWksu/V/bPN6BJIiXMLfFv/zBGk22pUWCNC8Xqoo05SyzwTk1LImFnQC10JVpwIyQHSKGKg2PxoNDsczp1vFWEKYWw+NPPA+OMBcg9w0nWsWHMrvGrt+ovRxq1o6+8WzDyozMNTEMPFsaKeP64awbMpRMzbVofyT9TGVeTJWKiq3tLrsAaGJdDjpAwZScqQiklXCnJse5FF+kzsMpxC5trWPz1AeloqiF88dDh7setCWsmMZMIoFFuEohAuYmR0pkvDxsIywZpi+FjmHMcmacbF3GQ19Upf1hpcUwk/w6EiknVmWK91Tve90dZpFHTP4PZXx2UeCvluhXRrz3+RmnM9Ib7y++WXd6kmiSpO0UWDpc7YG7abAgtZOoq0SN2tRJ3ejQN1zSe5/lCB+g0g/0MHkHYeFTb/64f8i5ico2wItR40t8KRVbexeV1rDMmz4o+96GxjBsTwu65GX8MsWVP3ZrsJemcH1+nBfNKNXoBk+1M8twZYmkrcD9r3sGp+ZWD8y3NB9848Pj46JF0GHOmKZ40uRKuVPCNCQYid3dfqV7XouGmefGDYxrJeiRfnZUaoDEIKWZuazwaQAGRcgOJXFiWkyQdkjS2VXgjhdhcV/nWzcsWsCr6sVyY2znb5yXs7rTeYHbr1qD461B0NnBuva9EMwtd1H/jAjOKXc3R+3ZPrSpAprZ1QrnwYZ/Jz5xlAU7qdwbDTV5EroNJBeCGUFnkBOtpj58fEdUqkMnxDyA0gC0A+CIarx9Qhl0J4a7DM4MYGfkvAi/GfVFKg0rjp71drRqj374I3XbVhvr3tRm2xDZX/icfJWnPmq6K6X8mwLz7HtRT8yoe+ep7glRrnLbDvgHQ5dtPoL6IVcJMHJs5A18bIPdKOyLBNwYf1yBZK7LiY9fKA0G1tAPkYEK6AjaQoZwtUdqNZmVMMYCRP/ENYZcpi7ILhIpfa0DiUoBjtERkD5EAq3iI3lLmvHP2L8Z4HdB1PZ/CEO8ED66rdX60xfukxl17PtaBXD551eAEd/6D5yiage8auEYxOD8LgLGWG6heLMuRaxAHiu6dFbAkxvA1rfbkSyIwCo7W9rQ0gr4Ph6X4uzYopXUOYkBmQZEWZp3aohehYg0Mx6Jq71IV6qHAzLE0dVvrhrt2XqmwcnqdmvP6ia71SVw74K6r/NzFHVw78O2uHD2XFd4/x3F95uIbv94ejK9+Fvo6JF6PJWXNzKT61vNYjnpbbOz4tIYii0ZVLHRJFCy2I2FsMuQHkBXAsALgAwwXIsDPOJDD5oBCcGKHCsxYHUDGmEw2bHRoQYoxokWnuWvdpOVhqk0Nzp2slpu6o46zAcl/080gKvlK7/MU0+tJLeIhSeEkJ/I8Aopugtian/EAn/JGywZlljU7UfSpItp99XdEhOUOYJzTGQcHhkBykg/BIyymaMkSX3CHP0M2hjm3900SQfh4VLk++TWm5sGYsrrNofrvMjrl4zqgyYJoPMecmTKUZ2syWQSKZYDSYRb3RYqCcjVVTa5RXOrvU3Zh4KVLUtcaO/mDQ6UDhvDFzi5r4R7sfXgLGW2NMt8YGTk5e7GuJuuN0sVbWaFe8NVoIDyJpAT15Ab8KkswQPBo0AY4MSy8XrQBmbexQ8vi52XZtABm73NSFhyWLlYWoaBsaZ9fpLjtq7f2Zy5jdJBqNQ6EEhgCFWYBfAGKwaKzUG60waqqALjqmDdmeo/jXnKo3rId7l2qEPHEt/DNt4R8Yy7kYOf4ZPtlr970YMfL8hgVWfkWk4/og+fl31mcK3UmbnKNHwaFIjVnEywCbz/i19lhri8FOjG3mdQBIceYPnxBCFElY2tBtA0hAA5dRYZWw73ZslsEIkxfR3Dk1H4/ZPCPNEV9REDdLsOJIWMd2mnpPsX61JmjRHAvZ0xKtWTA8UFC748B9NG3mFzLIlVnGi6rgizHDP7E9cFfPhdcdHk8/mBrxrvgG19nHanFwxqY5+6iW85Y6He5fUnYCAJtu5On303X01LFkmoFXgceS6TSHQ0shZDEMG7ptAAnk3XBWj6Q7rIBgD4YrxwddiLTainyZMQFWALPUGclEa4yH1HnP9I6GBhYvGslmjZ8yyc47wFEXNuoLNcVrA8w3QeNPSodvFjEfuvH6+76HT306m7j4CHgGlGvguZpWN5nGc0AlyXK9eln3dq48uZw6Gp46YgZQxnhQsfqSYJTn6c/MMzaA/I+yzL2BYAXEi4d+BUvNdi4MSleCGZGSlf26SpOxjfbADLQibmZF4ac4fs3PVpV/ak5vV6zfrwDjg/7WX6kl6ko6eepw2PHVV7FngREX5NOuzUBeba58QXziUvR8IRXnH6L9+Gi9YAmG0upkeedSLM0/1f+eQTgc0bmWe9bkRz9s4LgBJDBMvgqEqNFjtzuKgFI0ZzwRzMJwFGXNuJ3hXMim5QgjaVX+DAajFVwttcnZxpWzrWvXwb5w1FxNlS+RrU9mGr0eSbrjWDxt2PDOKOtGtHaNYXPL+6XXS7yKhV+YublBtebf2dRqEXESKjaGcSEcKqZJUgE9eeEhZoV2Wq6/g20UPDMaOJqfR06XzLZJyA0g16LCCoala+1V79FWSnBGkyE1KalZt7E2WWIQPDKZ2qFOMzCWbjaaDuRyW7BoLqerp34li1rUyTykLoAkihL12X1XuqlnSHEqvou7vF5KRe48FD0zqlrDuC+6BT4KiLgs/vvXCjm0dnjpSiNDyCRdXoASZZyn3E5Et1qUR+OGFUgFg+hwGRyCi5JMGLYmzQaQsbsJSCFt5la71idgWDvWJSmJpo2DjgTHrBzulWddtqnxsZv4RPzUiFD8GcLQCyOBHVS8a6CxGHqlS+DYWXqeBHo9YPIc4NZEc9GJVKxg4GVOMK9ni8Kyr3B3VFnPUmvOgCcozF8MY3mlhoq/Nmq88AF5ix5Jh6uY0eCEl12iwlJX1GJESJWTXW5D7YoLDplxS683gIw1PdnZuRmO0qRpu9GZcTZJ45SHxpqpA+DCDqoApzDoUpEuqw6Gdai8SpyRO5jV7btuqJxtwucKW0+6lnrzel2yA7MFSN6Vyt9Rs1yJKolbKuG8An4XwPFXxn0Wf/NaevsPkvOwgOL8ZblqxNgAsESKrdZYLl6hsNYiG4hW+HRgA8gNIMuyTt+kgeGlslV/3TXAa8SHoA5WjUez6kg4CtzNWpDYlVnHIYCzsmwwRByLENlVEca90qOYfy8Ubd0ztHwFxNaz4a+B4yob8E7zrlVWyVdMsW4p5VyLcpdpfnzW1040f2cAVQXBGk0uBI57hk2fKFVQVJ8WqEalNS1nliH9uSIlG0D+BwLIw4V9fKV7qTIjScDsU4OEwrFuQrdBIZRi7AelPknFthiwTC0F78cupNLcOTHl6pBxrWcxzwI/AGjSdcuFtZrlnRxo4lFJssvAdFY6uPakq32Yex0KT3FVN17jX5thY71bXSPFHiAdkAvKi/ucAmywbkJ6xSUdPzd03ADyQgbaWS+0znWvE0GAWUxZqUmYVfMttmZNdZAraj5tdIctWLE2lF7+ryOPDYV5T6S0ihu6JFfzgHzZmar4bYxo9gFNE4G3Azud1DfuPTRPRojuxq4HS5ZcZcTcW9/kymvm+kjT/ZWLXtOxASJJV4seC2smrCyjBVc711oAqkhIEEhTONeEqt7GpNkAcg4+yNnW+oa5VN3FZXUEh8V/2KqBfMhH22JbBURidjhsQEhyHuSdx35mhmFpTlzPovs0esXLpAeUX6UbCqtU5dP65UWgXO1IzyW2i5YHa6B4ExzvFLa45Fe2qgauO2qla5kIV/je95zxzj6HCoTxzITgJbKMlGJu2BTAZFE4mzUi6/6nOssbFgyWaC/fsXGxN4AEAORhvTOpAmxVtb6Zc5FIx0N/pHGOJGcv64UWZBGdYGXNWFUUX3Cwa0pe+dxnB+Tj/RLhTyNDXO35PKD/eM94zb12rldT+A7R7xkf5Z0fwrXONtd8ePQ1YDx/iVzJCrrh8YrGoRYpNJvXer/Um71LKrNsAty3GuQGkCtgeGLepc6wqqMsIOUc9UMVIy0plfQ6LFzFkVzImI0hfMulCVf1p0Hrco/F9vVB58Lbhlz3HXwnXexbPlX31h5PRR74SO6LFVWha6LAN/723X+aVyLHa4B/h7/u2gd699mvKegu+dWz2+HyzlqJn7VA1tK1DkVy5UnyjI1luAFkiSCHhZxir+NiVcG+bScsHxOFQUxhzmWMBg05NqtXY2ynjZ1d6wD2ornVpIvVqKuyZ9KXHP1upmZ/wD5/BShVHOlPr68Cxa2Gyj0WOLwRYd4Lwv0A/NX0erVDhou2C3fVQ0+sFO4CyVY+7LQgq9CtuvGdnlqIbvynXTKADMil+AnPDmaBxy3F3gByXuatldzA8HTyo2mgOA2OAMcqU2YYGghajR41G3KxRpJVvWc25wqFn6oPaamfRr7lVKC7rBF+ATR1AZUu1etuiWjw2vNfaQRdA527mjT3AKge17ZY6+4/7AqxpkPKi1+I1M0uFoADCl2QhU4YIz25aD2WrjVDIDfmHHOhFQqkk3A4Y5Yynn9bG0DGGl0LMKwsOy/FbHG+mDuHrEEqijxmiUXDMWiEmPUeOdcbuRDJpVWNSLYOeDP3Cmner568V0HyJDzWSqSyBpT3AOwvWRXgPGy/9MRnKTrP8/9HP7Rbc673ft6/XN956ENXAFvpYFfuC+BBNSwjO0AuXe4MZ24CFV7AUl0nXLEKrDozvXIUtrUBJICiNlophuyzHi2yGicBVxOZYDRkAtwC9NhGdyoQVlfCyr+e5x+LU6FCO7JSEzmrq50yZVaZMxfrdHfWLO+OLrl+261ZSF5Lp7+wbS3l5bUX9PUD/SKD5lpK/+hJozfbuvn9UXFqK5FhAFzhxhRlcK/pNWfjrn4+cp4pnS0aamqefaXTvq1/aoCcxhUwRG3YpKYs7pbw/O9vJkcqQ91prh0yNdtWIYGyMjgeArhAgntEmVbuAyWhCO2q528vpHqv49rdncYb4HnLoEuXcYf4RRvWR2urWukc64Fojn/Sa730XGs1kdNm0lod9MJ3q8aG6QAOHVGQlYKoZYtG1air/ITUWjas/pwSubVnNoA83elood5DK9dt7mq3QmVEj8xuIge4AhSNEQUCBlNv1Tor/Aizko8asNaa5BD1TMRjtHKQ3Eu/u1cX8lqAtsrHvvYUus2e+fIXc6mm6RdA8o/A5Dv9cPilJ7+vPnHxxNc1XNTnNn2jpt5NfnZ78bDpeKnqTbw8IeeKrAReN3zbAPK4f17OPCJGeSw7UnaknJGmHDHl5ElQbbQEGNbmTHSyB6KCXlwEVMAs9ymKPlG/HNs8pJgekoshz4Vp7wHD01T8zwgX/ki8PIu0LoS1d81T/kGvlV8BxItpwFKeTteUiWs6XJ5IRf9xaQMroNYdUW+fa44sgOheFYEESSSzAGXiLo3mbf0TRZBpygGIU0bKcd2yN53IMh9JuEZZkSkjB0ZKPDQPmRi+XUaJqBJo9fZmuVAFKazjZl8cX1mrP9JOJc/0ZcDTFx94V/T4q0fbaf2SvAGOXwPGu2qOvFAGeMhojJdnO9ttJyZfVTGcFOSzOk/cEh1rMFwN4wWFhSuQQTojN3e4qud1GfOBE8hyd/Pso4JUswHkBpAAgO//9XfQQ0GqORcWwdxc0m2RGPKUMJWxHfWeMq12WFJpW6TXxblw3lYEdTtzruZbczP6wGXxmzYhYl1StSaa+1X5skejPq78fknz4dG5x7UH6aSW92DOzWszVbzzS3gkqlwTO16tvS46hl2HujZelAlkkRnS1EZ9oAyyiudOAiZIE8AM+YT4/SjpCPcJ0zTR5WmDxg0gT5enqEF6cTaUnbFqOExT1BFDFDeRNszq4JzBLrrSQwd6qabfkUJzjjgDHOuw+Fm4yFu83e7IimboykjPpZy1YUh5vPqaol2sNfaRJq8XJ5cv/StjRLhQsjtr62NF8fw+pfObUeMtcPy1guf8Xio/+vR9zL8L0gQhLsAE6AjgWMEO0BHSJ6BPCAdIB7gfJB0W24RPAAep3N/9U56Pmw7kBpBn6/N5V8Z6Ouvp6iBXJiaSaMhIcnXWrR0DRphTbHbWC5I1a9e5822ts02VIfGiAHTxOOSN/PESV/tC6NYrj2vpvXzRAqcDR+JP8q2+67n460/+iGXtrzZ/bllE9Ldbdz+enJ0CAD/ni39C+IR0EPAZQKcDgOMMhDoIOEA6QjjGNi9A6cfYrsmPH0cKXns3y5Lmtv7pI0ieNv1avhoTteMEQ5ZBSOGuXmYbGyMmhCoC+MxiqpJW9Mti7CfMvGqqXeXMbP6dC/y6HwC0PPZ0MvG+Kvx4uwN+Sh3s7yNqFThXwXM1urtEmH5Ad5G8DwH5YFr95b955+23yhur340yoINchwKUBziOkI4Cjg0AI4KcCosmrkeEeQQ0xQUZqCm3H5F9gmtyuf6hdC83gPxHya+nJdB0sSSL6i2nCXKVKI8sAtPs6ooGyESLMdvCnAn716Z3ZiFs1plzwdgcEBe7Ja8Firfz1DVRh0td7K6Lekmu7OxPLWjTN1Ju3vGaz6hM/ZnrEhCtjUDdoP3xVs1xBVx5AzBugaIe9ONZ/biUpVJDjPQ6n4BhLtzqqQDjcVl3RI0gSyqOCcIBjklTPiq7B3izjKJzyRHf1j93BBm7fyphXS/qbaBPpI6mascKVS51ifysPICh6GOFXNhRChu1cGbYVMphUBOvna7/iP1UuANwq9/TnxlFXJqvXKM96vbnwQs58BprZzERsMK86V8L+cd+Cfc2xtbv5129sUSBOqIBZr1eAbBFluU6Jni77xTCFIhmDe0IV+Y06E8tjWwA+R/5DewaLC4Py6IFQBBmiUkGs6glwlIBvQRjpNxxfYDZwFJr7JoxVawilH5Y1H/QzL7srvTwLBOdN8z9in7kh3MkpjVgPBe3OB8Uv8D+uLc+95UaHq+lsHdIgvfOiLiXOscLAPzFyLHVFXnh9fFyTXK5vUSGNRrUsVi7TiLL9ZY+RxcbFp1qVb9sOMQM2kQoKyLO2gnPs5Yf54SHG0JuAAmUjq1m/v6CgABQMMgGmIZIk+sMYxhxhVgFxhn0GLeBxaWQI2A7Ll0NRwgjDDuBA8+Q5AaqrPKku0ZNa750Q8jU8qkXIz9d46YdLbqetp4Fg3/Pxs2tz+ce1L6Rkv8KdfHa/fq51btAUiWCRIztCA4pg3AKLiKAkJyNtyr4sSn/eB0sb4o9ksuzABN3dr1EvK1/4hRbhw4QV+gYk3bhXsgKbvsW+Tl2gu9oFo6FYe+6EzAGS6YAIYsd7GzutWuD5JLNDgR6DGS0fgTyNMjsGzYtEjw14ekroBfGxq+U+/5UyuEquGkh6r4uxssruHnFW/tekYq7rWk4s/vOhgp4rbutEiF2M5DwOuuodjZvdciq8uMtNZcyXBOEEjnWGiYmuB/L/TZg3ADynmii832lwImGSaEEHkA3NPdCFf40rQJgGfvRQHIsjJo2ChSUQwxFQbyojyOtkwt5O5o5HwX5wwqUuizLvdJE4e0I8tLg+MMv9RI3vYt8r7m96s/1uOYVcA2QrDXOcu/bMk25gV/Vd4wGTC51xwx5BceoOTqOqg0cV03LJ6l0wFVS8ZyPcB1Xm39bdr0B5LwzOLBmMwAQ8koJ7PjVTSh3gCGxCU8ggRqIVBV+hqb4Y8WPJlg0s1iunU5kn5hA8cGj80QBTCHPdn6nvra2oMmpzULqFBG1gjx6QBrrHpB8uD/EyyDOL6TYpzXCO6LHBeDeaMbEzY+MXilDiFGeiPxqB/ooV5lrxBHAAW1YHLEtRoLiAh2IyprBAfADPB9KpLkB4gaQ144xLVTsZ784gblZI6SZBYNZARyc5x2jITOL387zjbNj4Rny8TKN95Fh5j6i7A5A1oSbV+TOzM6HxtdA5M+wbBBuj0BeVde5p9N9y5EQWHSuLzFneB4RXkHBGyB5T8hfZhmhI6WD6vA3yhwkcADL8HcbDkdcJw4ga9c7AJM8wOwT1AHOg1zThowbQN4+Zo9+pmxTsILR3yMQBl02k51bRmkhhCJBFBT+muxTvarAZ12bmTBoFsa9O4q5lXp2L77ZxBKPmRt2jBpdYuA8gOSr7JtLwPhQLru2gV3aryvnlNPz1Bci9lvfw33FyUv1R5V5x0MBwwnEAWAZCMeR0FHAAeBnA8w6FK4aXepQR4BU0233I7IfQ/FnWxtA3lrela8SIYtJR5tITAC85pHNpIlN1eLU0zqGOsKooabS89xk6lR76vULGKjHQfJXapEXvLLnuchr4eMXClhflR27aMTFk4hSq0pIt/8Q74oeH4rsV0C0Rp/qJwn6OmTImB1r9Cfw2FEDD5COoo7I/Sxk/BS81h5z2+YFGKUM9ymix21tAHnHmp5tNtEsO6iMGKaWFs8WCbX2uFDgYQKtn28cFiZdYacwLoBxlkI7H3r80qjJuhdNSP2t1yhX5yEbuGAxF4k+ab/kRHiFw/046OHBjrG+9rn17+dGzZH8ol/3F3fLuaGiaKaoRoCaShMmQBMdtXBmzFQ+dtQdm6iFPkE/gnRcqoX+qUKhG0D+x0uxGxIYNBAaEmzK4O/HBC+qPNXHGp3mo5V65Oxa2AlVWCqPi+ZObdY0cV2kk+r+18HxztrX5XR6pTOs00YOznnZJy94bcxHXS0U96bY10SLeC+6PoDEQjfMfQFD/whwPPluVuuQsTHP7BgdJU2AH1rq3FJobw2bkl4fCnDOQhVz5/oQXG4/UDqSRR1yA8MNIG9m2P/yBCUL9xgLkLTfD8Z8nO0QwKrzWGTNMIamY4sYUxHQ7VkzKTyx63gPYjyIHGkc54mTC/WwK/XBy+BymiqfRJFroSR5/lwL1sytdvP8vIKfgKQW/7OPNM+e9nQuU3cOfK+NIC0fG091Wk/l8iRB/lpq/YVT8wUgnapkWSjx1NpidKhVa40hThE1ygqkrgPcPwF8tqaNynX3A7IfJc/96OO2NoC8DpAvI+gCJgc/DrBDRvr0iBrnwe5xjiKDNUOWuciwTRhZwK88prJoBiJuh3EE4iLQVjUW7vE86UGSF0DS9QdFl10auqAiXjrQuYDE9UHNa/7aK3OMp0ZXZySfJjF0Ho3dq6t5Lzj+Skp96TtYbnLUMZ1FswXdxQ9wfZbmzOcCBOvYT02tu2gSWdGcsQ20NoB85A38D/8OfE7g0YHsIMDENEppBH0IlkxLjWcGTFAKi/0C+tpkNzepoUu1E8LzOqlxr3/BEfCa9estwYc1ZF1THL9rtId3bzsFVi6iyRUAxBVAuUXJPgPHr0WIJP+4euMaSHIRaJdutA4xx1ilygIcBR0A1qixgWE3+jMB7H+v85OTTlkz29oA8q599t8/owZFADsLWbNPTyWtTmLpTLPYLKjVHYuTdtlmtZEDxM9WvCpajyQIqgqlrUUmq5HOSs3vhjXoldLXjed/JOK8ZC7FO4qHfv46pMv12EdOII/WKq/InvGesscXQXJm1rTPzkMBPOqMRei21h472bKm6Vhpg5U6WH7XVOwWqlnXBOUMuD801L+tDSABQE+AzOdR7p8Oz8aUShIb1AeDe5U2qxaILKDImW1HFo/rGVADNGtUWQaJuFJ7vDcauzD0rXPtxjMR3a8cCSuzj6dNFy3437r776h52dt5in32UxfqpZfqkXH/q6XMS4ybZkXxdxukVtAFC9AFIHq7XoEweNmOxqmO29Ru96roE11s6AgqhsWJfNd5jjGYts2QbwAZ+8fYMWlcUFbxufZwJwwxiWK0pdqdHgQNFBOoAeIQu5UGVK8a1e42xy7FTgLTZQ1WXQfFh87+OteluJU2L+p7p1zhy2wc/uLU90WhC30xijw7d+gKB/sXgHDNTuEyr3plu/qQulAJe6FbNb8ZoSmGH4DwlEFr4hQrhZqeS5+oPjSeP5w6inTzrnRSVZ9Wrm9R5AaQ8/rwaGqENgpxQKKQJCay2LqiORmGKZercK2VIFaLhSFAUXVGcqYbNuXxe3yveSMdPh2KPk2/1WWwhQ/Dk71+ofBz5WiQ7gYs3YVmOolBr8mN3UiDr4HdWtR5+r7Iy+aH1/72XUo/V0zTVssXytVgC+EvcwDwgeo1IxzCg8Y/IXwUIIzbomP9WWqTnw08VYCSJQW3IhRuOPc105ZebwB5aR1yJxYKs1DlMULWjLbAct2smGwt2DOFk113NyupuZFWZMlbQbI89pLU1o3h6F4cQpcOyEK36+mGF0HukqXCrwDjtZok78K3i0D9R5pprX3+Z6rjayDbvS/eqAPfx1/PDfDAg1TNuEqK3CJBHdq2efwnhCeqkddML2zNHicOcq/8rg0MN4B88PjYpWIZQ+h9osGMZgGG8bNAYbFTICqNkFCxU5hBswJlZd70kaQBNJWk8r6o6BQwa4SkyzVJab2DrTVbgxtH8AUK4sWIUWsAchkbr2pIfgkAeWWKp4++2U6Kp+BIu3Oy4FID55pa+Mn3QFKdKs8B0JHAUdAB1AFZnxA+BR3n7nR1KVRv2rWgHAa1sNYfuek9/oXrP/5U1VCGxAkYzSwlo6UARzPCaDQbWP1larOFtNJdKOztav2qjk0j621g1SQreG6itboHC1e72Fcz87mBXpvo9USwvD8Xdal7S6C3DbqW7pAzcF95Dt4Z6Z3dd4XqeGYbcAKOa899z+zjLTsCPiRZ52iug40Rc+y8rzu2jFehimmejSxdbyH418BRxdpVjOfiowXbbW0R5GJ/noeqabPBVqMNkhiaf3UFvgZ6TGHAhRkIK0ebSoD14hQ2d7BPIhDeAkDdTotuNGIemty50f2+Wm/kWjSJs7opT8PLR3yyeKUksSpSwfO/swJyXxPTvTUuheVY1vw3pBCQ6CPCT6mly58I+uAnpA84Ptp24UPuH4DeIb1DeoPwJukNQFyID6hEj18hCmxrA8ioALGzn0HiYkRH0XWOIydBMJhSeFyjDkMYYSGHZquqDXNnhAUNLx6kl6hzuA2ci6jt/HZdtH29kAKe3E/35GcPNdv78Z5H6oQrH8ZVcsyJ7uMjij28hwaq2/jZK4mH7miNHN8AvTdQA94hvEF8A/QzruMNqMCnN7h+SqiP+QnpHe5v3e8/RXwQyDorpWyR5AaQj9YISmWQgvBujECvHA0x1xguIE3PkUXh8VTNwcpQXwPC0sohTw4VnnVZT6lz4mMAtKo5oJUMfsUTu0/2TgFWt+qND65+hKgYpXE1Pb6vJPv1tOGOv8c7OfLkzVrjSUQvAJOkn5AC9GoECL0HYOoNKj/h76iA6HiD9EZ43Dc62u+IjvcH5B8wfbqUU+Xiw0+G0re11SAfeQOjKhmQ5iEkXgbCOxvMDjAZDtddPaoU+3oFBNVHVVXxohP5F64FOAqL5o5OwFEXwFG4Lr4rLS/9trPS6ok6kK6UXqWV7dc78NIDYIYV64SvAO09tcuQYQ4gdA9wE94h/4AUaTP8A23Mp4AfFD/JD8A+AH5A5feUPgB/B/wT7tOlevS2tgjy8eUejnNOIlUXhSJ+Ww2zSYJi8cCu7JhozvTjP8G/jtojS42y1SA5T6DxzrraJXaNVmh+K4igs872pchTqym67qp96jYo87bqeFNh77UddeGxp9niPaOKq5xqfp3SSN4HoEtBTi8jPB8N+CI6/ATxAcc7xAJ++oiIEnGRYpvwEdFliRxj+zukDxmOm074BpB/bGDlpY491Q61J8CMTAFqrOITTICZiBggD6HcuG5NC9KKFmTtdtuSt80rMv93AOMaUtyTOpEX0+cz6bPFoHlnvXBt8PkaWJ4qZuMEBNs7rf7cK7XFS1x1YkXYdqX2yAuAZleix2up9SXVJV07kckrmKkAGsh3ZH+H9CZXSaXL71FvfIN7pOLSm2qt0fM7XFFzdH9TAOYn2H1zveRdzWm2PHsDyC+VoyiCKr4zMbsowVjtEjiP+LAOhluNIrs5x4gqZ/fCGDInybToSNwyiLp48K0wYarp2ClbRmwaiE3af20o8XTOcUHW+QPSMq3YR3AJwOu89BsnkrvA8Zyb/VAK/QeehiH/gONN8gA+6CdcPyF/l1rNMYDP9Q55qUe2CPK9dK1r1PkO+bsT7xA+KeW6P9RznJ3tTBtAbjXIB1eMQBKQzeM6kpGaf2+K4epmHzmgDYNXhg0NZrUTXofF7aRpcxIlnhgeXioZ9ffXlRLTyuwfr3XNeULA7eqMKv/W6466UHO8o1Z5Mde/M429qWbUg7Ju1GN/5ex663cCgVWfMaaD2oSpqfFHuV4aMnqLWqMHILoq3fBdro8ATr3D/UM5vyvnGP2xEKKoPILZbk1BvpI2gNwiyK+tLECi8WhWhCZK5NdTCGuNsVi8miWYxb5IskWYNGNr5sQgOSsPe+m4ff3AWmRml0xl1hof511qnd7WR6OnNUi/0JTB/dTDPybgwhckzf6A+15K7R+pPfKstnssM43vgn8E6KmvKb61mqTrQ7W+qDL60yLKOvIzjwQ58GHHnH0/gtnL2y2ptGEx4hOd7K1Rs0WQD67jETge3NxlkKKK46TUUwRVj436e+FVlzaO5u0z5bAdTWnOJHkCPKdRzUno5Vh4dp8Blq7dXp9jJbo7BcdyEe7oFusLYHdl8FxnrXPdPzT+iHNhrz7eRfEXu9e3GDQ8id65EtGTxxIhvrX0GfgJcZ5vjJ8/44J3BjjW1PoNLPOR1BtYZiapN98PH++/PU88PfHxsn3atjaAfHj5JOggImdTdsKzQTlOtyqgCYQEmkpxL/LcLjJUE4xSO02HZqTQuSOdjbzocqqoS2i0NhZz/pyX/tQS8C50qa9R8dYuX4kQv3THP8or5gbS33p9vCsTmKK7vIz6ECM7AXQqg+JCzDRKb0LMOqJ2rt3fJY8aJfEO9w8of+YxrFv9SmQrbiC5AeSvLgrMgLwbfBQICXKVESBhYdAndpW5vpvKJh8ewCrd7d7HOw/CP6qetsJlJjqhonrAmS0jqEsK3PeMy/CLaHrJgkF64D12G8R1Tva15763AxzPmbtU+r3VGBstMK6rRYv1PmWER/goM5LvAD5IvoN8h/guw7uOPNokwQBPFlJ9Z4SDRRW6jfJudcgNIB88/gikKtJTJa5ttqhqyi+n6SB7qdEGtkvQYC/c3wHNnRHRvSC5Ej2uRn+4Ehl2f5S40e3lg+K2N0BmOSzOE2bQg3YJV+9zp9cOcbtBdPnG3KLEOs4DvSkaLrUL/dkaNXUAPABznnFUHSDHu0okiZzfAXwSzMxB2vKUYO49RyFeSWfcJt7xWW5rA8jVlRIwGpjI6MWUoXAyBnjO9qzS9tZZTlrDMHUeo7Ng7mkN8mIYdhKOXaoHXuxac0XI5o6pagIrhc3zlPwSM+ZLafalfP0atfHe/PfGbRfnOu8E49XoVCgqOx+l5hjgOA9zl3S6zkKiRZiS3gqn+h3yMgbkP+X5J6b8A+4/M/yD7i4jMAmUkAcDszdR5DrzSADe8c8JfVGMY1u/sv7jM2liONrU8WZa8wWsLJly16L1KAbdcEYiNiyZc1ScbLsgvnriQb0Y51lTAF/h+J5ZItTOJc5x/OIws84juq+C3yUguSD2wLvsBbsrtxTDcf4R34yebjVobj6FVMDxDfKYcQxw/AnXDyiEJgog/oTjB+Q/4rpmsQn3H5B+RNRZnsfw5gnHnM3TMUfGMzlMQh7SPMta369da9RsILkB5EMlSAKfYbsgiEwdvUJ9Os1uCLFFUiyD4pwLW7Bm3FVG0Ll2ILcDt5tR40oqiAuRyuUM+3Kt7rSxc0JF1L0K45dR6E5NxTVw1PVa5dnn9Wggecfj7vXCPt+US9r8E0K9/IDwBsdPAD8A/Kwd6xjlUWxz/JACTDE3c4qQhf+E4S27Dlac0VTyEjpgckxp2KqKW4r9J69cGjJQHRarTZYiXrEQngj71joCpBZ3WgNSluexahlLnnWJ761D3lX7uqPk14PnJaD8cubKXwxO+Pgb1Ree+uxl8/bzaeVktbzvVGqLP+D6HfAf8ADEAnw/5yjR30u6HR3sOv5TfWXcP8t85CfcP+D6nAY7tsriaTk7x0nFjcVlg2ejsmJfW8ZfwCLaAPI/9nIRZkXXkT0DhnX4u9QQa2ExBsIjJS/WC6hMmTmSZFP8Ifo5yLV5vYV4Lq+ne9eOet6BCuq0AQn0g3NdjaEDvI5tc0tNG7g843lhpEiLB1xRnXj0hHIt8taF8alrQeb6ZJBDOMCLaERT39FneMtoeUEMg9f7QPhQ3d5Ue0qNkniX/CDJK/CRpa5YXBobQCYD3We1+PJ2rXy6vDcD2dYGkGd7OEGYrMWJ5FxHjNpeiR/JYrOADi1mVKkPIM87D+R94HgWld0h338m6DC3vmdcK1YLaymqnUSAXMQb654r9wPIDaA/tV040zm7O0y+aE62EABeRozShWbQtRGfudMeNUfXrKgTUV+hA84NmK6TXSJHfy/36+qO+Sfcf8L9DdJPAB8yxSC4ca5AWBSWZQCn0skeEpDnTjZ7c7fynS8ph1sUuQHk/YkoNbkBTnXGmKzRYMz5GJeodaoBybBqqGk4ToHyesTXBZv95TrAnIg8cA3oeN6fuCcK/NrnONcReSMn/qXZzpPbSPyhmeNdTfLarcY74D+hqriD2ph5gwrQlYvq/GNjx+hNtYsNvEN8g6U30GIkSMikgYoZx9J7gYyooMkMJHl0st07e1+0gqVOPvStk70B5MOZl1zwRhdEh1JmcyiGTkT3RNeR61JlhZpd65ZLYOseuwqIJ4B5GVxuq49L1248j5CaSMUlAHwgQvylIuqvPt1qFPmF5z2NzoVjRIb+BqFEg0EPVFUEb8IUqOK25bp/tBlHKFTA5R/w/KHp+CHPn2JRdSSBMuMYjWrBYfE2LFJsSvCUzt/3RjncAPIPCRi8ZsblrIszQNIqKM2gSZBkY2dYBbfZWJnSzRrbH/aGdBkle842dBEcV8HzHjXxvt54bVbykijvpec7y77PueTShTRdv/h5n08fZMg/y4B3SZ/xIeld7nONcRageJd7Fad4g4f2o9zf4TlmH7MH2Hp+B3Xsx7dYRniEWa2nLyUyR7vQr4w9nVEOaRtybQB55zoqZnGiLzMPeVcz5T56YJuVLFhqs5xEISgWemEcsmHO5NCJ5tYciT6W8nDFovWe6PHUH+VujxldzzsvgeGlF3UPk0b3Fjh1JoQhXXpDDzB/TlXMe+R1TQUQ30rNMcRt5TWlDvWdSKd/yovTYMw//oDrp2YR3JmnTfz0Ib37uD9erEU06ueMjgRgFSBtTscXZpHqObLEZgO7AeRjAYLDzcyN5hbAJRBeZLSLZVf5GfZdBfSUS5XfEfSy+rNen+I6w+kGd47CXKgR8pf4zLhguX0D+BaR4wX9x1vRrHTX61k3BtPV6HMtlZb6AFPr0W0HyFf/7nJNQR8s9UYvIBhD30X8Vm8BhB6R4SyO+wHXZ6k3vjUnwsawwYfIg8xcZ8xUgvIGfIYY60FNs6cASh+sdLVPKIf9x0M8wEja1gaQAGwwYKCnZBlpyDTzADVmMMCOPQCKGWAG6304hRETc4AnM4CJLPcBpgKSCwAkVyKER42jLo2+XFLjuWigdVp35P3SZmusRN1ZAtAdkeQCqE/BeaHu2+4jrQhc6EJN9aa1LsKmNUZ15igRKhzpTunb9Q7XAdLHnG4rdB7dSwpeZh2hz6g96gOuA13zFFlPvyKbGIU6gKQEGYGswqgZViiHRXD+jHJoWxS5AeSd6297IZkwJGcyhzHDLCMxIzEAk8yxnZlEhtEL+DkIESXqLL93qbaXUXL1ALgAxzWdwQs867Mo8gwEsNB8bJjgK3OIHYjoatPmMqhejeZugvraTXdYqN4TnV56mHTfizk/OR0h/4TrE9BB0kGuzxIV1p8fkH9I+lDW7EQo/4gaZJmBLGk5XG/K/ib4Z4SI8YGq1AfFckomy4xjd64ojcXWqIHDh6KQe8vwbFt/1/W/AS42wNEUUz5ymEUdklSJ/HxpS1CPtHafAohAScnLVMbZYOEVSfH7cmStCs9qBdhW7kssGzVrUdtdwPRrn/Wa7sfNeutdKHuDSviQCrnmGnQogr/VrrMcVVSiKn6/V0ZMqIN7UA0jlf4Jb9TB+RJqPT8BfgDKoGBCqetwmRe3Rk2dcdQ8EF4ph1mYjI99NZuJ1xZB3rNSNFBcYW9Y8jNUoEMDQqOzryfOCFLqi5yTPLFr2sDBUJs8K0Je4hzfm9reAi1dF4XVNfHdS4/lvUCIx/Uj7xXhvZKmX/wsHrFomM8yUwPAqDf+CBEKdHXIMvvYQLCK4OoNjiqAW71oYvzH/d2NH27IrcVcxniunRh63Y2+M9062daBad/qWaMcbin2BpD3LC+QBlekyiUKXKTFkT4rmNmmqD+W5s0MhHMtnK2gpy5M+3NP19Klwt7y570isdcGynkB1G4BH3gvOAF/5kem0/Jkb/LVPoupsF7eivNgY8QA6IVw3+dZyMaqeYtUus44+kfrXHuRQSNOOtY+T4OdfMAsr61RDjHbuC4phwn0UptcHKEb5XADyC+urAxPLOGiz23OVtlWG+VhPZpUDFxqtBldAV+0SFndFq60Lh5KcXgBRHCZecIVpZxuO/GgB/Q9UeDVx+m6OPA9jJ+rTKDzcoO0UpPjIoxee4oc3OgARnnpOlePai/daXmdaZy3ZY/aosclHuM/4flDefp5HPWWTYca6WklRFQnX0edpNknAFkph4bQhkTOS8oh+vnJmXJIbpTDrQZ5T4oNAAPhR4c0t0mLRtnpkLg6l/v+4ic/T7ZHj/LhmvkagNbi/cV60ppm5Eq0wAtg+0cHFhcrCnw8/b33j63RyGsN1ri8w+ksqtS8ZKRSa5QqMP4EUMRt53lHSD/Ue10DP+G58Kz1A/I3UD8s4f34mvLwE7JjV0tsFey5UWPwWeezNGrcEpQjKslkixaZBZPDhwS+H+DsReRYGDinX/wGjhtA3pVtCTA45C4t0uwKbn0K3YMgVmW6aspeAbaELl9qKJ4U0tuvbe/v0Ixcj4guRUq/8DrujhoX4Mj1TH9VUJfXhTmuojAuK6iTp9W808/pGPxo/9HADwpNR+n39rtQ5Mv0E9CPEJmYwbKJUKjOTeIHdukdUh6Ojjwadp8hfHsuoza/NnURZE85NJSmzKR4jslBL/40p+c8u3VC2dLsLcW+cUwHQzBpRV6i1BKrZkWvAhG5SnBkej2wQFj0nMVL9beHDLB0FxCtR6C8opDWh1u8et+HI17Nf6UfTSSuKRf9QnDDe7af/4FSNTkUlsu/F7HbuGT8gPRDRd9RGbVR81YEcd+lYtG6cC3UR2HKvOeRnx8vYyaANDl8mP3cVKVHGefUlj6fjHv1lEOcUA5j3qJSDnlOOVzOjne75BZFbhHkrXUsvVySCmEIsXEAixN2LXLPdgitey1SpArDhg6DszZyULZJ3gpB/AP0DB8LkW9H0Lce8NVxkL7Wx5XuKW+96Fuf1ZpP9cmsaf/zNLKcf53g/lFA7iM8YYpxFqraTp1txCeAz9Kk+ZzdCKvJlj4BfhQ/mg+RH0opO0KJxyYsmyirpQ6767Ot3jONcjgCnggrg+W9cVeVOjtRWdkQbAPIG/vZVMtTcpbmi6KWXUFPEMpgeO1el6FwwIN2TZURtgqGHo+J+iNmCqL9KfulLgeOa4IUd9c7vxKOr26+y7bggc/lcqjIi+wirpQdyoSCilBtdRrU7C6oar7V7uPFbMs/VOuQdS7SS0oNvMv1k8QHyANLnqGi/B0dZ658Fyp86qU6eFXVozzAVcVviJ30WaUcpoQ0Zagq/Ih1unI29+D8vUhbPXJLsa8daglggpDkytmVsxDlSBWKWeVe1+tFhEIVJINmWOmIXABijkHgBbiup5aXMGAtnb7Kb75jRrDLd4kVAP2Kx/aFtJ9r9cCzzwCXZdxuybudamFeCrp1Qv+J1+WzbFkRlYhB8PeuW915WfsbXD/k/lOOyr3+aPcN+bM3SD+ZWCxaJRZfdU9Fe9mBnEqE11sfLb4zw8LUrVEOraMcYh7rqZTDMTjZ6j++Zskw5+ebeO4WQd4XfNlchnLPbp6DbghOgDKkCoAV+KYOEOMS95nm3wtQCoWfXbncF1q6p+oxrY50ClacIwC/rHq93lPR12vyPZf7nojuDBx5G/i/ElryQRBffl4TgEM0Vprg7ZsiAnxrArgqzZg6BB4iE8WZsEaOsU3AG4U3GN58sAOP7vQYnTWPzvNAwrLDR4CTlzN0y4O7TnZUdyqfukWQyQoYxvNJDli4HFKOnIrRQk9H3TBwiyC/DJDeJhjdhawpT8hyZA+Ac8Ul1HscLofcIWa4XFXRRyWylDug3M9PwiXJPQbScdua4BSI7klRydvD2LqVm19Jvy8yay7wyNeC0UfB8cuzerfkzZQhHcps4zty2CGERqPeI5Jsw95vcP8os40/y0zkT7iX2qT/lMKilZ5/wvATAz4Bzco8EswVKjwk0hSdbPjcqFmQVde8W9lHnJztF8pRSAfMHTI713+89iltjZotgrwOkG3P9AxkTtmJKVNDFrKYTHAINJcj0+QQwycWdIgudy+iFg7BFQpABSgX6fac2N47GHlv1Cfdi4o3tv9CzVHL6FEP4dhXm1eX3tvFJ4oh8JpGR3f6DTVyjFnHn5VFI/Bns0qIFPpH+92L1Bnwg8BPGd5IHQVTSJTNSt/MQB4JJSJlx+feFm9dYi8n2kQr1r7/3m2it5+xDGCHuUHDpbd6S7P1lR1sW/+UANkFehLl2U3MdDM6RZeQSTocGSYXlANLmcGUIU0gs6RM9wxahinLPRfJs5BNE7KgieTw8LH+0H11G5BOjpJWrP/VY4W38e/+iIX333TmS3OpfIEM4KOkxAUcy5xim3FU52GNLv1W8bfWLEQBvcHwRuGHkr1DfigsK5CKkZsughQYnexjRH26MM5F1dmCK5RDF5jmRg1JYBKwDxOvwb0Nkfe1axXjpHaS3gbHN4C8ttwzOv0v1zFnuKZkyInIQIp0OiHTzUG5DJnQrA3pNsGKQC5V65BRl3SV26KmKSgTSHcNX+vO0HIBbCVpaxYSOhe2YH+AXHD3uxqVXgetGj3yEZC7J3q84Fixqux1/lxTmU382YRuZ6Otny0iFH4KnSBFb7bVvKzxBvINxDtyflPiu5NHy9D6CUmojRqRSCWV9mEeyVHv7KEKoHOmUdXCm5qP65xymGfK4fBxBNLQTogxdB73g9Rqm3Fy3MBxA8iLmWme6dXumZMmZWTCMpyTgRNTngBkGSfCj4DtRE6ET6BNMGUIk8gj3ScwTQAmSZnABPEIqDRxlEHaXEj6hWjtCpNGrXZ4AqjX1Hr0x4EjHq09nukYLihDJ2k4V84fa42gdj1D+Kwd5qKwMxtnodgfFOMtAFXpe770s5BVscc9ZM6YjrXmSHX+2pxBLchVQLYASHNHHgg76Ezfk00kykBM867SUw5RTLzKiE9POczJQFejHDbxXGCjHG4A+diajgd0jn0OQ/YjciYzwcmNE8mJ5BFAAKLziIQBwgRognyCpwxqAnmMtBtHiEcQA6QxHssD5AOEATBC/EKbawXg1uwTqu5GL6rr54+V9Dg4XnBgXELZjZriqngElhxEXg4Hr0aMy+cN/2pVCbKmwlNVed6KKviboDamM/Os8R4ca48UO1LwN8rfNNibMg6QO8y6z25W766ZQhvvsfAotwnw0cCPE8ohZ1M19ba9RTy3Ug5dQBIw1fJIMuDoMfaThlURjF8vdG/rnw4gzRZ0PGmfJ590yBNHJhtt4tGSHUCONBwhDBCPkI0AjqCOAI+AHyAbQB4AjIAGyA8SR9KOAA4QBpAHAWODxms776P7bXMrvGBw9WhkeAscb9EX7wTXu/Jr3ik8fFpzlA6RVntnoOU/OyCMlBuqArc/CpMm6o3Bjvkp9+BdQz9p/Jl3fPdkx+E9O0rNUJ2orcqsoTMhwVua7QmAEcPk+HxKJ5TDYol0Sjk8E8/FarQcICwgoQ2UgyelmGX1eZGmb2sDyAuRDBoL0J45Zddxes8H5mnAYMndBjM7SjywGDRAGgsYDpAGkAnAIGAg9AlxgHEAeICQQAzl80rxWE8xwMbLc5CLTOi0qP4nrgcPGOICz/rasPvddUlewNabfyfog9K7QmXnR5ldLDVIvEUUqR9t3rEOgwMlWvTCtVZT9SHxU4O9fb7sj8PxqDrAjVbuY9WVj2jQorACCZaFvLPSqPEis3fpZHiDcthVG3rKISeAY7gcRn2zcLlKOYaru9CWZv9pAdh/+DewE1K9jILtTPbEo2M65Hw8ep6O7joKOkA6AjoKfoR0UMjxHyOS5IT+d7BeP8TvmK8HsB5XkY68EWndXVy96Xx6H2hxeVnW9hav9Rwc7zEi++qs41XKTy7gWFXA30ok+Napfhf2TBG/rRYKYAXDD4jvIN5IvtP4DvJDg30AOnoaJM6RGlek406rsfQiB2VETVyaQ+FJFtDEKZqHdbNgby6HKtQDL40XpEI5lEod0mef9laHnMVza+OG3FLsLYK8BJCpYEkGPAvKDj8o03T0KR91nBIGH5X9aGYHSiOFI4QjpAPIMdJnpRpFImQmR8RITzq59BGnQRgf4yD7eQTQF6pCzRJAl14tfscJ64ZzLZKo6hVepkHqK6u0SpaTIvu5RV1Jh2+D4/XokUtq4JXoEfPrlz6B2ljB+wyIeINY6o8VKFEB8Ue5/hPgG4gfIH7WrjeMPwG8H16fDvvf38TSfcZCvduiRrj2VqoCngIUU6lJaiAsX+hkd99ri0wLi0rGkDkDoxmTyzYPCQAfEniY4ENnhV6637WTvcxKtihyA8iVdfjXDGXN7T0SNML2Non8lMs854E+JAgGcCincisgsgBARofaQCWI6ew+PTiiXpddract0m2WQeJaY7JFYwAxagSSptlOrB9U7529Cs+8DLVLXuKc3LjmTWuVA8g9yD2APaChhSc4bcqcyqytRJb31ijXujGXGzK50QCln3L9LDTBt6bLCP8RIz6oVMEy0tPMtspjUPQfY0DczT7pONYBbHOHm0HV0be4DKq6EGq2Kop0NywVzDEzanJ0soejA4PNJz7TiXhu7mTOLGqcRfvRpGj8TA4kgx0AEzANtkpG2GBwA8gHMzWGN3ayIPUbIxJIzPjUp78refaU3JO7zKCBgsV7ZwI4BFjIACVAKSLHiCzZgBEJ1Bg1SSUJicYR8AGw3dVUmVgfAm9KE5ogHYv81iel4H6H104uKtkZkiTl0ryYWgtbqHYRtUyQy8FlAeTcw7gH+AzwFeALyCcQewDDdeuGK1Ei76k13tGQYetUf0D+U1Fv/H0xx+h6E/QDrh9w/xHRZXEYRBkUlxqLRmUwnEN6d/BTxEQA9OBD2+SYdgYZYHUWsSspFJ3Qs8idLuQhIs90dBzGVKLO2dyItVZYT3onI1DMGcAAR0SiTfCi/jl3KA3wByiH2jrZG0Cuptjf9pF6LJolpYa0t6zJP3VUgmsgMDD0ACvoDaIOhA0tfa7ptXAAkQQNEAZSR8A+y30MwqCsAw0DTLHttFmzLGkt/a4jXfPC3vgJ11sHDB+QH1EiGwUYTp2fDjplovnZGq9czqAWDTQ8AfYMyGFGgAYpomdjKscoF2lhjVz6aPLOmirvUe9ZRpEO4VDYMT/lTQn8Z2nKvKt0sQtjpjBlqiJ47WZjBkjgJ4kfMLzJcFBKGR5eB5wETwabMrDfwQ1IXVNr1k9WSSQc6shT5mU0x4poRerg6UR9aEE5vFCFRU0iFpRDL51smymHuEQ55Jcac9v6Z4kgB1sAUJy5rSqoCHtOBA5yHwAfIA2CDoRGQEeAB0BjRJI4SBjoOoA+QBzhPIJIcR0DoAMMQzRrcAA4wnEAtUcvaHi6w57vvI4A65n2xtaJrV3ZrAakcrhrBlZ1zyx0JmRepoIMxJPAEZBTRZ0I6iTdpBq+8bS5dNpx1u365FVw7G+z9n1lQMezUZ0yjlOYMe9AU+uZARKa02vgJ4g3gIVVo59I9gboE9PkTLtSqiPoGT6OSJ8HCPsyilNqf2ym6K3eSHZ+MKWTfUo5dLsAfxdcDufMogfXQjms2pB7BKMmd5TD2lnvKIdq8nnb4PgGkGsRi1tzf8NaFjvQkXDIP6fRjuloKR1gNpZ0NhoujkNJsweYjoKOhB0hHICIsiR8Ej6AVuYkIxKNmUgNBWCHs3BKOrtetFRj+Jkh66+Z8fEB4gPSm6KbPgNffX/qxsNVwdFP7Wn34cwIsdjeloPSu6ZNGSDpEO4kCsc1Pch7ZiIv39cBHIoXTAXEt9aAKWM9wZrBO+roDvGjCEzUBs0PkOUEwzfQfmiwt2k3fI5vH4Ln9kLUWCvBhAGii131GC9mqDZ/f32jZihA6olItenTzaxSpXBDCwZr525I96h5rlIOUTrZCePxABXKYYXTnnJYB9pZ/G62tQHkCUAuR1eYYoSbsye2IOT8Nh3S5KOmHLONZCIYg+J1OFyqTZjobMfnM0I6lo72saTfE9i0I48gpjjgpbMuBMtZ3xcQfmwK1+UnAySrVcA7xA9An6hOjcX7W65KqSmhTGgVBTi2sGSAcQToJIv/d/sZYVGUJcLkjFgR/+UFtYpbNcdbne2aVhd6YIkANfOq39rMY40U222In8TP0s0uQFnGfKSfID60Hw4AhcHiG+v/fKfAba6QFzOfy8EkziiHmC0Q5OXrLN1vy8GdTodZPJeLv1XnIXPX2C5D6ClB2ZuJV6UcIntQDocl5bBXUfPVD3aLHjeAPN0tdqUx05lWRZBVSPwl1dZOx3z0Q8p5sJSOlEZAJRpkoRKiCueWmh+DfghGk4Q2FXAs98FEFn62MJXmzrr4I5u69CR5HVWpcv9lmLnS6BCG9q4PSBnRVS3FS69SMdXb+6SqxRhqJ6NSujh+OrfHCq88rYrdYsTgJEU8bbZqmZYT551qFF510P/CnnUxyhOGWZFye40UP0paHXxqcjbZCguFNyS+6+ifcDmSNWYMWh2v/J4DGC1neLJS/zuRsOsGBqwCZG3ANMqhIU3RtOGHN8qhRNA6Xn1/7llQDlvTO1L7QjnksbB5Unqw7bI1ajaAPEt/xjib+orlaOXFZgmkO3zyacpMadKQJqoAG1QUyDFVdXEBmVGnm4qyT1XyqeCYQWQFMB5Zt0F2rrPYdtpJ0EfxPnmr3imK0ZYPyD/g+pD0AffPApClm918vxEeOt6n2HMySFlMIDW8U/vXW+vx3CTgOjhqCXr3oOip8Va8+ENT1AHepeoRow4gUeuRc+RYa47Ez8Ke+YFasyR/YkhvMBx4cEd2YEgxYkOGBnJKc+/JVTrZGXkYI62t84lpSTmsqkmt2VLFcwvlMGXH8ckWlMP60bI1as6jb0qXe1maTbxmyiHOND82yuEGkDeXuoo/JMC9zEWWSwWKRAeR8zRNtJQ5DBMteYyX20RoghjRYWhEltEbjiFcoQmOCYYMx7HIo0XKHduPEAdQyyhyBjCH/Aj3zwAJHOI6jnAcIP8soy7zBfgEkeGiFh1s1zzis5CwHnFufUsYCGOxsS0lx4U/1q+6D14Ax6VKei7g+BOuH6pzi637rJ9FiOJHAcffw6O6Ct2q8KvrAHi5zfAG4kNDOgRGZKA0OVSEJeABmDV6s5zhYwCk2DdqOhGQEjGq6Yp1e1wG8o5RyzwI+jLlcAY+Wkc5ZEifcQfkZEhZpY7pG+VwA8gHAfJjmsGwP6MaYh6y7vxGgD5pOh5Rx2ZQABA6llriLrZzQti6TwxFn7HcfpRwJNsYUKTmWGyfAI1L5BAgHBWNoUMwRQIAJX0A/gHwE/JP1RSy1iIhL2XIiALdl+5VLK0AcQfaGKM8wMyjYU2t48JWo43Kvp0i3cnrfuj44xJAa70xhtirXNnvcP8x0wabX8xPQFGLDL717xB+LzXKSiX8CeB3CD9g/ImU3ny0I4UJU1HVMQDZ54jKDJxyeTcsTRBH3o8Y8zHuZ5hZLJojyNZUOzFSYxHPdSt0pVKTpE4LFbPLYSCgt1vYpM/KEHpJgpL3LodRpxwOEzSkGX85C2pYBXP55nK4AeTKymVEpR4cNVA6H1sRyMxRUUfMPinrSOoIV+hDUtGYCWm0yr3eYeZi95exu89A4oiafsfn2u+lh9AtxGLGr4i+Ric7+MY/Cbwp0swfxcY0NxLbPPtYjr5m1r2DcZg1/1mSLgOMmgGSABm+3/H4akaW1hHwktzPnQrgdXB9LikEt1repchebA/0ozVq4vI7gN9Lal3qjfoB8HcQP0F+YLCJoGTBSHEi6tFTLko8hTSg6SS99VIWDgBzsxhwXH8PbVMbxVE03dyIVBsuAzEUyuEseTajpWNp4qUTERMDka1SDg3M8R7yYOBneW8tID2hHK4IaG5rA8gIlHbDuRDDSgBED7NM7McJH9MROY+Y8hGDHeE8MJWONVrqXDrWOrYmTnVFjJbk1KJOICwboqFTHRRTY8nUCGhWtn6H8NbAEDPfWHNkVTyclVXVc+WnHRmV1zy07nR0q3P3OryAoXfujj43bOgPCWFcGxi3xWs71uaJvNNndMwzjkABxTLb6K1J86PMQv5YcK6JMNUCPpDdgx6IODlWsLESqVWhh3RBtrw0biog1fT2EuWw8amLTmdQDuMNh4kXMR6LFlTLm7UQzwVzVxuO59eYutGdSjlEa9R42iiHG0D+ykp2BoS1P8PTZoERGpn96Ee6T0l5gg8ZVtTD59pjdKZh4UnjPsGsNHSaN01YNsiatazMQ8k8ut+pdLc/AH9XE3rFB1zvUjG5b+rX+igp+EfUH3UohvdBG3QthsPLAVMc6QvQRZLnnD28Z7/vGRgdzdq2ejTyel62EAe/aVZWxSaqNFk1yXqfU+ei0hP1xbkO2TNoajodohPxeOOHxnTgMftcuuCi9qdSYaAXsKqpfp07VKnzlREfmzKmfWqUQxWAPKMcVt58bb64kAtBNWUVyuFUSsGCnKX6cVKH7CJHypdVyp5y6EByx1Q72Xf0XjbK4QaQ50FL7vt4Xe2rCH7Hzt6lhYmuwbI+pknZM7JPNGVQM0gCAXJh3jXBLFPdOI8x6pOzp3ZElsIkKJNe/G5wAPSpaL58QvqE+6GrRZbtOAj6BPDZcbIPAA6Kn3O9Mfo0zpD82UXdlLk5MJJFqIIdOCqHg6NUPL8FFnYO6Lfw8TprZsGn9tnKAL8rao0/Oz71T0F1249gyhTmzMJjBm+AfofxB8AfSPah/XBQknOSN+pdEZeNHcFQI0oC0OTBISqdbBR+c2tnucOHGPUBh0hXq/oQTymHkR7n7sSQPGorbVzoaR2e5k725Q+1dZ87yiERjRokwJv02brLITfK4QaQF49dCwHTFimw7uhrgU6Zud7R/ZOZk6Y0eFbyicaSNndAozrmozmKpAplD1O5Tx0Uz+Wxk4BjKZfPHWvUDjU+55/4LKM+8wXNV6WaS310w+KuSPEowwhYIpBnsAt/bzFUfCgKJhUQDNAUlja31bwsuu+PpdTz6E6uYhOaVXZ+j1qjfkgFNGv6XKLIOWLELFVGVJCs4PgOw6RkChHG3Im4FWfAEjkyR9SIMmyNrlGD0ghplMPs8GFAOh6j4dJRDtFFczEwXoyra6m2mnjBADPYMV7TLcqhmnJT9yF3lMO54VKAfsJMOZxCZGONctgAeKMcbgB5tvvt0gUFLp1V2VvzZs+MT59wKPau7i63ifQsWKZhAkszh8yQjiJHBqOmzDsiSzoyxnxi7CduOzanGLX6Y+vUqgLBzDn+0Qm+/ixMkd9jkBo/QHyUlBjK2RESgns4ExjIyVpjnIfAvTRswtHRTrbV6DLKZd7Cpjlpn+UGaxf3koxZiAp/FKGJ9yYiESD4e0mr3zuLhBjVAWJ+EfwJlt/lbyCjeUP8REqf8d69dXx7Be7WZVbt/Hp8LAUgiVLXMwOmYwMmGcFjSbFr57qnHPqVWsMFyqF5NGpS73K4VLmbO+Id5dDkcFoTz50ph1ZMvKKTzUOGRps79AvKYc2hNsrhBpBn3cWVUZQKhqdSU01CUcIuTZ6niXk6YmIAHYYcpl08wD0sF5SGYtwVHWvHAEMRy2W1Ykhh5KVqYwdUybKQH/sA8KNZlM4Uux+dkX0Flx+ztmGZDXSflCfAS1ods5klnGqgV2uKGVBudUir21BMySxHw6bVJ+N1XhAP77FzRtCYHyifyRukH/LOWjXkx36H63dVemDxse7UeCqVcAZM4A3UTyR+Kg1HTkVBApESR/eim0usxmaOiK5qt9oIHLzR9Joobi803I9ZqzZqfNEpPqUckieUQy9RI1kA0pA+Qhl80divDl2wEuTPlEPUIfaMVcohFaUASk3xeKMcbgD5QIrNfuZuPhBUpmLWbVLlO8uY0oGTUsqeYNmC2yVKSkQTzo04qyFumzCMU7Xq3krCdSyUippuF1TGISJJ/WTzbW6c4zcFYLzP+ocxHK1Cs5PxSNIElY51bbjAyRK5ogAhkUurqgNA5jbqE6XZHC3WmadNzpI+yz7MWdpddSc/K+BJ/vv/2t7V9cax5cYiT/eMfDfJBkHy/39dkJcAC3sszUf3YeWBPB89GvlugnvzsixA8FiS7RlrupqHxSoGoU9rEXgZ/cZpZ4yP7rz3XTKNJBUfUL1S+BDSq96m/hrGnOvsG+///08/fx2WQizq5Bk/iIPlMAQZ3Q22SI899g7F85bDIFLRbjlUA+oSBBmWwxNdPe9LvCbLoak6TwLDclgNWF5ZDj1nSo1DqPmFhvZKrkkkQaKPBxq+3hkt4ndpUUDj11Iql+2G6wZsFsPmpqDGEmThRIQa/R7x012vKoxN4TR7+GUaPcpYfTDNDm9xzLyOAAbeYjD6NoQMu4K80uwGq1cAV57XTXZZoVKc5NQAWAx7N8NwRVs3JTEjOX+dJPr8Y1MT/HXKU8P2FytZW0TbdeyLsZhZ7MnfXlG2FastqWfYBb1iVLkA+BDgnaVcAdxRZIeFVfATC0xZHLOzZc4vKuLVZMt3rwasxas+CcIs2v8az3Ms0Lqjrs1y2KyJOinZrfrjYYhcjdjFe+DLbth+myyHc4RjE2qeHTXyYn/kcyfD3HJobfaxizKvCsW0HCZBPl83ez0SoQioJVw0BZzdNNPFRhJyWkxE7/W6sWzWqMT85h9bjdkrEvd5kQS15+cEBT4AKiXcLl5hHYePSAuXzS1UaxdlYnNfe0yzCKkIoixyExoJlilwAuI9xzbw7aM6GiM77NXiUAlcufavuSjQxoIYqvgUCnm4+jgJUN4q8JCJUKLtfQgyuLIn8OAC8scQXPARARN+/FZXp+23012u24baQziexItJkCEH2fW5HnbxhdpixIIhnx01Zu5IibOqVvtsOexHW/RVsEP2OFoO2xIvqleQVHmhVj/VeS+Ku5nUDpZDhPC0ArUULO21Vet/UbcKpOUwCfLl225Z/UijGsO4+qnv+Kqq7BfVIrWe17vKJrRKmAxnTjteGemOFJVICFKhRWQLbiB9tUGM4ThB0qZ8xpb0TQA76eM/MPuA8RKpPje2QWnwHcL3el5udtLtdDMxKEEbA96zfRBzlYgh3LSESM+FRA+s8IO2QKWZjeWT88gvvBrq+w3Ala5EX7oThu33/MlWKbog03qNP4AgSeEVIu/xcbWl3Ki6q6o3NHaO2Ju+2AqHRO3WK8Qs1Ng0ky8K2A6WEGr2I0Fir2OHdRChnRec6uNoOayfhKjPwjBjDKeF58aXrUgfu+F0j2qWQ0YfclgO4zXE0bptOSzmHm/Z/a3HpUDuD1hZnDw5LIe+uoHdcpijPkmQk4r99kSA/GX7hc9dGnomOJflbtedhUZYrVAYqfTVWVJBMRh9pKZWUmSL0KuWzK2hKVaANxg2F0u8XoWItbWzMGwC3tiO24Ir4Z5sAW5U3MWw72fd67nwdDcV9ZyJXoeQU1+UfuXFDhoRicfxIVLiPFdi1YL0ZWQq/v3H814kfbvy3N0ubXwn5htjedYlfNM/ew/Sj9Q/AX73X+VdRK4+siMPQva6ngiaB9c+Dft3IWR2kUQMJosc2ojHcFrpfTyoeGgFJ6FmJo0DmYzB8e40AL+wHHJYDqOK9C2HEtmQ7qhheTr+t2AgUShsshzGjKYWYJ8sh5t1JbtZGeX6dAOLYzf06bzyOccu8Q/bg/zFnZJPup6EAaU/ji/6amOpOJW7VewKbKA9hHaVqu9c8AbRM0ROEC7i1sNCgRn4gKAKpIrRKKgg7lTuVLGISNtgMAEqBcYTSBEDsSuxoaJSQVsLuVU73WEQwXo3qBd7AmGBShEnQlfRPWjCfy+d6BQaBDk+BCoqUAmCDEIUFVXt1xRaxWi3WHz1AzWGvSPxuy/OQh/2bip080239O8LIBcUuXBd7lyXB24P27XgZEatFbUUoO5dRBlhYd7K9dZGWAaDxA5K+izUEE60XagJD3azHKq+Prq3SqwarCnXk4BztBxOS7xCQW/ZkKu45dBWgdyj1/nKctie+7TCQo2oImN0pz0/lUmo0S/lmEQS5K858unN0lVGweFeKl+pfu34pGImYjBUtfrx+Ouy1DeV8w+LQCtTCtRUhQUGwSaGXSopoNgqShGiyGZCEwK607VlFewnH1zU4tPc2OkFSVwoPBV3FN5DXTVC72yySqvyIomik2OrFqNtJfPnYqshopJEGStrpUh77K2BD4A3GtwSSbuA/N5aAGOZFhpBjrEl4OLH6e6Z/gmRDyzLhwgeti7GtxXl+hjzgI0IdgKrfp5vfnXfo40fpE7HAE6WQ5Wj5bDGUgyVrkuN+HlfvcBSUMywLQqW2HLYwiAOlsMnJZuecWGL/7taif1cAO5dqHm2HPZcyTajo3EzkC8shxzP0eaAi5eNzPlhUmcSJHx2bEQPEvKLa4y/w7JT0opJBfZvpW7/suB8uaOqop78QrKpiJmb7BYXZ7t4ugVMSDH67pwWEdFOzO1ardPOZSVsWfvFqY9NYaZh5ShRUpW2Lwf49DF2eRMFisXX14qvtKX4LKeKq9KMpCGzdxg+YHyH2QXghd5vfA8xZqxCYFuLwAtELhBcAPmA4Iql3LmWh/37P9vyX9/pA9xy3H562CLYKj4OkjN87vtZOwoH6cgQasYbQnr1JxKWw1PshVF30HBZRkFYrYfn4rxENJm0UKRPlkNBHNnj2at5cjJVvILU1yM2Q8l+rvtGn/Ol5TDeG1jgA+M2hWZgCDTWyBXyxShC4h+SIFfhJ/L7P7enZYQSUIH1suP2b+sYreDrcpWRUi3H5MBR6XzlzJBXcfxAXRcnWLe9KSoH8am2x4uvbVUF4NWg+lEbbX2tf659X/HSSAjVHYKrLweLY7XZO5vNUXiF4gcMPwD8iNTuadCbF0gE2raUndPyjmp3nIuhokZuJbAUSBvbKXGEfCJIXy/g7pZP7ZMuOERKz3xE/sJyqHv07GbLoWpXgH3PY/Qhd4O9LVgeDxBvo1+5W6/WPlsOx/NTa1sOFcqwHJZZ5JmbkOwC07PlUF5ZDs3XDckOyJuH5667jVbCZDls/09Hy2EiRZo/thzt7zuKYLmbX5fFL7rf5dev9CF5+vqwUhxegZi5lxiGcucQwQmgLCJFWzJ4FLzhq9CwGWqp0wykQWQXwQbRe5TYG0R/Ts/Jwn5yR5EPMdypvIPyAcN3KP8mJt+hbcOgfGDRd8B+Anpl0TvWcofIXv/jX/fyn/9NOStwoxNM9Tgv2asfWZcC2W2IHOY3I4ldLNhqDzzvQk3zWE+OGivlF5ZDBWzzJZMHyyE+Ww7Fd1tX1ch5xPD1/96baxKODpZDErUIFmMfJejH85jR9JavHSyHQLh5wmreXjeLTEJNgT521LX45kMMy6HJk0STFWQS5J8KAXQjJOL1deexx8OD+vMkVeJpNUFcwMaRTwgee00x2lKqoLxXsEjkGRZj0U0hdxRViBYAqhJVZJ+BkeqhGSKxfOzDY6tbD5LFa1R7RJL61lPVgQcgV4CbgBvBW/ijf2DVd+pyheABq5vsVqnrg0UqBGQp3j7YK3BagccDKAWyAdirE+SHzxxy8WAHU0GJ3poVhVY77jfvQkbbRTCtJujOmaiedAgm3ntUHFZJWFgO8cJy+LzE0ax7sjvxfmU5bCERfLIc7m45xM1dPAfLYQ+tkGPLtVWLbW9OO8Yz5h73seXwuGsd3XKIlG+SIP8/SLG3hMSDC8rdUM+C9d2DA+bj0fNBRuaRPBkdJxeMpy13h0GMoYwKFpSq4D+th0xCCDZ5e3vH9e6rIlQegNwiJ/HUeosCFgrWMQYpTvEiuwA7jBU0Tz5XqVQxz7zEQ8gHRYzW9kxpRdG7lWXzz1TI3cTKAn77jVIfwOMeJ/wgw/MJ8uMGfIs9zlsFz6u/4r3C1oLCR8SGEQrDJotXmqclqJ5jsL/aMB+Hkv3Zcng8wf7SctjCLvhiy2FUk7YoqNUPExyTjJhWkwvaCE6zHPp4jy/xIrZVIB8Vgs+WQ4G5UDO3VVQh+94th4XA3m6ecap3JVv+l5bDRBLkH6/6RNq0Xz/lWrF/8/FGCcVSnm7iLUdwVIife0DsjXrBPPHB3oeU+HFwJHPP1slS9kjeeUDlHYIikMWrRHfVmKgRpkrxIXbFAyoGwmBEPa9ENUqt7DtppqdoywKaQR97PAeOPSo+s+clU/WAhd4BEIFsO/i2An+zsfpiq+Bfzi6YVAPfTsOhMis0babv7zkWPlsOD5+fxmPMWyMC+HF/Le6FboPZZTlYDlkKyl7dctiFmhgRmpRsQkevr/chg9BCqHmc9XjT5bGC/Luqu2fLYcuGjNxLfrUZsSf7JJIg/4SGpr/xgrgUWD4qHn9dQd1iWZN6ehifK85hESZfVKXyC7HmUAJ98bzMIKoGFdJtP9N2Kb9eawxc624vpXxfAuVN//CAHKJ6JBTduTqW6SYAVU90a1sCp2Oo7BX2l2/HP7jXQx7jc0jnEGqmER3j1JrAi7nFZ8thzOabQYovAmeJf09jT1FkQTpxayjZ6NKvVoOd/PhPOY9tiC8sh17sz8/JCbJbDreIO/tqkSEm0n1auCvTCaVbDsMB6q4dwBbFEq0A1OEzbJkYmlfxH3uoZFqSEolE4ssDZSKRSCSSIBOJRCIJMpFIJJIgE4lEIgkykUgkkiATiUQiCTKRSCSSIBOJRCIJMpFIJJIgE4lEIgkykUgkkiATiUQikQSZSCQSSZCJRCKRBJlIJBJJkIlEIpEEmUgkEkmQiUQikQSZSCQSSZCJRCKRBJlIJBJJkIlEIpEEmUgkEokkyEQikUiCTCQSiSTIRCKRSIJMJBKJJMhEIpFIgkwkEokkyEQikUiCTCQSiSTIRCKRSIJMJBKJJMhEIpFIJEEmEolEEmQikUgkQSYSiUQSZCKRSPzZ+B+GrlwhibMxxQAAAABJRU5ErkJggg==&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sakura</span>(<span class="params">x, y, s, r, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">s</span> = s;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">r</span> = r;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fn</span> = fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sakura</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">draw</span> = <span class="keyword">function</span> (<span class="params">cxt</span>) &#123;</span><br><span class="line">    cxt.<span class="title function_">save</span>();</span><br><span class="line">    <span class="keyword">var</span> xc = <span class="number">40</span> * <span class="variable language_">this</span>.<span class="property">s</span> / <span class="number">4</span>;</span><br><span class="line">    cxt.<span class="title function_">translate</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    cxt.<span class="title function_">rotate</span>(<span class="variable language_">this</span>.<span class="property">r</span>);</span><br><span class="line">    cxt.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">40</span> * <span class="variable language_">this</span>.<span class="property">s</span>, <span class="number">40</span> * <span class="variable language_">this</span>.<span class="property">s</span>)</span><br><span class="line">    cxt.<span class="title function_">restore</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sakura</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">update</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">x</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">y</span>(<span class="variable language_">this</span>.<span class="property">y</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">r</span> = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">r</span>(<span class="variable language_">this</span>.<span class="property">r</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">x</span> &gt; <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">this</span>.<span class="property">x</span> &lt; <span class="number">0</span> || <span class="variable language_">this</span>.<span class="property">y</span> &gt; <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">this</span>.<span class="property">y</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">r</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;fnr&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">x</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">s</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">r</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">x</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">y</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">s</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">r</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">sakura</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(sakura);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">update</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[i].<span class="title function_">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">draw</span> = <span class="keyword">function</span> (<span class="params">cxt</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[i].<span class="title function_">draw</span>(cxt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">size</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">option</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret, random;</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fnx&#x27;</span>:</span><br><span class="line">            random = -<span class="number">0.5</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1</span>;</span><br><span class="line">            ret = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> x + <span class="number">0.5</span> * random - <span class="number">1.7</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fny&#x27;</span>:</span><br><span class="line">            random = <span class="number">1.5</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">0.7</span></span><br><span class="line">            ret = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> y + random;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fnr&#x27;</span>:</span><br><span class="line">            random = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">0.03</span>;</span><br><span class="line">            ret = <span class="keyword">function</span> (<span class="params">r</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r + random;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">startSakura</span>(<span class="params"></span>) &#123;</span><br><span class="line">    requestAnimationFrame = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">mozRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">msRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">oRequestAnimationFrame</span>;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>),</span><br><span class="line">        cxt;</span><br><span class="line">    staticx = <span class="literal">true</span>;</span><br><span class="line">    canvas.<span class="property">height</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">    canvas.<span class="property">width</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">    canvas.<span class="title function_">setAttribute</span>(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;position: fixed;left: 0;top: 0;pointer-events: none;&#x27;</span>);</span><br><span class="line">    canvas.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;canvas_sakura&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(canvas);</span><br><span class="line">    cxt = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> sakuraList = <span class="keyword">new</span> <span class="title class_">SakuraList</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> sakura, randomX, randomY, randomS, randomR, randomFnx, randomFny;</span><br><span class="line">        randomX = <span class="title function_">getRandom</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        randomY = <span class="title function_">getRandom</span>(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">        randomR = <span class="title function_">getRandom</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        randomS = <span class="title function_">getRandom</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        randomFnx = <span class="title function_">getRandom</span>(<span class="string">&#x27;fnx&#x27;</span>);</span><br><span class="line">        randomFny = <span class="title function_">getRandom</span>(<span class="string">&#x27;fny&#x27;</span>);</span><br><span class="line">        randomFnR = <span class="title function_">getRandom</span>(<span class="string">&#x27;fnr&#x27;</span>);</span><br><span class="line">        sakura = <span class="keyword">new</span> <span class="title class_">Sakura</span>(randomX, randomY, randomS, randomR, &#123;</span><br><span class="line">            <span class="attr">x</span>: randomFnx,</span><br><span class="line">            <span class="attr">y</span>: randomFny,</span><br><span class="line">            <span class="attr">r</span>: randomFnR</span><br><span class="line">        &#125;);</span><br><span class="line">        sakura.<span class="title function_">draw</span>(cxt);</span><br><span class="line">        sakuraList.<span class="title function_">push</span>(sakura);</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        cxt.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">        sakuraList.<span class="title function_">update</span>();</span><br><span class="line">        sakuraList.<span class="title function_">draw</span>(cxt);</span><br><span class="line">        stop = <span class="title function_">requestAnimationFrame</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> canvasSnow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas_snow&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">startSakura</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stopp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (staticx) &#123;</span><br><span class="line">        <span class="keyword">var</span> child = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas_sakura&quot;</span>);</span><br><span class="line">        child.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(child);</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">cancelAnimationFrame</span>(stop);</span><br><span class="line">        staticx = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">startSakura</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开主题配置文件，将该文件引入 <code>inject</code> 的 <code>bottom</code> 处</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/sakura.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>如果想要更改漂浮物的样式，可以在 <code>img.src = &quot;xxx&quot;;</code> 处直接修改。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo标题旋转风车</title>
      <link href="/Blog_ButterFly/2024/03/22/Hexo%E6%A0%87%E9%A2%98%E6%97%8B%E8%BD%AC%E9%A3%8E%E8%BD%A6/"/>
      <url>/Blog_ButterFly/2024/03/22/Hexo%E6%A0%87%E9%A2%98%E6%97%8B%E8%BD%AC%E9%A3%8E%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个特效是看到了别人的博客之后学到的，很不错，可以看看原文 <a href="https://cnhuazhu.top/butterfly/2021/02/24/Hexo%E9%AD%94%E6%94%B9/Hexo%E5%B0%8F%E6%A0%87%E9%A2%98%E6%97%8B%E8%BD%AC%E9%A3%8E%E8%BD%A6%E8%AE%BE%E7%BD%AE/">Hexo小标题旋转风车设置</a></p><p>为了以后自己换电脑的话方便找，所以做一些记录</p><h3 id="设置旋转风车"><a href="#设置旋转风车" class="headerlink" title="设置旋转风车"></a>设置旋转风车</h3><p>打开主题配置文件，查找 <code>beautify</code> 并且修改为如下代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f863&#x27;</span></span><br></pre></td></tr></table></figure><p>并且在 <code>inject</code> 的 <code>head</code> 处引入文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;&lt;style&gt;#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before &#123; -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; &#125;&lt;/style&gt;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ButterFly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客添加自定义css和js文件</title>
      <link href="/Blog_ButterFly/2024/03/22/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89css%E5%92%8Cjs%E6%96%87%E4%BB%B6/"/>
      <url>/Blog_ButterFly/2024/03/22/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89css%E5%92%8Cjs%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>进入到主题目录资源文件夹下，也就是 <code>themes\butterfly\source</code> 文件夹下，然后就会看到三个文件夹 <code>css</code> ， <code>img</code> ， <code>js</code> ， <code>css</code> 和 <code>js</code> 文件就可以建在这里</p><p>当然这样的话会导致主题更新的时候会把你的文件更新掉，所以可以在根目录下创建 <code>css</code> 和 <code>js</code> 文件夹，并且把对应的文件放在这里面</p><p>在引用文件时要注意，一般来说是在主题配置文件里的 inject 引入。 <code>css</code> 一般在 <code>head</code> 引入，而 <code>js</code> 文件一般在 <code>bottom</code> 中引入，当然某些特殊情况除外</p><h3 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># 自定义css</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/style.css?1&quot;&gt;</span></span><br><span class="line">    <span class="comment"># 静态文件后面加个 ?任意内容  可以在每次更新之后用户自动重新请求.</span></span><br><span class="line">    <span class="comment"># 例如添加 ?1 ,在修改此文件后改成 ?2 ,用户访问你的网站时,不会使用本地的缓存,而是请求新的内容。没修改的话就不用动。</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># 自定义js</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/script.js?1&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># 引入多个文件就直接往下复制一行改一下文件名即可，如下：</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/script1.js?1&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/script2.js?1&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ButterFly导航栏居中</title>
      <link href="/Blog_ButterFly/2024/03/22/ButterFly%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%B1%85%E4%B8%AD/"/>
      <url>/Blog_ButterFly/2024/03/22/ButterFly%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前样式的导航栏实际上倒也还好，只是在查找 ButterFly 美化时恰巧看到了这个，所以就做一下并且记录下来，原文请参考 <a href="https://b.leonus.cn/2022/hexoCenter.html">butterfly博客导航栏居中</a></p><h2 id="搜索按钮修改"><a href="#搜索按钮修改" class="headerlink" title="搜索按钮修改"></a>搜索按钮修改</h2><p>按照如下代码修改文件 <code>themes\butterfly\layout\includes\header\nav.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">  span#blog-info</span><br><span class="line">    a(href=url_for(&#x27;/&#x27;) title=config.title)</span><br><span class="line">      if theme.nav.logo</span><br><span class="line">        img.site-icon(src=url_for(theme.nav.logo))</span><br><span class="line">      if theme.nav.display_title</span><br><span class="line">        span.site-name=config.title</span><br><span class="line">    </span><br><span class="line">  #menus</span><br><span class="line">    !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    #nav-right</span><br><span class="line">      if (theme.algolia_search.enable || theme.local_search.enable || theme.docsearch.enable)</span><br><span class="line">        #search-button</span><br><span class="line">          a.site-page.social-icon.search(href=&quot;javascript:void(0);&quot;)</span><br><span class="line">            i.fas.fa-search.fa-fw</span><br><span class="line">          //- span=&#x27; &#x27;+_p(&#x27;search.title&#x27;)</span><br><span class="line"></span><br><span class="line">    #toggle-menu</span><br><span class="line">      a.site-page(href=&quot;javascript:void(0);&quot;)</span><br><span class="line">        i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><h2 id="导航栏居中"><a href="#导航栏居中" class="headerlink" title="导航栏居中"></a>导航栏居中</h2><p>导航栏只需要绝对定位，然后距离屏幕左边 50% ，然后再往左移动自身的 50% 就可以了，这里需要写一个自定义的 <code>css</code> 文件，在文件夹下创建文件 <code>themes\butterfly\source\css\Navigation_style.css</code> ，在其中写入如下内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.menus_items</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: fit-content;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>fit-content</code> 使 <code>menus_items</code> 的宽度为内容宽度，可以避免一些奇怪的 bug</p><h2 id="子菜单栏横向"><a href="#子菜单栏横向" class="headerlink" title="子菜单栏横向"></a>子菜单栏横向</h2><p>子菜单居中其实也非常的简单，只需要使其所有子菜单先变成横向，然后再居中就好了</p><h3 id="子菜单横向"><a href="#子菜单横向" class="headerlink" title="子菜单横向"></a>子菜单横向</h3><p>再上述所建立的 <code>.css</code> 文件中再添加如下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.menus_items</span> <span class="selector-class">.menus_item</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.menus_item_child</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子菜单居中"><a href="#子菜单居中" class="headerlink" title="子菜单居中"></a>子菜单居中</h3><p>居中可以单独给每一个 <code>ul</code> 元素添加样式，可以把每一个子菜单调节到满意的位置，但是如果新增菜单需要修改一下这个文件</p><p>然后给每一个子菜单设置样式，这里拿其中一个做演示，如果有多个折叠子菜单，多复制几个就可以</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这里的2是代表导航栏的第二个元素，即有子菜单的元素，可以按自己需求修改 */</span></span><br><span class="line"><span class="selector-class">.menus_items</span> <span class="selector-class">.menus_item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) <span class="selector-class">.menus_item_child</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">65px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ButterFly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ButterFly主题美化</title>
      <link href="/Blog_ButterFly/2024/03/22/ButterFly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/Blog_ButterFly/2024/03/22/ButterFly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>我这里只总结了自己用到的，可以看原教程：<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">hexo主题butterfly配置</a></p><h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>在项目的根目录 <code>Blog</code> 右键打开终端，输入如下指令安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="literal">-b</span> master https://github.com/jerryc127/hexo<span class="literal">-theme-butterfly</span>.git themes/butterfly</span><br></pre></td></tr></table></figure><p>安装 <code>pug</code> 和 <code>stylus</code> 渲染器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>修改占点配置文件，开启主题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>为了減少升级主题带来的不便，可以把主题文件夹中的 <code>_config.yml</code> 重命名为 <code>_config.butterfly.yml</code>，复制到根目录下与站点配置文件同级。</p><p><code>Hexo</code> 会自动合并主题中的 <code>_config.yml</code> 和 <code>_config.butterfly.yml</code> ，如果存在同名配置，会使用 <code>_config.butterfly.yml</code> 的配置，其优先度较高。所以像和博客网址相关联的固定资料可以设置在 <code>_config.yml</code> 中，比如博客的标题、作者信息和邮箱等等资料，而和主题样式相关的配置放在 <code>_config.butterfly.yml</code> 中，那么在将来你想换一个主题是很方便的。</p><h3 id="设置博客个人资料"><a href="#设置博客个人资料" class="headerlink" title="设置博客个人资料"></a>设置博客个人资料</h3><p>修改站点配置文件，可以修改网站的各种基本资料</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">无风之地</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">或许从未开始，或许已经结束，但是我该走了</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">落</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><h3 id="导航栏菜单"><a href="#导航栏菜单" class="headerlink" title="导航栏菜单"></a>导航栏菜单</h3><p>修改主题配置文件，如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Menu 目錄</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">博文</span> <span class="string">||</span> <span class="attr">fa fa-graduation-cap:</span></span><br><span class="line">    <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">生活</span> <span class="string">||</span> <span class="attr">fas fa-list:</span></span><br><span class="line">    <span class="string">分享:</span> <span class="string">/show/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-external-link</span></span><br><span class="line">    <span class="string">相册:</span> <span class="string">/photos/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-camera-retro</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="comment"># 留言板: /comment/ || fa fa-paper-plane</span></span><br><span class="line">  <span class="comment">#留言板: /messageboard/ || fa fa-paper-plane</span></span><br><span class="line">  <span class="string">关于笔者:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-user</span></span><br></pre></td></tr></table></figure><h3 id="代码块显示设置"><a href="#代码块显示设置" class="headerlink" title="代码块显示设置"></a>代码块显示设置</h3><p>根据如下修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span> <span class="comment">#  darker / pale night / light / ocean / mac / mac light / false</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># copy button</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># show the code language</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">false</span> <span class="comment"># 代码自动换行，关闭滚动条</span></span><br></pre></td></tr></table></figure><p>同时将站点配置文件的 <code>highlight</code> 的 <code>enable</code> 设置为 <code>false</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="本地搜索功能"><a href="#本地搜索功能" class="headerlink" title="本地搜索功能"></a>本地搜索功能</h3><ul><li><p>安装搜索插件</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-search</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件中查找修改</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># 如果没有查到内容相关内容显示</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><p>创建对应的文件夹，需要保证创建的文件夹名称与导航栏菜单里的 <code>/ /</code> 中的内容一致才能打开对应的栏目。在根目录下右键打开终端输入指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page name</span><br></pre></td></tr></table></figure><p>这个 <code>name</code> 就是你要创建的文件夹名称，例如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories // 创建分类</span><br><span class="line">hexo new page tags // 创建标签</span><br></pre></td></tr></table></figure><p>指令输入之后会在 <code>/source/</code> 文件夹下会生成你所创建的文件夹，并且其中都包含着一个 index.md 文件，并且做如下修改， <code>title</code> 是对应的文件夹下的 index.md 文件做的修改</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2024-03-18 14:19:13</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2024-03-18 14:19:18</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2024-03-18 14:19:22</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h3 id="修改副标题"><a href="#修改副标题" class="headerlink" title="修改副标题"></a>修改副标题</h3><p>在主题配置文件中，查找并修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主頁subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize typed.js (配置typed.js)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># https://github.com/mattboldt/typed.js/#customization</span></span><br><span class="line">  <span class="attr">typed_option:</span></span><br><span class="line">  <span class="comment"># source 調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  調用一句網（簡體） https://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  調用今日詩詞（簡體） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">你的心界愈空灵，愈不觉得物界喧嚣</span></span><br></pre></td></tr></table></figure><h3 id="图片设置"><a href="#图片设置" class="headerlink" title="图片设置"></a>图片设置</h3><ul><li><p>网站图标</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br></pre></td></tr></table></figure></li><li><p>头像</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.jpg</span> <span class="comment">#图片路径</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span> <span class="comment">#头像会一直转圈  </span></span><br></pre></td></tr></table></figure></li><li><p>网站背景图</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Website Background (設置網站背景)</span></span><br><span class="line"><span class="comment"># can set it to color or image (可設置圖片 或者 顔色)</span></span><br><span class="line"><span class="comment"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="attr">background:</span> <span class="string">url(/img/background.jpg)</span></span><br></pre></td></tr></table></figure></li><li><p>主页头部图</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_img:</span> <span class="string">/img/index_img.jpg</span></span><br></pre></td></tr></table></figure></li><li><p>文章详情页图</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the banner of page not setting, it will show the top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/img/top_img.jpg</span></span><br></pre></td></tr></table></figure></li><li><p>归档页顶部图</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The banner image of archive page</span></span><br><span class="line"><span class="attr">archive_img:</span> <span class="string">/img/archive_img.jpg</span></span><br></pre></td></tr></table></figure></li><li><p>tag 标签页顶部图</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the banner of tag page not setting, it will show the top_img</span></span><br><span class="line"><span class="comment"># <span class="doctag">note:</span> tag page, not tags page (子標籤頁面的 top_img)</span></span><br><span class="line"><span class="attr">tag_img:</span> <span class="string">/img/tag_img.jpg</span></span><br></pre></td></tr></table></figure></li><li><p>categories 分类页顶部图</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the banner of category page not setting, it will show the top_img</span></span><br><span class="line"><span class="comment"># <span class="doctag">note:</span> category page, not categories page (子分類頁面的 top_img)</span></span><br><span class="line"><span class="attr">category_img:</span> <span class="string">/img/category_img.jpg</span></span><br></pre></td></tr></table></figure></li><li><p>统一文章封面</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># the position of cover in home page (封面顯示的位置)</span></span><br><span class="line">  <span class="comment"># left/right/both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">https:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br></pre></td></tr></table></figure></li><li><p>为每一篇文章设置不同的封面，可以在文章自己的 markdown 文件中添加配置</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">tags: [hello]</span><br><span class="line">categories:</span><br><span class="line">description: hello word~</span><br><span class="line">top<span class="emphasis">_img: /img/hello-1.png # 顶部背景图</span></span><br><span class="line"><span class="emphasis">cover: /img/hello-1.png # 文章封面</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="图片大图查看"><a href="#图片大图查看" class="headerlink" title="图片大图查看"></a>图片大图查看</h3><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="版权样式"><a href="#版权样式" class="headerlink" title="版权样式"></a>版权样式</h3><p>修改主题配置文件</p><ul><li><p>复制内容增加版权信息</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure></li><li><p>文章版权信息</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">author_href:</span> <span class="string">https://seashore.top</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>在文章最下面出现推送信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Related Articles</span></span><br><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示文章的最大数量</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># 创建日期或者更新日期 created update</span></span><br></pre></td></tr></table></figure><h3 id="侧边栏样式"><a href="#侧边栏样式" class="headerlink" title="侧边栏样式"></a>侧边栏样式</h3><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right </span></span><br></pre></td></tr></table></figure><h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">   <span class="attr">fab fa-github:</span> <span class="string">https://github.com/xxx</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">   <span class="attr">fab fa-qq:</span> <span class="string">tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=xxx&amp;website=www.oicqzone.com</span> <span class="string">||</span> <span class="string">QQ</span></span><br><span class="line">   <span class="attr">fas fa-envelope-open-text:</span> <span class="string">mailto:xxx||</span> <span class="string">Email</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="公告栏"><a href="#公告栏" class="headerlink" title="公告栏"></a>公告栏</h3><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span> <span class="comment">#修改公告栏信息</span></span><br></pre></td></tr></table></figure><h3 id="TOC目录"><a href="#TOC目录" class="headerlink" title="TOC目录"></a>TOC目录</h3><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># toc (目錄)</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">true</span> <span class="comment"># 是否展开</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> <span class="comment"># for post</span></span><br><span class="line">  <span class="attr">scroll_percent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="背景特效美化"><a href="#背景特效美化" class="headerlink" title="背景特效美化"></a>背景特效美化</h3><p>修改主题配置文件</p><ul><li><p>鼠标点击效果</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line"><span class="comment"># https://github.com/disjukr/activate-power-mode</span></span><br><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment">#  open shake (抖动特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mouse click effects: fireworks (鼠标点击效果:萤火特效)</span></span><br><span class="line"><span class="attr">fireworks:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">9999</span> <span class="comment"># -1 or 9999</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mouse click effects: Heart symbol (鼠标点击效果: 爱心)</span></span><br><span class="line"><span class="attr">click_heart:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mouse click effects: words (鼠标点击效果: 文字)</span></span><br><span class="line"><span class="attr">ClickShowText:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">富强</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">民主</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">文明</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">和谐</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">平等</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">公正</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">法治</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">爱国</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">敬业</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">诚信</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">友善</span></span><br><span class="line">  <span class="attr">fontSize:</span> <span class="string">15px</span></span><br><span class="line">  <span class="attr">random:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>打字效果</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line"><span class="comment"># https://github.com/disjukr/activate-power-mode</span></span><br><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment">#  open shake (抖动特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>背景特效</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Background effects (背景特效)</span></span><br><span class="line"><span class="comment"># canvas_ribbon (静止彩带)</span></span><br><span class="line"><span class="comment"># See: https://github.com/hustcc/ribbon.js</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">click_to_change:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Fluttering Ribbon (动态彩带)</span></span><br><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#星空特效</span></span><br><span class="line"><span class="comment"># canvas_nest</span></span><br><span class="line"><span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&#x27;0,0,255&#x27;</span> <span class="comment">#color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(<span class="doctag">note:</span> use &#x27;,&#x27; to separate.)</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.7</span> <span class="comment"># the opacity of line (0~1), default: 0.5.</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background, default: -1.</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># the number of lines, default: 99.</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>footer 背景</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer_bg:</span> <span class="literal">true</span> <span class="comment"># 设置为 false 将于主题色一致，设置为 true 与 top_img 一致</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><ul><li><p>安装字数统计插件</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-wordcount</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure></li><li><p>修改主题配置文件</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wordcount (字數統計)</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>修改主题配置文件，在 <code>addThis</code> ， <code>sharejs</code> ， <code>addtoany</code> 中选择一个开启就可以</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Share System (分享功能)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AddThis</span></span><br><span class="line"><span class="comment"># https://www.addthis.com/</span></span><br><span class="line"><span class="attr">addThis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">pubid:</span>  <span class="comment">#访问 AddThis 官网, 找到你的 pub-id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share.js</span></span><br><span class="line"><span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">sites:</span> <span class="string">facebook,twitter,wechat,weibo,qq</span>  <span class="comment">#想要显示的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AddToAny</span></span><br><span class="line"><span class="comment"># https://www.addtoany.com/</span></span><br><span class="line"><span class="attr">addtoany:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">item:</span> <span class="string">facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ButterFly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT主题美化</title>
      <link href="/Blog_ButterFly/2024/03/20/NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/Blog_ButterFly/2024/03/20/NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>当前用得最多的是next主题，下载地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next</a></p><p>可以直接在博客根目录中打开终端，输入代码将主题下载到目录 Blog/themes 中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme<span class="literal">-next</span>/hexo<span class="literal">-theme-next</span> themes/next</span><br></pre></td></tr></table></figure><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>打开根目录下的 <code>_config.yml</code> 文件（站点配置文件），查找并且修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">无风之地</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">或许从未开始，或许已经结束，但是我该走了</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">落</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>将主题修改为 <code>next</code> ，主题的语言需要查看 <code>themes/next/language</code> 文件夹中的简体中文是 <code>zh-CN</code> 还是 <code>zh-Hans</code></p><p>next的主题一共有4种，分别是 Muse，Mist，Pisces，Gemini。 可以挨个试试找一个喜欢的就行。选定主题需要在文件 <code>themes/next/_config.yml</code> 中查找并且修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure><p>然后在根目录打开终端，输入下列指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>完成之后打开你的博客就能看到了</p><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                      <span class="comment">#首页</span></span><br><span class="line">  archives: /archives/ || archive      <span class="comment">#归档</span></span><br><span class="line">  categories: /categories/ || th       <span class="comment">#分类</span></span><br><span class="line">  tags: /tags/ || tags                 <span class="comment">#标签</span></span><br><span class="line">  about: /about/ || user               <span class="comment">#关于</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar    #日历</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat      #腾讯公益404</span></span><br></pre></td></tr></table></figure><p>“||”前面的是目标链接，后面的是图标名称，next使用的图标全是 <a href="https://link.zhihu.com/?target=http%3A//www.fontawesome.com.cn/faicons/%23web-application">图标库 - Font Awesome 中文网</a> 这一网站的，有想用的图标直接在该网站上面找图标的名称就行。新添加的菜单需要翻译对应的中文，打开 <code>theme/next/languages/zh-CN.yml</code> ，在 <code>menu</code> 下设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br></pre></td></tr></table></figure><p>在根目录下打开终端，输入如下代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;categories&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;about&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;resources&quot;</span></span><br></pre></td></tr></table></figure><p>此时在根目录的sources文件夹下会生成 categories，tags，about，resources 四个文件，每个文件中有一个<code>index.md</code>文件，修改内容分别如下。如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">---</span></span><br><span class="line">title: 分类</span><br><span class="line">date: <span class="number">2020</span><span class="literal">-02-10</span> <span class="number">22</span>:<span class="number">07</span>:<span class="number">08</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">comments: false</span><br><span class="line"><span class="literal">---</span></span><br><span class="line"></span><br><span class="line"><span class="literal">---</span></span><br><span class="line">title: 标签</span><br><span class="line">date: <span class="number">2020</span><span class="literal">-02-10</span> <span class="number">22</span>:<span class="number">07</span>:<span class="number">08</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: false</span><br><span class="line"><span class="literal">---</span></span><br><span class="line"></span><br><span class="line"><span class="literal">---</span></span><br><span class="line">title: 关于</span><br><span class="line">date: <span class="number">2020</span><span class="literal">-02-10</span> <span class="number">22</span>:<span class="number">07</span>:<span class="number">08</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;about&quot;</span></span><br><span class="line">comments: false</span><br><span class="line"><span class="literal">---</span></span><br><span class="line"></span><br><span class="line"><span class="literal">---</span></span><br><span class="line">title: 资源</span><br><span class="line">date: <span class="number">2020</span><span class="literal">-02-10</span> <span class="number">22</span>:<span class="number">07</span>:<span class="number">08</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;resources&quot;</span></span><br><span class="line">comments: false</span><br><span class="line"><span class="literal">---</span></span><br></pre></td></tr></table></figure><h3 id="设置建站时间"><a href="#设置建站时间" class="headerlink" title="设置建站时间"></a>设置建站时间</h3><p>打开主题配置文件即 <code>themes/next</code> 下的 <code>_config.yml</code> ，查找 <code>since</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  since: <span class="number">2020</span><span class="literal">-02</span>   <span class="comment">#建站时间</span></span><br></pre></td></tr></table></figure><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>打开主题配置文件即 <code>themes/next</code> 下的 <code>_config.yml</code> ，查找 <code>avatar</code> ， <code>url</code> 后是图片的链接地址</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line">avatar:</span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  rounded: true</span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure><p>这里头像图片是需要保存在 <code>themes/next/source/images</code> 文件夹中</p><h3 id="网站图标设置"><a href="#网站图标设置" class="headerlink" title="网站图标设置"></a>网站图标设置</h3><p>只需要修改 <code>small</code> 和 <code>medium</code> 为图标路径就可以了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon<span class="literal">-16x16</span>.png</span><br><span class="line">  medium: /images/favicon<span class="literal">-32x32</span>.png</span><br><span class="line">  apple_touch_icon: /images/apple<span class="literal">-touch-icon-next</span>.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure><h3 id="设置背景图片"><a href="#设置背景图片" class="headerlink" title="设置背景图片"></a>设置背景图片</h3><p>打开主题配置文件，将 <code>style:source/_data/style.stl</code> 取消注释</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure><p>打开根目录 <code>source</code> 创建文件 <code>_data/styles.styl</code> ，添加以下内容</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line">body &#123;</span><br><span class="line">      background: url(images/background.png);//自己喜欢的图片地址</span><br><span class="line">      background<span class="literal">-size</span>: cover;</span><br><span class="line">      background<span class="literal">-repeat</span>: no<span class="literal">-repeat</span>;</span><br><span class="line">      background<span class="literal">-attachment</span>: fixed;</span><br><span class="line">      background<span class="literal">-position</span>: <span class="number">50</span>% <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>两种方法</p><ol><li><p>打开 <code>themes/next/source/css/_common/conponents/post/post.styl</code> ，修改 <code>.post-block</code></p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">use-motion</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hexo<span class="literal">-config</span>(<span class="string">&#x27;motion.transition.post_block&#x27;</span>)) &#123;</span><br><span class="line">    .post<span class="literal">-block</span> &#123;</span><br><span class="line">      opacity: <span class="number">0</span>;</span><br><span class="line">      margin<span class="literal">-top</span>: <span class="number">60</span>px;</span><br><span class="line">      margin<span class="literal">-bottom</span>: <span class="number">60</span>px;</span><br><span class="line">      padding: <span class="number">25</span>px;</span><br><span class="line">      background:rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>) none repeat scroll !important;</span><br><span class="line">      <span class="literal">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">      <span class="literal">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    .pagination, .comments&#123;</span><br><span class="line">      opacity: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>source/_date/style.styl</code> 文件，添加以下代码</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.post &#123;</span><br><span class="line">   margin<span class="literal">-top</span>: <span class="number">60</span>px;</span><br><span class="line">   margin<span class="literal">-bottom</span>: <span class="number">60</span>px;</span><br><span class="line">   padding: <span class="number">25</span>px;</span><br><span class="line">   <span class="literal">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">   <span class="literal">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="设置预览摘要"><a href="#设置预览摘要" class="headerlink" title="设置预览摘要"></a>设置预览摘要</h3><p>一般来说，上传完文章之后，会在主页上显示，但是显示的是原文，所以就显得十分难看。所以在每一个创建的 <code>.md</code> 文章上面添加如下代码，并且填写上对应信息，之后主页上显示的文章的内容就是 <code>description</code> 中的内容</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">---</span></span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">categories: </span><br><span class="line">description: </span><br><span class="line"><span class="literal">---</span></span><br></pre></td></tr></table></figure><h3 id="设置侧边栏显示效果"><a href="#设置侧边栏显示效果" class="headerlink" title="设置侧边栏显示效果"></a>设置侧边栏显示效果</h3><p>打开主题配置文件，找到 <code>Sidebar Settings</code> ，设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  <span class="comment"># Sidebar Position. #设置侧边栏位置</span></span><br><span class="line">  position: left</span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  - post    默认显示模式</span></span><br><span class="line">  <span class="comment">#  - always  一直显示</span></span><br><span class="line">  <span class="comment">#  - hide    初始隐藏</span></span><br><span class="line">  <span class="comment">#  - remove  移除侧边栏</span></span><br><span class="line">  display: post</span><br></pre></td></tr></table></figure><h3 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h3><p>打开主题配置文件，搜索并且修改</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/Luo25177|| github</span><br><span class="line">  E<span class="literal">-Mail</span>: mailto:beloved25177@<span class="number">126</span>.com || envelope</span><br></pre></td></tr></table></figure><h3 id="将博文内链接设置为蓝色"><a href="#将博文内链接设置为蓝色" class="headerlink" title="将博文内链接设置为蓝色"></a>将博文内链接设置为蓝色</h3><p>打开 <code>themes/next/source/css/_common/components/post/post.styl</code> 文件，将下面代码复制到最后</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post<span class="literal">-body</span> p a&#123;</span><br><span class="line">     color: <span class="comment">#0593d3;</span></span><br><span class="line">     border<span class="literal">-bottom</span>: none;</span><br><span class="line">     &amp;:hover &#123;</span><br><span class="line">       color: <span class="comment">#0477ab;</span></span><br><span class="line">       text<span class="literal">-decoration</span>: underline;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="显示文章字数和阅读时长"><a href="#显示文章字数和阅读时长" class="headerlink" title="显示文章字数和阅读时长"></a>显示文章字数和阅读时长</h3><p>需要用到插件 <code>hexo-wordcount</code> ，在 <code>Blog</code> 目录下打开终端，执行如下命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-wordcount</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>然后打开站点配置文件，在文件末加上下列代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                <span class="comment"># 文章字数统计</span></span><br><span class="line">  time: true                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  total_symbols: true          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  total_time: true             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  exclude_codeblock: false     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure><h3 id="显示站点文章总字数"><a href="#显示站点文章总字数" class="headerlink" title="显示站点文章总字数"></a>显示站点文章总字数</h3><p>需要用到插件 <code>hexo-wordcount</code> ，在 <code>Blog</code> 目录下打开终端，执行如下命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-wordcount</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>然后在 <code>/themes/next/layout/_partials/footer.swig</code> 文件尾部加上下列代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">theme</span>-<span class="title">info</span>&quot;&gt;</span></span><br><span class="line"><span class="class">  &lt;<span class="title">div</span> <span class="title">class</span>=&quot;<span class="title">powered</span>-<span class="title">by</span>&quot;&gt;&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;<span class="title">span</span> <span class="title">class</span>=&quot;<span class="title">post</span>-<span class="title">count</span>&quot;&gt;博客全站共</span>&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="设置文章末尾”本文结束”标记"><a href="#设置文章末尾”本文结束”标记" class="headerlink" title="设置文章末尾”本文结束”标记"></a>设置文章末尾”本文结束”标记</h3><p>在路径 <code>/themes/next/layout/_macro</code> 中新建 <code>passage-end-tag.swig</code> ，文件，并且添加如下代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:24px;&quot;</span>&gt;<span class="literal">-------------</span>本文结束&lt;i <span class="class"><span class="keyword">class</span>=&quot;<span class="title">fa</span> <span class="title">fa</span>-<span class="title">paw</span>&quot;&gt;&lt;/<span class="title">i</span>&gt;感谢您的阅读-------------&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接着打开 <code>/themes/next/layout/_macro/post.swig</code> 文件，在 <code>post-footer</code> 前， <code>END POST BODY</code> 之后添加下列代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> not is_index and theme.passage_end_tag.enabled %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include <span class="string">&#x27;passage-end-tag.swig&#x27;</span> %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在主题配置文件的末尾添加</p><h3 id="文章末尾添加版权说明"><a href="#文章末尾添加版权说明" class="headerlink" title="文章末尾添加版权说明"></a>文章末尾添加版权说明</h3><p>查找主题配置文件中的 <code>creative_commons</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by<span class="literal">-nc-sa</span></span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true  <span class="comment"># 将false改为true即可显示版权信息</span></span><br><span class="line">  language:</span><br></pre></td></tr></table></figure><h3 id="添加访问量统计"><a href="#添加访问量统计" class="headerlink" title="添加访问量统计"></a>添加访问量统计</h3><p>打开主题配置文件，查找并且修改下列代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>打开 <code>/themes/next/layout/_partials/footer.swig</code> ，在文件最后添加下列代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.busuanzi_count.enable %&#125;</span><br><span class="line">    &lt;script async src=<span class="string">&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;总访问量&lt;span id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt;次&lt;/span&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span>=&quot;<span class="title">post</span>-<span class="title">meta</span>-<span class="title">divider</span>&quot;&gt;|&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">span</span> <span class="title">id</span>=&quot;<span class="title">busuanzi_container_site_uv</span>&quot;&gt;总访客数&lt;<span class="title">span</span> <span class="title">id</span>=&quot;<span class="title">busuanzi_value_site_uv</span>&quot;&gt;&lt;/<span class="title">span</span>&gt;人&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">span</span> <span class="title">class</span>=&quot;<span class="title">post</span>-<span class="title">meta</span>-<span class="title">divider</span>&quot;&gt;|&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!-- 不蒜子计数初始值纠正 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="class">$(<span class="title">document</span>).<span class="title">ready</span>(<span class="title">function</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">    var int = setInterval(fixCount, <span class="number">50</span>);  // <span class="number">50</span>ms周期检测函数</span><br><span class="line">    var countOffset = <span class="number">20000</span>;  // 初始化首次数据</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fixCount</span><span class="params">()</span></span> &#123;            </span><br><span class="line">       <span class="keyword">if</span> (document.getElementById(<span class="string">&quot;busuanzi_container_site_pv&quot;</span>).style.display != <span class="string">&quot;none&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$</span>(<span class="string">&quot;#busuanzi_value_site_pv&quot;</span>).html(parseInt(<span class="variable">$</span>(<span class="string">&quot;#busuanzi_value_site_pv&quot;</span>).html()) + countOffset); </span><br><span class="line">            clearInterval(int);</span><br><span class="line">        &#125;                  </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$</span>(<span class="string">&quot;#busuanzi_container_site_pv&quot;</span>).css(<span class="string">&quot;display&quot;</span>) != <span class="string">&quot;none&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$</span>(<span class="string">&quot;#busuanzi_value_site_uv&quot;</span>).html(parseInt(<span class="variable">$</span>(<span class="string">&quot;#busuanzi_value_site_uv&quot;</span>).html()) + countOffset); // 加上初始数据 </span><br><span class="line">            clearInterval(int); // 停止检测</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a><strong>本地搜索</strong></h3><p>在 <code>Blog</code> 目录下右键打开终端并且输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-search</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>在主题配置文件中，查找并且做如下修改</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: manual   <span class="comment">#手动，按回车键或搜索按钮触发搜索</span></span><br></pre></td></tr></table></figure><h3 id="代码块样式自定义"><a href="#代码块样式自定义" class="headerlink" title="代码块样式自定义"></a>代码块样式自定义</h3><p>打开文件 <code>Blog/source/_data/styles.styl</code> ，添加以下内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: <span class="comment">#ff7600;</span></span><br><span class="line">    background: <span class="comment">#fbf7f8;</span></span><br><span class="line">    margin: <span class="number">2</span>px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: <span class="number">5</span>px <span class="number">0</span>;</span><br><span class="line">    padding: <span class="number">5</span>px;</span><br><span class="line">    border<span class="literal">-radius</span>: <span class="number">3</span>px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: <span class="number">1</span>px solid <span class="comment">#d6d6d6;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公式显示"><a href="#公式显示" class="headerlink" title="公式显示"></a>公式显示</h3><p>对于我来说，博客中有很多做控制的文章，所以会有很多公式，而公式显示不好就令作为一个完美主义者的我很头疼，所以查找了很多文章才把效果做好</p><p><code>NexT</code> 主题内部已经集成了 <code>MathJax</code> 和 <code>KaTeX</code> ，相对来说配置起来已经是很方便了。但在一些细节方面上还是存在各种小问题，比如说不支持行内渲染，公式换行，渲染冲突和超长公式等，所以下面会对这些问题做出解决方案</p><ol><li><p>启用 <code>MathJax</code></p><p> 打开主题配置文件，查找 <code>math</code> 并作如下修改</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure><ul><li><code>per_page</code>默认为<code>true</code>，表示每篇文章需要额外地单独启用 MathJax。 也就是说，还需要在其文章头部添加<code>mathjax: true</code>，否则其中的 MathJax 公式依然不会被解析。</li><li><code>engine</code>默认使用的是<code>mathjax</code>，相比<code>katex</code>功能更强大，同时也会慢一点</li></ul></li><li><p>更换渲染引擎</p><p> 启用完 MathJax 之后，就可以写一些简单的公示了，但是对于一些比较复杂的公式就会渲染出错，主要原因就是Hexo默认的渲染引擎<code>hexo-renderer-marked</code>对MathJax的支持很不好，会出现各种莫名其妙的问题。主题官方也推荐更换其它渲染引擎。这里推荐使用 <code>hexo-renderer-kramed</code></p><p> 在 <code>Blog</code> 文件夹下打开终端并且输入如下指令来实现渲染引擎的更换</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo<span class="literal">-renderer-marked</span> <span class="literal">--save</span></span><br><span class="line">npm i hexo<span class="literal">-renderer-kramed</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure></li><li><p>渲染冲突问题</p><p> 对于以下公式</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ \alpha\beta $</span><br><span class="line"></span><br><span class="line">$ \alpha<span class="emphasis">_\beta $</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">$ \alpha_</span>\beta = \gamma<span class="emphasis">_\delta $</span></span><br></pre></td></tr></table></figure><p> 最终渲染效果为 $\alpha\beta$， $\alpha_\beta$ 和 $ \alpha<em>\beta = \gamma</em>\delta $</p><p> 实际上是把同一行中的下划线渲染成了斜体符号，所以就出现上述问题，有个好办法就是直接修改 <code>hexo-renderer-kramed</code> 的源码</p><p> 打开文件， <code>node_modules/kramed/lib/rules/inline.js</code> ，做如下修改</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inline = &#123;</span><br><span class="line">  <span class="comment">// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line">  <span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line">  <span class="comment">// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 注意只改这两行，其它不需要改</p></li><li><p>公式超长</p><p> NexT主题对公式的样式配置存在一些小问题，导致当公式太长的时候，显示内容会超出文章区域。</p><p> 如果使用默认的配置，行内公式超长时总会超出文章显示区域，而块公式时候会超出区域则取决于选择的渲染方式（HTML-CSS不会超出区域，其他情况会）。</p><p> 进行了修改后，总是会在公式超出区域时生成滚动条，效果更佳理想。</p><p> 打开文件 <code>themes/next/layout/_third-party/math/mathjax.swig</code> 文件，在文件末端添加如下代码</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><br><span class="line">   <span class="title class_">MathJax</span>.<span class="property">Hub</span>.<span class="title class_">Queue</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> all = <span class="title class_">MathJax</span>.<span class="property">Hub</span>.<span class="title function_">getAllJax</span>(), i;</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; all.<span class="property">length</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(all[i].<span class="property">inputID</span> + <span class="string">&#x27;-Frame&#x27;</span>).<span class="property">parentNode</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;has-jax&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; theme.math.mathjax.cdn &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.has-jax</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">   <span class="attribute">overflow-x</span>: auto;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">   <span class="attribute">overflow-y</span>: hidden;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p> 最终也得到了解决，但是也有一些其它的问题</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a></p><p><a href="https://i-m.dev/posts/20190304-210101.html">Hexo+NexT使用MathJax问题 | I’m dev (i-m.dev)</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客创建</title>
      <link href="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/"/>
      <url>/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="绑定github"><a href="#绑定github" class="headerlink" title="绑定github"></a>绑定github</h2><h3 id="SSH与github"><a href="#SSH与github" class="headerlink" title="SSH与github"></a>SSH与github</h3><p>SSH（安全外壳协议，Secure Shell 的缩写）是建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。简单来说，SSH就是保障你的账户安全，将你的数据加密压缩，不仅防止其他人截获你的数据，还能加快传输速度。</p><p>一般来说，安装 git bash 之后实际上是自带 SSH 的，所以可以检验一下，在终端输入指令 <code>ssh</code> 会显示出 <code>usage</code> 的内容，那就是装好了，有问题的话，可以自行百度一下。</p><p>没问题了就可以输入指令 <code>ssh-keygen -t rsa</code> ，使用 RSA 算法生成密钥，然后，如下</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/IMG_20240320_093427.png" alt="IMG_20240320_093427.png"></p><p>其中 红色圈里面是输入保存的地址，蓝色圈里输入的是 passphrase，可以不输入，直接回车就行。最终去你保存的地址找到它</p><p>接下来我们要做的事情就是把公钥 id.pub  的内容添加到 GitHub。复制公钥 id.pub 文件里的内容，你可以通过目录找到 id.pub 文件的位置，打开复制里面的内容。（文件名是与上述操作中文件名称有关，我的设置的路径是 E:\id，所以相应的文件名就是 id）</p><p>之后进入github的主页，进入设置（settings），然后找到 SSH and GPG keys，点击 New SSH key，创建一个新的 SSH</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710899281606.png" alt="1710899281606.png"></p><p>将在文件 id.pub 中复制的内容，粘贴到图下的 key 中，然后点击 Add SSH key，就好了</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710899471693.png" alt="1710899471693.png"></p><p>之后，在终端中输入 <code>ssh -T [git@github.com](mailto:git@github.com)</code> 进行检验，第一次会有一个询问，只要回答 <code>yes</code> 就可以了，出现提示 <code>successfully authenticated</code> 就表示绑定成功。</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>具体github的使用可以查看 <a href="https://seashore.top/2024/03/18/git/">git使用</a>，应该还挺简单的吧。但是如果是第一次提交会出现需要输入用户名和邮箱的情况，这就输入自己的就可以了。而且第一次上传需要填写密码。成功之后应该能在自己的github账号中看到提交记录。</p><h2 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h2><p>我是在西部数码中购买的域名，所以这里就对西部数码的购买叙述一下吧</p><h3 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h3><p>进入西部数码的主页，点击域名注册，然后在域名查询中输入自己想要的域名，然后查询，然后需要找一个没有注册过的域名，然后才能注册（建议是选一个便宜的，一般来说便宜的可能 12/年，所以注意查看）</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710900188059.png" alt="1710900188059.png"></p><p>注册完成之后，就能在域名管理中看到自己注册的域名了</p><h3 id="域名使用"><a href="#域名使用" class="headerlink" title="域名使用"></a>域名使用</h3><p>可以看看 <a href="https://www.west.cn/services/domain/domainguide.asp">域名使用指南-西部数码 (west.cn)</a>，这个就是西部数码的域名使用流程。</p><p><strong>实名认真</strong></p><p>没有实名认证的话，域名是不能正常使用的</p><p><strong>域名解析</strong></p><p>这个就是将域名绑定到你的网站数据存储的地方，后面会细说。</p><p><strong>备案</strong></p><p>这个一定要注意，没有备案的网站域名是被认为是外网的，登录可能需要挂梯子，并且浏览器会报警告——网络不安全，备案完成之后就没问题了。但是备案完成之前，完成之前的步骤域名也是可以使用的。通常备案需要好几天，至少也需要一周左右，这一周就可以趁着还没备好案把自己的博客做一做先</p><h2 id="node-js-和-hexo"><a href="#node-js-和-hexo" class="headerlink" title="node.js 和 hexo"></a>node.js 和 hexo</h2><h3 id="node-js-安装"><a href="#node-js-安装" class="headerlink" title="node.js 安装"></a>node.js 安装</h3><p>下载地址：<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/">node.js官网</a></p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710900918219.png" alt="1710900918219.png"></p><p>如上图，点击上方的 Download，然后下载就行</p><p>安装的时候，记得给它找一个文件夹（注意建议别装在C盘），具体步骤可以看 <a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/antma/article/details/86104068">node.js安装步骤</a></p><p>安装完成之后，打开终端验证一下是否安装成功。在终端分别输入 <code>node -v</code> 和 <code>npm -v</code> 验证，安装好了的话会出现版本号的</p><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><p>hexo就是个人博客的框架，安装之前要现在github上创建一个仓库，仓库名称为 <code>[xxx.github.io](http://xxx.github.io)</code> 其中 <code>xxx</code> 就是你的 github 的用户名</p><p>然后在某一个你喜欢的位置创建一个文件夹 Blog，这个就是你的博客的本地文件夹了。然后进入该文件夹，右键打开终端，输入指令 <code>npm install -g hexo-cli</code> 安装 hexo。</p><p>安装完成之后进行初始化，终端输入指令 <code>hexo init</code></p><p>然后进行静态布置 <code>hexo g</code> ，部署之后可以利用 <code>hexo s</code> 在本地查看， <code>ctrl-c</code> 可以终止运行</p><h3 id="将hexo部署到github上"><a href="#将hexo部署到github上" class="headerlink" title="将hexo部署到github上"></a>将hexo部署到github上</h3><p>打开 Blog 目录下的 <code>_config.yml</code> 文件，查找如下内容并且进行修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:<span class="comment">//github.com/xxx/xxx.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>其中 xxx 就是你的github用户名</p><p>然后回到 Blog 文件夹中，安装 git 部署的插件，右键打开终端，在终端输入指令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后使用指令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 <span class="keyword">public</span></span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 <span class="keyword">public</span> 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>就可以上传到 github 上了，之后打开浏览器，输入网址 <code>[https://xxx.github.io](https://xxx.github.io)</code> 就可以打开你的网页了（xxx 还是你的 github 用户名）</p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><h3 id="解析域名-1"><a href="#解析域名-1" class="headerlink" title="解析域名"></a>解析域名</h3><p>进入西部数码的首页，登录之后，进入管理中心→域名管理，在自己购买的域名之后点击解析</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710902822135_(2" alt="1710902822135 (2).png">.png)</p><p>IPV4地址可以通过ping得到，打开终端输入指令 <code>ping [xxx.github.io](http://xxx.github.io)</code> xxx 就是你的github的用户名</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710903210185.png" alt="1710903210185.png"></p><p>得到对应的IPV4地址。但是实际上这个IPV4的地址是会跳动的，大概有8种，如图，可以全部添加进解析中</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710903400028_(1" alt="1710903400028 (1).png">.png)</p><p>一定要注意添加一个 CNAME 记录，并且内容为你的 github 的那个仓库名，或者说是你之前做好的那个网站的域名，上述填写的东西除了你的仓库名，其它每个人都是一致的。</p><h3 id="绑定github仓库"><a href="#绑定github仓库" class="headerlink" title="绑定github仓库"></a>绑定github仓库</h3><p>打开 Blog 文件中的 source 文件夹，创建一个 CNAME （无后缀）文件，写入你的域名，不要加 www 否则每次访问都必须加 www，但如果不带有 www，以后访问的时候带不带 www 都可以访问</p><p>在 Blog 文件夹中打开终端，输入下列指令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后打开 github 进入你的仓库 <code>[xxx.github.io](http://xxx.github.io)</code> 的设置中，进入 page 中，应该可以看到箭头处已经填上了你的域名，如果没有就可以手动填写一下（有可能是因为网络波动没上传上，可以看看有没有 CNAME 文件来看是否部署成功，正常来说 CNAME 上传成功之后就自动填上了）</p><p><img src="/Blog_ButterFly/2024/03/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/1710904280748_(1" alt="1710904280748 (1).png">.png)</p><p>这就完成了，在浏览器中输入你的域名就可以进入你的网页了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/Blog_ButterFly/2024/03/20/%E7%AE%97%E6%B3%95/"/>
      <url>/Blog_ButterFly/2024/03/20/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>用于寻找一个数组内最大或者最小的元素，单调的意思就是栈内的数据排列是单调递增或者递减的</p><p>例如，如果是一个单调递增的栈，遇到比top元素更小的元素的话，就需要把top之前比该元素小的元素全部弹出，之后再将该元素放入，继续维持单调栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode 42</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; height)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"> <span class="type">int</span>     n   = height.size();</span><br><span class="line"> <span class="type">int</span>     res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="comment">// 将栈顶中小的元素推出栈，并且计算这个范围内的数据</span></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.top() &lt; height[i]) &#123;</span><br><span class="line">   <span class="type">int</span> top = <span class="built_in">stack</span>.top();</span><br><span class="line">   <span class="built_in">stack</span>.pop();</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty()) <span class="comment">// 如果已经空了就中断不再进行下列的操作 说明已经计算完所有的数据了</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="type">int</span> left     = <span class="built_in">stack</span>.top();</span><br><span class="line">   <span class="type">int</span> currentwidth   = i - left - <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> currentheight  = min(height[left], height[i]) - height[<span class="built_in">stack</span>.top()];</span><br><span class="line">   res      += currentwidth * currentheight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将数据进栈</span></span><br><span class="line">  <span class="built_in">stack</span>.push(i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法的结构可以抽象为树形结构，N叉树</p><p><img src="/Blog_ButterFly/2024/03/20/%E7%AE%97%E6%B3%95/1671680280-ucUOKd-image.png" alt="1671680280-ucUOKd-image.png"></p><p>每次从集合中选取元素，可以选择的范围就会缩小，图中，n就是树的宽度，k就是树的深度，每次都搜索到叶子节点，就可以找到一个结果</p><p>回溯算法三部曲</p><ul><li><p>递归函数的返回值和参数</p><p>  需要定义两个全局变量，一个用来存储符合的结果，一个用于存储单次的结果，这样的话代码的可读性就比较好，有时候会定义开始位置来防止出现重复的结果</p></li><li><p>回溯的终止条件</p><p>  当每次回溯从开始位置已经不可能满足结果的条件了，就可以终止本次回溯，这个终止条件相当于是剪枝优化。</p><p>  当寻找到符合条件的结果之后，就可以终止本次回溯，也就是说，会回到上一层回溯的状态，然后跳过这一个元素并且继续回溯。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"> callBack(res, digits);</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> <span class="built_in">map</span>[<span class="number">10</span>][<span class="number">4</span>] = &#123;</span><br><span class="line"> &#123;<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">   &#123;<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">   &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">   &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">   &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">callBack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; numbers, <span class="built_in">string</span> digits)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (digits.length() == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> <span class="type">int</span> sl = <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">if</span> (digits[<span class="number">0</span>] - <span class="number">0x30</span> == <span class="number">7</span> || digits[<span class="number">0</span>] - <span class="number">0x30</span> == <span class="number">9</span>)</span><br><span class="line">  sl = <span class="number">4</span>;</span><br><span class="line"> <span class="type">int</span> n = numbers.size();</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sl; j++) &#123; numbers.emplace_back(s + <span class="built_in">map</span>[digits[<span class="number">0</span>] - <span class="number">0x30</span>][j]); &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sl; j++) &#123; numbers.emplace_back(numbers[i] + <span class="built_in">map</span>[digits[<span class="number">0</span>] - <span class="number">0x30</span>][j]); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> numbers.erase(numbers.begin(), numbers.begin() + n);</span><br><span class="line"> callBack(numbers, <span class="built_in">string</span>(digits.begin() + <span class="number">1</span>, digits.end()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法 Greedy"></a>贪心算法 Greedy</h2><p>在对问题求解的时候，总是作出当前来看最优的解，不从整体上考虑，只求的局部最优解</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>kmp相当于是双指针，对于需要匹配的字符串c2和目标字符串c1，next数组记录的是c1字符串与c2字符串不匹配的时候下一次的位置，这个next数组的记录一定需要寻找之前的与当前字符串相等的位置，并且需要回溯的时候回到那个位置。</p><p>next[i-1] 表示当前不匹配的话返回的上一个位置。如果返回的位置与当前的位置一直不相同就一直返回到开头，next[i-1] 就是如果有循环的字符串的话，返回到的上一次循环的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string c1, string c2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = c1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len2 = c2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> next[len1];</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; c1[i] != c1[k])</span><br><span class="line">        k = next[k - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (c1[i] == c1[k]) </span><br><span class="line">        k++;</span><br><span class="line">      next[i] = k; <span class="comment">// 记录与之相等的最相近的坐标位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; c1[i] != c2[j])</span><br><span class="line">        j = next[j - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (c1[i] == c2[j])</span><br><span class="line">        j++;</span><br><span class="line">      <span class="keyword">if</span> (j == len2)</span><br><span class="line">        <span class="keyword">return</span> i - len2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>与分治法相似，在求解子问题的时候，保留子问题的解，后面子问题求解时可以直接拿来计算</p><p>对于一个规模为n的问题，将其分解为k个规模较小的子问题（阶段），按顺序求解子问题，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，通过决策求得<strong>局部最优解</strong>，依次解决各子问题。最后可以通过简单的判断，得到原问题的解。</p><p><strong>阶段</strong>：求解第n个子问题称为第n个阶段。动态规划是按照顺序去求解子问题的，这里子问题的求解顺序很重要。</p><p><strong>状态</strong>：在求解第n个阶段时，已求解n-1个阶段的解，称为状态。</p><p><strong>决策</strong>：在求解第n个阶段时，根据状态和计算规则，可以得到第n个阶段时解。</p><p><strong>特征</strong></p><ol><li>大问题可分解</li><li>子问题易解决</li><li><p>解可合并</p><p> 利用该问题分解出的子问题的解可以合并为该问题的解</p></li><li><p>子问题重叠</p><p> 计算某个子问题的解，并且保存，节省后面重复计算的时间</p></li><li><p>当前状态=上一状态+当前局部最优解</p></li></ol><p><strong>基本步骤</strong></p><ol><li>设计状态</li><li>状态转移方程</li><li>设定初始状态</li><li>状态转移</li><li>得解</li><li><p>分治法</p><p> 对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。分治法其实就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p> <strong>基本特征</strong></p><ol><li><p>大问题可分解</p><p> 是使用分治法的前提，问题可分解，即是类似于数学归纳法，我们可以递归求解方程公式，然后根据方程公式设计出程序</p></li><li><p>子问题易解决</p></li><li>解可合并</li><li>子问题独立性</li></ol></li><li><p>拓扑排序</p><p> 对一个有向无环图进行拓扑排序，是将其中所有的顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个<a href="https://baike.baidu.com/item/%E5%81%8F%E5%BA%8F/2439087">偏序</a>得到该集合上的一个<a href="https://baike.baidu.com/item/%E5%85%A8%E5%BA%8F/10577699">全序</a>，这个操作称之为拓扑排序。</u,v></p><p> <strong>理解</strong></p><ul><li>在一个有向图中，对所有节点进行排序，要求没有一个节点指向它前面的节点</li><li>先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。</li><li>一直做改操作，直到所有的节点都被分离出来。</li><li><p>如果最后不存在入度为0的节点，但还存在节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。</p><p><a href="https://img-blog.csdn.net/20150507001759702">https://img-blog.csdn.net/20150507001759702</a></p><p><strong>实现思路</strong></p></li><li><p>先把入度为0的节点找到并且打印出来</p></li><li><p>删除入度为0的节点，继续循环上一步，直到图为null</p><p><strong>算法具体思路</strong></p></li></ul><ol><li><p>是遍历整个图中的顶点，找出入度为0的顶点，然后标记删除该顶点，更新相关顶点的入度，由于图中有V个顶点，每次找出入度为0的顶点后会更新相关顶点的入度，因此下一次又要重新扫描图中所有的顶点。故时间复杂度为O(V^2)</p><p> 问题：由于删除入度为0的顶点时，只会更新与它邻接的顶点的入度，即只会影响与之邻接的顶点。但是上面的方式却遍历了图中所有的顶点的入度。</p></li><li><p>先将入度为0的顶点放在栈或者队列中。当队列不空时，删除一个顶点v，然后更新与顶点v邻接的顶点的入度。只要有一个顶点的入度降为0，则将之入队列。此时，拓扑排序就是顶点出队的顺序。该算法的时间复杂度为O（V+E）</p><p><strong>实现</strong></p></li><li><p>遍历图中所有的顶点，将入度为0的顶点 入队列。</p></li><li>从队列中出一个顶点，打印顶点，更新该顶点的邻接点的入度(减1)，如果邻接点的入度减1之后变成了0，则将该邻接点入队列。</li><li><p>一直执行上面 第二步，直到队列为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode 课程表问题 拓扑排序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;numCourses, <span class="type">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; &amp;prerequisites)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">inDegree</span><span class="params">(numCourses, <span class="number">0</span>)</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">    <span class="type">int</span> n = prerequisites.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      mp[prerequisites[i][<span class="number">1</span>]].emplace_back(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">      inDegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numCourses; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[j] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : mp[i])</span><br><span class="line">            inDegree[a]--;</span><br><span class="line">          inDegree[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (inDegree[i] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="深度优先-DFS"><a href="#深度优先-DFS" class="headerlink" title="深度优先 DFS"></a>深度优先 DFS</h2><p>主要思路就是沿着一条路走到底，深入到不能深入为止，然后返回上一层继续深度优先，直到这条支路上没有可以探索的分支为止，就返回到上一层，相当于是暴力穷举</p><p><img src="https://img-blog.csdnimg.cn/04aeba61d8b84e95b7986a6b225eb51d.png" alt="https://img-blog.csdnimg.cn/04aeba61d8b84e95b7986a6b225eb51d.png"></p><p><strong>特点</strong></p><p>1、对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。要特别注意的是，二叉树的深度优先遍历比较特殊，可以细分为先序遍历、中序遍历、后序遍历（我们前面使用的是先序遍历）。<br>2、不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。<br>3、一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;</span><br><span class="line">  TreeNode *right;</span><br><span class="line"></span><br><span class="line">  TreeNode(): val(<span class="number">0</span>), left(nullptr), right(nullptr)&#123;&#125;</span><br><span class="line">  TreeNode(<span class="type">int</span> value): val(value), left(nullptr), right(nullptr)&#123;&#125;</span><br><span class="line">  TreeNode(<span class="type">int</span> value, TreeNode* left, TreeNode* right): val(value), left(left), right(right)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSF</span><span class="params">(TreeNode *root)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">  func(root-&gt;val);</span><br><span class="line">  DFS(root-&gt;left);</span><br><span class="line">  DFS(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSM</span><span class="params">(TreeNode *root)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">  DFS(root-&gt;left);</span><br><span class="line">  func(root-&gt;val);</span><br><span class="line">  DFS(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSB</span><span class="params">(TreeNode *root)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">  DFS(root-&gt;left);</span><br><span class="line">  DFS(root-&gt;right);</span><br><span class="line">  func(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>广度优先 BFS</p><p> 广度优先遍历是首先把起点相邻的几个点探索完成，然后去探索距离起点稍远一些（隔一层）的点，然后再去玩探索距离起点更远一些（隔两层）的点… 是一层一层的向外探索。</p><p> 遍历规则：<br> 1）先访问完当前顶点的所有邻接点。(应该看得出广度的意思)<br> 2）先访问顶点的邻接点先于后访问顶点的邻接点被访问。</p><p> <img src="https://img-blog.csdnimg.cn/1073d7220e174309b87218d24e080e5d.png" alt="https://img-blog.csdnimg.cn/1073d7220e174309b87218d24e080e5d.png"></p><p> <strong>特点</strong></p><p> 1、又叫层次遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止<br> 2、保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。<br> 3、一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;</span><br><span class="line">  TreeNode *right;</span><br><span class="line"></span><br><span class="line">  TreeNode(): val(<span class="number">0</span>), left(nullptr), right(nullptr)&#123;&#125;</span><br><span class="line">  TreeNode(<span class="type">int</span> value): val(value), left(nullptr), right(nullptr)&#123;&#125;</span><br><span class="line">  TreeNode(<span class="type">int</span> value, TreeNode* left, TreeNode* right): val(value), left(left), right(right)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(TreeNode *root)</span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode* &gt; bfs;</span><br><span class="line">  func(root-&gt;val);</span><br><span class="line">  <span class="keyword">while</span>(!bfs.empty())&#123;</span><br><span class="line">    TreeNode *p = bfs.front();</span><br><span class="line">    bfs.pop();</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">continue</span>;</span><br><span class="line">    func(p-&gt;val);</span><br><span class="line">    bfs.push(p-&gt;left);</span><br><span class="line">    bfs.push(p-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p>指针一左一右向中间逼近，例如二分查找法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> r = nums.size() - <span class="number">1</span>;</span><br><span class="line"> sort(nums.begin(), nums.end());</span><br><span class="line"> <span class="keyword">while</span> (r &gt; l) &#123;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">   l = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   r = mid;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> nums[r] == target ? r : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>一快一慢，步长一大一小，环的问题和单链表寻找中间节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line"> Node* next;</span><br><span class="line"> <span class="type">int</span>   val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有环</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">func</span><span class="params">(Node* node)</span></span><br><span class="line">&#123;</span><br><span class="line"> Node* fast = node-&gt;next;</span><br><span class="line"> Node* low  = node;</span><br><span class="line"> <span class="keyword">while</span> (fast != low) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fast-&gt;next-&gt;next)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 无环</span></span><br><span class="line">  fast = fast-&gt;next-&gt;next;</span><br><span class="line">  low  = low-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找中间节点</span></span><br><span class="line">Node* <span class="title function_">func</span><span class="params">(Node* node)</span></span><br><span class="line">&#123;</span><br><span class="line"> Node* fast = node;</span><br><span class="line"> Node* low  = node;</span><br><span class="line"> <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fast-&gt;next-&gt;next)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  fast = fast-&gt;next-&gt;next;</span><br><span class="line">  low  = low-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line">Node* <span class="title function_">func</span><span class="params">(Node* head)</span>&#123;</span><br><span class="line"> Node* fast = head;</span><br><span class="line"> Node* slow = head;</span><br><span class="line"> <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">  <span class="keyword">if</span>(fast-&gt;next) fast = fast-&gt;next-&gt;next;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  slow = slow-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>一般是右端向右扩充，达到停止条件之后不动，左端向右端逼近，达到停止条件之后不动，右端继续运动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode 3th</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span>     left  = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span>     right = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span>     n   = s.length();</span><br><span class="line"> <span class="built_in">unordered_set</span>&lt;<span class="type">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"> <span class="type">int</span>     res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (; right &lt; n; ++right) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">set</span>.find(s[right]) == <span class="built_in">set</span>.end())</span><br><span class="line">   <span class="built_in">set</span>.insert(s[right]);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   res = max(res, right - left);</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">set</span>.find(s[right]) != <span class="built_in">set</span>.end()) &#123;</span><br><span class="line">    <span class="built_in">set</span>.erase(s[left]);</span><br><span class="line">    left++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">set</span>.insert(s[right]);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> max(res, right - left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>&#123;LEFT, RIGHT&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">const</span> <span class="type">int</span>&amp; begin, <span class="type">const</span> <span class="type">int</span>&amp; end)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(begin &gt;= end)<span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> flag = LEFT;</span><br><span class="line">  <span class="type">int</span> left = begin;</span><br><span class="line">  <span class="type">int</span> right = end;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag == LEFT)&#123;</span><br><span class="line">      <span class="keyword">while</span>(vec[left] &lt; vec[right])right--;</span><br><span class="line">      flag == RIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(vec[left] &lt; vec[right])left--;</span><br><span class="line">      flag == LEFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = vec[left];</span><br><span class="line">    vec[left] = vec[right];</span><br><span class="line">    vec[right] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">quicksort</span>(vec, begin, left - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">quicksort</span>(vec, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(nlog_2n)$</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slowsort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      <span class="keyword">if</span>(vec[i] &lt; vec[j])&#123;</span><br><span class="line">        <span class="type">int</span> temp = vec[i];</span><br><span class="line">        vec[i] = vec[j];</span><br><span class="line">        vec[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(n^2)$</p><p>多次运行结果验证，90%的概率是快速排序速度快于冒泡排序</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><strong>桶排序</strong></h3><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>可以使用位运算来判断两个字符串是否有相同的字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string s2)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mask</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> &amp;c : s1)</span><br><span class="line">    mask[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> &amp;c : s2)</span><br><span class="line">    mask[<span class="number">1</span>] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> mask[<span class="number">0</span>] &amp; mask[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Brian Kernighan算法：Brian Kernighan算法可以用于清除二进制数中最右侧的1。Brian Kernighan算法的做法是先将当前数减一，然后在与当前数进行按位与运算。</strong></p><p>可以统计一个数字中二进制中1的数目，即1比特数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x) &#123;</span><br><span class="line"> x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line"> n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">line_segment_tree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;T&gt; tree;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"> <span class="comment">// 建树</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">const</span> vector&lt;T&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin == end) &#123;</span><br><span class="line">      tree[node] = nums[begin];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>((node &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, begin, mid, nums);</span><br><span class="line">    <span class="built_in">build</span>((node &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>, mid + <span class="number">1</span>, end, nums);</span><br><span class="line">    tree[node] = tree[(node &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>] + tree[(node &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 改变某个位置的数据</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val, <span class="type">int</span> node, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin == end) &#123;</span><br><span class="line">      tree[node] = val;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= mid) </span><br><span class="line">      <span class="built_in">change</span>(index, val, (node &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, begin, mid);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">change</span>(index, val, (node &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">    tree[node] = tree[(node &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>] + tree[(node &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 输出某个范围内的和</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">range</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> node, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == begin &amp;&amp; right == end) &#123;</span><br><span class="line">      <span class="keyword">return</span> tree[node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">range</span>(left, right, (node &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, begin, mid);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">range</span>(left, right, (node &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">range</span>(left, mid, (node &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, begin, mid) + <span class="built_in">range</span>(mid + <span class="number">1</span>, right, (node &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 初始化，存储一个数组</span></span><br><span class="line">  <span class="built_in">line_segment_tree</span>(<span class="type">const</span> vector&lt;T&gt;&amp; nums) : <span class="built_in">n</span>(nums.<span class="built_in">size</span>()), <span class="built_in">tree</span>(<span class="built_in">vector</span>&lt;T&gt;(nums.<span class="built_in">size</span>() * <span class="number">4</span>)) &#123;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, nums);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="寻找质数的算法"><a href="#寻找质数的算法" class="headerlink" title="寻找质数的算法"></a>寻找质数的算法</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>      ans = <span class="number">0</span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vs</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">   <span class="keyword">if</span> (vs[i]) &#123;</span><br><span class="line">    ans++;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) i * i &lt; n)</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i)</span><br><span class="line">      vs[j] = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;  primes;</span><br><span class="line"> <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isprime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isprime[i])</span><br><span class="line">   primes.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">  <span class="type">int</span> primenum = primes.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; primenum &amp;&amp; i * primes[j] &lt; n; ++j) &#123;</span><br><span class="line">   isprime[i * primes[j]] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N数和"><a href="#N数和" class="headerlink" title="N数和"></a>N数和</h2><p>leetcode-216</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;     temp;</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">9</span>); i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">check</span>(i, k, n)) &#123;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mask, <span class="type">int</span> k, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  temp.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; mask) &#123;</span><br><span class="line">    temp.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    sum += i;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp.<span class="built_in">size</span>() == k &amp;&amp; sum == n;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维前缀和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prefix_Sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span>     n = grid.<span class="built_in">size</span>();</span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"> sum[<span class="number">0</span>] = grid[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  sum[i] = sum[i - <span class="number">1</span>] + grid[i];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维前缀和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prefix_Sum</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span>         m = grid.<span class="built_in">size</span>();</span><br><span class="line"> <span class="type">int</span>         n = grid.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">size</span>();</span><br><span class="line"> <span class="comment">// 使用 m + 1 和 n + 1 主要是就不需要计算0处的数据了，初始化全为0就可以了</span></span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sum</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">   sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/DataStruct">github仓库</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled.png" alt="Untitled"></p><p>单向链表每次查找只能从前向后查找，单向的，只会有一个指针并且指向下一个节点。所以每个节点只能找到自己后面的节点，但是无法找到之前的链表。</p><p>对于<strong>循环</strong>链表，最末端的节点会指向头节点，形成首尾相接的循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mylist.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Mon 25 Sep 2023 20:34:40 CST</span></span><br><span class="line"><span class="comment">// Description: 单向链表 insert remove new delete</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ListNode(T) typedef struct listnode_##T&#123;\</span></span><br><span class="line"><span class="meta">  struct listnode_##T* next;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">&#125;listnode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listnode(T) listnode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewListNode(T) listnode_##T* newListNode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *node = (listnode_##T *) malloc(sizeof(listnode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newListNode(T) newListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteListNode(T) void deleteListNode_##T(listnode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteListNode(T) deleteListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LinkedList(T) typedef struct linkedlist_##T&#123;\</span></span><br><span class="line"><span class="meta">  struct listnode_##T *head;\</span></span><br><span class="line"><span class="meta">  struct listnode_##T *tail;\</span></span><br><span class="line"><span class="meta">  int length;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  void (*insert)(struct linkedlist_##T *list, int index, listnode_##T* node);\</span></span><br><span class="line"><span class="meta">  void (*remove)(struct linkedlist_##T *list, int index);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct linkedlist_##T *dst, struct linkedlist_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct linkedlist_##T *list);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct linkedlist_##T *list);\</span></span><br><span class="line"><span class="meta">&#125;linkedlist_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> linkedlist(T) linkedlist_##T</span></span><br><span class="line"><span class="comment">// insert at the front of index node</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Insert(T) void insert_##T(linkedlist_##T* list, int index, listnode_##T* node)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *iterator = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator-&gt;next != list-&gt;tail &amp;&amp; index--)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index &gt; 0)printf(<span class="string">&quot;index has out of range, but will insert tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  node-&gt;next = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  list-&gt;length++;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// remove the next of iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Remove(T) void remove_##T(linkedlist_##T* list, int index)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *iterator = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!list-&gt;length)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this list is empty, can&#x27;t remove node\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  index--;\</span></span><br><span class="line"><span class="meta">  while(iterator-&gt;next != list-&gt;tail &amp;&amp; index-- &gt; 0)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index != 0)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range, can&#x27;t remove node\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  listnode_##T *node = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = iterator-&gt;next-&gt;next;\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">  list-&gt;length--;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 都是以节点之后开始的</span></span><br><span class="line"><span class="comment">// [srcbegin, srcend) 节点id从1开始</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(linkedlist_##T *dst, struct linkedlist_##T *src, int dstbegin, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *dstit = dst-&gt;head;\</span></span><br><span class="line"><span class="meta">  listnode_##T *srcit = src-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(dstit-&gt;next != dst-&gt;tail &amp;&amp; dstbegin-- &gt; 0) dstit = dstit-&gt;next;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(dstbegin &gt; 0) printf(<span class="string">&quot;dstbegin has out of range, so merge begin at the tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  listnode_##T *copybegin;\</span></span><br><span class="line"><span class="meta">  listnode_##T *copyend;\</span></span><br><span class="line"><span class="meta">  int copylength = 0;\</span></span><br><span class="line"><span class="meta">  while(srcit-&gt;next != src-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    srcit = srcit-&gt;next;\</span></span><br><span class="line"><span class="meta">    srcbegin--;\</span></span><br><span class="line"><span class="meta">    srcend--;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcend &lt;= 0)break;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcbegin == 0)&#123;\</span></span><br><span class="line"><span class="meta">      copybegin = newListNode(T)(srcit-&gt;val);\</span></span><br><span class="line"><span class="meta">      copyend = copybegin;\</span></span><br><span class="line"><span class="meta">      copylength++;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(srcbegin &lt; 0)&#123;\</span></span><br><span class="line"><span class="meta">      listnode_##T *node = newListNode(T)(srcit-&gt;val);\ </span></span><br><span class="line">      copyend-&gt;next = node;\</span><br><span class="line">      copyend = copyend-&gt;next;\</span><br><span class="line">      copylength++;\</span><br><span class="line">    &#125;\</span><br><span class="line">  &#125;\</span><br><span class="line">  <span class="keyword">if</span>(srcbegin &gt; <span class="number">0</span>)&#123;\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;srcbegin has out of range, so stop merge\n&quot;</span>);\</span><br><span class="line">    <span class="keyword">return</span>;\</span><br><span class="line">  &#125;\</span><br><span class="line">  copyend-&gt;next = dstit-&gt;next;\</span><br><span class="line">  dstit-&gt;next = copybegin;\</span><br><span class="line">  dst-&gt;length += copylength;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(linkedlist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *it = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(it-&gt;next != list-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    listnode_##T *deletenode = it-&gt;next;\</span></span><br><span class="line"><span class="meta">    it-&gt;next = it-&gt;next-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deletenode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  list-&gt;length = 0;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(linkedlist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  return list-&gt;head-&gt;next == list-&gt;tail;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewLinkedList(T) linkedlist_##T *newLinkedList_##T()&#123;\</span></span><br><span class="line"><span class="meta">  linkedlist_##T *list = (linkedlist_##T *)malloc(sizeof(linkedlist_##T));\</span></span><br><span class="line"><span class="meta">  list-&gt;head = (listnode_##T *)malloc(sizeof(listnode_##T));\</span></span><br><span class="line"><span class="meta">  list-&gt;head-&gt;val = 0;\</span></span><br><span class="line"><span class="meta">  list-&gt;tail = (listnode_##T *)malloc(sizeof(listnode_##T));\</span></span><br><span class="line"><span class="meta">  list-&gt;tail-&gt;val = 0;\</span></span><br><span class="line"><span class="meta">  list-&gt;length = 0;\</span></span><br><span class="line"><span class="meta">  list-&gt;head-&gt;next = list-&gt;tail;\</span></span><br><span class="line"><span class="meta">  list-&gt;tail-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  list-&gt;insert = insert_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;remove = remove_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  return list;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newLinkedList(T) newLinkedList_##T()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteLinkedList(T) void deleteLinkList_##T(linkedlist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *iterator = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator)&#123;\</span></span><br><span class="line"><span class="meta">    listnode_##T *deletenode = iterator;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deletenode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  free(list);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteLinkedList(T) deleteLinkList_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINELIST(T) ListNode(T)\</span></span><br><span class="line"><span class="meta">  NewListNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteListNode(T)\</span></span><br><span class="line"><span class="meta">  LinkedList(T)\</span></span><br><span class="line"><span class="meta">  Insert(T)\</span></span><br><span class="line"><span class="meta">  Remove(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  NewLinkedList(T)\</span></span><br><span class="line"><span class="meta">  DeleteLinkedList(T)</span></span><br><span class="line"></span><br><span class="line">DEFINELIST(<span class="type">int</span>)</span><br><span class="line">DEFINELIST(<span class="type">char</span>)</span><br><span class="line">DEFINELIST(<span class="type">float</span>)</span><br><span class="line">DEFINELIST(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  linkedlist(<span class="type">int</span>) *<span class="built_in">list</span> = newLinkedList(<span class="type">int</span>);</span><br><span class="line">  linkedlist(<span class="type">int</span>) *list1 = newLinkedList(<span class="type">int</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node = newListNode(<span class="type">int</span>)(<span class="number">1</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node1 = newListNode(<span class="type">int</span>)(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">0</span>, node);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">1</span>, node1);</span><br><span class="line">  listnode(<span class="type">int</span>) *node2 = newListNode(<span class="type">int</span>)(<span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node3 = newListNode(<span class="type">int</span>)(<span class="number">4</span>);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">0</span>, node2);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">1</span>, node3);</span><br><span class="line">  <span class="comment">// while(iterator != list1-&gt;tail)&#123;</span></span><br><span class="line">  <span class="comment">//   printf(&quot;%d\n&quot;, iterator-&gt;val);</span></span><br><span class="line">  <span class="comment">//   iterator = iterator-&gt;next;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="built_in">list</span>-&gt;merge(<span class="built_in">list</span>, list1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *iterator = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(iterator != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">list</span>-&gt;remove(<span class="built_in">list</span>, <span class="number">0</span>);</span><br><span class="line">  iterator = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(iterator != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  deleteLinkedList(<span class="type">int</span>)(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/doublelist.png" alt="doublelist"></p><p>链表中有两个指针(pre, next)，并且指向前一个节点和后一个节点。头节点的前指针(pre)指向尾节点，并且尾节点的后指针(next)指向头节点，形成循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mydoublelist.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Thu 28 Sep 2023 14:34:59 CST</span></span><br><span class="line"><span class="comment">// Description: 双向链表</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ListNode(T) typedef struct ListNode_##T&#123;\</span></span><br><span class="line"><span class="meta">  struct ListNode_##T *pre;\</span></span><br><span class="line"><span class="meta">  struct ListNode_##T *next;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">&#125;ListNode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listnode(T) ListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewListNode(T) ListNode_##T *newListNode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *node = (ListNode_##T *) malloc(sizeof(ListNode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;pre = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteListNode(T) void deleteListNode_##T(ListNode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newListNode(T) newListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteListNode(T) deleteListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DoubleList(T) typedef struct doublelist_##T&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *head;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *tail;\</span></span><br><span class="line"><span class="meta">  int length;\</span></span><br><span class="line"><span class="meta">  void (*insert)(struct doublelist_##T *doublelist, int index, ListNode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*remove)(struct doublelist_##T *doublelist, int index);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct doublelist_##T *dst, struct doublelist_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct doublelist_##T *list);\</span></span><br><span class="line"><span class="meta">  void (*isempty)(struct doublelist_##T *list);\</span></span><br><span class="line"><span class="meta">&#125;doublelist_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> doublelist(T) doublelist_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Insert(T) void insert_##T(doublelist_##T *doublelist, int index, ListNode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *iterator = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator != doublelist-&gt;tail &amp;&amp; index--)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!index)\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range and will insert front of tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  node-&gt;next = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  node-&gt;pre = iterator;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next-&gt;pre = node;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = node;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;length++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Remove(T) void remove_##T(doublelist_##T *doublelist, int index)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *iterator = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator != doublelist-&gt;tail &amp;&amp; index--)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index &gt;= 0)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range, can&#x27;t remove any node\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;pre-&gt;next = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next-&gt;pre = iterator-&gt;pre;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;pre = NULL;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  free(iterator);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(struct doublelist_##T *dst, struct doublelist_##T *src, int dstbegin, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *dstit = dst-&gt;head;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *srcit = src-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(dstit-&gt;next != dst-&gt;tail &amp;&amp; dstbegin-- &gt; 0) dstit = dstit-&gt;next;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(dstbegin &gt; 0) printf(<span class="string">&quot;dstbegin has out of range, so merge begin at the tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  ListNode_##T *copybegin;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *copyend;\</span></span><br><span class="line"><span class="meta">  int copylength = 0;\</span></span><br><span class="line"><span class="meta">  while(srcit-&gt;next != src-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    srcit = srcit-&gt;next;\</span></span><br><span class="line"><span class="meta">    srcbegin--;\</span></span><br><span class="line"><span class="meta">    srcend--;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcend &lt;= 0)break;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcbegin == 0)&#123;\</span></span><br><span class="line"><span class="meta">      copybegin = newListNode(T)(srcit-&gt;val);\</span></span><br><span class="line"><span class="meta">      copyend = copybegin;\</span></span><br><span class="line"><span class="meta">      copylength++;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(srcbegin &lt; 0)&#123;\</span></span><br><span class="line"><span class="meta">      ListNode_##T *node = newListNode(T)(srcit-&gt;val);\</span></span><br><span class="line"><span class="meta">      copyend-&gt;next = node;\</span></span><br><span class="line"><span class="meta">      node-&gt;pre = copyend;\</span></span><br><span class="line"><span class="meta">      copyend = copyend-&gt;next;\</span></span><br><span class="line"><span class="meta">      copylength++;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin &gt; 0)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;srcbegin has out of range, so stop merge\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  dstit-&gt;next-&gt;pre = copyend;\</span></span><br><span class="line"><span class="meta">  copyend-&gt;next = dstit-&gt;next;\</span></span><br><span class="line"><span class="meta">  copybegin-&gt;pre = dstit;\</span></span><br><span class="line"><span class="meta">  dstit-&gt;next = copybegin;\</span></span><br><span class="line"><span class="meta">  dst-&gt;length += copylength;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(doublelist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  while(list-&gt;head-&gt;next != list-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    ListNode_##T *deletenode = list-&gt;head-&gt;next;\</span></span><br><span class="line"><span class="meta">    list-&gt;head-&gt;next = list-&gt;head-&gt;next-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deletenode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  list-&gt;tail-&gt;pre = list-&gt;head;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewDoubleList(T) doublelist_##T *newDoubleList_##T()&#123;\</span></span><br><span class="line"><span class="meta">  doublelist_##T *doublelist = (doublelist_##T *) malloc(sizeof(doublelist_##T));\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;head = (ListNode_##T *) malloc(sizeof(ListNode_##T));\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;tail = (ListNode_##T *) malloc(sizeof(ListNode_##T));\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;head-&gt;next = doublelist-&gt;tail;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;head-&gt;pre = doublelist-&gt;tail;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;tail-&gt;next = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;tail-&gt;pre = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;length = 0;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;insert = insert_##T;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;remove = remove_##T;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">  return doublelist;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteDoubleList(T) void deleteDoubleList_##T(doublelist_##T *doublelist)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *iterator = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator)&#123;\</span></span><br><span class="line"><span class="meta">    ListNode_##T *deleteNode = iterator;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deleteNode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  free(doublelist);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newDoubleList(T) newDoubleList_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteDoubleList(T) deleteDoubleList_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEDOUBLELIST(T) ListNode(T)\</span></span><br><span class="line"><span class="meta">  NewListNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteListNode(T)\</span></span><br><span class="line"><span class="meta">  DoubleList(T)\</span></span><br><span class="line"><span class="meta">  Insert(T)\</span></span><br><span class="line"><span class="meta">  Remove(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  NewDoubleList(T)\</span></span><br><span class="line"><span class="meta">  DeleteDoubleList(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEDOUBLELIST(<span class="type">int</span>)</span><br><span class="line">DEFINEDOUBLELIST(<span class="type">char</span>)</span><br><span class="line">DEFINEDOUBLELIST(<span class="type">float</span>)</span><br><span class="line">DEFINEDOUBLELIST(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  doublelist(<span class="type">int</span>) *<span class="built_in">list</span> = newDoubleList(<span class="type">int</span>)();</span><br><span class="line">  doublelist(<span class="type">int</span>) *list1 = newDoubleList(<span class="type">int</span>)();</span><br><span class="line">  listnode(<span class="type">int</span>) *node = newListNode(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node1 = newListNode(<span class="type">int</span>)(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">0</span>, node);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">1</span>, node1);</span><br><span class="line">  listnode(<span class="type">int</span>) *node2 = newListNode(<span class="type">int</span>)(<span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node3 = newListNode(<span class="type">int</span>)(<span class="number">4</span>);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">0</span>, node2);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">1</span>, node3);</span><br><span class="line">  <span class="built_in">list</span>-&gt;merge(<span class="built_in">list</span>, list1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *iterator = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">  <span class="keyword">while</span>(iterator-&gt;next != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">list</span>-&gt;remove(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  iterator = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">  <span class="keyword">while</span>(iterator-&gt;next != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%201.png" alt="Untitled"></p><p>是一种随机化的数据结构，实质上就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能</p><p>这种随机的数据结构，可以看做是一个二叉树的变种，它在性能上与红黑树、AVL树很相近；但是Skip List(跳跃列表)的实现相比前两者要简单很多</p><p>从功能角度来看，跳跃表就像在链表之上架起了查询的“高速公路”，可以在普通链表上快速的查找到所要的元素。在查找元素时，跳表能够提供 O(log n) 的时间复杂度</p><p>对于一个链表来说，需要查找某个元素必须从头向后扫描，直到找到该元素或者扫描到完整的链表。</p><p>但是对于一个有序链表，可以提取出来其中的某些节点作为索引值，可以更快的找到所需要的元素，如上图</p><p>要想实现比较快的查找，可以通过构建索引，使得每一个 K 级节点都有 K + 1 个指针，分别跳过 $2^K-1,2^{K-1}-1,…,2^0-1$ 个节点，这样就可以实现较快查找。</p><p>但是这个构建是静态的，并不能保证动态（插入或者删除节点）稳定性。所以可以首先确定一个实数 p，使得 $0&lt;p&lt;1$ 并且要求在跳表中具有 K 级指针的节点所占的比例为 $\frac{100}{2^{K+1}}$ 。这样每当插入新的节点时，那这个节点就有 50% 概率为 0 级节点，有…这就维持了跳跃表的平衡。</p><p>上述实现时，可以利用随机数 0~1，如果是 1 就加一个等级，一直到出现 0 为止。然后将节点插入到链表中</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%202.png" alt="Untitled"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myarray.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 27 Sep 2023 08:23:46 CST</span></span><br><span class="line"><span class="comment">// Description:</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Array(T) typedef struct array_##T&#123;\</span></span><br><span class="line"><span class="meta">  T *val;\</span></span><br><span class="line"><span class="meta">&#125;array_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> array(T) array_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewArray(T) array_##T *newArray_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  array(T) *array = (array_##T *)malloc(sizeof(array_##T));\</span></span><br><span class="line"><span class="meta">  array-&gt;val = (T *)malloc(sizeof(T) * size);\</span></span><br><span class="line"><span class="meta">  return array;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newArray(T) newArray_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteArray(T) void deleteArray_##T(array_##T *array)&#123;\</span></span><br><span class="line"><span class="meta">  free(array-&gt;val);\</span></span><br><span class="line"><span class="meta">  free(array);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteArray(T) deleteArray_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEARRAY(T) Array(T)\</span></span><br><span class="line"><span class="meta">NewArray(T)\</span></span><br><span class="line"><span class="meta">DeleteArray(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEARRAY(<span class="type">int</span>)</span><br><span class="line">DEFINEARRAY(<span class="type">char</span>)</span><br><span class="line">DEFINEARRAY(<span class="type">float</span>)</span><br><span class="line">DEFINEARRAY(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">array</span>(<span class="type">int</span>) *a = newArray(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  *(a-&gt;val) = <span class="number">1</span>;</span><br><span class="line">  *(a-&gt;val + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">  *(a-&gt;val + <span class="number">2</span>) = <span class="number">3</span>;</span><br><span class="line">  *(a-&gt;val + <span class="number">3</span>) = <span class="number">4</span>;</span><br><span class="line">  a-&gt;val[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val + <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val + <span class="number">3</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a-&gt;val[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">  deleteArray(<span class="type">int</span>)(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>固定长度的循环队列，在一般项目中比较常用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myqueue.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 27 Sep 2023 09:06:03 CST</span></span><br><span class="line"><span class="comment">// Description:</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queue_##T&#123;\</span></span><br><span class="line"><span class="meta">  T *val;\</span></span><br><span class="line"><span class="meta">  int head;\</span></span><br><span class="line"><span class="meta">  int tail;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  int (*maxsize)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  int (*getsize)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  int (*isfull)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queue_##T* queue, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct queue_##T *queue);\</span></span><br><span class="line"><span class="meta">&#125;queue_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize(T) int maxsize_##T(queue_##T *queue)&#123;return queue-&gt;size;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Getsize(T) int getsize_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;tail - queue-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(size <span class="string">&lt; 0)size += queue-&gt;</span>size;\</span></span><br><span class="line"><span class="meta">  while(size &gt; queue-&gt;size)size -= queue-&gt;size;\</span></span><br><span class="line"><span class="meta">  return size;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;head == queue-&gt;tail;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isfull(T) int isfull_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;tail == (queue-&gt;head - 1 &gt;= 0? queue-&gt;head - 1 : queue-&gt;head - 1 + queue-&gt;size);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(queue_##T *queue, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;tail == (queue-&gt;head - 1 &gt;= 0? queue-&gt;head - 1 : queue-&gt;head - 1 + queue-&gt;size))return;\</span></span><br><span class="line"><span class="meta">  queue-&gt;val[queue-&gt;tail] = val;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail += 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail %= queue-&gt;size;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;head == queue-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue is empty&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head++;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head %= queue-&gt;size;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;head == queue-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue is empty&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T)0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;val[queue-&gt;head];\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head = 0;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail = 0;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queue_##T *newqueue_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  queue_##T *queue = (queue_##T *) malloc(sizeof(queue_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;val = (T *) malloc(sizeof(T) * size);\</span></span><br><span class="line"><span class="meta">  queue-&gt;size = size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head = 0;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail = 0;\</span></span><br><span class="line"><span class="meta">  queue-&gt;maxsize = maxsize_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;getsize = getsize_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;isfull = isfull_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  return queue;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeue_##T(queue_##T* queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;val);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEQUEUE(T) Queue(T)\</span></span><br><span class="line"><span class="meta">  Maxsize(T)\</span></span><br><span class="line"><span class="meta">  Getsize(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Isfull(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEQUEUE(<span class="type">int</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">char</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">float</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">int</span>) *<span class="built_in">queue</span> = newqueue(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">queue</span>-&gt;isempty(<span class="built_in">queue</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;top(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;pop(<span class="built_in">queue</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  deletequeue(<span class="type">int</span>)(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可扩充的双向循环队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myqueue.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 27 Sep 2023 09:06:03 CST</span></span><br><span class="line"><span class="comment">// Description:</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queue_##T&#123;\</span></span><br><span class="line"><span class="meta">  void* start;\</span></span><br><span class="line"><span class="meta">  void* end;\</span></span><br><span class="line"><span class="meta">  T* ptr;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queue_##T *queue, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">&#125;queue_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(queue_##T *queue, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    T *newstart = (T *) malloc(2 *  queue-&gt;size);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, queue-&gt;size);\</span></span><br><span class="line"><span class="meta">    free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = queue-&gt;start + queue-&gt;size * 2;\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = queue-&gt;start + queue-&gt;size;\</span></span><br><span class="line"><span class="meta">    queue-&gt;size = 2 * queue-&gt;size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;ptr, &amp;val, sizeof(T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *)queue-&gt;ptr == queue-&gt;start)return;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start, queue-&gt;start + sizeof(T), queue-&gt;end - queue -&gt;start -  sizeof(T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -=1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  T data;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *)queue-&gt;ptr - queue-&gt;start &lt; sizeof(T))return 0;\</span></span><br><span class="line"><span class="meta">  memmove(&amp;data, queue-&gt;start, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return data;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queue_##T *newqueue_##T()&#123;\</span></span><br><span class="line"><span class="meta">  queue_##T *queue = (queue_##T *) malloc(sizeof(queue_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(sizeof(T) * 32);\</span></span><br><span class="line"><span class="meta">  queue-&gt;size = 32 * sizeof(T);\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + queue-&gt;size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  return queue;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeue_##T(queue_##T* queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEQUEUE(T) Queue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEQUEUE(<span class="type">int</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">char</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">float</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">int</span>) *<span class="built_in">queue</span> = newqueue(<span class="type">int</span>)();</span><br><span class="line">  <span class="type">int</span> i = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--)</span><br><span class="line">    <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, i);</span><br><span class="line">  i = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;top(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;pop(<span class="built_in">queue</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  deletequeue(<span class="type">int</span>)(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先可扩充队列"><a href="#优先可扩充队列" class="headerlink" title="优先可扩充队列"></a><strong>优先可扩充队列</strong></h3><p>根据特定的算法来实现排序，并且在每次插入元素时进行二分查找，找到合适的位置存入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: priorityqueue.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 04 Oct 2023 08:41:25 CST</span></span><br><span class="line"><span class="comment">// Description:  优先级队列</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DefaultCompare(T) int compare_##T(const T a, const T b)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(a &lt; b) return 1;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(a == b) return 0;\</span></span><br><span class="line"><span class="meta">  return -1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line">DefaultCompare(<span class="type">int</span>)</span><br><span class="line">DefaultCompare(<span class="type">char</span>)</span><br><span class="line">DefaultCompare(<span class="type">float</span>)</span><br><span class="line">DefaultCompare(<span class="type">double</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> defaultcompare(T) compare_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PriorityQueue(T) typedef struct priority_queue_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  T *ptr;\</span></span><br><span class="line"><span class="meta">  int (*compare)(const T a, const T b);\</span></span><br><span class="line"><span class="meta">  void (*push)(struct priority_queue_##T *queue, const T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  T (*getval)(struct priority_queue_##T *queue, int index);\</span></span><br><span class="line"><span class="meta">  int (*find)(struct priority_queue_##T *queue, const T val);\</span></span><br><span class="line"><span class="meta">  int (*size)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  int (*maxsize)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct priority_queue_##T *dst, struct priority_queue_##T *src, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">&#125;priority_queue_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> priorityqueue(T) priority_queue_##T</span></span><br><span class="line"><span class="comment">// Binary search sort insert</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(priority_queue_##T *queue, const T val)&#123;\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;ptr - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(sizeof(T) * size * 2);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, size * sizeof(T));\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = newstart + size * 2 * sizeof(T);\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = newstart + size * sizeof(T);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int left = 0, right = size;\</span></span><br><span class="line"><span class="meta">  while(right &gt; left)&#123;\</span></span><br><span class="line"><span class="meta">    int mid = (right + left) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    T *it = (T *) queue-&gt;start + mid;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(queue-&gt;compare(*it, val) &gt; 0) right = mid - 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(queue-&gt;compare(*it, val) &lt; 0) left = mid + 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;\</span></span><br><span class="line"><span class="meta">      left = mid;\</span></span><br><span class="line"><span class="meta">      break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start + (left + 1) * sizeof(T), queue-&gt;start + (left + 0) * sizeof(T), (size - left) * sizeof(T));\</span></span><br><span class="line"><span class="meta">  *((T *) queue-&gt;start + left + 0) = val;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;start == (void *) queue-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(queue-&gt;start, queue-&gt;start + sizeof(T), (queue-&gt;end - queue-&gt;start - 1));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;start == (void *) queue-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T) 0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  T val = *((T *) queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  return val;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size(T) int size_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;ptr - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize(T) int maxsize_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return (T *) queue-&gt;end - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;start == (void *) queue-&gt;ptr;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Find(T) int find_##T(priority_queue_##T *queue, const T val)&#123;\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;ptr - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  int left = 0, right = size - 1;\</span></span><br><span class="line"><span class="meta">  while(right &gt; left)&#123;\</span></span><br><span class="line"><span class="meta">    int mid = (left + right) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    T *it = (T *) queue-&gt;start + mid;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(queue-&gt;compare(*it, val) &gt; 0) right = mid - 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(queue-&gt;compare(*it, val) &lt; 0) left = mid + 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> return mid;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return -1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GetVal(T) T getval_##T(priority_queue_##T *queue, int index)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index * sizeof(T) + queue-&gt;start &gt; (void *) queue-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T) 0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return *((T *) queue-&gt;start + index);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(priority_queue_##T *dst, priority_queue_##T *src, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = src-&gt;ptr - (T *) src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcsize &lt; srcbegin)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;srcbegin has out of index, stop merge\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  for(int i = srcbegin; i &lt; srcend &amp;&amp; i &lt; srcsize; i++)&#123;\</span></span><br><span class="line"><span class="meta">    dst-&gt;push(dst, *((T *) src-&gt;start + i));\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewPriorityQueue(T) priority_queue_##T *newpriorityqueue_##T(int (*compare)(const T a, const T b))&#123;\</span></span><br><span class="line"><span class="meta">  priority_queue_##T *queue = (priority_queue_##T *) malloc(sizeof(priority_queue_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(32 * sizeof(T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + 32 * sizeof(T);\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;compare = compare;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size = size_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;maxsize = maxsize_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;find = find_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;getval = getval_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeletePriorityQueue(T) void deletepriorityqueue_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newpriorityqueue(T) newpriorityqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletepriorityqueue(T) deletepriorityqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEPRIORITYQUEUE(T) PriorityQueue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  Size(T)\</span></span><br><span class="line"><span class="meta">  Maxsize(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  Find(T)\</span></span><br><span class="line"><span class="meta">  GetVal(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  NewPriorityQueue(T)\</span></span><br><span class="line"><span class="meta">  DeletePriorityQueue(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">int</span>)</span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">char</span>)</span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">float</span>)</span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  priorityqueue(<span class="type">int</span>) *<span class="built_in">queue</span> = newpriorityqueue(<span class="type">int</span>) (defaultcompare(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">11</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;find(<span class="built_in">queue</span>, <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;find(<span class="built_in">queue</span>, <span class="number">10</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;size(<span class="built_in">queue</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;getval(<span class="built_in">queue</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;top(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;pop(<span class="built_in">queue</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  deletepriorityqueue(<span class="type">int</span>) (<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>有点类似于队列，但是在 C++ 中 vector 有个特点就是每次内存不足时会申请原来的内存的两倍的内存，然后将数据存入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myvector.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Fri 29 Sep 2023 11:36:37 CST</span></span><br><span class="line"><span class="comment">// Description: 向量</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vector(T) typedef struct vector_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  T *ptr;\</span></span><br><span class="line"><span class="meta">  int (*size)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  int (*max_size)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  void (*push_back)(struct vector_##T *vector, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop_back)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  void (*remove)(struct vector_##T *vec, int begin, int end);\</span></span><br><span class="line"><span class="meta">  int (*find)(struct vector_##T *vec, T val);\</span></span><br><span class="line"><span class="meta">  T (*back)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  T (*front)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  void (*copyfrom)(struct vector_##T *dst, struct vector_##T *src, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct vector_##T *dst, struct vector_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct vector_##T *vec);\</span></span><br><span class="line"><span class="meta">&#125;vector_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vector(T) vector_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size(T) int size_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  return vector-&gt;ptr - (T *)vector-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_size(T) int max_size_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  return (T *) vector-&gt;end - (T *) vector-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  return (void *) vector-&gt;ptr == vector-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push_back(T) void push_back_##T(vector_##T *vector, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;end - (void *)vector-&gt;ptr &lt; sizeof(T))&#123;\</span></span><br><span class="line"><span class="meta">    int size = vector-&gt;end - vector-&gt;start;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(size * 2);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, vector-&gt;start, size);\</span></span><br><span class="line"><span class="meta">    free(vector-&gt;start);\</span></span><br><span class="line"><span class="meta">    vector-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    vector-&gt;end = vector-&gt;start + size * 2;\</span></span><br><span class="line"><span class="meta">    vector-&gt;ptr = vector-&gt;start + size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(vector-&gt;ptr, &amp;val, sizeof(T));\</span></span><br><span class="line"><span class="meta">  vector-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop_back(T) void pop_back_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;ptr != vector-&gt;start)\</span></span><br><span class="line"><span class="meta">    vector-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this vector has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Back(T) T back_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;ptr == vector-&gt;start)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this vector is empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T)0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  memcpy(&amp;val, vector-&gt;ptr - 1, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return val;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Front(T) T front_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;ptr == vector-&gt;start)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this vector is empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T)0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  memcpy(&amp;val, vector-&gt;start, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return val;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Remove(T) void remove_##T(vector_##T *vec, int begin, int end)&#123;\</span></span><br><span class="line"><span class="meta">  T *pbegin = vec-&gt;start + begin;\</span></span><br><span class="line"><span class="meta">  T *pend = vec-&gt;start + end;\</span></span><br><span class="line"><span class="meta">  memcpy((void *)pbegin, (void *)pend, ((void *) vec-&gt;ptr - (void *) pend));\</span></span><br><span class="line"><span class="meta">  vec-&gt;ptr = pbegin + (vec-&gt;ptr - pend);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Find(T) int find_##T(vector_##T *vec, T val)&#123;\</span></span><br><span class="line"><span class="meta">  T *iterator = vec-&gt;start;\</span></span><br><span class="line"><span class="meta">  int index = 0;\</span></span><br><span class="line"><span class="meta">  while(iterator != vec-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(*iterator == val)return index;\</span></span><br><span class="line"><span class="meta">    iterator++;\</span></span><br><span class="line"><span class="meta">    index++;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return -1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// srcbegin and srcend is index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Copyfrom(T) void copyfrom_##T(vector_##T *dst, vector_##T *src, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = (void *) src-&gt;ptr - src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;begin index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcend * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;end index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int dstmaxsize = dst-&gt;end - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  int copysize = sizeof(T) * (srcend - srcbegin);\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(dstmaxsize &lt; copysize)&#123;\</span></span><br><span class="line"><span class="meta">    while(dstmaxsize &lt; copysize)\</span></span><br><span class="line"><span class="meta">      dstmaxsize &lt;&lt; 2;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(dstmaxsize);\</span></span><br><span class="line"><span class="meta">    dst-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(dst-&gt;start, src-&gt;start + sizeof(T) * srcbegin, copysize);\</span></span><br><span class="line"><span class="meta">  dst-&gt;ptr = (T *) dst-&gt;start + srcend - srcbegin;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(struct vector_##T *dst, struct vector_##T *src, int dstbegin, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = (void *) src-&gt;ptr - src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;begin index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcend * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;end index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int dstmaxsize = dst-&gt;end - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  int dstsize = (void *) dst-&gt;ptr - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  while(dstmaxsize &lt; dstsize + (srcend - srcbegin) * sizeof(T))\</span></span><br><span class="line"><span class="meta">    dstmaxsize &lt;&lt; 2;\</span></span><br><span class="line"><span class="meta">  void *newstart = malloc(dstmaxsize);\</span></span><br><span class="line"><span class="meta">  memcpy(newstart, dst-&gt;start, dstbegin * sizeof(T));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(T), src-&gt;start + srcbegin * sizeof(T), (srcend - srcbegin) * sizeof(T));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(T) + srcsize, dst-&gt;start + dstbegin * sizeof(T), (void *) dst-&gt;ptr - dst-&gt;start - dstbegin * sizeof(T));\</span></span><br><span class="line"><span class="meta">  free(dst-&gt;start);\</span></span><br><span class="line"><span class="meta">  dst-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">  dst-&gt;end = newstart + dstmaxsize;\</span></span><br><span class="line"><span class="meta">  dst-&gt;ptr = newstart + dstsize + (srcend - srcbegin) * sizeof(T);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(vector_##T *vec)&#123;\</span></span><br><span class="line"><span class="meta">  vec-&gt;ptr = vec-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewVector(T) vector_##T *newvector_##T()&#123;\</span></span><br><span class="line"><span class="meta">  vector_##T *vector = malloc(sizeof(vector_##T));\</span></span><br><span class="line"><span class="meta">  vector-&gt;start = malloc(sizeof(T) * 32);\</span></span><br><span class="line"><span class="meta">  vector-&gt;end = vector-&gt;start + sizeof(T) * 32;\</span></span><br><span class="line"><span class="meta">  vector-&gt;ptr = vector-&gt;start;\</span></span><br><span class="line"><span class="meta">  vector-&gt;size = size_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;max_size = max_size_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;push_back = push_back_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;pop_back = pop_back_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;front = front_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;back = back_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;find = find_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;remove = remove_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;copyfrom = copyfrom_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  return vector;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteVector(T) void deletevector_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  free(vector-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(vector);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newvector(T) newvector_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletevector(T) deletevector_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEVECTOR(T) Vector(T)\</span></span><br><span class="line"><span class="meta">  Size(T)\</span></span><br><span class="line"><span class="meta">  Max_size(T)\</span></span><br><span class="line"><span class="meta">  Push_back(T)\</span></span><br><span class="line"><span class="meta">  Pop_back(T)\</span></span><br><span class="line"><span class="meta">  Back(T)\</span></span><br><span class="line"><span class="meta">  Front(T)\</span></span><br><span class="line"><span class="meta">  Remove(T)\</span></span><br><span class="line"><span class="meta">  Find(T)\</span></span><br><span class="line"><span class="meta">  Copyfrom(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  NewVector(T)\</span></span><br><span class="line"><span class="meta">  DeleteVector(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEVECTOR(<span class="type">int</span>)</span><br><span class="line">DEFINEVECTOR(<span class="type">char</span>)</span><br><span class="line">DEFINEVECTOR(<span class="type">float</span>)</span><br><span class="line">DEFINEVECTOR(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>(<span class="type">int</span>) *v = newvector(<span class="type">int</span>)();</span><br><span class="line">  <span class="built_in">vector</span>(<span class="type">int</span>) *v2 =newvector(<span class="type">int</span>)();</span><br><span class="line">  <span class="type">int</span> i = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    v-&gt;push_back(v, i);</span><br><span class="line">  &#125;</span><br><span class="line">  i = <span class="number">33</span>;</span><br><span class="line">  v2-&gt;copyfrom(v2, v, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  v2-&gt;merge(v2, v, <span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v-&gt;back(v));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v2-&gt;back(v2));</span><br><span class="line">    v-&gt;pop_back(v);</span><br><span class="line">    v2-&gt;pop_back(v2);</span><br><span class="line">  &#125;</span><br><span class="line">  v-&gt;pop_back(v);</span><br><span class="line">  deletevector(<span class="type">int</span>)(v);</span><br><span class="line">  deletevector(<span class="type">int</span>)(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%203.png" alt="Untitled"></p><p>栈和堆是计算机中比较常用的数据结构，在计算机中，会有栈内存和堆内存，堆是向高地址扩展 也就是常说的向上生长。是不连续的内存区域。栈是向低地址扩展 也就是常说的向下生长。 是连续的内存区域。而且栈是系统分配的内存，速度较快，会自动回收，但是堆是程序员分配的内存，不会自动回收，但是程序结束之后会被回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mystack.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Fri 29 Sep 2023 14:05:50 CST</span></span><br><span class="line"><span class="comment">// Description: 栈</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Stack(T) typedef struct stack_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  T *ptr;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct stack_##T *stack, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*isfull)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*size)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*maxsize)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">&#125;stack_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stack(T) stack_##T</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(stack_##T *stack, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(stack-&gt;end - (void *)stack-&gt;ptr &lt; sizeof(T))&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this stack has been full\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy((void *)(stack-&gt;ptr), &amp;val, sizeof(T));\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *)stack-&gt;ptr - stack-&gt;start &lt; sizeof(T))&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this stack has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(stack-&gt;start == (void *)stack-&gt;ptr)return (T)0;\</span></span><br><span class="line"><span class="meta">  T data;\</span></span><br><span class="line"><span class="meta">  memcpy(&amp;data, stack-&gt;ptr - 1, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return data;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isfull(T) int isfull_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return (void *)stack-&gt;ptr == stack-&gt;end;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return (void *)stack-&gt;ptr == stack-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size(T) int size_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return stack-&gt;ptr - (T *) stack-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize(T) int maxsize_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return (T *) stack-&gt;end - (T *) stack-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewStack(T) stack_##T *newStack_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  stack_##T *stack = (stack_##T *) malloc(sizeof(stack_##T));\</span></span><br><span class="line"><span class="meta">  stack-&gt;start = malloc(sizeof(T) * size);\</span></span><br><span class="line"><span class="meta">  stack-&gt;end = stack-&gt;start + sizeof(T) * size;\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr = stack-&gt;start;\</span></span><br><span class="line"><span class="meta">  stack-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;isfull = isfull_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;size = size_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;maxsize = maxsize_##T;\</span></span><br><span class="line"><span class="meta">  return stack;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newStack(T) newStack_##T</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteStack(T) void deleteStack_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr = NULL;\</span></span><br><span class="line"><span class="meta">  stack-&gt;end = NULL;\</span></span><br><span class="line"><span class="meta">  free(stack-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(stack);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteStack(T) deleteStack_##T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINESTACK(T) Stack(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  Isfull(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Size(T);\</span></span><br><span class="line"><span class="meta">  Maxsize(T)\</span></span><br><span class="line"><span class="meta">  NewStack(T)\</span></span><br><span class="line"><span class="meta">  DeleteStack(T)</span></span><br><span class="line"></span><br><span class="line">DEFINESTACK(<span class="type">int</span>)</span><br><span class="line">DEFINESTACK(<span class="type">char</span>)</span><br><span class="line">DEFINESTACK(<span class="type">float</span>)</span><br><span class="line">DEFINESTACK(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>(<span class="type">int</span>) *<span class="built_in">stack</span> = newStack(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  <span class="type">int</span> i = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;push(<span class="built_in">stack</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  i = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="type">int</span> a = (<span class="built_in">stack</span>-&gt;top(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;pop(<span class="built_in">stack</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个树的节点有两个子结点 <code>right_leaf, left_leaf</code> ，从而树的结构表现为两个叉</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>是一种特殊的二叉树，但是左右两侧的树的高度之差不超过1，而且在二叉树中的查找速度相当于是 <script type="math/tex">O(\log_2n)</script> 。但是需要特定的算法来保持树的平衡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mybinarytree.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Mon 02 Oct 2023 10:57:36 CST</span></span><br><span class="line"><span class="comment">// Description: （平衡）二叉树</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(x, y) (x) &gt; (y)? (x) : (y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> treenode(T) struct treenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queuetreenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T **ptr;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queuetreenode_##T *queue, treenode_##T *val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">  treenode_##T *(*top)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">&#125;queuetreenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void pushtreenode_##T(queuetreenode_##T *queue, struct treenode_##T *val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    int size = queue-&gt;end - queue-&gt;start;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(2 * size);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, size);\</span></span><br><span class="line"><span class="meta">    free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = queue-&gt;start + 2 * size;\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = queue-&gt;start + size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(queue-&gt;ptr, &amp;val, sizeof(struct treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void poptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;start) return;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start, queue-&gt;start + sizeof(treenode_##T *), queue-&gt;end - queue-&gt;start - sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size--;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) treenode_##T *toptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *treenode = *((treenode_##T **) queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  return treenode;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queuetreenode_##T *newqueuetreenode_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  queuetreenode_##T *queue = (queuetreenode_##T *) malloc(sizeof(queuetreenode_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(sizeof(treenode_##T *) * size);\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + sizeof(treenode_##T *) * size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = pushtreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = poptreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = toptreenode_##T;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeuetreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeuetreenode_##T</span></span><br><span class="line"><span class="comment">// 这里的 size 函数是深度优点算法</span></span><br><span class="line"><span class="comment">// 广度优先算法需要借助其他数据结构了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TreeNode(T) typedef struct treenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T *parent;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T *left;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T *right;\</span></span><br><span class="line"><span class="meta">  int height;\</span></span><br><span class="line"><span class="meta">  void (*nodeDFS)(treenode_##T *this, void (*func)(T val));\</span></span><br><span class="line"><span class="meta">  void (*nodeBFS)(treenode_##T *this, void (*func)(T val));\</span></span><br><span class="line"><span class="meta">  void (*insertl)(struct treenode_##T *this, struct treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*insertr)(struct treenode_##T *this, struct treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  int (*isleaf)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">  int (*isroot)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">&#125;treenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeDFS(T) void nodeDFS_##T(treenode_##T *this, void (*func)(T val))&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!this)return;\</span></span><br><span class="line"><span class="meta">  func(this-&gt;val);\</span></span><br><span class="line"><span class="meta">  nodeDFS_##T(this-&gt;left, func);\</span></span><br><span class="line"><span class="meta">  nodeDFS_##T(this-&gt;right, func);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeBFS(T) void nodeBFS_##T(treenode_##T *this, void (*func)(T val))&#123;\</span></span><br><span class="line"><span class="meta">  queue(T) *nodequeue = newqueue(T)(32);\</span></span><br><span class="line"><span class="meta">  nodequeue-&gt;push(nodequeue, this);\</span></span><br><span class="line"><span class="meta">  while(nodequeue-&gt;size)&#123;\</span></span><br><span class="line"><span class="meta">    treenode_##T *node = nodequeue-&gt;top(nodequeue);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;pop(nodequeue);\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!node)continue;\</span></span><br><span class="line"><span class="meta">    func(node-&gt;val);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;push(nodequeue, node-&gt;left);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;push(nodequeue, node-&gt;right);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InsertL(T) void insertl_##T(treenode_##T *this, treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;left = node;\</span></span><br><span class="line"><span class="meta">  this-&gt;height = (1 + node-&gt;height &gt; this-&gt;height? 1 + node-&gt;height : this-&gt;height);\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = this;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InsertR(T) void insertr_##T(treenode_##T *this, treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;right = node;\</span></span><br><span class="line"><span class="meta">  this-&gt;height = (1 + node-&gt;height &gt; this-&gt;height? 1 + node-&gt;height : this-&gt;height);\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = this;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isleaf(T) int isleaf_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return !this-&gt;right &amp;&amp; !this-&gt;left;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isroot(T) int isroot_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return !this-&gt;parent;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTreeNode(T) treenode_##T *newtreenode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = (treenode_##T *) malloc(sizeof(treenode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  node-&gt;left = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;right = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;height = 0;\</span></span><br><span class="line"><span class="meta">  node-&gt;nodeDFS = nodeDFS_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;nodeBFS = nodeBFS_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;insertl = insertl_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;insertr = insertr_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;isleaf = isleaf_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;isroot = isroot_##T;\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTreeNode(T) void deletetreenode_##T(treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!node)return;\</span></span><br><span class="line"><span class="meta">  deletetreenode_##T(node-&gt;left);\</span></span><br><span class="line"><span class="meta">  deletetreenode_##T(node-&gt;right);\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newtreenode newtreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletetreenode(T) deletetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tree(T) typedef struct tree_##T&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *root;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  int (*compare)(const T a, const T b);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct tree_##T *this);\</span></span><br><span class="line"><span class="meta">  treenode_##T *(*getroot)(struct tree_##T *tree);\</span></span><br><span class="line"><span class="meta">  void (*insert)(struct tree_##T *this, T val);\</span></span><br><span class="line"><span class="meta">  int (*heightBFS)(treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*updateheight)(struct tree_##T *this);\</span></span><br><span class="line"><span class="meta">  void (*balanceBFS)(queue(T) *queue, treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*linkBFS)(queue(T) *queue, treenode_##T *node, int left, int right, int mid);\</span></span><br><span class="line"><span class="meta">  void (*balance)(struct tree_##T *this);\</span></span><br><span class="line"><span class="meta">&#125;tree_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tree(T) tree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return this-&gt;size == 0;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Getroot(T) treenode_##T *getroot_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return this-&gt;root;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HeightBFS(T) int heightBFS_##T(treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(node == NULL) return 0;\</span></span><br><span class="line"><span class="meta">  int heightleft = heightBFS_##T(node-&gt;left);\</span></span><br><span class="line"><span class="meta">  int heightright = heightBFS_##T(node-&gt;right);\</span></span><br><span class="line"><span class="meta">  node-&gt;height = max(heightleft, heightright) + 1;\</span></span><br><span class="line"><span class="meta">  return node-&gt;height;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Updateheight(T) void updateheight_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;heightBFS(this-&gt;root);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Insert(T) void insert_##T(tree_##T *this, T val)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = newtreenode_##T(val);\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!this-&gt;root)&#123;\</span></span><br><span class="line"><span class="meta">    this-&gt;root = node;\</span></span><br><span class="line"><span class="meta">    this-&gt;size++;\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  treenode_##T *iterator = this-&gt;root;\</span></span><br><span class="line"><span class="meta">  while(iterator)&#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(iterator-&gt;val == val)&#123;\</span></span><br><span class="line"><span class="meta">      printf(<span class="string">&quot;this tree has a same val, so can&#x27;t insert\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">      return;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(val <span class="string">&lt; iterator-&gt;</span>val)&#123;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span>(!iterator-&gt;left)&#123;\</span></span><br><span class="line"><span class="meta">        iterator-&gt;left = node;\</span></span><br><span class="line"><span class="meta">        break;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">      iterator = iterator-&gt;left;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(val &gt; iterator-&gt;val)&#123;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span>(!iterator-&gt;right)&#123;\</span></span><br><span class="line"><span class="meta">        iterator-&gt;right = node;\</span></span><br><span class="line"><span class="meta">        break;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">      iterator = iterator-&gt;right;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  this-&gt;balance(this);\</span></span><br><span class="line"><span class="meta">  this-&gt;updateheight(this);\</span></span><br><span class="line"><span class="meta">  this-&gt;size++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BalanceBFS(T) void balanceBFS_##T(queue(T) *queue, treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!node)return;\</span></span><br><span class="line"><span class="meta">  balanceBFS_##T(queue, node-&gt;left);\</span></span><br><span class="line"><span class="meta">  queue-&gt;push(queue, node);\</span></span><br><span class="line"><span class="meta">  balanceBFS_##T(queue, node-&gt;right);\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;left = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;right = NULL;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LinkBFS(T) void linkBFS_##T(queue(T) *queue, treenode_##T *node, int left, int right, int mid)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(left &gt;= right) return;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(left == mid - 1)&#123;\</span></span><br><span class="line"><span class="meta">    node-&gt;left = *((treenode_##T **) queue-&gt;start + left);\</span></span><br><span class="line"><span class="meta">    node-&gt;left-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> <span class="keyword">if</span>(left &lt; mid - 1)&#123;\</span></span><br><span class="line"><span class="meta">    int leftmid = (left + mid) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    node-&gt;left = *((treenode_##T **) queue-&gt;start + leftmid);\</span></span><br><span class="line"><span class="meta">    node-&gt;left-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">    linkBFS_##T(queue, node-&gt;left, left, mid - 1, leftmid);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(right == mid + 1)&#123;\</span></span><br><span class="line"><span class="meta">    node-&gt;right = *((treenode_##T **) queue-&gt;start + right);\</span></span><br><span class="line"><span class="meta">    node-&gt;right-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; mid + 1)&#123;\</span></span><br><span class="line"><span class="meta">    int rightmid = (right + mid) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    node-&gt;right = *((treenode_##T **) queue-&gt;start + rightmid);\</span></span><br><span class="line"><span class="meta">    node-&gt;right-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">    linkBFS_##T(queue, node-&gt;right, mid + 1, right, rightmid);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Balance(T) void balance_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  queue(T) *queue = newqueue(T)(this-&gt;root-&gt;height * 2);\</span></span><br><span class="line"><span class="meta">  this-&gt;balanceBFS(queue, this-&gt;root);\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;size - 1;\</span></span><br><span class="line"><span class="meta">  int mid = size &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">  this-&gt;root = *((treenode_##T **) queue-&gt;start + mid);\</span></span><br><span class="line"><span class="meta">  this-&gt;linkBFS(queue, this-&gt;root, 0, size, mid);\</span></span><br><span class="line"><span class="meta">  deletequeue(T) (queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTree(T) tree_##T *newtree_##T()&#123;\</span></span><br><span class="line"><span class="meta">  tree_##T *tree = (tree_##T *) malloc(sizeof(tree_##T));\</span></span><br><span class="line"><span class="meta">  tree-&gt;root = NULL;\</span></span><br><span class="line"><span class="meta">  tree-&gt;size = 0;\</span></span><br><span class="line"><span class="meta">  tree-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;getroot = getroot_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;insert = insert_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;heightBFS = heightBFS_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;updateheight = updateheight_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;balanceBFS = balanceBFS_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;linkBFS = linkBFS_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;balance = balance_##T;\</span></span><br><span class="line"><span class="meta">  return tree;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTree(T) void deletetree_##T(tree_##T *tree)&#123;\</span></span><br><span class="line"><span class="meta">  deletetreenode_##T(tree-&gt;root);\</span></span><br><span class="line"><span class="meta">  free(tree);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newtree(T) newtree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletetree(T) deletetree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINETREE(T)  TreeNode(T)\</span></span><br><span class="line"><span class="meta">  Queue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)\</span></span><br><span class="line"><span class="meta">  NodeDFS(T)\</span></span><br><span class="line"><span class="meta">  NodeBFS(T)\</span></span><br><span class="line"><span class="meta">  InsertL(T)\</span></span><br><span class="line"><span class="meta">  InsertR(T)\</span></span><br><span class="line"><span class="meta">  Isleaf(T)\</span></span><br><span class="line"><span class="meta">  Isroot(T)\</span></span><br><span class="line"><span class="meta">  NewTreeNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteTreeNode(T)\</span></span><br><span class="line"><span class="meta">  Tree(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Getroot(T)\</span></span><br><span class="line"><span class="meta">  HeightBFS(T)\</span></span><br><span class="line"><span class="meta">  Updateheight(T)\</span></span><br><span class="line"><span class="meta">  Insert(T)\</span></span><br><span class="line"><span class="meta">  BalanceBFS(T)\</span></span><br><span class="line"><span class="meta">  LinkBFS(T)\</span></span><br><span class="line"><span class="meta">  Balance(T)\</span></span><br><span class="line"><span class="meta">  NewTree(T)\</span></span><br><span class="line"><span class="meta">  DeleteTree(T)</span></span><br><span class="line"></span><br><span class="line">DEFINETREE(<span class="type">int</span>)</span><br><span class="line">DEFINETREE(<span class="type">char</span>)</span><br><span class="line">DEFINETREE(<span class="type">float</span>)</span><br><span class="line">DEFINETREE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  tree(<span class="type">int</span>) *tree = newtree(<span class="type">int</span>)();</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">1</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">1</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">2</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">3</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">-1</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">-2</span>);</span><br><span class="line">  tree-&gt;root-&gt;nodeDFS(tree-&gt;root);</span><br><span class="line">  tree-&gt;root-&gt;nodeBFS(tree-&gt;root);</span><br><span class="line">  deletetree(<span class="type">int</span>)(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h3><p>相当于是一个多节点的树，每个节点都有多个子节点，多叉树，操作系统中的文件结构就类似于一个有根多叉树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: k-arytree.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Thu 05 Oct 2023 11:35:22 CST</span></span><br><span class="line"><span class="comment">// Description: 有根树</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> treenode(T) struct treenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queuetreenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T **ptr;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queuetreenode_##T *queue, treenode_##T *val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct queuetreenode_##T *dst, struct queuetreenode_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  treenode_##T *(*top)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">&#125;queuetreenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void pushtreenode_##T(queuetreenode_##T *queue, struct treenode_##T *val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    int size = queue-&gt;end - queue-&gt;start;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(2 * size);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, size);\</span></span><br><span class="line"><span class="meta">    free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = queue-&gt;start + 2 * size;\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = queue-&gt;start + size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(queue-&gt;ptr, &amp;val, sizeof(struct treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void poptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;start) return;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start, queue-&gt;start + sizeof(treenode_##T *), queue-&gt;end - queue-&gt;start - sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size--;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) treenode_##T *toptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = *((treenode_##T **) queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(queuetreenode_##T *dst, queuetreenode_##T *src, int dstbegin, int srcbegin, int srcen)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = src-&gt;ptr - (treenode_##T * *) src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin &gt;= srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;begin index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcend * sizeof(treenode_##T *) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;end index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int dstmaxsize = dst-&gt;end - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  int dstsize = (void *) dst-&gt;ptr - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  while(dstmaxsize &lt; dstsize + (srcend - srcbegin) * sizeof(treenode_##T *))\</span></span><br><span class="line"><span class="meta">    dstmaxsize &lt;&lt; 2;\</span></span><br><span class="line"><span class="meta">  void *newstart = malloc(dstmaxsize);\</span></span><br><span class="line"><span class="meta">  memcpy(newstart, dst-&gt;start, dstbegin * sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(treenode_##T *), src-&gt;start + srcbegin * sizeof(treenode_##T *), (srcend - srcbegin) * sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(treenode_##T *) + srcsize, dst-&gt;start + dstbegin * sizeof(treenode_##T *), (void *) dst-&gt;ptr - dst-&gt;start - dstbegin * sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  free(dst-&gt;start);\</span></span><br><span class="line"><span class="meta">  dst-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">  dst-&gt;end = newstart + dstmaxsize;\</span></span><br><span class="line"><span class="meta">  dst-&gt;ptr = newstart + dstsize + (srcend - srcbegin) * sizeof(treenode_##T *);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queuetreenode_##T *newqueuetreenode_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  queuetreenode_##T *queue = (queuetreenode_##T *) malloc(sizeof(queuetreenode_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(sizeof(treenode_##T *) * size);\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + sizeof(treenode_##T *) * size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = pushtreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = poptreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = toptreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeuetreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeuetreenode_##T</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TreeNode(T) typedef struct treenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *parent;\</span></span><br><span class="line"><span class="meta">  queuetreenode_##T *children;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  void (*insert)(treenode_##T *this, treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*dfs)(treenode_##T *this, void (*func)(treenode_##T *node));\</span></span><br><span class="line"><span class="meta">  void (*bfs)(treenode_##T *this, void (*func)(treenode_##T *node));\</span></span><br><span class="line"><span class="meta">  int (*isleaf)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">  int (*isroot)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">&#125;treenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeInsert(T) void nodeinsert_##T(treenode_##T *this, void (*func)(treenode_##T *node))&#123;\</span></span><br><span class="line"><span class="meta">  children-&gt;push(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeDFS(T) void nodedfs_##T(treenode_##T *this, void (*func)(treenode_##T *node))&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!this)return;\</span></span><br><span class="line"><span class="meta">  func(this);\</span></span><br><span class="line"><span class="meta">  nodedfs_##T(this-&gt;left, func);\</span></span><br><span class="line"><span class="meta">  nodedfs_##T(this-&gt;right, func);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeBFS(T) void nodebfs_##T(treenode_##T *this, void (*func)(treenode_##T *node))&#123;\</span></span><br><span class="line"><span class="meta">  queue(T) *nodequeue = newqueue(T)(32);\</span></span><br><span class="line"><span class="meta">  nodequeue-&gt;push(this);\</span></span><br><span class="line"><span class="meta">  while(nodequeue-&gt;size)&#123;\</span></span><br><span class="line"><span class="meta">    treenode_##T *node = nodequeue-&gt;top(nodequeue);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;pop(nodequeue);\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!node)continue;\</span></span><br><span class="line"><span class="meta">    func(node);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;merge(nodequeue, this-&gt;children, nodequeue-&gt;ptr - (treenode_##T **) node-&gt;start, 0, this-&gt;children-&gt;ptr - (treenode_##T **) this-&gt;children-&gt;start);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IsLeaf(T) int isleaf_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return this-&gt;children-&gt;ptr == this-&gt;children-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IsRoot(T) int isroot_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return !this-&gt;parent;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTreeNode(T) treenode_##T *newtreenode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = (treenode_##T *) malloc(sizeof(treenode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;children = newqueue();\</span></span><br><span class="line"><span class="meta">  node-&gt;insert = NodeInsert(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;bfs = NodeBFS(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;dfs = NodeDFS(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;isleaf = IsLeaf(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;isroot = IsRoot(T);\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTreeNode(T) void deletetreenode_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;dfs(this, free);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newtreenode(T) newtreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletetreenode(T) deletetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tree(T) typedef struct tree_##T&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *root;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">&#125;tree_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tree(T) tree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTree(T) tree_##T *newtree_##T()&#123;\</span></span><br><span class="line"><span class="meta">  tree_##T *tree = (tree_##T *) malloc(sizeof(tree_##T));\</span></span><br><span class="line"><span class="meta">  tree-&gt;root = NULL;\</span></span><br><span class="line"><span class="meta">  tree-&gt;size = 0;\</span></span><br><span class="line"><span class="meta">  return tree;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTree(T) tree_##T *deletetree_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  deletetreenode(T)(this-&gt;root);\</span></span><br><span class="line"><span class="meta">  free(this);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINETREE(T) TreeNode(T)\</span></span><br><span class="line"><span class="meta">  Queue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)\</span></span><br><span class="line"><span class="meta">  NodeInsert(T)\</span></span><br><span class="line"><span class="meta">  NodeDFS(T)\</span></span><br><span class="line"><span class="meta">  NodeBFS(T)\</span></span><br><span class="line"><span class="meta">  IsLeaf(T)\</span></span><br><span class="line"><span class="meta">  IsRoot(T)\</span></span><br><span class="line"><span class="meta">  NewTreeNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteTreeNode(T)\</span></span><br><span class="line"><span class="meta">  Tree(T)\</span></span><br><span class="line"><span class="meta">  NewTree(T)\</span></span><br><span class="line"><span class="meta">  DeleteTree(T)</span></span><br></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵实际上就是一个结构体内部有着一个二维数组，并且对这个二维数组进行维护，进行加减乘等运算，还有转置和逆运算</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/matrix.png" alt="matrix"></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图结构是描述和解决实际应用问题的一种基本而有力的工具，可以定义为 <code>G=(V, E)</code> ，其中 <code>V</code> 中的元素称作顶点，集合 <code>E</code> 中的元素对应着 <code>V</code> 中的某一对顶点的边</p><p>对于任何边 <code>e = (u, v)</code> ，称顶点u和v彼此邻接（adjacent），互为邻居；而它们都与边 <code>e</code> 彼此关联（incident），在无向图中，与顶点v关联的边数，称作v的度数（degree），记作 <code>deg(v)</code></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/map.png" alt="map"></p><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>对于上述中的 <code>E</code> 集合中的边是没有方向的，或者说是双向的。</p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>对于上述中的 <code>E</code> 集合中的边是有方向的的</p><h3 id="混合图"><a href="#混合图" class="headerlink" title="混合图"></a>混合图</h3><p>对于上述中的 <code>E</code> 集合中的边是有方向和无方向的混合的</p><h3 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h3><p>联接于同一顶点之间的边，称作自环（self-loop）</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理</title>
      <link href="/Blog_ButterFly/2024/03/19/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/Blog_ButterFly/2024/03/19/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="四种内存分配和释放的方式"><a href="#四种内存分配和释放的方式" class="headerlink" title="四种内存分配和释放的方式"></a>四种内存分配和释放的方式</h3><div class="table-container"><table><thead><tr><th>分配</th><th>释放</th><th>类型</th><th>是否可重载</th></tr></thead><tbody><tr><td>malloc</td><td>free</td><td>C-function</td><td>否</td></tr><tr><td>new</td><td>delete</td><td>C++-expressions</td><td>否</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++-function</td><td>可</td></tr><tr><td>allocator<T>::allocate()</T></td><td>allocator<T>::deallocate()</T></td><td>C++-STL</td><td>可自由设计并且搭配任何容器</td></tr></tbody></table></div><h3 id="memory-primitives"><a href="#memory-primitives" class="headerlink" title="memory primitives"></a><strong>memory primitives</strong></h3><div class="table-container"><table><thead><tr><th>malloc</th><th>free</th><th>不可重载</th></tr></thead><tbody><tr><td>new</td><td>delete</td><td>不可重载</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>可重载</td></tr><tr><td>allocator<T>::allocate()</T></td><td>allocator<T>::deallocate()</T></td><td>可以自由设计并搭配任何容器</td></tr></tbody></table></div><h3 id="new-expression"><a href="#new-expression" class="headerlink" title="new expression"></a><strong>new expression</strong></h3><p>new 有两个作用，申请内存→构造函数，申请内存使用 operator new 实际上使用的还是 malloc 函数来申请内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Complex)); <span class="comment">// 分配内存</span></span><br><span class="line">    pc = <span class="built_in">static_cast</span>&lt;Complex*&gt;(mem); <span class="comment">// cast，就是指针转型，转化为Complex*类型</span></span><br><span class="line">    pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 指针调用构造函数，用户不能直接使用该指令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(std::bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 申请失败就不执行构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果想要直接调用构造函数，可以用 placement new</span></span><br><span class="line"><span class="keyword">new</span>(p)<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>过程:</p><ol><li>调用operator new分配内存</li><li>调用构造函数生成类象</li><li>返回相应指针</li></ol><h3 id="delete-expression"><a href="#delete-expression" class="headerlink" title="delete expression"></a><strong>delete expression</strong></h3><p>就是先调用析构函数，在调用 delete 函数，delete函数实际上调用的还是 free 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pc:</span><br><span class="line">pc-&gt;~<span class="built_in">Complex</span>();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>过程:</p><ol><li>调用析构函数</li><li>调用operator new()</li></ol><h3 id="Ctor-amp-Dtor"><a href="#Ctor-amp-Dtor" class="headerlink" title="Ctor &amp; Dtor"></a><strong>Ctor &amp; Dtor</strong></h3><p>构造函数不能直接调用，但是析构函数能够直接调用</p><h3 id="array-new-amp-array-delete"><a href="#array-new-amp-array-delete" class="headerlink" title="array new &amp; array delete"></a><strong>array new &amp; array delete</strong></h3><p>就是创建一个数组，创建时会调用 placement new 函数来创建，调用构造函数的顺序 0，1，2</p><p>在delete时创建几个就需要delete几个，会调用多次析构函数，调用顺序 2，1，0</p><h3 id="placement-new-amp-placement-delete"><a href="#placement-new-amp-placement-delete" class="headerlink" title="placement new  &amp;  placement delete"></a><strong>placement new  &amp;  placement delete</strong></h3><p>并不会分配内存，只是会使用已分配的内存来定义一个变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buf = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">Complex *pc = <span class="built_in">new</span>(buf)<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> []buf;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="per-class-allocator"><a href="#per-class-allocator" class="headerlink" title="per-class allocator"></a><strong>per-class allocator</strong></h3><p>想利用类内重载operator new去接管内存的分配，然后利用内存池的观念，即创建出一大段连续空间的内存，然后将其切割成一小段一小段，将创建的元素对象放在内存池切分好的各分段小内存片中，这样避免了多次调用new而造成生成多个带有cookie的内存空间。通过内存池的观念，可以生成一大段只带有两个头尾cookie的内存空间，而该一大段内存空间又被切分成每一小段的内存空间，且其中的每一小段内存空间片都可以共享这一整体的cookie信息。其实就是连续new多个变量，用得时候直接调用就可以。为了能将一大段内存空间切分成一小段一小段，然后通过单向链表的形式串接起来，所以必须多引入一个next指针。但这又会增加class的大小</p><h3 id="static-allocator"><a href="#static-allocator" class="headerlink" title="static allocator"></a><strong>static allocator</strong></h3><p>可以认为是有一条指针指向一条链表,其实就是提前创建一个元素指针的数组，使用的时候在调用赋值，这个allocator就是用来维护这个链表的</p><h3 id="macro-for-static-allocator"><a href="#macro-for-static-allocator" class="headerlink" title="macro for static allocator"></a><strong>macro for static allocator</strong></h3><p>macro 宏，就是创建数组，每个数组元素都是静态的</p><h3 id="global-allocator"><a href="#global-allocator" class="headerlink" title="global allocator"></a><strong>global allocator</strong></h3><p>这个全局的 allocator 里有16个链表，用来为所有的元素类型进行服务</p><h3 id="new-handler"><a href="#new-handler" class="headerlink" title="new handler"></a><strong>new handler</strong></h3><p>当 operator new 没有能力为你分配一个你所申请的 memory，会抛出一个异常，但是以前的老编译器会 返回0，所以就需要检查一下所申请的指针<br>如果想要不抛出异常，而是返回一个0，可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new(nothrow) Foo;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在抛出异常之前，会先调用一个可以由 client 指定的 handler ，以下是 new handler 的形式和设定方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*new_handler)(); // 就是定义一个函数，在执行报错之前运行</span><br><span class="line">new_handler set_new_handler(new_handler p)throw();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设计良好的 new_handler 只有两个选择</p><ul><li>让更多的 memory 内存可用，就是先看看有哪些分配的内存可以释放掉，不影响整个运作的，释放完之后再次分配一次内存，看能否分配成功</li><li>调用 abort() 或者 exit()</li></ul><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h3><p>malloc 内存必须是 16 的倍数<br>cookie 必须是 8 个位</p><p><strong>内存布局:</strong></p><div class="table-container"><table><thead><tr><th>cookie</th><th>记录区块的大小</th></tr></thead><tbody><tr><td>debug header</td><td></td></tr><tr><td>block size</td><td></td></tr><tr><td>debug tail</td><td></td></tr><tr><td>pad</td><td>这一块就是为了能够使申请的内存区块是16的倍数而做的填充</td></tr></tbody></table></div><h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a><strong>allocator</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class allocator</span><br></pre></td></tr></table></figure><p>allocator 里面最重要的函数，没有操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pointer allocate(size_type _N, const void *)</span><br><span class="line">&#123;</span><br><span class="line">    return (_Allocate((difference_type) _N,(pointer)0));</span><br><span class="line">&#125;</span><br><span class="line">void deallocator(void _FARQ *_P,size_type)</span><br><span class="line">&#123;</span><br><span class="line">    operator delete(_P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pointer allocate(size_type _N, const void *)</span><br><span class="line">&#123;</span><br><span class="line">    return (::allocate((difference_type) _N,(pointer)0));</span><br><span class="line">&#125;</span><br><span class="line">void deallocator(void _FARQ *_P,size_type)</span><br><span class="line">&#123;</span><br><span class="line">    ::operator delete(_P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 GNU2.9 中，所有的容器都使用着 alloc</p><h3 id="std-alloc-vs-pool-alloc"><a href="#std-alloc-vs-pool-alloc" class="headerlink" title="std::alloc vs __pool_alloc"></a><strong>std::alloc vs __pool_alloc</strong></h3><p>在 G2.9 的 <code>std::alloc</code> 变成了 G4.9 的 <code>_pool_alloc</code> 变成了编制外的 <code>__pool_alloc</code> 存在于 <code>__gnu_cxx</code> 里面，不再是标准库里的函数</p><h3 id="G4-9-标准分配器"><a href="#G4-9-标准分配器" class="headerlink" title="G4.9 标准分配器"></a>G4.9 标准分配器</h3><p><code>allocator</code> 实际上就是引用 <code>new()</code> 和 <code>delete()</code> 函数</p><p><code>pool_alloc</code> 里面没有任何的 data 只有函数，所以大小为1</p><h3 id="std-alloc"><a href="#std-alloc" class="headerlink" title="std::alloc"></a><strong><a href="https://blog.csdn.net/qq_34269632/article/details/115636008?spm=1001.2014.3001.5506">std::alloc</a></strong></h3><p>在G2.9中， <code>std::alloc</code> 中有 16 个容器，可以满足所有的元素类型,每一个位置上分配的元素大小为 <code>8x(n+1)</code> 所以当元素的大小超出当前的最大的元素大小时就会调用 <code>malloc</code> 来创建容器，在申请使用的时候，就会分配给容器一个容器内存，创建的时候会根据容器内的元素类型大小来分配内存，例如元素大小为 32 位的话就会分配 32 x 20 个内存，如果不够用的话，就会再次申请，每次申请之后会分配内存 32 x 20 x 2 位内存，其中的一半会被分割用来分配所申请的内存，另一半就挂载在 <code>alloc</code> 容器上，RounndUp  就是能把所申请的内存给补充为8的倍数</p><p><strong>embedded pointer</strong><br><code>embedded pointer</code> 指针，是用来管理内存块的，相当于一个链表。 内存块，在客户使用的时候，就会把一整块内存当作是元素，就会把内存块中的指针给覆盖掉</p><h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a><strong><a href="https://blog.csdn.net/qq_34269632/article/details/115704696">malloc</a></strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAlloc&#123;</span><br><span class="line">    LPVOID lpAddress,       // 要分配的内存区域的地址 (当实参为0时，由操作系统指定地址)</span><br><span class="line">    DWORD dwSize,           // 分配的大小</span><br><span class="line">    DWORD flAllocationType, // 分配的类型</span><br><span class="line">    DWORD flProtect         // 该内存的初始保护属性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>virtualAlloc</code> 是一个 Window API 函数，该函数的功能是在调用进程的虚拟地址空间预定或者提交一部分页</li><li><code>flAllocationType</code> ：<ul><li><code>MEM_RESERVE</code> 保留分配地址，不分配物理内存。这样可以阻止其它分配函数 <code>malloc</code> 和 <code>LocalAlloc</code> 等再使用已保留的内存范围，直到它被释放</li><li><code>MEM_COMMIT</code> 为指定地址空间提交物理内存。这个函数初始化内在为零</li></ul></li></ol><p>在 window 下的 virtualloc 有两种格式</p><ul><li><code>VirtualAlloc(0, 1Mb, MEM_RESERVE,...)</code> 表示保留，不是真的分配</li><li><code>VirtualAlloc(0, 1Mb, MEM_COMMIT,...)</code> 表示真实分配出去</li></ul><h3 id="free-p"><a href="#free-p" class="headerlink" title="free(p)"></a><strong>free(p)</strong></h3><p>内存中的分级:</p><p>header → 32个group → 64个 free-list，程序中每个 header 管理 32 个组，每个组管理 64 条链表</p><p>使用 free(p) 先确定 header→group→free-list，在程序初始化的时候就创建了 16 个 header，看 p 的地址在那个 header 之间，在确定位置</p><h3 id="内存分段管理"><a href="#内存分段管理" class="headerlink" title="内存分段管理"></a><strong>内存分段管理</strong></h3><p>在申请内存的时候不是直接申请一大块，而是申请 32 kB，里面有 16 个header，每个header中有 32 个 group，每个group 中有 64 条链表，在 64 条链表上有一个整数。在内存申请中，对于已经申请来的内存，如果里面的存储数据已经被释放掉，也不会当时就还给系统，而是等程序结束后所用使用的释放的内存一起归还</p><p>_sbh_pHeaderDefer 是个指针，指向一个全回收 group 所属的 header，这个 group 原本打算被释放掉，但是暂时保留，当有第二个全回收 group 之后就会释放掉，并且把第二个 group 设为 defer。想要继续分配内存的话，可以直接从 defer 中取出 block 来进行分配，这时候 defer 指针将会被取消</p><p>SBH 分配好 block 之后，最终会将 cntEntries 累加1，但是会检查它原本是否为0，如果是，那就看此次所在的 header 是否defer 并且此次所用值 Group 是否 defer，都吻合就取消其defer身份(令 _sbh_pHeaderDefer = null)</p><p>这意味着 defer 必须是一个全回收的group，全新的 group不会是 defer，_sbh_inGroupDefer 是一个索引，指出 Region 中哪个 group 是 defer</p><h3 id="Loki-allocator"><a href="#Loki-allocator" class="headerlink" title="Loki allocator"></a><strong>Loki allocator</strong></h3><p>里面有3个class</p><ol><li>Chunk 最低阶</li><li>FixedAllocator 中阶</li><li>SmallObjectAllocator 高阶，也就是使用者面对的 allocator</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Chunk</span><br><span class="line">pData_: unsigned char*;  // 就是一个指针，将来会分配一块较大的内存</span><br><span class="line">firstAvailableBlock_: unsigned char;   // 第一个可用区块的位置</span><br><span class="line">// 一般的分配器都是把分配的内存切成小块，用链表连接，并且引入一个嵌入式指针来引用</span><br><span class="line">// 但是这里不是使用指针，这个数据就相当于一个索引，就是表示当前指针指向的是第几号内存块，这个索引值不是按顺序排列的,就相当于一个最高优先权</span><br><span class="line">blocksAvailable_: unsigned char;</span><br><span class="line">// 表示还有多少内存可以分配</span><br><span class="line"></span><br><span class="line">FixedAllocator</span><br><span class="line">chunks_: vector&lt;Chunk&gt;; // 表示生成多个Chunk</span><br><span class="line">allocChunk_:Chunk*; // 指向Chunk</span><br><span class="line">deallocChunk_:Chunk*;// 指向Chunk</span><br><span class="line">// 会指向其中的某两个</span><br><span class="line"></span><br><span class="line">SmallObjAllocator</span><br><span class="line">pool_:vector&lt;FixedAllocator&gt;;// 申请了多个FixedAllocator</span><br><span class="line">pLastAlloc:FixedAllocator*; // 指向某两个 FixedAllocator</span><br><span class="line">pLastDealloc:FixedAllocator*;</span><br><span class="line">chunkSize:size_t;</span><br><span class="line">maxObjectSize:size_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特点:</p><ol><li>精简强悍，手段暴力</li><li>使用特殊手段(用array代替list，用index来取代pointer)</li><li>能使用简单的方式判断chunk是否全回收，进而将memory归还</li><li>有deferring(暂缓归还)的能力</li><li>这是个allocator，用来分配大量小块的，不带cookie的memory block，最佳客户是容器，本身就使用vector</li><li>用到了标准库的容器和分配器，也用到了 loki 的分配器和容器</li></ol><h3 id="GUN-C-对allocator的描述"><a href="#GUN-C-对allocator的描述" class="headerlink" title="GUN C++对allocator的描述"></a><strong>GUN C++对allocator的描述</strong></h3><p>对于元素类型为 T 的容器的 <code>Allocator</code> 的模板实参默认是 <code>allocator&lt;T&gt;</code>. 其接口只有大约20个 public 声明，包括嵌套的 <code>typedefs</code> 和成员函数</p><ol><li><code>T* allocate(size_type n, const void* hint = 0)</code></li><li><code>void deallocator(T* p,size_type n)</code><br>这里的 n 表示客户申请的元素个数，实际空间大小应该是 <code>n*sizeof(T)</code><ul><li>这些内存通常使用 <code>operator::new</code> 来获得，但是何时调用和调用频率无具体指定<ul><li><code>__gnu_cxx::new_allocator</code> 实际上分配内存调用的是 <code>::operator new</code> 和 <code>::operator delete</code></li><li><code>__gnu_cxx::malloc_allocator</code> 实际上调用的是 std::malloc 和 std::free</li></ul></li><li>另一种方法就是使用智能型 allocator，将分配所得的内存加以缓存(cache)，实现机制:</li></ul></li><li>可以是一个 <code>bitmap index</code>，用于索引至一个以 2 的指数倍成长的篮子</li><li>也可以是一个相较之下比较简易的 fixed-size pooling cache ，这里的cache 被程序内的所有容器共享，而 <code>operator new</code> 和 <code>operator delete</code> 不经常被调用，这可以带来速度上的优势。使用这个技巧的 <code>allocator</code> 包括:<ul><li><code>__gnu_cxx::bitmap_allocator</code> 使用bit-map来追踪被使用和未被使用的内存块</li><li><code>__gnu_cxx::pool_allocator</code> 申请一个内存池</li><li><code>__gnu_cxx::__mt_alloc</code></li><li><code>__gnu_cxx::debug_allocator</code> 可以包覆于任何 <code>allocator</code> 之上,它把客户的申请量添加一些，然后由 <code>allocator</code> 回应，并且以那一小块额外内存放置 <code>_size</code> 信息 <code>deallocator()</code> 收到一个pointer，就会检查size并且以 assert()保证吻合</li><li><code>__gnu_cxx::array_allocator</code> 允许分配一个已知且固定大小的内存块，内存来自 <code>std::array objects</code> ，使用这个 <code>allocator</code> 之后，固定大小的容器就不需再调用 <code>::operator new</code> 和 <code>::operator delete</code> 。这就允许我们使用 <code>STL abstractions</code> 而无需再进行时添乱，增加开销。甚至再 <code>program startup()</code> 情况下也可以使用</li><li><code>__gnu_cxx::new_alloc</code> 实现出简单的 <code>operator new</code> 和 <code>operator delete</code> 语义</li><li><code>__gnu_cxx::malloc_alloc</code> 与上例唯一不同的是，使用C语言的 <code>std::malloc 和 std::free</code>。 存在于 <code>stdio.h</code> 库里</li></ul></li></ol><p><code>Class allocator</code> 只拥有 <code>typedef, constructor, rebind</code> 等成员，继承自一个 <code>high-speed-extension allocators</code>(高速扩充分配器)，也因此所有的分配和归还都取决于这个 <code>base class</code> ，这个 <code>base class</code> 用户无法触碰</p><p>GNU C++ 提供了三项综合测试来完成 <code>C++ allocator</code> 之间的对比:<br><code>Insertion</code> 经过多次 <code>iterations</code> 之后各种 STL 容器将拥有某些的极大量<br>多线程环境中的 <code>insertion and erasure</code>，这个测试展示 <code>allocator</code> 归还内存的能力，以及测量线程之间对内存的竞争<br>A threaded producer/consumer model 分别测试循序式 <code>sequence</code> 和关联式 <code>associative</code> 的容器</p><h3 id="gnu-cxx-new-allocator"><a href="#gnu-cxx-new-allocator" class="headerlink" title="__gnu_cxx::new_allocator"></a><strong>__gnu_cxx::new_allocator</strong></h3><p><code>#include &lt;ext/new_allocator.h&gt;</code></p><p>所有分配器的根源就是 memory 中 <code>include &lt;xmemory&gt;</code>， <code>xmemory</code> 中 <code>include &lt;xmemory0&gt;</code> ，里面有两个关于 <code>allocate</code> 的重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef value*pointer;</span><br><span class="line">typedef size_t size_type;</span><br><span class="line">void deallocate(pointer _Ptr, size_type)</span><br><span class="line">&#123; // deallocate 在 _Ptr 处的元素，不考虑 size</span><br><span class="line">    ::operator delete(_Ptr);</span><br><span class="line">&#125;</span><br><span class="line">pointer allocator(size_type_Count)</span><br><span class="line">&#123; // allocate 一定数量的元素</span><br><span class="line">    return (_Allocate(_Count,(pointer)0)); // 就是调用 ::operator new</span><br><span class="line">&#125;</span><br><span class="line">pointer allocator(size_type_Count,const void*)</span><br><span class="line">&#123;// allocate 一定数量的元素，不考虑 隐含参数</span><br><span class="line">    return (allocate(_Count)); // 调用上面的 allocate</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>标准库 <code>&lt;bits/allocator.h&gt;</code> 中的 <code>allocator</code> 继承于 <code>new_allocator</code> ，list vector deque 的分配器就是标准库的分配器</p><h3 id="gnu-cxx-malloc-allocator"><a href="#gnu-cxx-malloc-allocator" class="headerlink" title="__gnu_cxx::malloc_allocator"></a><strong>__gnu_cxx::malloc_allocator</strong></h3><p>里面的 <code>allocate</code> 就是调用的 <code>std::malloc</code> , <code>deallocate</code> 调用的是 <code>std::free</code></p><h3 id="gnu-cxx-array-allocator"><a href="#gnu-cxx-array-allocator" class="headerlink" title="__gnu_cxx::array_allocator"></a><strong>__gnu_cxx::array_allocator</strong></h3><p><code>#include &lt; ext/array_allocator.h&gt;</code></p><p>内部就是一个c++数组，它的第二模板参数就是一个小版本的标准</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">teplate&lt;typename _Tp,typename _Array = std::tr1::array&lt;_Tp,1&gt;&gt;</span><br><span class="line">class array_allocator:public array_allocator_base&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    typedef size_t size_type;</span><br><span class="line">    typedef _Tp value_type;</span><br><span class="line">    typedef _Array array_type;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    array_type* _M_array; // 就是一根指针，用来指向一种 array_type*,指向静态的数组，不需要释放，只有动态才需要释放</span><br><span class="line">    size_type _M_used;</span><br><span class="line">public:</span><br><span class="line">    array_allocator(array_type* __array = NULL)throw():_M_array(_array),M_used(size_type())&#123;&#125;</span><br><span class="line">    pointer allocate(size_type __n,const void * = 0)</span><br><span class="line">    &#123;</span><br><span class="line">       if(_M_array == 0||_M_used+_n&gt;_M_array-&gt;size())</span><br><span class="line">            std::__throw_bad_alloc();</span><br><span class="line">        pointer __ret = _M_array -&gt;begin()+_M_used;</span><br><span class="line">        _M_used += __n;</span><br><span class="line">        return __ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="debug-allocator"><a href="#debug-allocator" class="headerlink" title="debug_allocator"></a><strong>debug_allocator</strong></h3><p>就是把外部的一个分配器包装起来，包装进 <code>debug_allocator</code> 中<br><code>&lt;ext/debug_allocator.h&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pointer allocate(size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">  pointer __res = _M_allocator.allocate(__n + _M_extra);  // 申请内存的时候申请额外内存</span><br><span class="line">  size_type* __ps = reinterpret_cast&lt;size_type*&gt;(__res);</span><br><span class="line">  *__ps = __n;</span><br><span class="line">  return __res + _M_extra;  // 返回 额外 的数据之后的数据，但是不适用额外值</span><br><span class="line">&#125;</span><br><span class="line">void deallocate(pointer __p, size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">  if (__p)</span><br><span class="line">  &#123;</span><br><span class="line">    pointer __real_p = __p - _M_extra; // 要释放掉的时候就把extra也释放掉， extra 作用是记录分配的内存的数量</span><br><span class="line">    if (*reinterpret_cast&lt;size_type*&gt;(__real_p) != __n)</span><br><span class="line">    &#123;</span><br><span class="line">      throw std::runtime_error(&quot;debug_allocator::deallocate wrong size&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    _M_allocator.deallocate(__real_p, __n + _M_extra);  // 用所包装的分配器归还内存</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">    throw std::runtime_error(&quot;debug_allocator::deallocate null pointer&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pool-alloc"><a href="#pool-alloc" class="headerlink" title="__pool_alloc"></a><strong>__pool_alloc</strong></h3><p><code>&lt;ext/pool_allocator.h&gt;</code><br><code>__gnu_cxx::allocator&lt;T&gt;</code></p><h3 id="bitmap-allocator"><a href="#bitmap-allocator" class="headerlink" title="bitmap_allocator"></a><strong>bitmap_allocator</strong></h3><p>如果只申请单个元素，调用下面两个函数</p><ul><li><code>_M_allocate_sigle_object()</code>  只申请单个元素</li><li><code>_M_deallocate_sigle_object()</code> 只释放一个元素</li></ul><p>如果申请多个元素，那就调用下面的函数</p><ul><li><code>::operator new</code></li><li>::operator delete</li></ul><p>申请内存的时候，直接申请 64 个 blocks，每个blocks都是8个字节</p><p><img src="/Blog_ButterFly/2024/03/19/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20210501161118199.png" alt="20210501161118199.png"></p><p>count (记录整个区块的大小) - usecount(就是用户使用掉的blocks数量) - <code>bitmap[1]</code> - <code>bitmap[0]</code> - 64个blocks(将来会成倍增长)</p><p><code>bitmap[0]</code> 和 <code>bitmap[1]</code> 就是两个整数，一个整数是 32 位，所以要用两个整数来表示 64 位的blocks,最开始的时候 <code>bitmap[0]</code> ， <code>bitmap[1]</code> 都是 FFFFFFFF，usecount是0</p><p>随着不断地使用， <code>bitmap[0]</code> 和 <code>bitmap[1]</code> 会不断变小</p><p>例如如果已经使用了 63 个区块的话:  <code>usecount = 63</code> ， <code>bitmap[1],bitmap[0]</code> 数为 80000000 00000000 ，每个blocks的大小就是  8 16 32 64…<br><code>__mini_vector</code> 在这个 <code>bitmap_allocator</code> 中自己设计的一个容器，用来放置这个 blocks 有三个指针:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_M_start // 指向blocks开头的指针</span><br><span class="line">_M_finish // 指向 blocks 结尾的下一个元素</span><br><span class="line">_M_end_of_storge // 指向</span><br></pre></td></tr></table></figure><p>如果已经把第一个 super blocks 用光之后，就会使用第二个 super blocks，第二个 super blocks 中有 128 个blocks，是第一个的两倍，这时候会使用 4 个 bitmap 来记录 super blocks size，而且负责这个blocks的 __mini_vector 也会扩充编程四个指针</p><p><img src="/Blog_ButterFly/2024/03/19/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2021050116201663.png" alt="2021050116201663.png"></p><p>不同类型的 blocks 不会混在一起，是分开存储的，只是在 <code>__mini_vector</code> 上有体现， <code>__mini_vector</code> 的两个指针中间的东西会增长，中间的区块就是表示的存储区块</p><p>如果在分配过程中没有运行全回收，那么申请的内存的区块大小会成倍增长，每次的全回收会导致申请的区块减半</p><p><strong>全回收</strong> </p><p>如果第一个blocks 中已经回收了几个 block，并未发生全回收时，接下来如果要分配 blocks 的话，是从 已经申请好的但是并未用完的 blocks 中分配</p><p>如果第二个 blocks 用光了，还要再分配几个blick，而且已经回收了的blocks 中有空余，就会调用，如果用光了就会再次申请</p><p>其实每个blocks就是相当于一个 __mini_vector 的元素，元素排列以blocks的大小为依据，而且vector中最多可以有 64 个元素</p><p>如果__mini_vector 中元素个数已经满了，还要新进来元素，那就判断新进来的blocks的大小，如果比原来里面的最末者还要大，就直接delete掉，如果小于最末者，就插入适当的位置，并且把最末者delete掉</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a><strong>const</strong></h3><p>当成员函数的 const 和 non-const 两个版本都存在，那么 const object 只会调用const版本，non-const object 只能调用 non-const 版本</p><div class="table-container"><table><thead><tr><th></th><th>const object( data members 不变 )</th><th>non-const object(data members 可变动)</th></tr></thead><tbody><tr><td>const member function(保证不更改data members)</td><td>true</td><td>true</td></tr><tr><td>non-const member function(不保证不更改data members)</td><td>false</td><td>true</td></tr><tr><td>当设计成员函数的时候，一定要注意，如果使用 const 元素，就必须搭配 const member function，否则会默认调用的是 non-const member function</td><td></td><td></td></tr><tr><td>non-const member object 可以调用 const member function</td><td></td><td></td></tr><tr><td>const 属于签名部分</td><td></td></tr></tbody></table></div><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new delete"></a><strong>new delete</strong></h3><p>new 先分配内存 再调用构造函数</p><p>delete 先调用析构函数 再释放内存</p><p>可以重载 new 和 delete 函数</p><p>array new 一定要搭配 array delete</p><p>如果有重载就调用重载的，否则调用全局的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void* operator new(size_t size)</span><br><span class="line">&#123;return malloc(size);&#125;</span><br><span class="line">void* operator new(size_t size,void*start)</span><br><span class="line">&#123;</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br><span class="line">void* operator new(size_t size, long extra)</span><br><span class="line">&#123;</span><br><span class="line">    return malloc(size+extra);</span><br><span class="line">&#125;</span><br><span class="line">void* operator new(size_t size,long extra,char init)</span><br><span class="line">&#123;</span><br><span class="line">    return malloc(size+extra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc free"></a><strong>malloc free</strong></h3><p>在代码中可以直接利用 <code>malloc</code> 申请一个固定大小的内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p = (int *)malloc(sizeof(int));</span><br></pre></td></tr></table></figure><p><strong>c++的结构体内存大小</strong></p><ol><li>空结构体占用1个字节</li><li>结构体中包含的数组则不占用空间</li><li>结构体中的成员函数不占用空间</li><li><p>结构体中的一个或多个虚函数只占用一个指针大小的空间</p><p> 虚函数表</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序的生前死后</title>
      <link href="/Blog_ButterFly/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/"/>
      <url>/Blog_ButterFly/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="startup"><a href="#startup" class="headerlink" title="startup"></a><strong>startup</strong></h3><p>默认的startup函数是由 linker(连接器) 自己选择的</p><h3 id="1-内存初始化"><a href="#1-内存初始化" class="headerlink" title="1. 内存初始化"></a>1. <strong>内存初始化</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190919233800651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190919233800651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>内存块：</p><ul><li>从哪里来</li><li>大小多少</li><li>回收到哪<br>SBH(Small Block Heap)：应付CRT本身以及main进去之后的所有内存（size=1024=1k）。</li></ul><p>如果客户要的区块大小要小于sbh_threshold（size=1016，加上图中的上下的00000131(各占4个字节)，1016+8=1024，即1K），将从sbh内部去申请内存。反之，使用HeapAlloc(win提供的API函数)，让操作系统提供服务。</p><p>因此，内存小于等于1K的，VC6认为它足够小，它将使用SBH去服务它。反之，若大于1K，将有操作系统那些”池塘”（HeapAlloc等函数）来提供。（内存块从哪里来）</p><p><em>HeapAlloc</em>:HeapAlloc是Windows提供的API，在进程初始化的时候，系统会在进程的地址空间中创建1M大小的堆，称为默认堆（Default Heap），该大小为默认值，可以通过/HEAP连接器开关进行修改。用户也可以通过HeapCreate创建额外的堆，堆的使用可以更有效的进行内存管理，避免线程同步的开销以及快速的释放内存等</p><p>我们可以向操作系统要求 A 一大块内存，B 一大块内存，C 一大块内存，我们可以根据不同的用途从不同的内存块获取</p><p><em>SBH初始化</em>:<br>给我一块区域，大小4096(初始值，可以弹性增长),取名为 crtheap<br>heap_init 在初始化的时候申请了 <a href="https://img-blog.csdnimg.cn/20190909005831841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70">16 个header</a>，每个header的<a href="https://img-blog.csdnimg.cn/20190909010216461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70">内部情况</a></p><h3 id="2-io-初始化，包括-printf，cout-等等"><a href="#2-io-初始化，包括-printf，cout-等等" class="headerlink" title="2. io 初始化，包括 printf，cout 等等"></a>2. <strong>io 初始化，包括 printf，cout 等等</strong></h3><h3 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1. 内存分配"></a>1. <strong><a href="https://img-blog.csdnimg.cn/20190920224423330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70">内存分配</a></strong></h3><p>线膨胀大小决定要多大的内存，然后去那内存，拿完后函数返回，设置区块串接<br><strong>malloc_crt</strong>:</p><ul><li>调试模式 使用一般的 malloc 分配内存</li><li>非调试模式 malloc——dbg 分配内存并且登记一些信息</li></ul><p>_ioinit() 需要分配内存<br>会对第一步所申请到的内存进行一系列的包装</p><p>对于vc10，不在执行一些函数，图中展示了 heap_alloc_base 的源码</p><p><img src="https://img-blog.csdnimg.cn/20190920224423330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190920224423330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl _ioinit(void)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 只有这一段与内存有关，是用来分配内存的</span><br><span class="line">    // IOINFO_ARRAY_ELTS 32</span><br><span class="line">    // sizeof(ioinfo) 8</span><br><span class="line">    if((pio = _malloc_crt(IOINFO_ARRAY_ELTS * sizeof(ioinfo))) == NULL)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在调试模式下，要加上上下文等关键信息，加完的长度要登记在cookie之中(图中的 00000131，在之前的 130 的基础上需要加一个 bit 位来登记状态)，最后还要进行字节对齐</p><p>0x100(内存块的大小) + 0x24(36) + 0x8 = 0x12c -&gt; 0x130</p><p><strong><a href="https://img-blog.csdnimg.cn/20190920231934961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70">heap_alloc_dbg</a></strong><br>heap中，需要分配内存的地方可能是 CRT 本省，也可能是应用程序，在要完内存之后，如果小于 1k，区块就膨胀，之后回去SBH挖取一小块内存，然后区块将被串接起来，就像图中的<a href="https://img-blog.csdnimg.cn/20190920232724770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70">Debug Heap</a>链表</p><p><strong>heap_alloc_bae</strong></p><p>: 内存检查，如果小于1k就从SBH中拿取，大于将从操作系统中拿取<br>这里的 __sbh_threshold 为 1K</p><p><img src="https://www.notion.soC++%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E4.png" alt="https://www.notion.soC++%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E4.png"></p><h3 id="2-从SBH拿内存-ioinit"><a href="#2-从SBH拿内存-ioinit" class="headerlink" title="2. 从SBH拿内存(ioinit)"></a>2. 从SBH拿内存(ioinit)</h3><p><img src="https://img-blog.csdnimg.cn/20190922224306504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190922224306504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>在32位的电脑上没有64位的变量，bitvGroup被分为了Hi和Lo两部分，BITVEC是unsigned int型，为32位。所以共有[32]组，每组64bits，64位的电脑上可以直接使用一个64位的变量解决<br>在管理内存的时候，我们是先挖出一大块，然后有需要的时候就切一块，当回收的时候就归还内存，对于使用单个元素大小一样的内存块，管理内存尽量把它们连接到一起(要么就是物理虚拟地址连接，要么就是链表)，这种设计准备了 64 条链表，用于管理 64 种不同类型的变量，归还的时候，对于有着相同大小的元素的区块，就把它链接到对应的链表上</p><p><img src="https://img-blog.csdnimg.cn/2019092223443098.png" alt="https://img-blog.csdnimg.cn/2019092223443098.png"></p><p><img src="https://img-blog.csdnimg.cn/20190923001046222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190923001046222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>每次都能申请 1MB大小的内存，分为 32个group，每次使用的时候先使用 1/32，也就是 32k，再把32k切成 8 块，每块就是 4k</p><p><img src="https://img-blog.csdnimg.cn/20190923001823850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190923001823850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>当切出130bytes出去立马就变成了131bytes了，因为它的这个设计需要1个bytes表示它的状态是给出去了还是在SBH手中<br>0xffffffff表示为-1（上下个占8个byte），用来防止链表合并,0xffffffff表示为-1（上下个占8个byte），用来防止链表合并。4096-8*2=4088。前面讲过希望设计大小是16的倍数，最靠近16边界的是4080，因此8bytes保留。<br>总结:</p><ol><li>首先，我们有16个header，每一个header管理的事情是1M里面的32K切成8块，这8块是由64条链表来管理。</li><li>一开始是最后一条链表负责把page8链接起来（130=304/16=19，从0开始排列，19-1=18。理论应该是#18 List进行供应，但因为现在这些链表都是空的，只有最后一个链表是有挂载page，所以第18号链表是空的，最后发现最后一个链表的page起着作用，所以在page中把130bytes切出去了）</li><li>在page中把130bytes切割出来。130bytest、是所有程序都会面临，_ioinit()需要的内存大小就是130bytes，于是剩下ec0bytes 。这就是首次内存分配。</li><li>接下来对page1继续切割（只有当page1 内存切割完成后，才会去切割page2的内存），当切割至第15次，开始释放</li></ol><p>链表的各自任务是以16在变化的，所以由#35 链表进行回收。#35 链表的指针将指向240bytes的地址。<br>当第16次分配内存时，将分配b0大小,操作系统将从之前释放的240bytes中的空间重新切割,240-b0=190，剩下的190将重新分配给#24 List维护管理。所以，内存切割分配是个动态的过程，不断调整所属的链表。</p><p>各个元素大小相同的空区块将会合并，合并后的区块也会被串起来，然后合成一整个大链表，每个链表的头尾都有 0xffffffff 作为分隔符，保证它们不合并</p><pre><code>![https://img-blog.csdnimg.cn/20190928182049605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70](https://img-blog.csdnimg.cn/20190928182049605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)![https://img-blog.csdnimg.cn/20190928190203119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70](https://img-blog.csdnimg.cn/20190928190203119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)</code></pre><h3 id="3-获得命令行参数"><a href="#3-获得命令行参数" class="headerlink" title="3. 获得命令行参数"></a>3. <strong>获得命令行参数</strong></h3><h3 id="4-获得环境变量"><a href="#4-获得环境变量" class="headerlink" title="4. 获得环境变量"></a>4. <strong>获得环境变量</strong></h3><p>一共会分配 240H来储存，这里面有 10 条指针，每一条指针都指着一个 指向环境变量的字符串，实际上10条指针所指向的字符串的长度之和不到240H，但经过一系列的膨胀等操作，最后就变成 240H</p><p>在VC环境中，我们发现main()函数共有三个参数，其中包含一个独特的参数_environ。当然，不同的平台main的参数是不同的，我们需要注意的是calling convention。</p><p><img src="https://img-blog.csdnimg.cn/20191002144623755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20191002144623755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>_environ：pointer to pointer tabale，table中的每个entry都是指向环境变量的字符串的指针，一共有10个指针<br>我们可以查找到 _environ的首地址，，并且根据其指向的是指向字符串的指针，而字符串总是由‘\0’结束，四个字节为一个指针，因此，共有十个指针，需要注意的是其所指向的字符串的长度。</p><p><img src="https://img-blog.csdnimg.cn/20191002145330241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20191002145330241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>可以验证之前在程序最开始所分配的内存大小 240 H，每一块内存都需要加上 cookie 然后再补充到 16 的整数倍，但是还没有到达240H，只有230H，在经过一系列膨胀等操作，最后变成240H</p><p><img src="https://img-blog.csdnimg.cn/20191002153456407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20191002153456407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>这里分配的 240h 的内存再之后设置完 envp 就会被释放掉，其实就是把 操作系统中的环境变量都给获取拷贝过来，之后就释放掉了</p><h3 id="5-设置argv"><a href="#5-设置argv" class="headerlink" title="5. 设置argv"></a>5. <strong>设置argv</strong></h3><p>argv 格式(假设 argv 为 n) : 连续的 n 个字符，最终用 /0 结束，n个指针分别指向 n 个字符串，这个其实就是执行的 c程序 所生成的 .exe 文件的绝对地址，在进行膨胀</p><p><img src="https://img-blog.csdnimg.cn/20191002153456407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20191002153456407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>例如: 这个地址有55个字节，那么字符串长度就是 56，那么这一块字符串所占的长度就是 4+4+56 = 64，在经过一系列膨胀，最后变成大小为 100h 的内存 =&gt; 0x64h</p><h3 id="6-设置envp，就是当前程序运行环境的参数"><a href="#6-设置envp，就是当前程序运行环境的参数" class="headerlink" title="6. 设置envp，就是当前程序运行环境的参数"></a>6. <strong>设置envp，就是当前程序运行环境的参数</strong></h3><p>这个操作指令引发了 11 次环境分配，每一块都要分成如上图所示的链表，把内存链接起来，所占用的内存大小就是 11*4+36(膨胀) =&gt; 80<br>这个环境分配的顺序就如上图所示，首先分配最下面的</p><h3 id="7-c-初始化"><a href="#7-c-初始化" class="headerlink" title="7. c 初始化"></a>7. <strong>c 初始化</strong></h3><h3 id="8-进入-main-函数"><a href="#8-进入-main-函数" class="headerlink" title="8. 进入 main 函数"></a>8. <strong>进入 main 函数</strong></h3><p>mainret = main(<strong>argc,</strong>argv,_environ) 在不同的平台，参数数量不同</p><h3 id="9-exit-0-退出程序"><a href="#9-exit-0-退出程序" class="headerlink" title="9. exit(0) 退出程序"></a>9. <strong>exit(0) 退出程序</strong></h3><h3 id="自定-Startup-code"><a href="#自定-Startup-code" class="headerlink" title="自定 Startup code"></a><strong>自定 Startup code</strong></h3><p>一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int MyStartup(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    HANDLE crtHeap = HeapCreate(HEAP_NO_SERIALIZE,0x010,4000*1024);</span><br><span class="line">    int*p = (int*)HEAPAlloc(crtHeap,HEAP_ZERO_MEMORY,0x010);</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i = 0;i&lt;100;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0;j&lt;100;j++,p++)</span><br><span class="line">        &#123;</span><br><span class="line">            *p = i*100+(j+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MessageBoxA(NULL,p,&quot;abcd&quot;,MB_OK);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是需要设置，令程序在开始的时候执行的是我们自定义的 MyStartup<br>而且，main 函数需要使用启动代码调用</p><h3 id="windows-heap-manager"><a href="#windows-heap-manager" class="headerlink" title="windows heap manager"></a>windows heap manager</h3><p>在c程序运行的时候，会创建一个 heap，这个heap大小小于 4MB，在首地址偏移 178(16进制) 位的位置上，有 128 个free list，自由的双向链表，每个链表就是一对指针，所以所占的内存大小就是 128 * 8 就是 0x400，这一块内存是连续的，这些链表的指针所存储的地址信息都是颠倒过来的，每条链表的两根指针都是指向的同一位置<br>这些链表只有第一根链表是指向的一个区块，其他的指针都是指向的自己所在的链表，没有指向任何自由区块<br>在windows里的自由区块有cookie，但是windows里的cookie是一种上下融合的，即表示上一块的大小也表示下一块的大小，虽然跟 C++ 程序里的内存分配的自由区块的分布方式不同，但是作用都是相同的<br>但是首个区块的 cookie 中并没有前一个区块的信息，存储的内容应该另有意义<br>Header 用以记录本区块和前一个区块的大小，长度大小的单位是 单元，每个单元的大小就是 8bytes，这样的用意就是: 长度为 n+1 的区块回收的时候，就会挂载到 free[n], 就是第 n 条链表，因为每条 free list 的”责任间隔”就是 8</p><p>例如: 在程序中如果声明了需要 1024 个字节的内存，那么就会从第一个自由区块中分配 1024 个字节的大小，就是80个单元，但是实际上是分配了 83 个单元<br>80(1024) + cookie(1) + tail for debug(2) = 83个，剩下的内存就是 原来的 - 83 个单元，剩下的区块依旧挂载在第 0 块自由区块，剩下的内存会生成一个cookie，这个cookie里存储的就是上一个内存块的大小(0x83)以及自己的内存块的大小</p><h3 id="ioinit-amp-fopen"><a href="#ioinit-amp-fopen" class="headerlink" title="_ioinit() &amp; fopen()"></a>_ioinit() &amp; fopen()</h3><p>建议阅读下图右侧的备注</p><p><img src="/Blog_ButterFly/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/20191014235423852.png" alt="Untitled"></p><p><img src="https://img-blog.csdnimg.cn/20191015000206330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20191015000206330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70"></p><p>在一开始的时候就获得了一个静态的数组，这个数组里最多可以获得 64 根指针，就是静态指针，这个是由于一维索引有 6 位，也就是 $2^6=64$ ，二维索引有 5 位，也就是 $2^5=32$ ，所以程序最多可以打开 2048 个file</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    long osfhnd; // os file handle</span><br><span class="line">    char osfile; // os file</span><br><span class="line">    char pipech;</span><br><span class="line">&#125;ioinfo;</span><br><span class="line"></span><br><span class="line">struct _iobuf</span><br><span class="line">&#123;</span><br><span class="line">    char* _ptr;</span><br><span class="line">    int _cnt;</span><br><span class="line">    char* _base;</span><br><span class="line">    int _flag;</span><br><span class="line">    int _file;</span><br><span class="line">    int _charbuf;</span><br><span class="line">    int _bufsiz;</span><br><span class="line">    char* _tmpfname;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct _iobuf FILE;</span><br></pre></td></tr></table></figure><ul><li><p><code>ioinfo</code>：其对应到C/C++程序对应的 <code>fopen</code> 得到的变量（ <code>FILE fp=fopen(&quot;xxx.dat&quot;，“wb”)</code> 中的FILE 变量）</p><p>  Linux 对应于 <strong>FILE</strong> 的是 <code>File Desriptor(**fd**)</code>，Windows 对应的则是 <code>file handle</code> </p></li><li><p>每个进程至少有三个 file handle（stdin，stdout，stderr），接下来的动作就是把继承下来的这三个或更多的 file handle 抄录到 struct ioinfo。所以，一个进程最多可以开出 64*32=2048个FILE，其中包括从父进程继承下来的部分。</p></li><li>操作系统通过函数 <code>GetStartInfo()</code> 函数获得 <code>inherited opened file headles</code> 把继承而来的这三个或更多的 <code>file handle</code> 拷贝到 <code>struct ioinfo</code></li></ul><h3 id="Kernel-Mode-and-User-Mode"><a href="#Kernel-Mode-and-User-Mode" class="headerlink" title="Kernel Mode and User Mode"></a>Kernel Mode and User Mode</h3><p><img src="/Blog_ButterFly/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/20191020105029701.png" alt="20191020105029701.png"></p><p>lpReserved2 将指向 inherited handles info 。字节0~3表示一个N值，代表了继承了几个file handle（原则上一般至少有stdin、stdout、stderr 三个file handle）。  N value for OSfile 则是 ioinfo 结构体中的 char os file，N OS handle values 则是ioinfo结构体中的 long osfhnd。</p><p>借由调用GetstartupInfo函数，取得lpReserved2指针，指向inherited handles info，取出N，OSfile，osfhnd，copy填入到ioinfo的结构体中。借由这种方式去登记/记载 父进程继承而来的file handle。</p><p><img src="/Blog_ButterFly/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/20191020113111545.png" alt="20191020113111545.png"></p><p><img src="/Blog_ButterFly/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/20191020113227477.png" alt="20191020113227477.png"></p><p>由上可知一个进程最多可以容纳/拥有/开启 32*64=2048 个 <code>ioinfo</code> 。而 <code>fopen()</code> 会去寻找一个还没有使用的</p><p><img src="/Blog_ButterFly/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/20191020115449348.png" alt="20191020115449348.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11STL</title>
      <link href="/Blog_ButterFly/2024/03/19/C-11STL/"/>
      <url>/Blog_ButterFly/2024/03/19/C-11STL/</url>
      
        <content type="html"><![CDATA[<h3 id="STL-六大部件"><a href="#STL-六大部件" class="headerlink" title="STL 六大部件"></a>STL 六大部件</h3><ol><li>容器 <code>Container</code></li><li>分配器 <code>Allocators</code> 用于为算法分配地址</li><li>算法 <code>Algorithms</code></li><li>迭代器 <code>Iterators</code> 容器中就会有迭代器，用于遍历元素，就是可以表示容器中的所有种类的元素</li><li>适配器 <code>Adapters</code> 就像是一个泛化的指针， 对迭代器，仿函数，容器进行适配</li><li>仿函式 <code>Functors</code> 就是一种函数<br>数据在容器里，操作数据的函数在另外的类里</li></ol><h3 id="时间复杂度-Big-oh"><a href="#时间复杂度-Big-oh" class="headerlink" title="时间复杂度(Big-oh)"></a>时间复杂度(Big-oh)</h3><ol><li>$O(1),O(c)$ ： 常数时间</li><li>$O(n)$ ：线性时间</li><li>$O(\log_n x)$ ：次线性时间</li><li>$O(n^2)$ ：平方时间</li><li>$O(n^3)$ ：立方时间</li><li>$O(2^n)$ ：指数时间</li><li>$O(n\log_2n)$ ：线性与二次方成长之间的模式</li></ol><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><strong>Sequence Container(序列式)</strong></p><ol><li><code>Arrary</code> (数组) 固定大小 12</li><li><code>Vector</code> (向量) 末尾扩充 12<ul><li><code>heap</code> 以算法形式呈现（<code>xxx_heap()</code>）12</li><li><code>priority_queue</code> 12</li></ul></li><li><code>List</code> (双向环状链表) 任意进出 4-&gt;8</li><li><p><code>Forward-List</code> (单向链表) 任意进出 4</p><p> <code>List</code> 比 <code>Forward-List</code> 占用内存多</p></li><li><p><code>slist</code> 单向 非标准 之后改为 <code>forward_list</code> 4</p></li><li><code>Deque</code> (双向队列) 两端扩充删减 40<ul><li><code>queue</code> 40</li></ul></li><li><code>stack</code> 40</li></ol><p><strong>Associative Contaiiner(关联式) (用于大量查找)(一般都用二分的方法，两侧均匀分布)</strong></p><ol><li><code>Set/Multiset</code> 用红黑数[高度平衡]来作 <code>set</code> ，没有 <code>key</code> 和 <code>value</code> 之分， <code>set</code> 里面的内容不可重复,可以用 <code>Multiset</code> 12 -&gt; 24</li><li><code>Map/Multimap</code> 每个元素都有 <code>key</code> 和 <code>value</code> ，可以用 <code>key</code> 来查找， <code>map</code> 里面的元素不可重复,可以用 <code>Multiset</code> 12 -&gt; 24</li><li><code>hashtable</code> 之后所有 <code>hash</code> 改变为 <code>unordered</code><ul><li><code>hash_set</code> 20 -&gt; 28</li><li><code>hash_map</code> 20 -&gt; 28</li><li><code>hash_multiset</code> 20 -&gt; 28</li><li><code>hash_multimap</code> 20 -&gt; 28</li><li><code>rb_tree</code> 12 -&gt; 24 (非公开)</li></ul></li></ol><p><strong>Unorderd Container(不定序) (其实也是一种关联式的)</strong></p><ol><li><code>Unordered Set/MultiSet</code></li><li><code>Unordered Map/Multimap</code></li></ol><p><code>HashTable Sepreate Chaining</code> ，分离链接法，解决 hash碰撞（冲突）的方法</p><p>每一个存放的位置就是一个链表，把元素存入相应的位置，如果元素都在同一位置就存在同一位置上</p><h3 id="range-based-for-statement"><a href="#range-based-for-statement" class="headerlink" title="range-based for statement"></a>range-based for statement</h3><p>类似于 <code>python</code> 的遍历循环<br><code>for(i:list)</code></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在c++中，在某一个函数中引用某一个变量并不会改变该变量的数值，只有使用引用或者指针才可以</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>对于 <code>auto</code> 的变量，编译器会自动识别变量类型，但是也要知道是什么类型</p><h3 id="分配器-allocator"><a href="#分配器-allocator" class="headerlink" title="分配器(allocator)"></a>分配器(allocator)</h3><p>可以直接使用分配器来分配内存，释放内存，元素越小，分配器分配的多余的内存占比越高，如果使用分配器，分配几个就是释放几个， <code>allocate</code> 和 <code>deallocate</code> 就是分配内存和删除分配</p><p><code>allocate</code> 实际上是调用的 <code>operate new</code></p><p><code>deallocate</code> 实际上是调用的 <code>operate delete</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(num, (pointer)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p, num);</span><br></pre></td></tr></table></figure><p>最常用的是</p><p><code>new - delete new()</code> 调用的也是 <code>malloc(),free()</code>用于分配内存</p><p><code>malloc - free</code></p><h3 id="OOP-Object-Oriented-Programming-GP-Generic-Programming"><a href="#OOP-Object-Oriented-Programming-GP-Generic-Programming" class="headerlink" title="OOP(Object-Oriented Programming) GP(Generic Programming)"></a>OOP(Object-Oriented Programming) GP(Generic Programming)</h3><p>面向对象编程和泛型编程</p><ol><li>OOP 企图将 <code>datas</code> 和 <code>methods</code> 关联起来 就是类里面包含 <code>data</code> 和 <code>function</code></li><li>GP 企图将 <code>datas</code> 和 <code>methods</code> 分开来 类里只包含数据或者只包含 <code>function</code></li></ol><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>原则就是向整数的运算方式靠近<br>链表的例子，对于 <code>++</code> 操作符重载，对于 <code>--</code> 也是如此</p><ol><li><p>后置 <code>i++</code> 不可以加两次，传回来的是结构体 <code>c++++</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125; <span class="comment">// 记下来原来的东西，然后前进一个，返回原来的值，引用前置++的重载，这里的 = 也被重载，就是一个拷贝构造函数</span></span><br></pre></td></tr></table></figure></li><li><p>前置 <code>++i</code> 可以加两次，因为传回来的是引用 <code>++++c</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>所有的模板函数 <code>template&lt; typename, class Allocator = allocator&lt;T&gt;&gt;</code> ，默认第二个参数为 <code>allocator&lt;T&gt;</code></p><ol><li><p>类模板</p><ul><li><p>泛化 可以接受任意类型的变量</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; struc __type_traits&#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>特化 对某一种类的变量有独特的定义</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; struc __type_traits&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; struc __type_traits&lt;<span class="type">short</span>&gt;&#123;...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; struc __type_traits&lt;<span class="type">int</span>&gt;&#123;...&#125;</span><br><span class="line"><span class="comment">// 另一种方法</span></span><br><span class="line">__STL_TEMPLATE_NULL struc __type_traits&lt;<span class="type">char</span>&gt;&#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>偏特化</p><p>  个数上的：有多个模板参数，但是只绑定其中的几个的一种特化</p><p>  范围上的：必须有一个主模板,模板类型被部分明确化</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本来是类型 T ，缩小范围到 T* T的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; struc __type_traitsz&lt;T*&gt;&#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数模板</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>模板模板</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> N&gt; <span class="keyword">typename</span> Continer&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a, Continer&lt;U&gt; b)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>迭代器，用于链接容器和算法，为了使标准算法也适用于 <code>native pointer</code>（普通的指针, int…），因为 <code>native pointer</code> 不像 <code>iterator</code> 一样已经定义算法所需的五个信息，要想标准算法也适用于 <code>native pointer</code> ，就必须要 <code>native pointer</code> 提供那五个信息， <code>iterator_traits</code> 做的就是这个工作，帮助 <code>native pointer</code> 告诉算法那五个信息，这就是 <code>iterator_traits</code> 关键作用所在</p><p>在运算过程中，容器需要得到算法的下面五种类型，但是只有迭代器 <code>iterator</code> 拥有下面 5 种类型，所以就需要算法来获取运算的类型，就是 <code>iterator_traits()</code> 可以获取算法的类型</p><p>运行过程：算法提问→迭代器回答</p><p>有 5 种问题，就是这五种类型：</p><ol><li><code>iterator_category</code> 类别</li><li><code>difference_type</code> 距离</li><li><code>value_type</code> 数值</li><li><code>reference_type</code> 引用</li><li><code>pointer_type</code> 指针</li></ol><h3 id="Iterator-Traits"><a href="#Iterator-Traits" class="headerlink" title="Iterator Traits"></a>Iterator Traits</h3><p>特性，特质，是一个特性类，用来定义迭代器的属性，会判断是 <code>class iterator</code> 还是 <code>non-class iterators</code></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>类中，只有 <code>data</code> 占用内存，动态增长的 <code>array</code>，用3个指针来控制整个容器，内部含有3个指针， <code>vector</code> 本身所占内存为 3 个字节</p><p>在有新的数据 push_back 时，如果还有存储空间那就放进去，如果没有足够的存储空间，容器就会<strong>两倍增长</strong>，前半段储存原数据，后半段储存新的数据，增长的时候就会在计算机里开辟一段新的空间，并且删除原来的。其实就是放不下了又重新找了块2倍大的地，再搬过去。如果使用 insert 插入，也需要将所有元素搬过去</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><code>array</code> 不能扩充，在定义时就需要指明大小</p><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>单向链表和 <code>list</code> 相似</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p><code>iterator start</code> 每个里面包含四个指针，就是下面的四个，指向开始的 node</p><p><code>iterator finish</code> 每个里面包含四个指针，就是下面的四个，指向结尾 node 的下一个 node</p><p><code>map_pointer map</code> 指向一块连续的空间，空间内储存 node，node 内存储数据</p><p><code>size_type map_size</code> 就是 map 的大小，finish-start</p><p>创建的一个 <code>deque</code> 对象本身 40个位，是分段连续的一堆数据，按照一个一个节点 <code>node</code> 存储，这些节点就是储存在一个 <code>vector(map)</code> 中，需要用指针 <code>iterator</code> 串联， <code>cur,first,last,node</code> 四个指针</p><ol><li><code>node</code> 指向指针的指针，就是指向的是某一个 node</li><li><code>cur</code> 当前所指向 node 中的数据</li><li><code>first</code> 就是当前 node 的内存的最前端</li><li><code>last</code> 就是当前 node 的最后端</li></ol><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>内含一个 <code>deque</code> ，都是 <code>deque</code> 做事的，不提供迭代器，但是不可选择 <code>vector</code> 作迭代器</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>内含一个 <code>deque</code> ，都是 <code>deque</code> 做事的，不提供迭代器，可以选择 <code>vector</code> 作迭代器</p><h3 id="RB-tree：red-black-tree"><a href="#RB-tree：red-black-tree" class="headerlink" title="RB-tree：red-black tree"></a>RB-tree：red-black tree</h3><p>就是红黑树，是平衡二分搜索树</p><p>特点：</p><ol><li>排列规则有利 <code>search</code> 和 <code>insert</code> ，保持适度平衡</li><li>提供遍历操作和 <code>iterator</code></li><li>按正常规则的遍历，便能获得排序状态</li><li>不应该使用 <code>rb-tree</code> 的 <code>iterator</code> 去改变元素值，但是编程层面不禁止</li><li><code>rb-tree</code> 为 <code>set</code> 和 <code>map</code> 服务(作为底部支持)，而 <code>map</code> 允许元素的 <code>data</code> 被改变， <code>key</code> 不可以改变</li></ol><p><strong>rb_tree 提供两种操作</strong>：</p><ol><li><code>insert_unique()</code> ：表示节点的 <code>key</code> 一定在整个 <code>tree</code> 中独一无二</li><li><code>insert_equal()</code> ：表示节点 <code>key</code> 的值可以重复 <code>multiset</code></li></ol><p><strong>用三个参数表示自己：</strong></p><ol><li><code>size_type node_count rb_tree</code> 的大小 4</li><li><code>link_type header</code> 是一个指针 <code>rb_tree_node*</code> 指向这个红黑树所在地址 4</li><li><code>Compare key_compare</code> 定义时传进来的一个函数 1</li></ol><p>对于大小为 0 的 <code>class</code> 定义时大小为 1</p><p>由于上面是9 要分配4的倍数的 so 12</p><p><strong>但是在新版里，一个红黑树的大小是6个字节(24位)</strong></p><ol><li>_M_color _Rb_tree_color  枚举类12位</li><li>_M_parent _Base_ptr 指针4位</li><li>_M_right _Base_ptr</li><li>_M_left _Base_ptr</li></ol><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>里面需要的数据 node， 就是结点</p><p><strong>每个结点中含有三个东西</strong></p><ol><li>pre_ptr 指向前一个node</li><li>next_ptr 指向后一个node</li><li>data node里存储的数据</li></ol><h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>以红黑树为底层结构，可以<strong>自动排序</strong>，<strong>排序的依据是key</strong>，但是 <code>set/multiset</code> 的 <code>value</code> 和 <code>key</code> 都是同一个， <code>set/multiset</code> 提供遍历操作以及 <code>iterator</code> 。按正常规则遍历就能获得排序状态(sorted)</p><p>我们无法使用 <code>set/multiset</code> 的 <code>iterator</code> 改变元素值，因为 <code>key</code> 有严谨的排列规则</p><p><code>set/multiset</code> 中的 <code>iterator</code> 是 <code>rb_tree</code> 中的 <code>const_iterator</code> ，禁止对元素赋值</p><p><code>set</code> 中的元素不能重复，使用的是 <code>rb_tree._M_insert_unique()</code></p><p><code>Multiset</code> 中的元素可以重复，使用的是 <code>rb_tree._M_insert_equal()</code></p><p><code>set</code> 中的所有操作都是调用红黑树完成的</p><h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>以红黑树为底层结构，可以<strong>自动排序，排序的依据是key</strong></p><p><code>map/multimap</code> 提供遍历的操作以及 <code>iterator</code></p><p>无法使用 <code>map/multimap</code> 的 <code>iterator</code> 改变元素的 <code>key</code> ，但是可以改变 <code>data</code> 的值。所以 <code>map/multimap</code> 内部自动将 <code>user</code> 指定的 <code>key</code> 设置为 <code>const</code><br><code>map</code> 元素 <code>key</code> 必须独一无二，使用的是 <code>rb_tree._M_insert_unique()</code><br><code>multimap</code> 可以多个，使用的是 <code>rb_tree._M_insert_equal()</code></p><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>在空间足够时，对应的元素就放在对应的位置上，空间不足时，那就编号除以内存最大值取余，就放到那个位置上去，这就是发生碰撞，这些碰撞的元素就串在一起，变成一个链表，这种方法就是 <code>seprate chaining</code> 。但是会形成太长的链表，所以就定义了打散的操作，在定义 <code>hashtable</code> 时，就会定义篮子的个数(一般定义为<strong>素数</strong>)，GNU 中定义为53个，当元素个数大于篮子的个数时，就会调用打散的操作，这时候会把篮子扩充到最接近53两倍的质数97个，所有元素重新排列，还是取余的操作。这个扩充的质数不需要再次计算，已经定义了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Val</span>, <span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Key</span>, <span class="comment">// 键值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_HashFcn</span>, <span class="comment">// 用于通过传入参数得到编号 是一个函数/仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_ExtractKey</span>, <span class="comment">// 萃取类型，就是一种方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_EqualKey</span>,  <span class="comment">// 比较大小的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt; <span class="comment">// 分配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>hashtable的参数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_HashFcn              _M_hash; <span class="comment">// 函数 1</span></span><br><span class="line">_EqualKey             _M_equals; <span class="comment">// 函数 1</span></span><br><span class="line">_ExtractKey           _M_get_key; <span class="comment">// 函数 1</span></span><br><span class="line">vector&lt;_Node*, _Nodeptr_Alloc&gt;          _M_buckets; <span class="comment">// 篮子 vector中有3个指针 就是12位</span></span><br><span class="line"><span class="type">size_t</span>             _M_num_elements; <span class="comment">// 用于计数 4</span></span><br><span class="line"><span class="comment">// 总大小 19 -&gt; 20， 就是hashtable的大小 20</span></span><br></pre></td></tr></table></figure><h3 id="hash-function-amp-hash-code"><a href="#hash-function-amp-hash-code" class="headerlink" title="hash_function &amp; hash_code"></a>hash_function &amp; hash_code</h3><p><code>template &lt;typename T&gt; struct hash&#123;&#125;</code> 有多种泛化</p><p><code>hash function</code> 的目的就是根据里面的元素值来算出 <code>hash code</code> ，以此来放进 <code>hashtable</code> 的 <code>bucket</code> 中，（它的 <code>bucket</code> 是按 <code>vector</code> 排列的，而里面元素使用 <code>list</code> 来排列）。经过 <code>hash code</code> 之后使得元素更乱或者说更随机的放入 <code>hashtable</code> 中，以避免发生碰撞。<strong>所谓的哈希函数就是产生一个数，这个数越乱越好，以至于达到避免碰撞或减少碰撞的目的</strong></p><p><strong>modulus</strong>(运算)：就是对于编号取余的操作，返回取余后的值</p><p><code>hash_set</code> → <code>unordered_sethash_multiset</code> → <code>unordered_multisethash_map</code> → <code>unordered_maphash_multimap</code> → <code>unordered_multimap</code></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><div class="table-container"><table><thead><tr><th></th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>公有继承</td><td>public</td><td>protected</td><td>不可见</td></tr><tr><td>私有继承</td><td>private</td><td>private</td><td>不可见</td></tr><tr><td>保护继承</td><td>protected</td><td>protected</td><td>不可见</td></tr></tbody></table></div><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>容器 <code>Container -&gt; class template</code></li><li>算法 <code>algorithm -&gt; function template</code><br>是用来处理容器里的数据的，需要的信息必须从迭代器获得，迭代器必须有算法相应的所有信息</li><li>迭代器 <code>Iterator -&gt; class template</code>，是由容器决定的，五种 <code>iterator_category</code><ul><li><code>input_iterator_tag</code> 代表是 <code>istream_iterator</code> 类型；</li><li><code>farward_iterator_tag</code> 是代表迭代器是单向链表类型，如 <code>farward_list</code> ， <code>hashtable</code> ， <code>unordered_set</code> ， <code>unordered_map</code></li><li><code>bidirectional_iterator_tag</code> 是代表迭代器是双向链表类型，如 <code>list</code> ， <code>rb_tree</code> ， <code>set</code> ， <code>map</code></li><li><code>random_access_iterator_tag</code> 是代表迭代器可以跳转，如 <code>ite+=5</code> 。一般是用于序列式容器如： <code>array</code> ， <code>vector</code> ， <code>deque</code></li><li><code>output_iterator_tag</code> 代表是 <code>ostream_iterator</code> 类型；</li><li>迭代器类型影响着算法的效率，当测算距离时，有的是从头++到目标点，有的是直接减去</li></ul></li><li>仿函数 <code>Functor -&gt; class template</code></li><li>适配器 <code>Adapter -&gt; class template</code></li><li>分配器 <code>Allocator -&gt; class template</code></li></ol><h3 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h3><ul><li><code>qsort()</code>: 排列</li><li><code>bsearch()</code>: 二分查找法</li><li><code>accumulate()</code> 累计</li><li><code>replace()</code> 取代</li><li><code>replace_if()</code> 符合条件取代</li><li><code>replace_copy()</code> 取代并且复制</li><li><code>count()</code> 计数</li><li><code>count_if()</code> 有条件的计数</li><li><code>sort()</code> 排序，默认为从小到大</li><li><code>find()</code> 循序式寻找</li><li><code>find_if()</code> 循序式查找，满足条件</li><li><code>reverse_iterator()</code> 反向迭代器，就是从末尾走到头</li><li><code>rebegin()</code> 就是重新定义，读取内存实现逆向思维，其实就是指代着 <code>end()</code></li><li><code>rend()</code> 指代着 <code>begin()</code></li><li><code>binary_search()</code> 二分搜寻，必须是排序过的</li><li><code>lower_bound()</code> 二分搜寻，并且把数值插进去，插进位置是接近小数的那个位置必须是排序过的</li><li><code>lower_bound()</code> 二分搜寻，并且把数值插进去，插进位置是接近大数的那个位置必须是排序过的</li></ul><h3 id="容器不带有sort-的"><a href="#容器不带有sort-的" class="headerlink" title="容器不带有sort()的"></a>容器不带有sort()的</h3><ul><li><code>array</code></li><li><code>vector</code></li><li><code>deque</code></li><li><code>set/multiset</code></li><li><code>map/multimap</code></li><li><code>unorder_set/unorder_multiset</code></li><li><code>unorder_map/unorder_multimap</code></li></ul><p>在容器 list forward_list 中不带有 <code>sort</code> 函数（ <code>sort()</code> 函数支持跳转），也不能使用全局 <code>sort()</code> 函数，所以标准库的算法并不支持所有的容器</p><h3 id="容器带有count-的"><a href="#容器带有count-的" class="headerlink" title="容器带有count()的"></a>容器带有count()的</h3><ul><li><code>set/multiset</code></li><li><code>map/multimap</code></li><li><code>unorder_set/unorder_multiset</code></li><li><code>unorder_map/unorder_multimap</code></li></ul><h3 id="functor-仿函数"><a href="#functor-仿函数" class="headerlink" title="functor 仿函数"></a>functor 仿函数</h3><p>像函数一样，只为算法，其实就是一个类，作用相当于一个函数指针，<strong>必须重载小括号</strong></p><ul><li><code>_Identity()</code> 传入什么传出什么</li><li><code>_Select1st()</code> 传入类型为 <code>pair&lt;T1,T2&gt;</code> ，传回第一个</li><li><code>_Select2nd()</code> 传回第二个</li><li><code>greater()</code> 比大小，取大的，但是需要指定类型</li><li><code>less()</code> 取小的</li><li><code>unary_function</code> 一个结构体，只是给传入的类型换个名字</li><li><code>binary_function</code> 一个结构体，只是给传入的类型换个名字</li></ul><p>仿函数的可适配的条件：选则适当的来继承</p><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>就是改变容器内的方法来实现新的方法，却不再实现原来的功能，利用两种方法实现</p><ol><li>继承</li><li>内含，例如stack queue 等都是容器适配器</li></ol><p><strong>仿函数适配器函数适配器 adapters</strong></p><p>就是改变器，改造器，包括:</p><ul><li><code>iterator adapters</code></li><li><code>container adapters</code></li><li><code>functor adapters</code></li></ul><p><strong>函数适配器 binder2nd</strong></p><p><code>binder2nd</code> 是继承 <code>unary_function</code> 的一个结构体，是对 <code>unary_function</code> 的一个适配，作用是绑定第二参数</p><p><code>typename + object</code> 表示声明变量</p><p><code>typename()</code> 表示调用函数</p><p><strong>not1</strong> </p><p>就是不的意思 一般存在于修饰比较的函数，修饰 <code>bind2nd</code> 函数，是用来把符合某种特殊条件的『函数对象』转换为反义「函数对象」的函数</p><p><strong>适配器 bind() 绑定</strong></p><ol><li><code>function</code></li><li><code>function objects</code></li><li><code>member function _1</code> 必须是某个 <code>object</code> 的地址， <code>_1</code> 是一个占位符号，可以用来替代参数</li><li><code>data members _1</code> 必须是某个 <code>object</code> 的地址</li></ol><p>返回一个 <code>function object ret</code> ， 调用 <code>ret</code> 相当于调用上述的 1,2,3 或者是取出 4</p><p><strong>迭代器适配器</strong></p><p><code>reverse_iterator</code> 接受一个模板参数，逆向迭代器，就是正负前进的方向改变一下，从尾部开始，用—来遍历‘</p><p><code>inserter</code> 插入迭代器，就是要自己弄出一个空间来,把要插入的字符串copy到对应的位置，但是其他的迭代器会把插入点之后的数据覆盖</p><p><strong>x适配器</strong></p><p><code>ostream_iterator</code> 例如对于 <code>cout</code> ，就是定义一个有着 <code>cout</code> 作用的变量</p><p><code>istream_iterator</code> 例如对于 <code>cin</code>，就是定义一个有着 <code>cin</code> 作用的变量</p><p><code>hash function</code>万用的 <code>hash_function</code></p><h3 id="变易算法"><a href="#变易算法" class="headerlink" title="变易算法"></a><strong>变易算法</strong></h3><p>变易算法就是在调用时会改变操作对象的数值</p><h3 id="非变易算法"><a href="#非变易算法" class="headerlink" title="非变易算法"></a>非变易算法</h3><p>就是在调用时不会改变操作对象的数值</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组，一队东西的组</p><p><code>tuple&lt;&gt;</code> 模板是 <code>pair</code> 模板的泛化，但允许定义 <code>tuple</code> 模板的实例，可以封装不同类型的任意数量的对象，因此 <code>tuple</code> 实例可以有任意数量的模板类型参数。 <code>tuple</code> 模板定义在 <code>tuple</code> 头文件中， <code>tuple</code> 这个术语也适用于很多其他的场景，例如数据库，这里一个 <code>tuple</code> 就是由一些类型的不同数据项组成的，这和 <code>tuple</code> 的概念相似。 <code>tuple</code> 对象有很多用途。当需要将多个对象当作一个对象传给函数时， <code>tuple</code> 类型是很有用的。是表示元组容器, 是不包含任何结构的,可以用于函数返回多个返回值</p><p><code>tuple</code> 容器, 可以使用直接初始化和 <code>make_tuple()</code>初始化。访问元素使用 <code>get&lt;&gt;()</code> 方法, 注意 <code>get</code> 里面的位置信息, 必须是常量表达式(const expression)</p><p>可以通过 <code>std::tuple_size&lt;decltype(t)&gt;::value</code> 获取元素数量。 <code>std::tuple_element&lt;0, decltype(t)&gt;::type</code> 获取元素类型</p><p>如果 <code>tuple</code> 类型进行比较，则需要保持元素数量相同类型可以比较，如相同类型，或可以相互转换类型(int&amp;double)</p><p>无法通过普通的方法遍历 <code>tuple</code> 容器, 因为 <code>get&lt;&gt;()</code> 方法, 无法使用变量获取值</p><h3 id="可变数量的模板参数"><a href="#可变数量的模板参数" class="headerlink" title="可变数量的模板参数"></a>可变数量的模板参数</h3><p>新语法， <code>typename... Tail</code> 表示有多个类型很多个 <code>type</code>， <code>Tail...</code> 表示有多个参数，这种新语法会自动递归，比如有5个参数，他会继承4个参数的自己，就好比把5分成了1+4，然后继续分4为1+3，一直到1+0终止（是在一直继承）</p><h3 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a>type_traits</h3><p><img src="/Blog_ButterFly/2024/03/19/C-11STL/bb4ba44c11264594b912a3c24becfd70.png" alt="bb4ba44c11264594b912a3c24becfd70.png"></p><p>在C++11中，这些 <code>type traits</code> 变得更加多，多达几十个，这样对于我们自己编写的类，要想使用 <code>type traits</code> 就变得更加冗长。但是在 C++11 中，不仅仅C++自带类可以自动提供自带的 <code>type traits</code> ，连我们自己编写的类都可以自动提供正确的 <code>type traits</code> 结果，不再需要我们自己编写</p><p><code>traits</code> 特化 是 c++ 模板编程中使用的一种技术，主要功能：</p><p>把功能相同而参数不同的函数抽象出来，通过 <code>traits</code> 将不同的参数的相同属性提取出来，在函数中利用这些用 <code>traits</code> 提取的属性，使得函数对不同的参数表现一致。</p><p><code>traits</code> 是一种特性萃取技术,它在 <code>Generic Programming</code> 中被广泛运用,常常被用于使不同的类型可以用于相同的操作,或者针对不同类型提供不同的实现。 <code>traits</code> 在实现过程中往往需要用到以下三种C++的基本特性:</p><ul><li><code>enum</code></li><li><code>typedef</code></li><li><code>template (partial) specialization</code></li></ul><p>其中</p><ul><li><code>enum</code> 用于将在不同类型间变化的标示统一成一个,它在 C++ 中常常被用于在类中替代 <code>define</code>,你可以称 <code>enum</code> 为类中的 <code>define</code></li><li><code>typedef</code> 则用于定义你的模板类支持特性的形式,你的模板类必须以某种形式支持某一特性,否则类型萃取器 <code>traits</code> 将无法正常工作</li><li><code>template (partial) specialization</code> 被用于提供针对特定类型的正确的或更合适的版本</li></ul><p><strong>实现</strong></p><p>对于一些简单的traits，可以找到源代码，是通过模板偏特化来实现的</p><p>然后对于一些复杂的type traits，无法在C++标准库中找到，猜测是编译器在运行期间推导出来的</p><h3 id="std-cout"><a href="#std-cout" class="headerlink" title="std::cout"></a>std::cout</h3><p>C++中的 <code>cout</code> 之所以可以接受那么多类对象，是因为标准对操作符 <code>&lt;&lt;</code> 做出了非常多的重载，如果我们自己编写的类的对象想要进行打印，就需要自己对 <code>&lt;&lt;</code> 进行重载</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>在C++11中，标准库在 <code>&lt;utility&gt;</code> 中提供了一个有用的函数 <code>std::move</code>  ， <code>std::move</code> 并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲， <code>std::move</code> 基本等同于一个类型转换： <code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code></p><ol><li><code>std::move</code> 函数可以以非常简单的方式将左值引用转换为右值引用。</li><li>C++ 标准库使用比如 <code>vector::push_back</code> 等这类函数时，会对参数的对象进行复制，连数据也会复制。这就会造成对象内存的额外创建，本来原意是想把参数 <code>push_back</code> 进去就行了,通过 <code>std::move</code>，可以避免不必要的拷贝操作</li><li><code>std::move</code> 是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率，改善性能.。</li><li>对指针类型的标准库对象并不需要这么做</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左值-右值-左值引用-右值引用"><a href="#左值-右值-左值引用-右值引用" class="headerlink" title="左值-右值-左值引用-右值引用"></a>左值-右值-左值引用-右值引用</h3><p><strong>左值-右值</strong></p><ul><li>左值：是可以放在赋值号左边可以被赋值的值，左值必须要在内存中有实体</li><li>右值：当在赋值号右边取出值赋给其他变量的值，右值可以在内存也可以在CPU寄存器</li></ul><p>一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址<strong>。</strong></p><p><strong>引用</strong></p><p>引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。引用可以改变指针的指向，还可以改变指针所指向的值。</p><p>引用的基本规则：</p><ol><li>声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象。即引用必须初始化，不能对引用重定义</li><li>对引用的一切操作，就相当于对原对象的操作</li></ol><p><strong>左值引用-右值引用</strong></p><p>C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p><ul><li>可以取地址的，有名字的，非临时的就是左值；</li><li>不能取地址的，没有名字的，临时的就是右值；</li></ul><p>所以立即数，函数返回的值等都是右值。而非匿名对象(包括变量)，函数返回的引用，const对象等都是左值。从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)。而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及const对象)。</p><ul><li><p>左值引用</p><p>  左值引用在汇编层面其实和普通的指针是一样的；定义引用变量必须初始化，因为引用其实就是一个别名，需要告诉编译器定义的是谁的引用。</p><p>  使用常引用来引用常量数字，因为此刻内存上产生了临时变量保存了该常量数字，这个临时变量是可以进行取地址操作的，所以引用的值相当于是这个常量</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b= b1;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; c= <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 与上述常量引用一致</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; d = a1;</span><br></pre></td></tr></table></figure><p>  左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用</p><p>  但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了</p></li><li><p>右值引用</p><p>  右值引用是C++ 11新增的特性，所以C++ 98的引用为左值引用。右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。</p><p>  在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量。但是，唯一 一点的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。</p><p>  右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; e= <span class="number">10</span>;</span><br><span class="line">e = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新标准</title>
      <link href="/Blog_ButterFly/2024/03/19/C-11%E6%96%B0%E6%A0%87%E5%87%86/"/>
      <url>/Blog_ButterFly/2024/03/19/C-11%E6%96%B0%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h3 id="variadic-template">variadic template</h3><p>就是参数个数随意的模板，定义任意个参数的模板，可以是任意类型<br>而且可以依据参数重载，关键字 typename… 也可以实现递归，下面的这两种给方式可以并存<br>相较来看，第一个定义比较特化，第二个比较泛化，所以就会，如果传入参数是 1 + x 那么就调用第一个，否则调用第二个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> seed, types&amp; ...args)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">func</span>(args...);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(types&amp; ...args)</span></span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="space-in-template-expressionn-ullptr-std-nullptr-t">Space in Template <code>Expressionn**ullptr</code> &amp; <code>std::nullptr_t</code></h3><p>左边是一个 <code>object</code>，就是0的空的指针，允许使用 <code>null</code> 代替0</p><h3 id="auto">auto</h3><p><code>auto</code> 表示不知道是什么类型的变量，可以把任意变量赋予 <code>auto</code> 变量<br>编译过程中，编译器会自动识别类型, 但是有时候不能使用 <code>auto</code>，使用 <code>aut</code> 必须初始化，不然不能使用（由于编译器不知道类型以及大小，不好分配空间）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verctor&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123;&#125;; <span class="comment">// 后面的参数表示 lambda 函数，无法确定类型就使用auto</span></span><br></pre></td></tr></table></figure><h3 id="lambda-函数">lambda 函数</h3><p>以 <code>[]</code> 开始的变量<br><code>[]</code> 开头表示 <code>lambda</code> 函数，可以在函数内部定义，相当于一个仿函数</p><h3 id="uniform-initialization">Uniform Initialization</h3><p>一致性的初始化<br>一致初始化，一般发生在<strong>大括号，等于号</strong><br>可以直接在声明变量之后加上大括号，里面放入初始化的值<br>编译器在看到{…}之后，就会做出一个 <code>initializer_list&lt;type&gt;</code>,关连着一个 <code>arrary&lt;type,n&gt;</code>, 调用函数时， <code>arrary</code>内的元素可以被编译器分解，逐一传给函数。但是如果该函数参数是一个 <code>initializer_list&lt;T&gt;</code>，调用者却不能够给予整个 <code>T</code> 参数，然后然后以为它们会被自动转化为一个 <code>initializer_list&lt;T&gt;</code> 传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//-&gt; 内部有一个arrary&lt;int, 3&gt;</span></span><br><span class="line">verctor&lt;<span class="type">int</span>&gt;v &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">//-&gt; 内部有一个arrary&lt;int, 4&gt;</span></span><br><span class="line">verctor&lt;string&gt; cities &#123;<span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;NewYork&quot;</span>&#125;; <span class="comment">// -&gt;内部有一个arrary&lt;string, 2&gt;</span></span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c &#123;<span class="number">4.0</span>,<span class="number">3.0</span>&#125;; <span class="comment">// -&gt;内部有一个arrary&lt;float,2&gt;</span></span><br><span class="line"><span class="comment">// 上面的代码都关连着一个arrary&lt;type,n&gt;</span></span><br></pre></td></tr></table></figure><p><strong><code>Initializer Lists</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;    <span class="comment">// 未定义初值</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;  <span class="comment">// 定义为0</span></span><br><span class="line"><span class="type">int</span> *p;   <span class="comment">// 未定义初值</span></span><br><span class="line"><span class="type">int</span> *q&#123;&#125;; <span class="comment">// 定义为 nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>;                          <span class="comment">// 可以把5.3转型为5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;                         <span class="comment">// 可以把5.3转型为5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.3</span>&#125;;                          <span class="comment">// error  大括号无法转型</span></span><br><span class="line"><span class="type">int</span> x4 = &#123;<span class="number">5.3</span>&#125;;                       <span class="comment">// error 大括号无法转型</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;                           <span class="comment">// ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">999999</span>&#125;;                      <span class="comment">// 超出界限也不可以</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5.3</span>&#125;; <span class="comment">// error 无法转型</span></span><br></pre></td></tr></table></figure><p><strong><code>initializer_list&lt;T&gt;</code></strong><br>存在于仓库 <code>&lt;bits/stl_algo.h&gt;</code>中，是一种变量，就是定义时能够接收任意类型和数量的变量，但是所有变量类型都一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;T&gt; a&#123;x,x,x,x,x&#125;;</span><br></pre></td></tr></table></figure><p>其实它的背后是一个 <code>array&lt;T, n&gt;</code> 一个数组</p><p><strong><code>explicit</code></strong><br>编译器在编译时，计算时会自动把数值转化为与结果相应的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="comment">// explicit</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re, <span class="type">int</span> im = <span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;;<span class="comment">// 单一形参</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real), (imag + x.imag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>如果不加上 <code>explicit</code> 时，编译器就会把 5 转化为复数，但是只能调用单一形参的构造函数，然后相加，但是加上 <code>explicit</code> 之后，禁止调用Complex的构造函数转化，所以相加时就会报错</p><p><strong><code>_iter_less_iter()</code></strong><br>位于标准库 <code>&lt;bits/predefined_oops.h&gt;</code> 中，是一个比较大小的函数，返回一个结构体 <code>_Iter_less_iter</code>是一个有重载 <code>()</code> 的结构体，使用 <code>&lt;</code> 比较大小</p><h3 id="range-based-for-statement">range-based for statement</h3><p>存在于c++中的语法，类似于python</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i :initlist)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="default-delete">default &amp; delete</h3><p>C++11允许添加 <code>=default</code> 说明符到函数声明的末尾，以将该函数声明为显示默认构造函数。这就使得编译器为显示默认函数生成了默认实现，它比手动编程函数更加有效。<br>例如，每当我们声明一个有参构造函数时，编译器就不会创建默认构造函数。在这种情况下，我们可以使用default说明符来创建默认说明符。</p><p>默认函数需要用于特殊的成员函数（默认构造函数，复制构造函数，析构函数等），或者没有默认参数。例如，以下代码解释了非特殊成员函数不能默认</p><p><code>=default</code> 就是定义函数为默认函数<br><code>=delete</code> 就是定义函数已经被禁用，不能再使用<br><code>=0</code> 是一种定义纯虚函数的方法，如果在父类结构体中声明函数=0，那么子类想要使用这个函数就必须重写</p><h3 id="big-five">big-five</h3><ol><li><code>Desconstructor</code> 构造函数</li><li><code>copy constructor</code> 复制构造</li><li><code>operator=</code> 拷贝赋值函数</li><li><code>copy constructor</code> 移动构造函数 <code>class_name(class_name &amp;&amp; )</code></li><li><code>Destructor</code> 析构函数</li></ol><h3 id="nocopy">NoCopy</h3><p>在结构体中，所有的拷贝操作都被删除，不能进行拷贝，就是把编译器默认的拷贝函数给删除了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nocopy</span>(<span class="type">const</span> nocopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">nocopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> nocopy&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="nodtor">NoDtor</h3><p>就是在结构体中的析构函数被删除，无法删除生成的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NoDtor</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">NoDtor</span>() = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 最后只能调用delete函数来删除比那两</span></span><br></pre></td></tr></table></figure><h3 id="privatecopy">PrivateCopy</h3><p>此结构体中不可以被拷贝，但是可以被 <strong><code>friend</code></strong> 和 <strong><code>member</code></strong> 来拷贝，如果想要完全禁止拷贝操作，不但必须把拷贝函数放进 <strong><code>private</code></strong>，而且不可以定义它</p><h3 id="alias-template-template-typedef">Alias Template (template typedef)</h3><p>不能对 Alias Template 进行特化，不能对这个重定义之后的名字做特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line">------------</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T, MyAlloc&lt;T&gt;</span>&gt;;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; std::vector&lt;T, MyAlloc&lt;T&gt;&gt; Vec&lt;T&gt;;</span><br><span class="line"><span class="comment">// 上面两种用 define 和 typedef 情况都达不到需求，而且，typedef 是不能接受参数的</span></span><br></pre></td></tr></table></figure><h3 id="template-template-parameter">template template parameter</h3><p>模板的模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;<span class="keyword">class</span> <span class="title class_">Con</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(T item)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Con&lt;T&gt; container_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实就是再定义一个结构体时，传入的模板参数是一个带有模板参数的模板参数，通常在使用时，这个参数 <code>Con</code> 就会用作 <code>class</code> 类型，而且在这个 <code>class</code> 里，可以定义多种的 <code>Con</code> 类</p><h3 id="type-alias">Type Alias</h3><p>就是对原来存在的类型名称进行重新定义名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> zhengshu <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>上述操作就是把 int 重命名为 zhengshu</p><h3 id="throw">throw</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">excpt_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="type">int</span> <span class="type">double</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子就是说，在函数声明之后，定义了一个动态异常的声明 <code>throw(int, double)</code> ，指出了 <code>excpt_func</code> 可能抛出的异常的类型<br>在函数抛出异常时，就会导致函数<em>栈</em>被依次展开，并依帧调用本帧种已经构造的变量的析构函数，来终止程序运行<br>在 <code>c++11</code> 中被 <code>noexcept</code> 代替</p><h3 id="noexcept">noexcept</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">except_func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">except_func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="comment">/*常量表达式*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个常量表达式会被转化为 <code>bool</code> 类型的，如果是 <code>true</code> 就不会抛出异常，否则就会抛出异常。<code>noexcept</code> 表示修饰的函数不会抛出异常，如果修饰的函数抛出了异常，那就会调用 <code>std::terminate()</code> 函数来终止程序的运行，比 <code>throw()</code> 效率更高，相当于是这个函数不能抛出异常</p><h3 id="override">override</h3><p>就是覆盖掉已经存在的一个方法，并且对其进行重写，从而达到不同的作用，通常在类的继承中搭配虚函数使用，一般就是子类对父类的虚函数进行重写，再次调用时就使用子类的该函数方法，对于普通的函数不能重写</p><ol><li>纯虚函数(必须重写，否则不能使用该函数) 只有接口被继承<br><code>virtual void func() = 0;</code></li><li>普通虚函数(可以重写)<br><code>virtual void func();</code></li></ol><h3 id="final">final</h3><p>就是一种禁用派生的关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 禁用重写 (就是该函数即使是虚函数也不能重写)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line"><span class="comment">// 2. 禁用继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fun</span> <span class="keyword">final</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="decltype">decltype</h3><p><code>decltype</code> 相当于 <code>typeof()</code>，可以使得编译器找到表达式的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T1 x, T2 y);</span><br></pre></td></tr></table></figure><p>就是获取数据的类型，充当返回类型，也可以用于 lambda 表达式，面对 lambda表达式 我们只有object， 没有类型，用 <code>decltype</code> 能获得表达式的类型</p><h3 id="lambda-函数">lambda 函数</h3><ul><li>表达式把函数当作对象，把这个表达式当作对象使用</li><li>表达式可以赋值给变量，也可以当作参数传给真正的函数</li><li>在定义包含 lambda 函数的不定序的容器时或者定义一个排序准则，会用到 lambda 类型，这时候需要用到 <code>decltype</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">/*captures*/</span>]<span class="comment">/*&lt;tparams&gt;*/</span>(<span class="comment">/*param*/</span>)-&gt; <span class="comment">/*retType*/</span>&#123;<span class="comment">/*body*/</span>&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>captures</code> 捕获变量列表，就是在定义 <code>lambda函数</code> 的那个作用范围内的变量可以通过[]传入使用<ul><li><code>[epsilon]</code> 将参数 <code>epsilon</code> 按值传递</li><li><code>[&amp;epsilon]</code> 按引用传递</li><li><code>[&amp;]</code> 按引用捕获表达式中使用到的所有变量</li><li><code>[=]</code> 按值捕获表达式中使用到的所有变量</li><li><code>[&amp;,epsilon]</code> 除了 <code>epsilon</code> 以外，其他都按引用传递</li><li><code>[=,&amp;epsilon]</code> 除了 <code>epsilon</code> 以外，其他都按值传递</li><li>如果使用按值捕获，但是在 lambda 表达式中还想要修改拷贝的值，可以使用 <code>mutable</code> 关键字修饰，但是修改也不影响表达式之外的值</li></ul></li><li><code>tparams</code> 模板参数列表，可以省略</li><li><code>params</code> 参数，传入的列表参数，就是形参，没有参数可以省略不写 <code>()</code></li><li><code>retType</code> 返回值类型，两种情况下可以不写 :<ul><li>无返回值</li><li>返回值可以被编译器推导</li><li>如果使用 <code>lambda表达式</code> 中含有多个返回值，可以指定返回值类型</li></ul></li><li><code>body</code> 函数体，用于编写具体函数逻辑的地方</li></ol><h3 id="lambdas-函数">lambdas 函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] () <span class="keyword">mutable</span> throwSpec -&gt; retType &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>第一段 <code>[]</code> 是 <code>lambdas表达式</code> 的标志性符号，看见 此符号就应该知道，这是lambdas表达式。‘[]’内可以使用外部变量</li><li>第二段 <code>()</code> 里可以放入参数。</li><li><code>mutable</code> 关系着 <code>[]</code> 里的数据是否可以被改写。</li><li><code>throwSpec</code> 表示抛出异常。</li><li><code>retType</code> 是描述 [] 的返回类型。</li><li><code>&#123;&#125;</code> 是函数本体</li></ol><h2 id="标准库">标准库</h2><h3 id="rvalue-reference">Rvalue reference</h3><p>右值实现了转移语义和精确传递，主要目的：</p><ol><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</li><li>能够简洁明确的定义泛型函数<br>判断左值还是右值时，看能不能对表达式取地址，如果能，那就是左值，否则就是右值，一般来说左值引用使用符号 <code>&amp;</code> ，右值引用使用符号 <code>&amp;&amp;</code><br><code>std::move()</code>作用就是将左值当作右值来处理，一旦使用 <code>move</code> 函数将左值变为右值就不能再次使用了,就是移动构造函数<br>事实上我们是做了一个浅拷贝（shallow copy）。至于要将之前的指针置为空的原因在于，我们的类会在析构的时候 <code>delete</code> 掉我们的数组。那么我们浅拷贝出来的这个对象的成员变量（arr指针）就变成了一个悬挂指针（空指针）<br><strong>深拷贝</strong><br>当一个类里面有指针时，深拷贝就是不仅复制指针，而且指针所指向的内容也复制一份<br><strong>浅拷贝</strong><br>当一个类里面有指针时，深拷贝就是不仅复制指针，但是指针所指向的内容不会复制，两个指针指向同一个内容</li></ol><h3 id="perfect-forwarding">perfect Forwarding</h3><p>完美转发<br><code>std::forward&lt;T&gt;()</code>，作用就是将数据的左右值类型保留</p><p>是C++11中引入的一种编程技巧，它允许在编写泛型函数时保留参数的类型和值类别，从而实现高效且准确地传递参数。这种技术通过使用右值引用和模板类型推导，使得在函数中以原始参数的形式传递参数给其他函数时，不会发生不必要的拷贝操作，从而提高性能</p><p>完美转发的一个关键概念是引用折叠，即一个声明的右值引用实际上是一个左值。这为参数转发（传递）提供了可能。例如，在C++中，我们可以使用 <code>std::move</code> 将左值转换为右值引用，从而在需要时将左值当作右值使用，避免不必要的拷贝操作。</p><p>在函数模板中，完美转发意味着完全依照模板的参数类型，将参数传递给函数模板中调用的另一个函数。例如，在模板函数 <code>IamForwording</code> 中，我们希望将参数按照传入时的类型传递给目标函数 <code>IrunCodeActually</code> ，而不产生额外的开销。为了实现这一点，我们需要传递的是一个引用类型，因为引用类型不会有额外的开销。同时，我们需要考虑转发函数对类型的接收能力，因为目标函数可能需要即接收左值引用，又接受右值引用。</p><p>总结来说，完美转发是一种在C++中实现高效参数传递的技术，它通过使用右值引用、模板类型推导和引用折叠等特性，确保参数传递时的性能优化和类型匹配。</p><h3 id="universal-reference">universal reference</h3><p>通用引用<br>构成通用引用有两个条件:</p><ol><li>必须满足 <code>T&amp;&amp;</code> 这种形式</li><li>类型必须是能够通过编译器推断得到的</li></ol><p>可以构成通用引用的情况:</p><ol><li><p>函数模板参数</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>auto</code> 声明</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = ....;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>typedef</code> 声明，相当于是重命名一样</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u32; <span class="comment">// 将无符号整型重命名为 u32</span></span><br></pre></td></tr></table></figure></li><li><p><code>decltype</code> 声明</p><p><code>auto</code> 和 <code>decltype</code> 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中， <code>varname</code> 表示变量名， <code>value</code> 表示赋给变量的值， <code>exp</code> 表示一个表达式。</p><p><code>auto</code> 根据=右边的初始值 <code>value</code> 推导出变量的类型，而 <code>decltype</code> 根据 <code>exp</code> 表达式推导出变量的类型，跟=右边的 <code>value</code> 没有关系。</p><p>另外， <code>auto</code> 要求变量必须初始化，而 <code>decltype</code> 不要求，因为已知初始类型。</p><p>主要依据就是引用类型合成</p><ol><li>T&amp; &amp; =&gt; T&amp;</li><li>T&amp;&amp; &amp; =&gt; T&amp;</li><li>T&amp; &amp;&amp; =&gt; T&amp;</li><li>T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</li></ol></li></ol><h3 id="tuple">tuple</h3><p>就是组，一堆不同类型的东西可以储存到一起，储存为 tuple</p><hr><h2 id="面向对象的高级编程">面向对象的高级编程</h2><p>C++ 98  (1.0)</p><p>C++ 03  (TR1, Tecgnical Report 1)</p><p>C++ 11  (2.0)</p><p>C++ 14</p><p>c++ 包括<strong>语言和标准库</strong>，程序对象就是包含数据和数据处理数据方法，c语言中的数据可以被任意函数处理，c++中的数据与可以处理这个数据的方法封装在一起，就是 <code>class</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _XXX_H_   <span class="comment">// 防御式的声明，防止重复引入产生报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XXX_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">// 跟上两行的效果相同</span></span></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="comment">// 1. class head</span></span><br><span class="line"><span class="comment">// 2. class body 有些方法在函数内定义，有些在函数外定义</span></span><br><span class="line"><span class="comment">// inline 函数 : 在class内部定义，不在本体中定义但是想要作为inline函数需要加关键字inline，函数太复杂无法做成inline函数，是否编译为inline函数也不一定</span></span><br><span class="line"><span class="comment">// public:公开，所有的函数方法  private:私有，一般把数据封装，不可访问，但是可以调用class内部方法来改变  protected: 保护</span></span><br><span class="line"><span class="comment">// 构造函数: 函数名称与类的名称相同，可以有参数并且可以有默认值，只有构造函数才有的(初值列，初始列)，不需要有返回类型，不需要有返回值，也可以重构构造函数</span></span><br><span class="line"><span class="comment">// singleton类 这种类的构造函数放进private中，创建时只能调用该类的函数方法创建</span></span><br><span class="line"><span class="comment">// const member functions 常量成员函数，定义函数时使用const关键字时表示该函数不能被改变</span></span><br><span class="line"><span class="comment">// return by value 和 return by reference</span></span><br><span class="line"><span class="comment">// 第一个是返回值，第二个是返回引用，返回值类型是xx&amp;</span></span><br><span class="line"><span class="comment">// return by value 会产生临时物体。</span></span><br><span class="line"><span class="comment">// return by reference看起来象指针，但不会返回一个为NULL的引用，所以这点倒比指针安全，但也要注意引用对象的作用范围。返回对象的地址，但是不能返回局部变量的引用</span></span><br><span class="line"><span class="built_in">complex</span>(<span class="type">double</span> r, <span class="type">double</span> i):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;  <span class="comment">// 这种方法只能在构造函数中使用，效率更高</span></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="友元-friend">友元(friend)</h3><p>在定义 <code>class</code> 中，函数声明前加 <code>friend</code> 关键字，那么这个函数就可以任意调用 <code>private</code> 中的值，也就是打破了封装，而不是使用 <code>class</code> 内的函数来拿到 <code>private</code> 中的值，这样的函数执行更快<br>同一个 <code>class</code> 里的各个 <code>object</code> 互为友元</p><ol><li><code>value</code> 必须是 <code>private</code> 中的</li><li>参数尽可能的使用 <code>reference</code> 引用 来传递， <code>(const)</code></li><li>返回值尽量用 <code>reference</code> 来传递，但是不能传递局部变量的引用</li><li>在 <code>class</code> 中的函数要加 <code>const</code></li><li>构造函数特殊语法</li></ol><h3 id="return-by-reference">return by reference</h3><p>表示返回值是引用的形式，<code>return by reference</code> 传出者无需知道接收者是以什么形式接收的，但是只用指针来传输，就必须知道传出的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="title function_">compute</span><span class="params">(<span class="type">int</span>* a)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = compute(&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作符重载">操作符重载</h3><p>对于操作符 <code>(+=,-=,*=....)</code> 重载时，引入参数时，第一个参数就是 <code>this</code>，第二个参数就是引用的另一个值，返回时可以用 <code>return by reference</code></p><p><code>return by reference</code> 传出者无需知道接收者是以什么形式接收的，但是只用指针来传输，就必须知道传出的类型</p><p>但是对于操作符 <code>(+,-,...)</code> 重载时，返回值必须是一个 <code>local object</code>，不能用 <code>return by reference</code> 传出数据</p><h3 id="临时对象">临时对象</h3><p><code>typename()</code> 创建临时对象，它的生命到下一行就结束了，没有名字，一般在 <code>return</code> 中使用</p><ol><li>建立一个没有命名的非堆（non-heap）对象，也就是无名对象时，会产生临时对象</li><li>构造函数作为隐式类型转换函数时，会创建临时对象，用作实参传递给函数</li><li>函数返回一个对象时，会产生临时对象。以返回的对象最作为拷贝构造函数的实参构造一个临时对象</li></ol><h3 id="拷贝">拷贝</h3><p><strong>浅拷贝</strong>只拷贝指针，<strong>深拷贝</strong>就是拷贝指针内的内容，但是得提前准备好内存地址,先准备一块空间，再把要拷贝的内容考进去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="type">const</span> String &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.my_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(my_data, str.my_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拷贝赋值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> String &amp;String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)  <span class="comment">// 目的是为了检测是否是自己赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] my_data;</span><br><span class="line">    my_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.my_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(my_data, str.my_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拷贝构造</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> &amp;r, <span class="type">double</span> &amp;i) &#123;</span><br><span class="line">        real= r; imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="stack-栈-heap-堆">stack(栈) heap(堆)</h3><p><code>stack</code> 是存在于某个作用域的一个内存空间，当你调用函数时，函数本身就会形成一个 <code>stack</code> 来放置它接收到的参数，以及返回地址，在函数体内声明的任何变量其所使用的内存都取自栈</p><p><code>heap</code> <code>system heap</code> 是指由操作系统提供的一块全局内存空间，程序可以动态分配，从其中获得若干块，但是，操作完之后必须释放掉，不然导致内存泄漏</p><h3 id="stack-objects-static-local-objects-global-objects-heap-objects">stack objects / static local objects / global objects / heap objects</h3><ol><li><p><code>stack objects</code> 栈变量</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;&#125;;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态参数，生命周期只要离开作用域就会自动调用析构函数清理</p></li><li><p><code>static local objects</code> 静态本地变量</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是所谓的静态参数，生命在作用域结束之后依然存在，直到整个程序结束</p></li><li><p><code>global objects</code> 全局变量</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;&#125;;</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c3 = &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>c3</code> 就是一种全局变量，生命在整个程序结束之后结束，也可以看作是静态变量，不同之处在于可以被所有函数调用</p></li><li><p>heap objects 指针变量</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;&#125;;</span><br><span class="line">....</span><br><span class="line">&#123;</span><br><span class="line">    Complex *p = <span class="keyword">new</span> Complex;</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 重要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p</code> 所指的就是 <code>heap object</code>，但是在程序结束时没有 <code>delete</code> 掉，那么指针就会被释放，但是指针所指的内存中的内容不会被删除，所以在 <code>new</code> 之后一定要 <code>delete</code> ，以免造成内存泄漏</p></li></ol><h3 id="new">new</h3><p>先分配 <code>memory</code> 一块空间，再调用 <code>ctor</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Complex *p = <span class="keyword">new</span> Complex;</span><br><span class="line"><span class="comment">// 编译器转化为 ：</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span> (<span class="built_in">sizeof</span>(Complex));  <span class="comment">// 分配类型</span></span><br><span class="line">p = <span class="built_in">static_cast</span>&lt;Complex*&gt;(mem); <span class="comment">// 转型动作</span></span><br><span class="line">p-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 构造函数，通过指针调用其构造函数</span></span><br><span class="line"><span class="comment">// 上面调用的一步实质上就是 ： Complex::Complex(p, 1, 2);</span></span><br></pre></td></tr></table></figure><h3 id="delete">delete</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">// 在编译器转化为：</span></span><br><span class="line">String::~<span class="built_in">String</span>(p);  <span class="comment">// 先调用析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;  <span class="comment">// 释放内存</span></span><br><span class="line"><span class="comment">// 释放内存函数的内部其实就是调用 free(p) 函数</span></span><br></pre></td></tr></table></figure><h3 id="vc中内存的分配">VC中内存的分配</h3><p>在 vc 中，内存分配都是按照 16 的倍数来分配的，不足的补为16的倍数，而且在分配的区域块的第一个内存表示区块的大小，例如分配64位就会用 <code>0x0040</code> 来表示，一般最后一位 1 表示分配出去，0 表示未分配</p><p><strong><code>arrary new</code> 要搭配 <code>arrary delete</code></strong></p><p>不然就会导致头指针那一块内存被释放，但是剩下的内存无法释放并且找不到指针，就会造成内存泄漏</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;   <span class="comment">// 这样写会把所有都删掉，会调用3次析构函数，分别把动态分配的内存删掉</span></span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// 这样写就只会删除1个，只调用1次析构函数，只删除1次，就会有两个不被删除，造成内存泄漏</span></span><br></pre></td></tr></table></figure><p>&amp; 出现在 type 类型 之后表示引用，出现在 object变量 之前，表示取地址</p><h3 id="static">static</h3><p>在创建函数或者变量之前加上 <code>static</code> 表示创建静态的函数和变量<br>静态的函数只能处理静态的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">double</span> m_rate;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span></span>&#123;m_rate = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> Account::m_rate <span class="number">8.0</span>;  <span class="comment">// 要不要给初值都可以</span></span><br><span class="line"><span class="comment">// 调用static的方法：</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line">Account::<span class="built_in">set_rate</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">Account a;</span><br><span class="line">a.<span class="built_in">set_rate</span>(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>类似于内存池：把 <code>ctors</code> 放进 <code>private</code> 内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstances</span><span class="params">(<span class="keyword">return</span> a;)</span></span>;  <span class="comment">// 外界可以通过这个函数得到 这个惟一的结构体 a</span></span><br><span class="line">        <span class="built_in">setup</span>()&#123;....&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">A</span>();                    <span class="comment">// 把构造函数放进private中，表示外界不能创建</span></span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">        <span class="type">static</span> A a;             <span class="comment">// 单建单体单立，只存在唯一的 a，但是没有使用的话就会显得浪费</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这种创建单个唯一的a变量更好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstances</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">setup</span>()&#123;....&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">A</span>();                    <span class="comment">// 把构造函数放进private中，表示外界不能创建</span></span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstances</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="class-template-类模板">class template 类模板</h3><p>需要在创建类时在之前声明 <code>template&lt;typename T&gt;</code> ，在类中要使用某种数据类型就可以用T代替</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 或者 template&lt;class T&gt; 都一样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Complex</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">Complex</span>&lt;<span class="type">double</span>&gt;(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p>表示 <code>T</code> 还没有指定，可以创建不同类型的数据，会产生两段完全一样的代码，即代码膨胀，在编译时就会对传入的数据类型进行推导，然后把函数内的T全部改为指定的数据类型</p><h3 id="namespace-命名空间">namespace 命名空间</h3><ol><li><code>using directive</code><br>就是在函数开始之前声明 <code>using namespace xx</code></li><li><code>using declaration</code><br>就是在函数前声明只使用某个命令 <code>using std::cout</code></li></ol><h3 id="更多细节：">更多细节：</h3><ol><li>operator type() const;</li><li>explicit complex(…):initialization list{}</li><li>pointer-like object</li><li>function-like object</li><li>Namespace</li><li>template specialization</li><li>Standard Library</li><li>variadic template</li><li>move ctor</li><li>Rvalue reference</li><li>auto</li><li>lambda</li><li>range-base for loop</li><li>unordered contaioners</li></ol><h3 id="结构体的复合-继承-委托">结构体的复合，继承，委托</h3><ol><li><p>结构体的复合</p><p>其实就是对原来结构体的部分功能的重新使用，感觉像是结构体中套结构体，例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        deque&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造和析构函数</strong><br>构造由内到外：<br>外部的结构体首先调用内部的结构体的构造函数，然后才执行外部的构造函数</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>(...):<span class="built_in">Component</span>() &#123;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>析构由外到内：<br>析构函数执行时首先调用外部结构体的析构函数，先把自己的任务做完，再调用内部函数的析构函数</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container::~<span class="built_in">Container</span>(...) &#123;... ~<span class="built_in">Component</span>();&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结构体的委托(Delegation)</p><p>就是在结构体中定义一个另一个结构体的指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        StringRep* rep; <span class="comment">// 记得析构函数 delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结构体的继承</p><p>可以继承父类的方法，子类的对象有父类的成分，模板方法</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">list_node</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">listlink</span> : <span class="keyword">public</span> list_node&#123;&#125;; <span class="comment">// public 继承</span></span><br></pre></td></tr></table></figure><p>构造由内而外，析构由外而内，父类的 <code>dtor</code> 必须是 <code>virtual</code> 虚函数，否则会出现未定义的行为。</p></li></ol><p><strong>虚函数</strong><br>虚函数后面加 = 0，表示这个函数为<strong>纯虚函数</strong>，纯虚函数的一般形式： <code>virtual 函数类型 函数名 (参数表列) =0</code><br><strong>特点</strong>：</p><ol><li>纯虚函数没有函数体；</li><li>一个类里如果包含 ＝0 的纯虚函数，那么这个类就是一个抽象类</li><li>抽象类不能具体实例化（不能创建它的对象），而只能由它去派生子类</li><li>在派生类中对此函数提供定义后，它才能具备函数的功能，可被调用。<br>non-virtual(非虚)函数：不希望子类结构体重新定义它<br>virtual(虚)函数：希望子类结构体重新定义，并且在父类中已有默认定义<br>pure virtual(纯虚)函数：希望子类一定要重新定义它，并且在父类中没有默认定义，但是其实是可以有默认定义的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">object</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// non-virtual</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; <span class="comment">// impure virtual</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// pure-virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rectange</span>:<span class="keyword">public</span> shape&#123;...&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">document::<span class="built_in">onfileopen</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">serialize</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mydoc</span> : <span class="keyword">public</span> docunment</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">serialize</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mydoc mydoc;</span><br><span class="line">    mydoc.<span class="built_in">onfileopen</span>(); <span class="comment">// 其实是执行 document.onfileopen()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数在运行的时候,子类结构体变量可以直接调用父类结构体的函数，函数中包含着虚函数，并且在子函数中有定义，就会跳到子函数中执行该函数（相当于执行命 <code>mydoc.serialize()</code>），再跳回父类的函数中</p><h3 id="转换函数-conversion-function">转换函数 conversion function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>  <span class="comment">// 分数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) : <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominator);&#125; <span class="comment">// 分数转为小数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">        <span class="type">int</span> m_denominator; <span class="comment">// 分母</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">4</span> + f; <span class="comment">// 返回值就是4.6   Fration的double函数把f转化为double 类型的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="non-explicit-one-arguement-ctor">non-explicit-one-arguement ctor</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>  <span class="comment">// 分数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) : <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den)&#123;&#125; <span class="comment">// non-exciplict</span></span><br><span class="line">        Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Fraction</span>(<span class="keyword">this</span>-&gt;m_numerator, )</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">        <span class="type">int</span> m_denominator; <span class="comment">// 分母</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction b = f + <span class="number">4</span>; <span class="comment">// 会调用 non-explicit ctor函数将4转化为Fration(4,1)，然后调用operate+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子，如果函数 <code>operate double</code> 也存在的话，电脑会认为有两种方法，会报错</p><ol><li>把f转化为 <code>double</code>，与4相加，再转化为 <code>Fraction</code></li><li>把4转化为 <code>Fraction</code>，与f相加</li></ol><p>这时就需要在构造函数之前加上 <code>explict</code>，这时候在加法中就不会把4转化为 <code>Fraction</code>，而是先把f转化为 <code>double</code>，再加法，在转化</p><h3 id="智能指针-pointer-like-classes">智能指针 pointer-like classes</h3><p>像指针的结构体，需要重载 <code>*</code> 和 <code>-&gt;</code> 符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pointer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">pointer</span>()&#123;<span class="keyword">delete</span> ptr;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> ptr;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++标准库中也有智能指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; p;</span><br><span class="line"><span class="comment">// get返回原指针</span></span><br></pre></td></tr></table></figure><h3 id="仿函数">仿函数</h3><ul><li>– 其实就是一些小的 <code>class</code> 组合而成，而且这些 <code>class</code> 里面有对小括号的重载</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fillter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;std::cout&lt;&lt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure><h3 id="模板：">模板：</h3><p>模板的匹配规则：</p><ol><li><p>最优化的优于次特化的，即模板参数最精确匹配的具有最高的优先权</p></li><li><p>非模板函数具有最高的优先权。如果不存在匹配的非模板函数的话，那么最匹配的和最特化的函数具有高优先权<br>其实就是精确度越高优先权越高</p></li><li><p>类模板</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    T m;</span><br><span class="line">    <span class="function">T <span class="title">getm</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数模板</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getvalue</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成员模板</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">T <span class="title">getx</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>模板特化</p><p>函数模板特化是在一个统一的函数模板不能在所有类型实例下正常工作时，需要定义类型参数在实例化为特定类型时函数模板的特定实现版本</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span>&lt;<span class="type">bool</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">mymax</span><span class="params">(<span class="type">const</span> T t1, <span class="type">const</span> T t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> t1 &lt; t2 ? t2 : t1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt; &gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">mymax</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* t1,<span class="type">const</span> <span class="type">char</span>* t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="built_in">strcmp</span>(t1,t2) &lt; <span class="number">0</span>) ? t2 : t1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>模板偏特化(局部特化)</p><p>对于有多个模板参数的函数或者类，只对其中一个或几个模板参数进行特化处理，但是没有全部进行特化处理，这样就是模板偏特化</p></li><li><p>模板泛化</p></li><li><p>模板模板参数<br>使用带模板参数的对象来作为模板</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N,<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;container&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    container&lt;T&gt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>数量不定的模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abs</span><span class="params">(T&amp; a, Args&amp;... args)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="vptr-虚指针-vtbl-虚函数表">vptr(虚指针) vtbl(虚函数表)</h3><p><img src="https://img-blog.csdnimg.cn/20210323151830567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfWV9GZWk=,size_16,color_FFFFFF,t_70#pic_center" alt="https://img-blog.csdnimg.cn/20210323151830567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfWV9GZWk=,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>虚指针</strong>是一个地址值，以该地址作为起始地址的一片单元格内部存放着各个虚函数地入口地址(这个函数地址也可以相当于是一个指针)，这一片内存就是虚函数表，虚指针就是指向指针的指针<br>对于不同的子类所复写的虚函数也都存放在虚函数表中，这个虚函数表应当是自己的虚函数表，不是父类的虚函数表，对于不同类型的对象会调用不同的虚函数。但是如果子类没有重写父类的虚函数，并且父类的虚函数也不是纯虚函数，那么这个子类的虚函数表调用就是调用的是父类的虚函数表</p><p><img src="https://img-blog.csdnimg.cn/90f3d3f0d7f34b2c87329fd00f4cbcf3.png" alt="https://img-blog.csdnimg.cn/90f3d3f0d7f34b2c87329fd00f4cbcf3.png"></p><h3 id="this-对象模型">this(对象模型)</h3><p>首先，对于类的开辟空间，如果一个空的类，系统也会默认给类分配为1个字(32位)的空间，而且成员函数的定义不影响类的内存大小<br>this是类中指向这个调用非静态成员函数的对象，this指针不需要自己手动声明或定义，它是被系统定义的<br><strong>作用</strong></p><ol><li>用于区分形参和成员变量名</li><li>用于返回类的本身</li><li>如果我们创建一个类的空指针，我们依然可以调用不涉及成员变量的类的函数，但是不能访问带有成员变量的成员函数，成员变量与具体的对象有关</li></ol><p><strong>常函数</strong><br>就是类里面的函数不能修改成员变量的特殊函数，除非成员变量之前加上关键字 <code>mutable</code> ，常函数本质上是限制了 <code>this</code> 指针，将指针由 <code>typename *const this</code> 修改为 <code>const typename *const this</code> 让其不能对指向的内容进行修改，常用语法是 <code>返回类型+函数名()+const</code></p><p><strong>常对象</strong><br>常对象就是在对象前加 <code>const</code>，常对象不能对成员变量进行修改，除非成员变量前加关键字 <code>mutable</code>，并且常对象只能调用常函数，因为通过非常函数调用有可能改变成员变量，常变量语法是 <code>const+类型名+变量名</code></p><h3 id="const">const</h3><p>当成员函数的 <code>const</code> 和 <code>non-const</code> 两个版本都存在，那么 <code>const object</code> 只会调用 <code>const</code> 版本， <code>non-const object</code> 只能调用 <code>non-const</code> 版本</p><table><thead><tr><th></th><th>const object(data members 不变)</th><th>non-const object(data members 可变动)</th></tr></thead><tbody><tr><td>const member function(保证不更改data members)</td><td>true</td><td>true</td></tr><tr><td>non-const member function(不保证不更改data members)</td><td>false</td><td>true</td></tr><tr><td>函数形参使用const来修饰的话，既可以引入常量也可以引入非常量</td><td></td><td></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> String <span class="title">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">str.<span class="built_in">print</span>(); <span class="comment">// print 不是const函数,在定义的时候可以定义为const 成员函数</span></span><br></pre></td></tr></table></figure><h3 id="mutable">mutable</h3><p>是可变的，易变的，与 <code>const</code> 相反，这个关键字是为了突破 <code>const</code> 的限制而设计的，被 <code>mutable</code> 所修饰的变量，将永远处于可变的状态，即使在 <code>const</code> 函数中也是可变的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">mutable</span> <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      num++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="new-delete">new delete</h3><p><code>new</code> 先分配内存 再调用构造函数<br><code>delete</code> 先调用析构函数 再释放内存<br>可以重载 <code>new</code> 和 <code>delete</code> 函数</p><p>对于函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> seed, types&amp; ...args)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(types&amp; ...args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>第一种比较特化，如果传入参数的话，优先考虑第一种情况</p><h3 id="nullptr-and-std-nullptr-t">nullptr and std::nullptr_t</h3><p>用 <code>nullptr</code> 表示0或者空指针，<code>nullptr</code> 的类型是 <code>std::nullptr_t</code></p><h3 id="auto-变量">auto 变量</h3><p><code>auto</code> 表示不知道是什么类型的变量，可以把任意变量赋予 <code>auto</code> 变量，编译过程中，编译器会自动识别类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verctor&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123;&#125;; <span class="comment">// 后面的参数表示 lambda 匿名函数，无法确定类型就使用auto</span></span><br></pre></td></tr></table></figure><h3 id="auto-keywiord">auto keywiord</h3><p>用 <code>auto</code> 关键字来定义函数的返回值</p><h3 id="uniform-initializtion">uniform initializtion</h3><p>一致初始化，一般发生在<strong>大括号，等于号</strong>，可以直接在声明变量之后加上大括号，里面放入初始化的值，编译器在看到 <code>&#123;...&#125;</code> 之后，就会做出一个 <code>initializer_list&lt;type&gt;</code> ，关连着一个 <code>arrary&lt;type,n&gt;</code>, 调用函数时， <code>arrary</code> 内的元素可以被编译器分解，逐一传给函数。但是如果该函数参数是一个 <code>initializer_list&lt;T&gt;</code> ，调用者却不能够给予整个 <code>T</code> 参数，然后然后以为它们会被自动转化为一个 <code>initializer_list&lt;T&gt;</code> 传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  -&gt; arrary&lt;<span class="type">int</span>, <span class="number">3</span>&gt;</span><br><span class="line">verctor&lt;<span class="type">int</span>&gt;v &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  -&gt;arrary&lt;<span class="type">int</span>, <span class="number">4</span>&gt;</span><br><span class="line">verctor&lt;string&gt; cities &#123;<span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;NewYork&quot;</span>&#125;;-&gt;arrary&lt;string, <span class="number">2</span>&gt;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c &#123;<span class="number">4.0</span>,<span class="number">3.0</span>&#125;;</span><br><span class="line"><span class="comment">// 上面的代码都关连着一个arrary&lt;type,n&gt;</span></span><br></pre></td></tr></table></figure><p><strong>函数的参数为 <code>initializer_list&lt;T&gt;</code></strong></p><p>对于 <code>&#123;&quot;Berlin&quot;,&quot;NewYork&quot;&#125;</code> 会形成一个 <code>initializer_list&lt;string&gt;</code> ，背后会有一个 <code>arrary&lt;string, n&gt;</code> 。</p><p>调用 <code>vectir&lt;string&gt;ctors</code> 时，编译器找到了一个 <code>vector&lt;string&gt;ctor</code> 接受 <code>initializer_list&lt;string&gt;</code>。 所有的容器都如此</p><p><strong>函数的参数为单个的变量</strong></p><p>对于 <code>complex&lt;double&gt; c &#123;4.0,3.0&#125;</code> ，会把 <code>arrary&lt;type&gt;</code> 中的每一个参数分开，以此执行 <code>complex&lt;type&gt; ctor</code></p><p><code>complex&lt;type&gt;</code> 并没有任何 <code>ctor</code> 接受 <code>initializer_list&lt;type&gt;</code></p><h3 id="initializer-list">initializer_list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;    <span class="comment">// 未定义初值</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;  <span class="comment">// 定义为0</span></span><br><span class="line"><span class="type">int</span> *p;   <span class="comment">// 未定义初值</span></span><br><span class="line"><span class="type">int</span> *q&#123;&#125;; <span class="comment">// 定义为 nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>;                          <span class="comment">// 可以把5.3转型为5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;                         <span class="comment">// 可以把5.3转型为5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.3</span>&#125;;                          <span class="comment">// error 大括号无法转型</span></span><br><span class="line"><span class="type">int</span> x4 = &#123;<span class="number">5.3</span>&#125;;                       <span class="comment">// error 大括号无法转型</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;                           <span class="comment">// ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">999999</span>&#125;;                      <span class="comment">// 超出界限也不可以</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5.3</span>&#125;; <span class="comment">// error 无法转型</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = vals.<span class="built_in">begin</span>(); p!=vals.<span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;*p&quot;</span> &lt;&lt; <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;); <span class="comment">// 依次打印输出</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">p</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; b &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">p</span>(initializer_list&lt;T&gt;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;p(initializer_list)&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(suto i :initlist)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 1</span></span><br><span class="line">P q&#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// 2,参数为整个包，如果2不在了，就会拆解为单个的，调用1</span></span><br><span class="line">P r&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 2</span></span><br><span class="line">P s = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对于只包含少量的参数的函数，可以用{…args}传入多个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line"><span class="built_in">min</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="explicit-明确的-不允许转化类型">explicit 明确的 不允许转化类型</h3><p>默认的编译器在编译时，计算时会自动把数值转化为与结果相应的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="comment">// explicit</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re, <span class="type">int</span> im = <span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;;<span class="comment">// 单一形参</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real), (imag + x.imag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>如果不加上 <code>explicit</code> 时，编译器就会把 5 转化为复数，但是只能调用单一形参的构造函数，然后相加<br>但是加上 <code>explicit</code> 之后，禁止调用 <code>Complex</code> 的构造函数转化，所以相加时就会报错，这个关键字加在构造函数中</p><h3 id="default-delete">default &amp; delete</h3><p><code>C++11</code> 允许添加 <code>=default</code> 说明符到函数声明的末尾，以将该函数声明为显示默认构造函数。这就使得编译器为显示默认函数生成了默认实现，它比手动编程函数更加有效。<br>例如，每当我们声明一个有参构造函数时，编译器就不会创建默认构造函数。在这种情况下，我们可以使用 <code>default</code> 说明符来创建默认说明符。<br>默认函数需要用于特殊的成员函数（默认构造函数，复制构造函数，析构函数等），或者没有默认参数。例如，以下代码解释了非特殊成员函数不能默认<br><code>default</code> 就是默认函数，只针对特殊的函数，例如构造函数与析构函数<br><code>delete</code> 就是禁用函数，可以用在任意函数上，与=0不同，=0只能用于虚函数中</p><h3 id="big-three-big-five">big-three(big-five)</h3><ol><li><code>Desconstructor</code> 构造函数</li><li><code>copy constructor</code> 复制构造</li><li><code>operator =</code> 拷贝赋值函数</li><li><code>copy constructor</code> 移动构造函数 <code>class_name(class_name &amp;&amp; )</code></li><li><code>Destructor</code> 析构函数</li></ol><h3 id="nocopy">NoCopy</h3><p>在结构体中，所有的拷贝操作都被删除，不能进行拷贝，就是把编译器默认的拷贝函数给删除了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nocopy(const nocopy&amp;) = delete; // 拷贝函数</span><br><span class="line">nocopy &amp;operator=(const nocopy&amp;) = delete; // 拷贝赋值函数</span><br></pre></td></tr></table></figure><h3 id="nodtor">NoDtor</h3><p>就是在结构体中的析构函数被删除，无法删除生成的类的变量，而且这个变量依然在栈中，需要我们手动删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NoDtor() = default;</span><br><span class="line">~NoDtor() = delete;</span><br><span class="line">delete p; // 最后只能调用delete函数来删除变量</span><br></pre></td></tr></table></figure><h3 id="privatecopy">PrivateCopy</h3><p>此结构体中不可以被拷贝，但是可以被<strong>friend</strong>和<strong>member</strong>来拷贝，如果想要完全禁止，不但必须把拷贝函数放进<strong>private</strong>，而且不可以定义它</p><h3 id="alias-template-template-typedef">Alias Template (template typedef)</h3><p>不能对 Alias Template 进行特化，不能对这个重定义之后的名字做特化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">using vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">vec&lt;int&gt; coll;// 相当于 std::vector&lt;T,MyAlloc&lt;T&gt;&gt; coll</span><br><span class="line">------------</span><br><span class="line">#define Vec&lt;T&gt; template&lt;typename T&gt; std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">typedef template&lt;typename T&gt; std::vector&lt;T, MyAlloc&lt;T&gt;&gt; Vec&lt;T&gt;;</span><br><span class="line">// 上面两种情况都达不到需求，而且，typedef 是不接受参数的</span><br></pre></td></tr></table></figure><h3 id="排序函数">排序函数</h3><p>排序函数一般都会规定排序方法，这个排序方法有多种形式</p><ol><li>函数</li><li>lambda 函数</li><li>类，前提是这个类里面必须有重载()的函数</li></ol><h3 id="引用">引用&amp;</h3><p>相当于是一个常量指针</p><ol><li>用于定义变量，必须在定义时初始化，并且之后不再改变(常量指针)</li><li>用于函数参数的类型限定，相当于是传入一个指针，可以更快并且内存也占用更少</li><li>可以作为函数返回值，返回一个常量指针</li></ol><h3 id="volatile-关键字">volatile 关键字</h3><p>用于修饰变量，作用是告诉编译器不要对这个变量做过度的优化，并且这个变量是易变的，每次读取使用这个变量时，是从变量的地址直接读取的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">// 1. 本程序段中不能对a作修改，任何修改都是非法的，或者至少是粗心，编译器应该报错，防止这种粗心；</span></span><br><span class="line"><span class="comment">// 2. 另一个程序段则完全有可能修改，因此编译器最好不要做太激进的优化。</span></span><br><span class="line"><span class="comment">// “const”含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”。</span></span><br><span class="line"><span class="comment">// “volatile”的含义是“请不要做没谱的优化，这个值可能变掉的”，而并非“你可以修改这个值”。</span></span><br><span class="line"><span class="comment">// const和volatile这两个类型限定符不矛盾。</span></span><br><span class="line"><span class="comment">// const表示（运行时）常量语义：被const修饰的对象在所在的作用域无法进行修改操作，编译器对于试图直接修改const对象的表达式会产生编译错误。</span></span><br><span class="line"><span class="comment">// volatile表示“易变的”，即在运行期对象可能在当前程序上下文的控制流以外被修改（例如多线程中被其它线程修改；对象所在的存储器可能被多个硬件设备随机修改等情况）</span></span><br><span class="line"><span class="comment">// 被volatile修饰的对象，编译器不会对这个对象的操作进行优化。</span></span><br><span class="line"><span class="comment">// 一个对象可以同时被const和volatile修饰，表明这个对象体现常量语义，但同时可能被当前对象所在程序上下文意外的情况修改。</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-关键字">constexpr 关键字</h3><p>修饰的变量在编译阶段就可以运算结束，程序中不能更改</p><p>数据可以存在只读区.嵌入式开发感知更强.</p><p>可以用在需要完整常量表达式的场合. 还能做一下简单计算.</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity游戏开发-MYSQL</title>
      <link href="/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/"/>
      <url>/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a>MySQL配置</h3><ol><li>先安装一个数据库，我使用的是 <code>8.0.35</code> 版本的，版本没什么大的要求。也可以安装一个可视的 <code>UI</code> 界面，例如 <code>workbench</code>，方便做一些操作</li><li>在数据库中添加表格，然后将某一个 <code>user</code> 的 <code>localhost</code> 设置为 <code>%</code>，就可以实现其他设备的登录了</li></ol><h3 id="unity端配置"><a href="#unity端配置" class="headerlink" title="unity端配置"></a>unity端配置</h3><ol><li>在 <code>Assets</code> 文件目录下新建一个文件夹 <code>Plugins</code> 用来存放数据库需要的一些文件 （必须是这个名称，不能更改，不然 unity 不能识别出来）</li><li>可以不用下载 <code>MySQL Connnector/NET</code>，直接在 <code>vs</code>中安装 <code>mysql</code> 包 项目→管理 <code>NuGet</code> 程序包，直接在浏览中搜索 <code>MySQL</code>，安装第一个，之后它会自己把依赖装好</li><li><p>然后，最最重要的一步，在vs的解决方案资源管理器的项目的引用之下，找到 <code>mysql.Data</code> 这个项目，查看它所在的路径，在文件资源管理器中找到它，把它拖到第一步所建好的文件夹中，然后进入unity它会报错，查看错误信息，是需要一些文件，然后再在项目引用之下找到 <code>Google.Protobuf</code> , <code>K4os.Compression.LZ4</code> , <code>K4os.Compression.LZ4.Streams</code> , <code>K4os.Hash.xxHash</code> , <code>BouncyCastle.Cryptography</code> , <code>System.IO.Pipelines</code> ,  <code>System.IO</code> , <code>System.Runtime.CompilerServices.Unsafe</code>，但是我的里面是没有 <code>ZstdSharp</code> 的，需要像第二步一样自己安装一下，然后拖到 <code>unity</code> 的 <code>Plugins</code>，需要注意版本问题，一般直接使用vs中对应程序集的路径就可以</p><p><img src="/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/vsSet.png" alt="vsSet.png"></p></li><li><p>也是极其重要的一步，在unity的安装目录之下的 <code>Editor/Data/MonoBleedingEdge/lib/mono/unityjit-win32</code> 中，找到以下四个文件</p><ul><li><code>I18N.dll</code></li><li><code>I18N.CJK.dll</code></li><li><code>I18N.MidEast.dll</code></li><li><p><code>I18N.West.dll</code></p><p><img src="/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/unitySet1.png" alt="unitySet1.png"></p></li></ul></li><li><p>把 <code>unity</code> 的 <code>File</code> → <code>Build Settings</code> → <code>Player Settings</code> → <code>Api Compatibility Level</code> 更改为 <code>.NET Framewok</code></p><p> <img src="/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/unitySet.png" alt="unitySet.png"></p></li><li><p>然后就可以实现在<strong>局域网之中</strong>连接到这个数据库了</p></li><li><p>附上代码</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InputField username;</span><br><span class="line"><span class="keyword">public</span> InputField password;</span><br><span class="line"><span class="keyword">public</span> GameObject LOG;</span><br><span class="line"><span class="keyword">public</span> Canvas canvas;</span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line"><span class="built_in">string</span> sqlSer = <span class="string">&quot;server=49a17g0230.zicp.fun;port = 21514;database = dragondata;user = root;password = Beloved@25177&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signin</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MySqlConnection conn = <span class="keyword">new</span> MySqlConnection(sqlSer);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn.Open();</span><br><span class="line">        UnityEngine.Debug.Log(<span class="string">&quot;------链接成功------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">string</span> sqlQuary = <span class="string">&quot;select * from userlib where account = @paral1 and password = @paral2&quot;</span>;</span><br><span class="line">        MySqlCommand comd = <span class="keyword">new</span> MySqlCommand(sqlQuary, conn);</span><br><span class="line">        comd.Parameters.AddWithValue(<span class="string">&quot;paral1&quot;</span>, username.text);</span><br><span class="line">        comd.Parameters.AddWithValue(<span class="string">&quot;paral2&quot;</span>, password.text);</span><br><span class="line">    </span><br><span class="line">        MySqlDataReader reader = comd.ExecuteReader();</span><br><span class="line">        <span class="keyword">if</span> (reader.Read())</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Debug.Log(<span class="string">&quot;------用户存在，登录成功！------&quot;</span>);</span><br><span class="line">            SceneManager.LoadScene(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LOG.GetComponent&lt;showlogcontent&gt;().logmsg = <span class="string">&quot;登录失败，用户不存在&quot;</span>;</span><br><span class="line">            GameObject log = GameObject.Instantiate(LOG, transform.position, Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            log.transform.SetParent(canvas.transform, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (System.Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MySqlConnection conn = <span class="keyword">new</span> MySqlConnection(sqlSer);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn.Open();</span><br><span class="line">        <span class="comment">// UnityEngine.Debug.Log(&quot;-----连接成功！------&quot;);</span></span><br><span class="line">    </span><br><span class="line">        <span class="built_in">string</span> sqlQuary = <span class="string">&quot;select * from userlib where account = @paral1 and password = @paral2&quot;</span>;</span><br><span class="line">        MySqlCommand comd = <span class="keyword">new</span> MySqlCommand(sqlQuary, conn);</span><br><span class="line">        comd.Parameters.AddWithValue(<span class="string">&quot;paral1&quot;</span>, username.text);</span><br><span class="line">        comd.Parameters.AddWithValue(<span class="string">&quot;paral2&quot;</span>, password.text);</span><br><span class="line">    </span><br><span class="line">        MySqlDataReader reader = comd.ExecuteReader();</span><br><span class="line">        <span class="keyword">if</span> (reader.Read())</span><br><span class="line">            UnityEngine.Debug.Log(<span class="string">&quot;-----用户名已存在，请重新输！------&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Insert_User(username.text, password.text);</span><br><span class="line">            UnityEngine.Debug.Log(<span class="string">&quot;------注册成功，请进行登入------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (System.Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Insert_User</span>(<span class="params"><span class="built_in">string</span> username, <span class="built_in">string</span> password</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MySqlConnection conn = <span class="keyword">new</span> MySqlConnection(sqlSer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn.Open();</span><br><span class="line">        <span class="built_in">string</span> signupdata = System.DateTime.Now.ToString(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> sqlInsert = <span class="string">&quot;insert into userlib(account,password,signupdata) values(&#x27;&quot;</span> + username + <span class="string">&quot;&#x27;,&#x27;&quot;</span> + password + <span class="string">&quot;&#x27;,&#x27;&quot;</span> + signupdata + <span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line">        MySqlCommand comd2 = <span class="keyword">new</span> MySqlCommand(sqlInsert, conn);</span><br><span class="line">        <span class="built_in">int</span> resule = comd2.ExecuteNonQuery();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (System.Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="外网连接配置"><a href="#外网连接配置" class="headerlink" title="外网连接配置"></a>外网连接配置</h3><p>可以使用局域网以外的网络连接上服务器，需要下载<strong>花生壳</strong></p><ol><li><p>下载好之后，在花生壳中新增映射</p><p> <img src="/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/HSK.png" alt="HSK.png"></p><ul><li>映射类型选择 <code>TCP</code></li><li><code>TCP</code> 选择普通 <code>TCP</code> 就行</li><li>不使用模板</li><li>外网域名好像随便一个就行，我直接使用的软甲给的提示</li><li>端口选择动态的，因为固定的要钱</li><li>内网主机就是本机的IP地址，直接在中断输入 <code>ipconfig</code>，其中的 <code>IPv4</code> 地址就是</li><li>内网端口就是 <code>mysql</code> 所使用的 <code>3306</code> 端口</li></ul></li><li><p>映射完成之后可以看到</p><p> <img src="/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/HSK1.png" alt="HSK1.png"></p><p> 其中最重要的就是访问地址了，可以在 <code>mysql</code> 中试着连接一下，其中的 <code>hostname</code>  就是外网域名，port就是映射之后的端口</p><p> <img src="/Blog_ButterFly/2024/03/19/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-MYSQL/mysqltest.png" alt="mysqltest.png"></p></li><li><p>好像需要开启本电脑的3306端口的远程连接</p><ul><li>进入应用 高级安全 <code>windowsDefender</code> 防火墙</li><li>点击入站规则-&gt;新建规则</li><li>配置端口， <code>mysql</code> 使用的是 <code>tcp</code> 协议，使用的是3306端口</li></ul></li><li>在 <code>unity</code> 中创建连接<br><code>string sqlSer = &quot;server=49a17g0230.zicp.fun;port = 21514;database = database;user = root;password = password&quot;;</code><br>其中的server就是访问地址的域名，也就是外网域名，冒号后面的就是端口，也就是最终映射出的端口</li><li>最后就可以实现数据库的远程连接了，并且不需要在同一个局域网</li></ol>]]></content>
      
      
      <categories>
          
          <category> unity游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>request-python学习记录</title>
      <link href="/Blog_ButterFly/2024/03/19/request-python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/Blog_ButterFly/2024/03/19/request-python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="requests-学习"><a href="#requests-学习" class="headerlink" title="requests 学习"></a>requests 学习</h2><p><strong>静态网络与动态网络</strong></p><ul><li>动态xml页面: 如果网络界面是由js加载上去的，那么网络就是动态的</li><li>静态xml页面: 没有使用js加载</li><li>通用爬虫: 通常指搜索引擎的爬虫 面向互联网上所有的网站</li><li>聚焦爬虫: 针对特定网站的爬虫 针对几个网站，特定的网站</li></ul><p><strong>步骤</strong></p><ol><li>url list</li><li>响应内容 提取url</li><li>提取数据</li><li>入库</li></ol><p><strong>DNS服务器</strong>: 根据客户给定的域名，来返回对应的 ip 地址，客户通过 ip 地址请求页面，返回页面的 html+js+css+.jpg</p><h3 id="url形式"><a href="#url形式" class="headerlink" title="url形式:"></a>url形式:</h3><ul><li>scheme://host[:port# ]/path/…/[?query-string ][#anchor ]</li><li>scheme: 协议(http,https,ftp)</li><li>host: 服务器的ip地址或者域名</li><li>port: 服务器的端口(如果是默认端口就是 80 / 443)</li><li>path: 访问资源的路径</li><li>query-string: 参数，发送给http服务器的数据</li><li>anchor: 锚点(跳转到网页的指定冒点位置)<br>url地址带上锚点与不带锚点是一样的</li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>http</p><ul><li>超文本传输协议</li><li>默认端口号: 80<br>https / <a href="http://xn--yfr16ad4eh64dhfza.cn/">网址后面加.cn</a></li><li>http + SSL(安全套接字层)</li><li>默认端口号: 443<br>https 比 http 更安全，但是性能更低<br>https 在发送数据之前会对数据进行加密，服务端接收到数据之后还需要对数据进行解密，就可以获得内容</li></ul><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法,HTTP是一种基于”请求与响应”模式的、无状态的应用层协议。HTTP协议采用URL作为定位网络资源的的标识符。<br><a href="http://host/">http://host</a>[:post][path]<br>host:合法的Internet主机域名或ip地址<br>port:端口号，缺省为80<br>path:请求资源的路径</p><p><strong>user-agent</strong>: 包括电脑的版本号，浏览器的版本号，浏览器的内核版本，操作系统的信息(linux,windows,macos 以及对应的版本)<br>通过user-agent能够让网页知道访问它的对象的信息等，如果发现<br><strong>cookie</strong>: 就是保存在浏览器本地的本人浏览器信息，但是不太安全，而且一个站点的cookie都是有限的，不能无线申请<br><strong>session</strong>: 就是保存在网址上的个人信息数据，一般可以存储无限个</p><p>我们在申请网址的时候只需要带上name和value就可以</p><p>Ajax</p><h3 id="HTTP-URl的理解"><a href="#HTTP-URl的理解" class="headerlink" title="HTTP URl的理解:"></a>HTTP URl的理解:</h3><p>url是通过HTTP协议存取资源的的Internet路径，一个URL对应一个数据资源</p><h3 id="HTTP协议对资源的操作"><a href="#HTTP协议对资源的操作" class="headerlink" title="HTTP协议对资源的操作"></a>HTTP协议对资源的操作</h3><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>请求获取URL位置的资源</td></tr><tr><td>HEAD</td><td>请求获取URL位置资源的响应消息报告，即获得资源的头部信息</td></tr><tr><td>POST</td><td>请求向URL位置的资源后附加新的消息</td></tr><tr><td>PUT</td><td>请求向URL位置存储一个资源，覆盖原URL位置的资源</td></tr><tr><td>PATCH</td><td>请求局部更新URL位置的资源,即改变该处资源的部分内容</td></tr><tr><td>DELETE</td><td>请求删除URL位置存储的资源</td></tr><tr><td>以上方法中，GET,HEAD是从服务器获取信息到本地，PUT,POST,PATCH,DELETE是从本地向服务器提交信息。通过URL和命令管理资源，操作独立无状态，网络通道及服务器成了黑盒子。</td><td></td></tr><tr><td>文档</td></tr></tbody></table></div><h3 id="requests库7个主要方法"><a href="#requests库7个主要方法" class="headerlink" title="requests库7个主要方法"></a>requests库7个主要方法</h3><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>requsts.requst()</td><td>构造一个请求，最基本的方法，是下面方法的支撑</td></tr><tr><td>requsts.get()</td><td>获取网页，对应HTTP中的GET方法</td></tr><tr><td>requsts.post()</td><td>向网页提交信息，对应HTTP中的POST方法</td></tr><tr><td>requsts.head()</td><td>获取html网页的头信息，对应HTTP中的HEAD方法</td></tr><tr><td>requsts.put()</td><td>向html提交put方法，对应HTTP中的PUT方法</td></tr><tr><td>requsts.patch()</td><td>向html网页提交局部请求修改的的请求，对应HTTP中的PATCH方法</td></tr><tr><td>requsts.delete()</td><td>向html提交删除请求，对应HTTP中的DELETE方法</td></tr></tbody></table></div><p>只有post请求才能够请求数据</p><p>应用场景:<br>get(): 除了post请求之外的指令一般都使用get请求<br>post(): 提交表单，传输数据非常多的时候，例如:利用百度翻译或者传输图片</p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a><a href="https://blog.csdn.net/qq_45477063/article/details/124810709">响应状态码</a></h3><ul><li>200: 成功</li><li>302: 临时转移至新的url</li><li>307: 临时转移至新的url</li><li>404: not found</li><li>500: 服务器内部错误，可能是对方反爬虫</li></ul><p>assert 断言<br>str 可以通过endode方法转化为 bytes<br>bytes 也可以通过decode方法转化为 str</p><h3 id="爬虫的流程"><a href="#爬虫的流程" class="headerlink" title="爬虫的流程"></a>爬虫的流程</h3><ul><li>url—-&gt;发送请求，获取响应—-&gt;提取数据—-&gt;保存</li><li>发送请求，获取相应—-&gt;提取url<br>爬虫要根据当前的url地址对应的相应为准，当前的url地址的elements的内容和url的响应不一样</li></ul><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>get()请求的返回值就是一个响应数据，也就是请求的结果，响应状态码<br>get()的返回值包括text，就是返回值的一个属性</p><ul><li>text<ul><li>类型 str</li><li>解码类型 根据http头部对响应的编码做出有根据的推测来推测出来的文本编码</li><li>修改解码方式: response.text.encoding = “utf8”<br>encoding，响应内容的编码方式</li></ul></li><li>content<ul><li>类型 bytes</li><li>解码类型 没有指定</li><li>可以修改解码方式 response.content.decode(“utf8”)</li></ul></li></ul><h3 id="判断是否请求成功"><a href="#判断是否请求成功" class="headerlink" title="判断是否请求成功"></a>判断是否请求成功</h3><p>使用assert，后面加入判断内容，如果判断内容是真的，那就不报错，否则就会报错</p><h3 id="response-的常用方法"><a href="#response-的常用方法" class="headerlink" title="response 的常用方法"></a>response 的常用方法</h3><ul><li>response.text</li><li>response.content</li><li>response.status_code</li><li>response.request.headers</li><li>response.headers</li><li>response.url 会打印出当前的网址，并且带参数，是一种url的编码方式，可以使用url解码</li></ul><h3 id="字符串格式化的方式"><a href="#字符串格式化的方式" class="headerlink" title="字符串格式化的方式"></a>字符串格式化的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;&lt;http://www.baidu.com/s?wd=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;pyhton&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>登录注册(post比get更安全)</li><li>需要传输大文本内容的时候</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reponse = requests.post(<span class="string">&quot;&lt;http://www.baidu.com&gt;&quot;</span>,data = data,headers = headers)</span><br></pre></td></tr></table></figure><p>data:字典的形式，用来存储需要传输的数据<br>传回的数据是 json 类型的一个数据</p><p>返回的数据的类型:json,text,html</p><h3 id="使用代理ip"><a href="#使用代理ip" class="headerlink" title="使用代理ip"></a>使用代理ip</h3><ul><li>使用爬虫需要使用代理</li><li>根据ip地址能够追查到某个地址某个人，防止真实的ip地址暴漏</li><li>代理ip:<ul><li>透明代理 可以追查到真实的ip地址</li><li>普匿代理</li><li>高匿代理 不易追查</li></ul></li><li>检查代理ip的可用性:<ul><li>可以使用requests添加超时参数，判断ip地址的质量</li></ul></li><li>可以准备一堆ip地址，组成ip池，随机选择一个ip来用<ul><li>随机选择ip代理地址<ul><li>{“ip”:ip,”times”:0}</li><li>[{},{},{}]用列表来进行排序，按照使用次数来排列</li><li>选择使用较少的10个ip地址，从中选取一个</li></ul></li></ul></li></ul><h3 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h3><ul><li>cookie存放在客户的浏览器上，session保存在服务器上</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗</li><li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你的服务器的性能</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点只能保存20个cookie</li><li>带上cookie和session的好处:能够请求到登录之后的界面</li><li>带上cookie和session的弊端:<ul><li>一套cookie和session往往之和一个用户对应</li><li>请求太快，请求太多，容易被服务器识别为爬虫</li></ul></li><li>不需要cookie的时候尽量不使用cookie</li><li>但是为了获取登录之后的页面，必须使用cookie</li></ul><h3 id="携带cookie进行请求"><a href="#携带cookie进行请求" class="headerlink" title="携带cookie进行请求"></a>携带cookie进行请求</h3><ul><li>携带一堆cookie进行请求，把cookie组成一个cookie池</li><li>cookie储存为一个字典，然后字典组成列表，进行排序使用</li></ul><h3 id="requests中的session类"><a href="#requests中的session类" class="headerlink" title="requests中的session类"></a>requests中的session类</h3><p>session来实现客户端和服务端的会话保持<br>使用方法:</p><ul><li>实例化一个session对象</li><li>让session来发送get或者post请求</li><li>session = requests.session()</li><li>response = session.get(url,header)</li><li>这个session中保存了对方服务器中设置的cookie,其实就是获取到了之前登陆的信息</li></ul><p>请求登陆网站的思路:</p><ul><li>实例化session</li><li>先使用session发送请求，登录对应网站，把cookie保存在session中</li><li>在使用session请求登陆之后才能访问的网站，session能够自动携带登陆成功时保存在其中的cookie信息，进行请求</li></ul><h3 id="不发送post请求，使用cookie获取登陆后的页面"><a href="#不发送post请求，使用cookie获取登陆后的页面" class="headerlink" title="不发送post请求，使用cookie获取登陆后的页面"></a>不发送post请求，使用cookie获取登陆后的页面</h3><ul><li>cookie过期时间太长的网站</li><li>cookie过期之前能够拿到所有的数据</li><li>配合其他的程序一起使用，其他的程序获取cookie，当前程序专门请求页面</li></ul><h3 id="字典生成-字典推导式"><a href="#字典生成-字典推导式" class="headerlink" title="字典生成 字典推导式"></a>字典生成 字典推导式</h3><p>能够把cookie转化为字典:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookies = &#123;i.split(<span class="string">&quot;=&quot;</span>)[<span class="number">0</span>]:i.split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> cookies.splits(<span class="string">&quot;;&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><p>就是能把 ; 作为分割的工具，把一个个元素分割，而且等号前面的作为 key，等号后面的作为 value<br>cookie是存在于headers中的，也可以直接放到请求里去</p><h3 id="获取登陆后页面的三种方式"><a href="#获取登陆后页面的三种方式" class="headerlink" title="获取登陆后页面的三种方式"></a>获取登陆后页面的三种方式</h3><ol><li>实例化session，使用session发送post请求，在使用session来获取登录之后的界面</li><li>headers中添加cookie键，值为cookie字符串</li><li>在请求方法中添加cookie作为参数，接受字典形式的cookie，字典形式的cookie中的键是cookie的name，值是cookie的valuek</li></ol><h3 id="寻找登陆的-post-地址"><a href="#寻找登陆的-post-地址" class="headerlink" title="寻找登陆的 post 地址"></a>寻找登陆的 post 地址</h3><ul><li>在form表单中寻找action地址<ul><li>post的数据是input标签中name的值作为变量，真正的用户名密码作为值的字典，post的url地址就是action对应的地址</li><li>如果没有action的url地址的解决方法:<ul><li>抓包,但是登陆的时候页面会跳转就看不到之前的界面的源码了<ul><li>使用错误的密码登录</li><li>在检查界面勾选上 preserve log</li></ul></li></ul></li></ul></li></ul><h3 id="requests-小技巧"><a href="#requests-小技巧" class="headerlink" title="requests 小技巧"></a>requests 小技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests.utils</span><br><span class="line">requests.utils.dict_from_cookiejar  <span class="comment"># 就是把cookie对象转化为字典</span></span><br><span class="line">requests.utils.cookiejar_from_dict  <span class="comment"># 就是把为字典转化为cookies</span></span><br><span class="line">requests.utils.unquote(未解码的url地址) <span class="comment"># 就是对url地址解码</span></span><br><span class="line">requests.utils.quote(url) <span class="comment"># 就是把url进行编码，但是不会把/编码，会对:?进行编码</span></span><br><span class="line">response = requests.get(url,timeout = <span class="number">10</span>) <span class="comment"># 设置超时，10s钟之内没有返回响应就会报错</span></span><br><span class="line">response = requests.get(<span class="string">&quot;&lt;https://www.12306.cn/mormhweb/&gt;&quot;</span>,verify = <span class="literal">False</span>) <span class="comment"># 获取证书验证 verify 就是表示是否证书验证，false就是不验证，默认为true</span></span><br><span class="line"><span class="keyword">assert</span> response.status_code == <span class="number">200</span> <span class="comment"># 断言，如果为真就继续运行，如果为假就会报错</span></span><br></pre></td></tr></table></figure><p>cookie 是存在于 response 中的，就是网页保存到我们本地的 cookie</p><p>alias:可以对指令进行重命名，但是只能在linux中使用，例如<br>alias fanyi=”Python 绝对路径/xxx.py”,就相当于在终端种输入了 python 绝对路径/xxx.py</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> request </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32-ucos使用</title>
      <link href="/Blog_ButterFly/2024/03/19/stm32-ucos%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/stm32-ucos%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h3><p>计算机只由硬件构成的叫做“裸机“，不能工作，必须有软件</p><ol><li><p>多任务</p><p> 把一个大任务分解为几个小任务，那在一个任务需要等待I/O时就可以交出CPU的使用权去运行其他的任务，可以极大的提高CPU的利用效率。</p></li><li><p>内核类型</p><ul><li><p>可剥夺型内核</p><p>  总是运行优先级别最高的任务，即使CPU正在运行某一个低优先级的任务，当高优先级的任务准备就绪时，就会剥夺低优先级的任务的CPU的使用权。</p></li><li><p>不可剥夺型内核</p><p>  总是优先级别高的任务最先获得CPU的使用权，要求每个任务都能主动放弃CPU的使用权。</p></li></ul></li><li><p>任务切换时间</p><p> 多任务系统的任务之间的切换是需要时间的。操作系统的任务调度器就是做这项工作的。调度器在进行任务切换时需要一段时间，这段时间的长短也影响系统实时性，任务调度器进行任务切换所用的时间不能受到应用程序中其他因素（任务数目等）的影响。</p></li><li><p>终端延时</p><p> 外部事件的发生会以中断申请信号的形式通知CPU，然后才运行中断服务程序来处理该事件，自CPU响应中断到CPU转向中断服务程序之间所用的时间叫做终端延时，也影响系统的实时性。</p></li></ol><h3 id="ucosii使用"><a href="#ucosii使用" class="headerlink" title="ucosii使用"></a>ucosii使用</h3><ol><li><p>用户应用程序的结构</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *pdata)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* pdata)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">OSInit(); <span class="comment">// 初始化ucosii</span></span><br><span class="line">OSTaskCreate(task1,....); <span class="comment">// 创建任务</span></span><br><span class="line">OSStart(); <span class="comment">// 启动任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用 <code>OSStart()</code>函数启动各项任务之后，任务就交给操作系统管理和调度了。</p></li><li><p>系统任务</p><ol><li><p>空闲任务</p><p> 为了使CPU在没有用户任务可执行的时候有事可做，ucosii提供了一个空闲任务的系统任务，用户可以对空闲任务进行增加操作等，并且一个用户的应用程序必须使用这个空闲任务，不能用软件删除。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OS_TaskIdle</span><span class="params">(<span class="type">void</span>* p_arg)</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CRITICAL_METHOD == 3u </span></span><br><span class="line">OS_CPU_SR  cpu_sr = <span class="number">0u</span>; <span class="comment">// 为CPU状态寄存器分配存储空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    p_arg = p_arg; <span class="comment">// 不使用会出现警告，有些编译器出现报错</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        OS_ENTER_CRITICAL();<span class="comment">// 进入临界区，关闭所有中断</span></span><br><span class="line">        OSIdleCtr++;</span><br><span class="line">        OS_EXIT_CRITICAL(); <span class="comment">// 开放中断</span></span><br><span class="line">        OSTaskIdleHook(); <span class="comment">// 调用用户的任务的HOOK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>统计任务</p><p> 系统的统计任务 <code>OSTaskStat()</code> 可以每秒计算一次CPU在单位时间内被使用的时间，并且把结果以百分比的形式存放在变量 <code>OSCPUUsage</code> 中</p><p> 用户是否使用这个统计任务，可以根据应用程序的实际需要选择，如果要使用就必须把定义在头文件 <code>OS_CFG.h</code> 中的系统配置常数 <code>OS_TASK_STAT_EN</code> 设置为1，并且在创建统计任务之前调用函数 <code>OSStatInit()</code> 对统计任务初始化。</p></li></ol></li><li><p>任务优先级别和优先权</p><p> ucosii的每个任务都必须具有一个唯一的优先级别。ucosii把任务的优先权分为64个优先级别，每一个优先级别都用一个数字表示。数字0表示任务的优先级别最高，数字越大则表示任务的优先级别越高。</p><p> 通常程序的任务数小于64。用户可以在需要的时候在文件 <code>OS_CFG.h</code> 文件中通过给表示最低优先级别的常数 <code>OS_LOWEST_PRIO</code> 赋值来定义程序中优先级别的数目。一旦被定义就意味着系统中可以使用的优先级别为 <code>0 ~ OS_LOWEST_PRIO</code> 一共OS_LOWEST_PRIO+1个，也限制了程序的任务数量。系统总是把 <code>OS_LOWEST_PRIO</code> 自动给空闲任务，把 <code>OS_LOWEST_PRIO-1</code> 给统计任务（如果使用的话）。</p></li><li><p>任务堆栈</p><ol><li><p>任务堆栈的创建</p><p> 为了方便定义任务堆栈，文件 <code>OS_CPU.h</code> 中专门定义了一个数据类型 <code>OS_STK</code> </p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> OS_STK; <span class="comment">// 类型长度为16位 2个字节</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STK_SIZE 512  <span class="comment">// 定义堆栈长度 1024 个字节</span></span></span><br><span class="line">OS_STK TaskStk[TASK_STK_SIZE]; <span class="comment">// 定义一个数组作为任务堆栈</span></span><br></pre></td></tr></table></figure><p> 创建任务函数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INT8U  <span class="title function_">OSTaskCreate</span> <span class="params">(<span class="type">void</span>   (*task)(<span class="type">void</span> *p_arg), <span class="comment">// 指向任务的指针</span></span></span><br><span class="line"><span class="params">                     <span class="type">void</span>    *p_arg, <span class="comment">// 传递给任务的参数</span></span></span><br><span class="line"><span class="params">                     OS_STK  *ptos, <span class="comment">// 任务堆栈栈顶的指针</span></span></span><br><span class="line"><span class="params">                     INT8U    prio)</span> <span class="comment">// 指定任务的优先级别参数</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>任务创建</p><p> 程序通过函数 <code>OSTaskCreate()</code> 来创建一个任务</p><p> 函数对于创建任务的优先级别进行一系列判断，确定该优先级别合法并且未被使用之后，就调用函数 <code>OSTaskStkInit</code> 和 <code>OS_TCBInit</code> 对任务堆栈和任务的控制块进行初始化，初始化成功之后，把任务计数器加一之外还要判断ucosii的核心是否处于运行状态（<code>OSRunning == 1</code>），如果正在运行，调用 <code>OSSched()</code> 进行任务调度。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">INT8U  <span class="title function_">OSTaskCreate</span> <span class="params">(<span class="type">void</span>   (*task)(<span class="type">void</span> *p_arg),</span></span><br><span class="line"><span class="params">                     <span class="type">void</span>    *p_arg,</span></span><br><span class="line"><span class="params">                     OS_STK  *ptos,</span></span><br><span class="line"><span class="params">                     INT8U    prio)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_STK     *psp;</span><br><span class="line">    INT8U       err;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CRITICAL_METHOD == 3u                 <span class="comment">/* Allocate storage for CPU status register               */</span></span></span><br><span class="line">    OS_CPU_SR   cpu_sr = <span class="number">0u</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL_IEC61508</span></span><br><span class="line">    <span class="keyword">if</span> (OSSafetyCriticalStartFlag == OS_TRUE) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span> (OS_ERR_ILLEGAL_CREATE_RUN_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (prio &gt; OS_LOWEST_PRIO) &#123;             <span class="comment">/* Make sure priority is within allowable range           */</span></span><br><span class="line">        <span class="keyword">return</span> (OS_ERR_PRIO_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OS_ENTER_CRITICAL();</span><br><span class="line">    <span class="keyword">if</span> (OSIntNesting &gt; <span class="number">0u</span>) &#123;                 <span class="comment">/* Make sure we don&#x27;t create the task from within an ISR  */</span></span><br><span class="line">        OS_EXIT_CRITICAL();</span><br><span class="line">        <span class="keyword">return</span> (OS_ERR_TASK_CREATE_ISR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (OSTCBPrioTbl[prio] == (OS_TCB *)<span class="number">0</span>) &#123; <span class="comment">/* Make sure task doesn&#x27;t already exist at this priority  */</span></span><br><span class="line">        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;<span class="comment">/* Reserve the priority to prevent others from doing ...  */</span></span><br><span class="line">                                             <span class="comment">/* ... the same thing until task is created.              */</span></span><br><span class="line">        OS_EXIT_CRITICAL();</span><br><span class="line">        psp = OSTaskStkInit(task, p_arg, ptos, <span class="number">0u</span>);             <span class="comment">/* Initialize the task&#x27;s stack         */</span></span><br><span class="line">        err = OS_TCBInit(prio, psp, (OS_STK *)<span class="number">0</span>, <span class="number">0u</span>, <span class="number">0u</span>, (<span class="type">void</span> *)<span class="number">0</span>, <span class="number">0u</span>);</span><br><span class="line">        <span class="keyword">if</span> (err == OS_ERR_NONE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (OSRunning == OS_TRUE) &#123;      <span class="comment">/* Find highest priority task if multitasking has started */</span></span><br><span class="line">                OS_Sched();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            OS_ENTER_CRITICAL();</span><br><span class="line">            OSTCBPrioTbl[prio] = (OS_TCB *)<span class="number">0</span>;<span class="comment">/* Make this priority available to others                 */</span></span><br><span class="line">            OS_EXIT_CRITICAL();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (err);</span><br><span class="line">    &#125;</span><br><span class="line">    OS_EXIT_CRITICAL();</span><br><span class="line">    <span class="keyword">return</span> (OS_ERR_PRIO_EXIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>信号量和事件标志</p><ol><li><p>信号量</p><p> 信号量是用于同步和互斥的工具。信号量的值只能是0或正整数。信号量的值表示当前可用的资源数。当进程占有一个资源时，信号量减1，当进程释放一个资源时，信号量加1。如果信号量的值已经为0，那么等待进程将会被阻塞，直到有一个进程释放了一个资源，将信号量的值加1。</p><ul><li><p>创建信号量</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS_EVENT *<span class="title function_">OSSemCreate</span><span class="params">(INT16U cnt)</span>; <span class="comment">//信号量计数器初始值</span></span><br></pre></td></tr></table></figure></li><li><p>请求信号量</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求失败进入等待状态</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">OSSemPend</span> <span class="params">(OS_EVENT  *pevent,  <span class="comment">// 信号量指针</span></span></span><br><span class="line"><span class="params">                 INT32U     timeout, <span class="comment">// 等待时间限制</span></span></span><br><span class="line"><span class="params">                 INT8U     *perr)</span> <span class="comment">// 错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求失败继续运行</span></span><br><span class="line">INT16U  <span class="title function_">OSSemAccept</span> <span class="params">(OS_EVENT *pevent)</span> <span class="comment">// 信号量指针</span></span><br></pre></td></tr></table></figure></li><li><p>发送信号量</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INT8U  <span class="title function_">OSSemPost</span> <span class="params">(OS_EVENT *pevent)</span> <span class="comment">// 信号量指针</span></span><br></pre></td></tr></table></figure></li><li><p>删除信号量</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OS_EVENT  *<span class="title function_">OSSemDel</span> <span class="params">(OS_EVENT  *pevent, <span class="comment">// 信号量指针</span></span></span><br><span class="line"><span class="params">                     INT8U      opt, <span class="comment">// 删除条件选项</span></span></span><br><span class="line"><span class="params">                     INT8U     *perr)</span> <span class="comment">// 错误信息</span></span><br><span class="line">opt:</span><br><span class="line">1. OS_DEL_NO_PEND 等待任务表中没有等待任务时删除</span><br><span class="line">2. OSDEL_ALLWAYS 无论有无等待任务都删除</span><br><span class="line">！只能在任务中删除信号量，不能在中断中删除</span><br></pre></td></tr></table></figure></li><li><p>查询状态</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INT8U  <span class="title function_">OSSemQuery</span> <span class="params">(OS_EVENT     *pevent,</span></span><br><span class="line"><span class="params">                   OS_SEM_DATA  *p_sem_data)</span> <span class="comment">// 存储信号量状态的结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> os_sem_data &#123;</span><br><span class="line">    INT16U  OSCnt;                          <span class="comment">/* Semaphore count                                         */</span></span><br><span class="line">    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE];  <span class="comment">/* List of tasks waiting for event to occur                */</span></span><br><span class="line">    OS_PRIO OSEventGrp;                     <span class="comment">/* Group corresponding to tasks waiting for event to occur */</span></span><br><span class="line">&#125; OS_SEM_DATA;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>事件标志</p><p> 事件标志是一种进程同步工具，它可以用于同步进程之间的时间。事件标志的值只能为0或1。当事件标志的值为0时，等待进程将会被阻塞。当事件标志的值为1时，等待进程将会被唤醒，继续运行。事件标志主要用于等待某一个事件的发生，例如等待一个条件成立，或者等待一个时间的到来。</p></li></ol></li><li><p>时间管理</p><p> ucosii提供了以下三种时间管理方法：</p><ol><li><p>任务延迟</p><p> 函数 <code>OSTimeDly()</code> 可以使当前执行的任务进入延迟状态，延迟的时间是以系统时钟节拍为单位的。</p></li><li><p>任务延迟直到事件标志被设置</p><p> 函数 <code>OSTimeDlyHMSM()</code> 可以使当前执行的任务进入延迟状态，延迟时间是以时、分、秒、毫秒表示的，当设定的时间到达或事件标志被设置时，任务将会恢复执行。</p></li><li><p>获取系统时钟</p><p> 函数 <code>OSTimeGet()</code> 可以获取当前系统时钟的值，该值是以时钟节拍计数的。可以用于时间戳或超时计数等。</p></li></ol></li><li><p>任务通信与同步</p><ol><li><p>队列</p><p> 队列是一种任务通信的机制，用于在多个任务之间传递数据。队列的大小是固定的，队列可以存储指定类型的数据，每个数据的大小必须相同。队列分为FIFO队列和优先级队列。</p></li><li><p>信号量和事件标志</p><p> 信号量和事件标志是用于同步和互斥的工具。信号量的值只能是0或正整数。信号量的值表示当前可用的资源数。当进程占有一个资源时，信号量减1，当进程释放一个资源时，信号量加1。如果信号量的值已经为0，那么等待进程将会被阻塞，直到有一个进程释放了一个资源，将信号量的值加1。事件标志是一种进程同步工具，它可以用于同步进程之间的时间。事件标志的值只能为0或1。当事件标志的值为0时，等待进程将会被阻塞。当事件标志的值为1时，等待进程将会被唤醒，继续运行。事件标志主要用于等待某一个事件的发生，例如等待一个条件成立，或者等待一个时间的到来。</p></li><li><p>互斥量</p><p> 互斥量是一种用于保护共享资源的机制。当一个任务获得了互斥量的所有权，其他任务将无法访问共享资源，只有当该任务释放互斥量的所有权时，其他任务才能再次访问共享资源。</p></li></ol></li><li><p>中断处理</p><p> 中断是一种异步事件，当外设发生中断时，CPU会暂停当前的任务，转而执行中断的处理程序。ucosii提供了中断服务例程（ISR）的支持，可以在ISR中使用ucosii的信号量、消息队列和事件标志等机制来完成各种任务。需要注意的是，中断服务程序应该尽量短小，以保证系统的实时性。</p></li><li><p>常见问题解决</p><ol><li><p>任务堆栈不够用</p><p> 如果任务的堆栈不够用，会导致任务运行异常，可以增加任务堆栈的大小或者减少任务中使用的局部变量的数量。</p></li><li><p>任务优先级别设置不当</p><p> 如果任务的优先级别设置不当，会导致低优先级的任务无法得到CPU的使用权，从而导致系统异常。可以通过调整任务的优先级别来解决该问题。</p></li><li><p>队列、信号量和事件标志使用不当</p><p> 如果队列、信号量和事件标志使用不当，会导致任务之间的同步和通信出现问题，可以通过检查代码来解决该问题。</p></li></ol></li><li><p>任务挂起和恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务挂起函数</span></span><br><span class="line">INT8U <span class="title function_">OSTaskSuspend</span><span class="params">(INT8U prio)</span>； <span class="comment">// prio是挂起任务的优先级别</span></span><br><span class="line"><span class="comment">// 参数为 OS_PRIO_SELF 时为挂起自身</span></span><br><span class="line"><span class="comment">// 根据具体的情况返回报错信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">OS_NO_ERR 无错误</span></span><br><span class="line"><span class="comment">OS_TASK_PEND_IDLE</span></span><br><span class="line"><span class="comment">OS_PRIO_INVALID</span></span><br><span class="line"><span class="comment">OS_TASK_SUSPEND_PRIO</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务恢复函数</span></span><br><span class="line">INT8U  <span class="title function_">OSTaskResume</span> <span class="params">(INT8U prio)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">OS_NO_ERR 无错误</span></span><br><span class="line"><span class="comment">OS_TASK_NOT_SUSPEND</span></span><br><span class="line"><span class="comment">OS_PRIO_INVALID</span></span><br><span class="line"><span class="comment">OS_TASK_RESUME_PRIO</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>任务调度器上锁和解锁</p><p>调度器上锁解锁函数 <code>OSSchedLock (void)</code>， <code>OSSchedUnlock (void)</code> 用于禁止任务调度，让cpu执行当前任务保持cpu 的控制权，解锁后可以进行调度。</p><p>实现原理很简单，对全局变量锁定嵌套计数器 <code>OSLockNesting</code> 进行操作， <code>OSLockNesting</code> 记录了上锁函数 <code>OSSchedLock (void)</code> 的调用次数， <code>OSSchedLock (void)</code> 中对变量进行加一操作， <code>OSSchedUnlock (void)</code> 对变量进行减一操作，在引起任务调度的函数中进行判断，若变量  <code>OSLockNesting</code> 的值大于0，说明任务调度上锁，进行任务调度的函数中进行判断 <code>if (OSLockNesting &gt; 0u)</code> ，后 <code>return</code> ，不进行任务调度。但要满足一个条件，调用者不是中断服务子函数。</p><p>上锁和解锁要成对使用！因为上锁以后系统就会被锁住，其他任务都不能运行，这些函数包括 <code>OSFlagPend</code> 、 <code>OSMboxPend</code> 、 <code>OSMutexPend</code> 、 <code>OSQPend</code> 、 <code>OSSemPend</code> 等。</p><p>例如在延时函数中不再进行任务调度，当前有中断函数运行或任务锁,直接返回，当前有嵌套锁定,直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (OSIntNesting &gt; <span class="number">0u</span>) &#123;   <span class="comment">/* See if trying to call from an IS */</span></span><br><span class="line">        <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (OSLockNesting &gt; <span class="number">0u</span>) &#123;  <span class="comment">/* See if called with scheduler locked */</span></span><br><span class="line"><span class="keyword">return</span>;&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32f4 </tag>
            
            <tag> ucosii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv</title>
      <link href="/Blog_ButterFly/2024/03/19/opencv/"/>
      <url>/Blog_ButterFly/2024/03/19/opencv/</url>
      
        <content type="html"><![CDATA[<h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><h3 id="图片转灰度图"><a href="#图片转灰度图" class="headerlink" title="图片转灰度图"></a>图片转灰度图</h3><p>这个操作可以在一开始读取照片时就完成，也可以自己根据每个像素点，把每个像素点的r,b,g三个参数调成一样的，也就能形成灰度图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">imread</span>(<span class="params">filename: <span class="built_in">str</span>, flags: <span class="built_in">int</span> = ...</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的flags能选择读入图片的形式：0是灰度图，1是彩色图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">1</span>]):</span><br><span class="line">        point = [i,j]</span><br><span class="line">        (b,g,r) = img[i,j]</span><br><span class="line">        b = <span class="built_in">int</span>(b)</span><br><span class="line">        g = <span class="built_in">int</span>(g)</span><br><span class="line">        r = <span class="built_in">int</span>(r)</span><br><span class="line">        <span class="comment"># gray = 255</span></span><br><span class="line">        gray = (b + g + r)/<span class="number">3</span>  <span class="comment"># 第一种灰度化方法</span></span><br><span class="line">        <span class="comment"># gray = r*0.299 + g*0.587 + b*0.114   # 第二种灰度化方法</span></span><br><span class="line">        img[i,j] = np.array([gray,gray,gray],dtype = np.uint8)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就是把每个像素点上的r,g,b改为相同的数值<br>在图片读入后，每个图片的shape数据可能含有不同的参数数量：<br>比如在彩色图中就是（height，width，3）表示高度和宽度和3个色彩通道</p><h3 id="HSV图"><a href="#HSV图" class="headerlink" title="HSV图"></a>HSV图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cvtColor(src: Mat, code: <span class="built_in">int</span>, dts: Mat = ..., dstCn: <span class="built_in">int</span> = ...)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个函数中，src是传入的图片，数据类型为int，dst是输出的图片，dstCn就是输出图片的数据类型</p><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><h3 id="高斯噪声"><a href="#高斯噪声" class="headerlink" title="高斯噪声"></a>高斯噪声</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_noise</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,img.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,img.shape[<span class="number">1</span>]):</span><br><span class="line">            s = np.random.normal(<span class="number">0</span>,<span class="number">24</span>,<span class="number">3</span>)</span><br><span class="line">            (b,g,r) = img[i,j]</span><br><span class="line">            img[i,j] = (clamp(b+s[<span class="number">0</span>]),clamp(g+s[<span class="number">1</span>]),clamp(r+s[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_noise</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,img.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,img.shape[<span class="number">1</span>]):</span><br><span class="line">            s = np.random.normal(<span class="number">0</span>,<span class="number">24</span>,<span class="number">3</span>)</span><br><span class="line">            (b,g,r) = img[i,j]</span><br><span class="line">            img[i,j] = (clamp(b+s[<span class="number">0</span>]),clamp(g+s[<span class="number">1</span>]),clamp(r+s[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实高斯噪声就是图片上的每个像素点都不同程度的发白，也就是每个像素点上的r，b，g都会不同程度的增大，增大的程度满足于正态分布</p><h3 id="椒盐噪声"><a href="#椒盐噪声" class="headerlink" title="椒盐噪声"></a>椒盐噪声</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sp_noise</span>(<span class="params">img, prog</span>):</span><br><span class="line">    ran = prog * img.shape[<span class="number">0</span>] *img.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">int</span>(ran)):</span><br><span class="line">        i = np.random.randint(<span class="number">0</span>,img.shape[<span class="number">0</span>])</span><br><span class="line">        j = np.random.randint(<span class="number">0</span>,img.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> np.random.randint(<span class="number">0</span> ,<span class="number">2</span>):</span><br><span class="line">            img[i,j] = <span class="number">255</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img[i,j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>椒盐噪声就是图片上一些随机的点随机的变为黑色或者白色，这样也使得照片看起来就像被撒上了一把椒盐<br>函数中的prog就是生成椒盐噪声的点的比率</p><h2 id="去噪"><a href="#去噪" class="headerlink" title="去噪"></a>去噪</h2><h3 id="高斯去噪"><a href="#高斯去噪" class="headerlink" title="高斯去噪"></a>高斯去噪</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GaussianBlur(src: Mat, <span class="comment"># 要处理的图片</span></span><br><span class="line">ksize,     <span class="comment"># 卷积核的大小</span></span><br><span class="line">sigmaX,</span><br><span class="line">dts: Mat )  <span class="comment"># 输出图像</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>去噪原理就是在卷积核矩阵内运用权重</p><h3 id="中值去噪"><a href="#中值去噪" class="headerlink" title="中值去噪"></a>中值去噪</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">medianBlur(src: Mat, ksize, d: Mat = ...)  <span class="comment"># kesize是中值检测的范围大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中值去噪就是在某一像素点一定范围内对所有的像素点的rgb值排序，然后取中值</p><h3 id="均值去噪"><a href="#均值去噪" class="headerlink" title="均值去噪"></a>均值去噪</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blur(src: Mat, ksize, dts: Mat = ) <span class="comment"># kesize是检测的范围大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>均值去噪就是在某一像素点一定范围内对像素点取平均值，然后赋值给该像素点的rbg值</p><h2 id="图像的轮廓提取"><a href="#图像的轮廓提取" class="headerlink" title="图像的轮廓提取"></a>图像的轮廓提取</h2><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erode(imggray,(<span class="number">3</span>,<span class="number">3</span>).dst:Mat =)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数中第一个参数是输入的图片,最后一个参数表示输出的图片，中间的(3,3)表示每个像素点膨胀的大小</p><h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dilate(src: Mat, kernel, dts: Mat)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的第一个参数为输入的图片，第二个参数kernel是腐蚀的大小，最后一个参数是输出的图片</p><h3 id="轮廓提取"><a href="#轮廓提取" class="headerlink" title="轮廓提取"></a>轮廓提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">morphologyEx(img, cv2.MORPH_GRADIENT, (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是第一种方法，第一个参数是传入的图片，第二个参数是选择模式，选择gradient就是梯度运算，也就是轮廓提取，如果选择0的话就是腐蚀，选择1就是膨胀，其他的就是原图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imggray_2=cv2.Laplacian(imggray,cv2.CV_64F)</span><br><span class="line">imggray_l=cv2.convertScaleAbs(imggray_2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是第二种方法，也是梯度运算来提取图像轮廓的</p><h2 id="图像检测"><a href="#图像检测" class="headerlink" title="图像检测"></a>图像检测</h2><h3 id="圆形检测"><a href="#圆形检测" class="headerlink" title="圆形检测"></a>圆形检测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">circles = c.HoughCircles(img,  <span class="comment"># 输入图像</span></span><br><span class="line">    c.HOUGH_GRADIENT,  <span class="comment"># 使用的检测方法</span></span><br><span class="line">    <span class="number">1</span>,  <span class="comment"># 原图与输出的分辨率之比</span></span><br><span class="line">    <span class="number">50</span>,  <span class="comment"># 圆心之间最小间距</span></span><br><span class="line">    param1=<span class="number">50</span>,  <span class="comment"># 高阈值</span></span><br><span class="line">    param2=<span class="number">40</span>,  <span class="comment"># 越大检测到的圆越完美</span></span><br><span class="line">    minRadius=<span class="number">50</span>, <span class="comment"># 最小的的圆的半径</span></span><br><span class="line">    maxRadius=<span class="number">0</span>)  <span class="comment"># 最大的半径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>圆形检测就是检测图像中的圆形，并且返回值为一个数列的数列，每个数列里包含着三个参数，前两个参数是圆形的坐标，第三个参数是圆形的半径大小</p><h3 id="直线检测"><a href="#直线检测" class="headerlink" title="直线检测"></a>直线检测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lines = c.HoughLinesP(img,</span><br><span class="line">    <span class="number">0.5</span>,     <span class="comment"># 最小尺寸步长</span></span><br><span class="line">    np.pi/<span class="number">480</span>,     <span class="comment"># 最小角度步长</span></span><br><span class="line">    <span class="number">30</span>,  <span class="comment"># 阈值，越小判定出的直线越多</span></span><br><span class="line">    minLineLength=<span class="number">100</span>,  <span class="comment"># 最小线长</span></span><br><span class="line">    maxLineGap=<span class="number">10</span>)  <span class="comment"># 非共线直线的最大距离</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直线检测就是检测直线的函数，返回值是一个数列的数列，每个数列里含有四个参数，前两个是直线的起点坐标，后两个是直线的终点坐标</p><h2 id="特征点检测"><a href="#特征点检测" class="headerlink" title="特征点检测"></a>特征点检测</h2><h3 id="harries角点检测"><a href="#harries角点检测" class="headerlink" title="harries角点检测"></a>harries角点检测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.cornerHarris(gray, <span class="comment"># 传入图像</span></span><br><span class="line"><span class="number">2</span>, <span class="comment"># 邻域大小</span></span><br><span class="line"><span class="number">3</span>,</span><br><span class="line"><span class="number">0.04</span>)</span><br><span class="line">dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">img[dst&gt;<span class="number">0.01</span>*dst.<span class="built_in">max</span>()]=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]  <span class="comment"># 将角点绘制到原图上</span></span><br><span class="line"></span><br><span class="line">void cvCornerHarris( const CvArr* image,  <span class="comment"># 输入图像</span></span><br><span class="line">CvArr* harris_responce,  <span class="comment"># Harris检测responces的图像。与输入图像等大。</span></span><br><span class="line"><span class="built_in">int</span> block_size,   <span class="comment"># 邻域大小</span></span><br><span class="line"><span class="built_in">int</span> aperture_size=<span class="number">3</span>,   <span class="comment"># 扩展 Sobel 核的大小</span></span><br><span class="line">double k=<span class="number">0.04</span> )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角点检测就是把图像中的角点给标注出来</p><h3 id="sift特征点提取"><a href="#sift特征点提取" class="headerlink" title="sift特征点提取"></a>sift特征点提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sift = cv2.SIFT_create()     <span class="comment"># 创造sift算子</span></span><br><span class="line">kp, des= sift.detectAndCompute(gray, <span class="literal">None</span>)   <span class="comment"># 从灰度图例提取特征keypoint</span></span><br><span class="line">img_2 = cv2.drawKeypoints(img,kp,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>)) <span class="comment"># 在图像中画上特征点</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;as&quot;</span>,img_2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sift特征点提取需要先定义一个sift算子，然后只能对灰度图处理，从灰度图里提取特征点的数据，最后画在原图上就可以</p><h3 id="orb特征点提取"><a href="#orb特征点提取" class="headerlink" title="orb特征点提取"></a>orb特征点提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">orb = cv2.ORB_create() <span class="comment"># 定义一个orb算子</span></span><br><span class="line">kp = orb.detect(gray, <span class="literal">None</span>)   <span class="comment"># 从灰度图中提取信息</span></span><br><span class="line">img_3 =cv2.drawKeypoints(img,kp,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)) <span class="comment"># 最后把特征点画到原图上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>orb特征点提取跟sift相似，也是需要先创建一个算子，然后再从灰度图里提取数据，最后画在原图上</p><h3 id="BFMATCH特征点匹配"><a href="#BFMATCH特征点匹配" class="headerlink" title="BFMATCH特征点匹配"></a>BFMATCH特征点匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sift = cv2.SIFT_create()</span><br><span class="line">kp_1, des_1= sift.detectAndCompute(gray_1, <span class="literal">None</span>)</span><br><span class="line">kp_2, des_2 = sift.detectAndCompute(gray_2, <span class="literal">None</span>)</span><br><span class="line">bf = cv2.BFMatcher()   <span class="comment"># 创造一个BF匹配算子</span></span><br><span class="line">matches = bf.knnMatch(des_1, des_2, k=<span class="number">2</span>)   <span class="comment"># 从两张图片上的des数据提取相似特征点的信息</span></span><br><span class="line">good = []</span><br><span class="line"><span class="keyword">for</span> m,n <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="keyword">if</span> m.distance &lt; <span class="number">0.8</span>*n.distance:</span><br><span class="line">        good.append(m)                <span class="comment"># 对提取的相似匹配特征点进行筛选，</span></span><br><span class="line">res = cv2.drawMatches(img_1, kp_1, img_2, kp_2, good, <span class="literal">None</span>, flags=<span class="number">2</span>)  <span class="comment"># 最后画出特征点</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;as&quot;</span>,res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特征点匹配就是把两张图片上的特征点分别提取出来，然后再找相似的特征点，随后筛选出比较好的，匹配度高的特征点，最后在画在图上</p><h2 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h2><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p>在每张图片上，每个像素点的数据中都包括三个参数rgb，表示这个像素点的颜色</p><h3 id="转灰度图"><a href="#转灰度图" class="headerlink" title="转灰度图"></a>转灰度图</h3><p>这个操作可以在一开始读取照片时就完成，也可以自己根据每个像素点，把每个像素点的r,b,g三个参数调成一样的，也就能形成灰度图<br>这个就是把每个像素点上的r,g,b改为相同的数值<br>在图片读入后，每个图片的shape数据可能含有不同的参数数量：<br>比如在彩色图中就是（height，width，3）表示高度和宽度和3个色彩通道</p><h3 id="HSV图特点"><a href="#HSV图特点" class="headerlink" title="HSV图特点"></a>HSV图特点</h3><p>一种颜色空间, 也称六角锥体模型 (Hexcone Model)。 这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）。</p><h3 id="高斯噪声特点"><a href="#高斯噪声特点" class="headerlink" title="高斯噪声特点"></a>高斯噪声特点</h3><p>其实高斯噪声就是图片上的每个像素点都不同程度的发白，也就是每个像素点上的r，b，g都会不同程度的增大，增大的程度满足于正态分布</p><h3 id="椒盐噪声特点"><a href="#椒盐噪声特点" class="headerlink" title="椒盐噪声特点"></a>椒盐噪声特点</h3><p>椒盐噪声就是图片上一些随机的点随机的变为黑色或者白色，这样也使得照片看起来就像被撒上了一把椒盐</p><h3 id="高斯去噪原理"><a href="#高斯去噪原理" class="headerlink" title="高斯去噪原理"></a>高斯去噪原理</h3><p>去噪原理就是在卷积核矩阵内运用一定的权重计算来获得rgb的值</p><h3 id="中值去噪原理"><a href="#中值去噪原理" class="headerlink" title="中值去噪原理"></a>中值去噪原理</h3><p>中值去噪就是在某一像素点一定范围内对所有的像素点的rgb值排序，然后取中值</p><h3 id="均值去噪原理"><a href="#均值去噪原理" class="headerlink" title="均值去噪原理"></a>均值去噪原理</h3><p>均值去噪就是在某一像素点一定范围内对像素点取平均值，然后赋值给该像素点的rbg值</p><h3 id="圆形检测原理"><a href="#圆形检测原理" class="headerlink" title="圆形检测原理"></a>圆形检测原理</h3><p>就是通过分析灰度图像来检测图像中的圆形<br>圆形检测就是检测图像中的圆形，并且返回值为一个数列的数列，每个数列里包含着三个参数，前两个参数是圆形的坐标，第三个参数是圆形的半径大小</p><h3 id="直线检测原理"><a href="#直线检测原理" class="headerlink" title="直线检测原理"></a>直线检测原理</h3><p>直线检测也是分析灰度图<br>直线检测就是检测直线的函数，返回值是一个数列的数列，每个数列里含有四个参数，前两个是直线的起点坐标，后两个是直线的终点坐标</p><h3 id="harries-角点检测"><a href="#harries-角点检测" class="headerlink" title="harries 角点检测"></a>harries 角点检测</h3><p>检测的是角点，再检测图像中，如果选取的是周围颜色一致的点，那么在这个点周围是没有特点的，而在直线上，沿着直线行进时也是看不出来的，只有在角点上，只要图框移动，都能很清楚看出来，所以要检测角点。</p><h3 id="sift-特征点提取"><a href="#sift-特征点提取" class="headerlink" title="sift 特征点提取"></a>sift 特征点提取</h3><p>是一种检测局部特征算法，该算法通过求一幅图中的特征点及其有关scale和orientation的描述子来得到特征<br>SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等</p><h3 id="orb-特征点检测"><a href="#orb-特征点检测" class="headerlink" title="orb 特征点检测"></a>orb 特征点检测</h3><p>ORB算法分为两部分，分别是特征点提取和特征点描述</p><h3 id="特征点匹配"><a href="#特征点匹配" class="headerlink" title="特征点匹配"></a>特征点匹配</h3><p>一个图像的特征点由两部分构成：关键点（Keypoint）和描述子（Descriptor）<br>关键点指的是该特征点在图像中的位置，有些还具有方向、尺度信息<br>描述子通常是一个向量，按照人为的设计的方式，描述关键点周围像素的信息，通常描述子是按照外观相似的特征应该有相似的描述子设计的<br>首先提取图像中的关键点，这部分是查找图像中具有某些特征（不同的算法有不同的）的像素，然后根据得到的关键点位置，计算特征点的描述子，最后根据特征点的描述子，进行匹配</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="编译器的结构介绍"><a href="#编译器的结构介绍" class="headerlink" title="编译器的结构介绍"></a>编译器的结构介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[高级语言]--&gt;|编译|B[汇编语言]</span><br><span class="line">A--&gt;|编译|C[机器语言]</span><br><span class="line">B--&gt;|汇编|C</span><br></pre></td></tr></table></figure><p>编译流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A(源程序)--&gt;B[预处理器]--&gt;|将存储在不同文件中的源程序聚合在一起，宏展开|C(处理后的源程序)--&gt;D[编译器]--&gt;E(汇编语言)--&gt;F[汇编器]--&gt;G(可重定位目标文件)--&gt;H[链接器&amp;加载器]--&gt;|修改可重定位目标文件，将修改后的指令和数据放入内存中|I(可执行目标文件)</span><br><span class="line">J(库文件)--&gt;H</span><br></pre></td></tr></table></figure><p>编译器结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A(字符流)--&gt;B[词法分析器]--&gt;C(词法单元流)--&gt;D[语法分析器]--&gt;E(语法树)--&gt;F[语义分析器]--&gt;G(语法树)--&gt;H[中间代码生成器&amp;机器无关代码优化器]--&gt;I(中间表示形式)--&gt;J[目标代码生成器]--&gt;K(目标机器语言)--&gt;L[机器相关代码优化器]--&gt;M(目标机器代码)</span><br></pre></td></tr></table></figure><p>其中机器无关代码优化器之前的部分都是属于前端，与源语言相关，之后的部分属于后端，与目标语言相关</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>任务：</p><p>从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型，将识别出的单词转换成统一的机内表示——词法单元(token)形式</p><p>其中token是一个二元组，&lt;种别码，属性值&gt;</p><div class="table-container"><table><thead><tr><th>单词类型</th><th>种别</th><th>种别码</th></tr></thead><tbody><tr><td>关键字</td><td>program, if…</td><td>一词一码</td></tr><tr><td>标识符</td><td>变量名，过程名</td><td>多词一码（太多了，不确定性，所以多词一码）</td></tr><tr><td>常量</td><td>整形</td><td>一型一码</td></tr><tr><td>运算符</td><td>算数，关系，逻辑</td><td>一词一码或者一型一码</td></tr><tr><td>界限符</td><td>; = {} ()</td><td>一词一码</td></tr></tbody></table></div><p>可以检测的错误的类型：</p><ol><li>单词拼写错误</li><li>非法字符</li></ol><p>词法错误检测：</p><p>如果当前状态与当前输入符号在转换表中对应的信息为空，则报错，调用错误处理程序</p><p>错误处理：</p><p>查找已扫描字符串中最后一个对应于某终态的字符：</p><ul><li>如果找到了，将该字符与其前面的字符识别成一个单词，然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词</li><li>没找到，确定出错，采用错误恢复策略</li></ul><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>任务：</p><p>从词法分析器输出的token序列中，识别出各类短语，并构造语法分析树</p><ul><li>对于赋值语句 <code>d=a+b*c;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A((a))</span><br><span class="line">B((b))</span><br><span class="line">C((c))</span><br><span class="line">D((d))</span><br><span class="line">add((+))</span><br><span class="line">mul((*))</span><br><span class="line">equ((=))</span><br><span class="line">en((;))</span><br><span class="line">Define--&gt;equ</span><br><span class="line">Define--&gt;en</span><br><span class="line">equ--&gt;D</span><br><span class="line">equ--&gt;add</span><br><span class="line">add--&gt;A</span><br><span class="line">add--&gt;mul</span><br><span class="line">mul--&gt;B</span><br><span class="line">mul--&gt;C</span><br></pre></td></tr></table></figure><ul><li>对于声明语句 <code>int a, b, c;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">INT((int))</span><br><span class="line">A((a))</span><br><span class="line">B((b))</span><br><span class="line">C((c))</span><br><span class="line">d1((,))</span><br><span class="line">d2((,))</span><br><span class="line">en((;))</span><br><span class="line">Define--&gt;INT</span><br><span class="line">Define--&gt;d1</span><br><span class="line">Define--&gt;en</span><br><span class="line">d1--&gt;A</span><br><span class="line">d1--&gt;d2</span><br><span class="line">d2--&gt;B</span><br><span class="line">d2--&gt;C</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>高级程序语言中的语句分为两类</p><ul><li><p>声明语句</p><p>  任务：</p><p>  收集标识符的属性信息</p><ol><li>种属——简单变量，复合变量，过程。。。</li><li>类型——整形，字符。。。。</li><li>存储位置和长度</li><li>值</li><li>作用域</li><li><p>对于过程还有参数和返回值信息</p><p>标识符存放在符号表中，通常还有一个字符串表，用于存放标识符和字符常数。在符号表中的name字段分成两个部分，第一个部分是在字符串表中的起始位置，另一个部分是标识符的长度</p></li></ol></li><li><p>执行语句</p><p>  任务：</p><p>  语义检查</p><p>  常见的语义错误</p><ul><li>变量或过程未经声明就使用</li><li>变量或过程名重复声明</li><li>运算分量类型不匹配 （可以进行自动类型转换）</li><li>操作符与操作数之间类型不匹配<ul><li>数组下标不是整数</li><li>对于非数组使用数组访问形式</li><li>对于非过程名使用过程调用操作符</li><li>过程调用得到参数类型或数目不匹配</li><li>函数返回类型有误</li></ul></li></ul></li></ul><h3 id="中间代码生成和编译器后端"><a href="#中间代码生成和编译器后端" class="headerlink" title="中间代码生成和编译器后端"></a>中间代码生成和编译器后端</h3><ul><li><p>中间代码生成</p><p>  源程序的中间表示可以有多种形式</p><ul><li><p>三地址码</p><p>  三地址指令码由类似于汇编语言的指令序列组成，每个指令<strong>最多</strong>有三个操作数</p><p>  其中的地址可以有三种形式</p><ul><li>源程序中的名字</li><li>常量</li><li><p>编译器生成的临时变量</p><p>将指令表示成数据结构有三种形式</p></li><li><p>四元式 (运算符, 源操作数1, 源操作数2, 目的操作数)</p></li><li>三元式</li><li>间接三元式</li></ul></li><li>语法结构树/语法树</li></ul></li><li><p>目标代码生成器</p><p>  以源程序的中间表示形式作为输入，并且把它映射到目标语言</p><p>  任务：</p><p>  为程序中使用的变量合理分配寄存器</p></li><li><p>代码优化</p><p>  为改进代码所使用的等价程序变换，使其运行得更快，占用空间更小</p><ul><li>机器无关代码优化</li><li>机器相关代码优化</li></ul></li></ul><h2 id="语言及其文法"><a href="#语言及其文法" class="headerlink" title="语言及其文法"></a>语言及其文法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>字母表$\Sigma$</p><p>  是一个有穷符号集合 （ASCII，UNICODE）</p><p>  其中包括：字母，数字，标点符号…</p><p>  运算：</p><ul><li>乘积 $\Sigma_1\Sigma_2={ab\ |a\in\Sigma_1,b\in\Sigma_2}$</li><li>幂运算 $\left\{\begin{aligned}\Sigma^0&amp;={\varepsilon}\\\Sigma^n&amp;=\Sigma^{n-1}\Sigma&amp;&amp;n\geq1\end{aligned}\right.$为长度为n的符号串构成的集合</li><li>正闭包 $\Sigma^+=\Sigma \bigcup \Sigma^2 \bigcup \Sigma^3…$ 正整数次幂的并集</li><li>克林闭包 $\Sigma^*=\Sigma^0 \bigcup \Sigma^+$ 任意符号串构成的集合，并且符号串长度可以为0</li></ul></li><li><p>串</p><p>  对于一个字母表，字母表的克林闭包的每个元素都是字母表上的一个串，串是字母表中符号的一个有穷序列，串s的长度记作 |s| ，是指串中符号的个数。长度为0的串为空串，记为 $\varepsilon$</p><p>  运算：</p><ul><li>连接 $x连接y=xy$， $x\varepsilon = \varepsilon x = x$</li><li>幂运算 $\left\{\begin{aligned}s^0&amp;={\varepsilon}\\s^n&amp;=s^{n-1}s&amp;&amp;n\geq1\end{aligned}\right.$</li></ul></li></ul><h3 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h3><p>$G=(V_T,V_N, P, S)$</p><ul><li><p>$V_T$ 终结符集合</p><p>  是文法所定义的语言的基本符号，有时也称为 token</p></li><li><p>$V_N$ 非终结符集合</p><p>  用来表示语法成分的符号，也称为语法变量</p><p>  $V_T \cap V_N = \Phi$</p><p>  $V_T \cup V_N = 文法符号集$</p></li><li><p>$P$ 产生式集合</p><p>  描述了将终结符和非终结符组合成串的方法</p><p>  产生式一般形式： $\alpha → \beta$ 读作 $\alpha$ 定义为 $\beta$</p><ul><li>$\alpha\in(V_T\cup V_N) ^+$ 并且其中至少包含一个 $V_N$ 中的元素，称为产生式的头或者左部</li><li>$\beta\in(V_T\cup V_N) ^*$ 常委产生式的体或者右部</li><li>简写 $\alpha→\beta_1,\alpha→\beta_2 ⇒ \alpha→\beta_1|\beta_2$</li></ul></li><li><p>$S$ 开始符号</p><p>  $S \in V_N$ 表示该文法中的最大的语法成分</p></li></ul><h3 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h3><ul><li><p>推导</p><p>  给定文法 $G=(V_T, V_N, P, S)$ 如果 $\alpha → \beta \in P$ 那么可以将符号串 $\gamma \alpha \delta$ 中的 $\alpha$ 替换成 $\beta$，记作  $\gamma \alpha \delta \Rightarrow \gamma \beta \delta$。  $\gamma \alpha \delta$ 直接推导出 $\gamma \beta \delta$，就是用产生式的右部替换左部</p><p>  $\alpha \Rightarrow^n \alpha_n$称作n步推导</p><ul><li>$\Rightarrow^+$ 正数步推导出</li><li>$\Rightarrow^*$ 若干步推导出</li></ul></li><li><p>归约</p><p>  利用产生式的右部替换成左部</p></li><li><p>句型</p><p>  如果 $S \Rightarrow^<em> \alpha，\alpha \in (V_T\cup V_N)^</em>$ 则称 $\alpha$ 是 $G$ 的一个句型。</p><p>  句型既可以包含终结符，也可以包含非终结符，也可能是空串</p></li><li><p>句子</p><p>  如果 $S \Rightarrow^* w, w \in V_T$ 则称 $w$ 是 $G$ 的一个句子。</p><p>  是不包含非终结符的句型</p></li><li><p>语言</p><p>  由文法 $G$ 的开始符号 $S$ 推导出的所有句子构成的集合称为文法 $G$ 的生成语言，记作 $L(G)$</p><p>  $L(G)={w|S\Rightarrow^<em>w, w\in V_T^</em>}$</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701258014934.png" alt="1701258014934.png"></p></li></ul><h3 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h3><ul><li><p>chomsky 文法分类体系</p><ul><li><p>0型</p><p>  无限制文法，要求产生式的左部至少包含一个非终结符</p></li><li><p>1型</p><p>  上下文有关文法，要求产生式左部的长度不能大于产生式右部的长度</p></li><li><p>2型 CFG</p><p>  上下文无关文法，产生式左部必须是一个非终结符</p></li><li><p>3型</p><p>  正则文法</p><ol><li>右线性文法，产生式右部，要么是一个终结符号串，要么是在终结符号串右侧加一个非终结符号</li><li><p>左线性文法，产生式右部，要么是一个终结符号串，要么是在终结符号串左侧加一个非终结符号</p><p>最多只能有一个非终结符，而且位于一侧</p></li></ol></li></ul></li></ul><pre><code>四级文法逐级限制， $0 \supset 1 \supset 2 \supset 3$</code></pre><h3 id="CFG的分析树"><a href="#CFG的分析树" class="headerlink" title="CFG的分析树"></a>CFG的分析树</h3><p>定义</p><ul><li>根节点的标号为文法开始符号</li><li>内部节点表示对一个产生式的应用，该节点的标号是此产生式的左部A，该节点的子节点的标号从左到右构成了产生式的右部</li><li>叶节点的标号既可以是非终结符号，也可以是终结符，从左到右排到叶节点得到的符号串称为是这棵树的产出或边缘</li><li>分析树中每一棵子树的边缘被称为该句型的一个短语，如果子树只有父子两代节点，那么这棵子树的边缘被称为该句型的一个直接短语，即高度为2的子树。直接短语一定是给定句型的产生式的右部，反之不成立</li></ul><p>二义性文法</p><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>代数定律</p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701259994334.png" alt="1701259994334.png"></p><h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p>给一些正则表达式命名，并且在之后的正则表达式中像使用字母表中的符号一样使用这些名字</p><h3 id="有穷自动机FA"><a href="#有穷自动机FA" class="headerlink" title="有穷自动机FA"></a>有穷自动机FA</h3><p>对具有一系列离散的输入输出信息和有穷数目的内部状态（概括了对过去输入信息处理的状况）的一类处理系统建立的数学模型。系统只需要根据当前所处的状态和当前所面临的输入信息就可以决定系统的后继行为。每当系统处理了当前的输入之后，系统的内部状态也将发生改变</p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701260586073.png" alt="1701260586073.png"></p><ul><li>输入带：用于存放输入符号串</li><li>读头：从左向右逐个读取输入符号，不能修改，只读，不能往返移动</li><li>有穷控制器：具有有穷个状态数，根据当前的状态和当前输入符号控制进入下一个状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">start--&gt;0((0))--&gt;|a|1((1))--&gt;|b|2((2))--&gt;|b|3(((3)))</span><br><span class="line">0--&gt;|a|0</span><br><span class="line">0--&gt;|b|0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>FA定义接收</strong></p><p>给定输入串x，如果存在一个对应于串x的从初始状态到某个终止状态的转换序列，则称串x被该FA接收。</p><p><strong>最长子串匹配原则</strong></p><ul><li>当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配</li><li>在到达某个状态之后，只要输入带上还有符号，FA就继续前进，以便寻找尽可能长的匹配</li></ul><h3 id="有穷自动机分类"><a href="#有穷自动机分类" class="headerlink" title="有穷自动机分类"></a>有穷自动机分类</h3><p>正则文法 $\Leftrightarrow$ 正则表达式 $\Leftrightarrow$ FA</p><ul><li><p>确定的有穷自动机 DFA</p><p>  $M=(S,\Sigma,\delta,s^0,F)$ </p><ul><li>S 有穷状态集</li><li>$\Sigma$ 输入字母表，即输入符号集合</li><li>$\delta$ 将 $S<em>\Sigma$ 映射到S的转换函数。 $\forall s \in S, a\in \Sigma, \delta(s, a)$ 表示从状态s出发，沿着标记为a的边所能够到达的<em>*状态</em></em></li><li>$s_0$ 开始状态， $s_0\in S$</li><li>F 接收状态集合， $F\subseteq S$</li></ul></li><li><p>非确定的有穷自动机 NFA</p><p>  $M=(S,\Sigma,\delta,s^0,F)$ </p><ul><li>S 有穷状态集</li><li>$\Sigma$ 输入字母表，即输入符号集合</li><li>$\delta$ 将 $S<em>\Sigma$ 映射到 $2^S$ 的转换函数。 $\forall s \in S, a\in \Sigma, \delta(s, a)$ 表示从状态s出发，沿着标记为a的边所能够到达的<em>*状态集合</em></em></li><li>$s_0$ 开始状态， $s_0\in S$</li><li>F 接收状态集合， $F\subseteq S$</li></ul></li><li><p>带有 $\varepsilon -边$ 的NFA</p><p>  $M=(S,\Sigma,\delta,s^0,F)$ </p><ul><li>S 有穷状态集</li><li>$\Sigma$ 输入字母表，即输入符号集合</li><li>$\delta$ 将 $S<em>(\Sigma \cup \{\varepsilon\})$ 映射到 $2^S$ 的转换函数。 $\forall s \in S, a\in (\Sigma \cup \{\varepsilon\}), \delta(s, a)$ 表示从状态s出发，沿着标记为a的边所能够到达的<em>*状态集合</em></em></li><li>$s_0$ 开始状态， $s_0\in S$</li><li>F 接收状态集合， $F\subseteq S$</li><li>空边表示不需要任何输入就可以进行状态转变0</li></ul></li><li><p>子集构造法</p><p>  输入： NFA</p><p>  输出： 接收同样语言的DFA</p></li></ul><h2 id="语法分析-1"><a href="#语法分析-1" class="headerlink" title="语法分析"></a>语法分析</h2><h3 id="自顶向下的语法分析"><a href="#自顶向下的语法分析" class="headerlink" title="自顶向下的语法分析"></a>自顶向下的语法分析</h3><p>是从分析树的顶部向分析树的底部方向构造分析树，可以看成是从文法开始符号S推导出词串的过程</p><p>每一步推导中，都需要做两个选择</p><ul><li>替换当前句型中的哪个非终结符</li><li>用该非终结的哪个候选式进行替换</li></ul><p><strong>最左推导</strong></p><p>总是选择每个句型的最左非终结符进行替换</p><p>根据下一个终结符选择最左非终结符的一个候选式</p><p><strong>最右归约</strong></p><p>是最左推导的逆向式</p><p><strong>最右推导——规范推导</strong></p><p>总是选择每个句型的最右非终结符进行替换</p><p><strong>最左归约——规范归约</strong></p><p>是最右推导的逆向式</p><p><strong>最左推导和最右推导是唯一的</strong></p><p><strong>递归下降分析</strong></p><p>由一组过程组成，每个过程对应一个非终结符</p><p>从文法开始符号S对应的过程开始，其中递归调用文法中其他的非终结符对应的过程。如果S对应的过程体恰好扫描了整个输入串，则完成语法分析。否则可以回溯来重新扫描</p><p><strong>预测分析</strong></p><p>是递归下降分析的一个特例，在输入中向前看固定个数的符号来选择正确的产生式</p><p>预测n步的LL(n)  文法</p><h3 id="文法转换"><a href="#文法转换" class="headerlink" title="文法转换"></a>文法转换</h3><p>当同一个非终结符的多个候选式存在共同前缀时，将导致回溯现象</p><p><strong>左递归</strong></p><ul><li>直接左递归——直接左递归经过一次推导就可以看出文法存在左递归 $A→A\alpha$</li><li>间接左递归——间接左递归侧需多次推导才可以看出文法存在左递归 $A→beta→A\alpha$</li></ul><p>左递归文法会使递归下降分析器陷入无限循环，需要消除，可以把左递归转换成右递归</p><p>栗子：</p><p>$A→A(\alpha|\beta)$ ⇒ $A→(\beta|\alpha) A’\ A’→(\alpha|\beta)A’|\varepsilon$</p><p><strong>消除左递归算法</strong></p><ul><li>输入：不含循环推导和空产生式的文法G</li><li>输出：等价的无左递归文法</li><li><p>方法</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701312730264.png" alt="1701312730264.png"></p></li></ul><p><strong>提取左公因子</strong></p><p>将推导式中最左侧公共部分提取出来</p><p>栗子：</p><p>$S→aAd|aBe\\A→c\\B→b$</p><p>$S→aS’\\S’→Ad|Be\\A→c\\B→b$</p><p>实际上是改写产生式来推迟决定，等读入足够多的输入，获得足够的信息再做出正确的选择</p><h3 id="预测分析的文法"><a href="#预测分析的文法" class="headerlink" title="预测分析的文法"></a>预测分析的文法</h3><p><strong>预测分析法的工作过程</strong></p><p>从文法开始符号出发，在每一步推导中根据当前句型的最左非终结符A和当前输入符号a，选择正确的A-产生式，为保证分析的确定性，选出的候选式必须是唯一的</p><p><strong>S_文法——简单的确定性文法</strong></p><ul><li>每个产生式的右部都以终结符开始</li><li>同一非终结符的各个候选式的首终结符的都不同</li><li>不包含空产生式</li><li>根据当前输入符号最多选取一个候选式，不产生冲突</li></ul><p><strong>非终结符的后继符号集</strong></p><p>可能在某个句型中紧跟在 A 后边的终结符的集合，记作 $FOLLOW(A)$， $FOLLOW(A)={a| S\Rightarrow^<em>\alpha A a \beta, a \in V_T, \alpha, \beta \in (V_T \cup V_N)^</em>}$</p><p>如果 A 是某个句型的最右符号，则将结束符 ”$” 添加到 $FOLLOW(A)$ 中</p><p><strong>产生式的可选集</strong></p><ul><li>产生式 $A→\beta$ 的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记作 $SELECT(A→B)$</li><li>如果 $\varepsilon \in FIRST(\alpha)$，那么 $SELECT(A→\alpha)=(FIRST(\alpha)-\{\varepsilon\})\cup FOLLOW(\alpha)$</li><li>如果 $\varepsilon \notin FIRST(\alpha)$，那么 $SELECT(A→\alpha)=FIRST(\alpha)$</li></ul><p><strong>q_文法</strong></p><ul><li>每个产生式的右部或为 $\varepsilon$，或以终结符开始</li><li>具有相同左部的产生式右不相交的可选集</li><li>不含右部为非终结符开头的产生</li></ul><p><strong>串首终结符集</strong></p><ul><li>串首终结符：串首的第一个符号并且是终结符</li><li>给定一个文法符号串 $\alpha$，α的串首终结符 FIRST(α) 被定义为可以从 α 推导出的所有串首终结符构成的集合。如果 $\alpha ⇒^* \varepsilon$，那么 $\varepsilon$ 也存在 FIRST(α) 中</li><li>对于 $\forall \alpha \in (V_T\cup V_N)^+, FIRST(\alpha) = \{a|\alpha⇒^<em>a \beta, a \in V_T, \beta \in (V_T \cup V_N)^</em>\}$</li><li>如果 $\alpha⇒^*\varepsilon$ 则 $\varepsilon \in FIRST(\alpha)$</li></ul><p><strong>LL(1)文法</strong></p><p>文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式 $A→\alpha|\beta$ 满足以下条件</p><ul><li>如果 α 和 β 均不能推导出 ε，则 $FIRST(\alpha)\cap FIRST(\beta)=\Phi$</li><li>α 和 β 至多有一个能推导出 ε</li><li>如果 $\beta⇒^*\varepsilon$，则 $FIRST(\alpha)\cap FOLLOW(A)=\Phi$</li><li>如果 $\alpha⇒^*\varepsilon$，则 $FIRST(\beta)\cap FOLLOW(A)=\Phi$</li><li>同一非终结符的各个产生式的可选集互不相交</li></ul><h3 id="FIRST集与FOLLOW集的计算"><a href="#FIRST集与FOLLOW集的计算" class="headerlink" title="FIRST集与FOLLOW集的计算"></a>FIRST集与FOLLOW集的计算</h3><p><strong>FIRST集的计算</strong></p><p>不断应用下列规则，直到没有新的终结符或者空串可以被加入到任何FIRST集合中为止</p><ul><li>如果X是一个终结符，那么FIRST(X)={X}</li><li>如果X是一个非终结符，且 $X→Y_1…Y_k \in P (k\geq 1)$，那么如果对于某个i，a在 $FIRST(Y_i)$ 中且空串在所有的 $FIRST(Y_1),,,,FIRST(Y_{i-1})$ 中（即 $Y_1….y_{i-1}⇒^*\varepsilon$），就把a加入到 FIRST(X) 中。如果对于所有的 j=1, 2…..,k, ε 在 $FIRST(Y_j)$ 中，那么将空串加入到 FIRST(X)</li><li>如果 $X→\varepsilon \in P$，那么将空串加入到 FIRST(X)中</li></ul><p><strong>计算串 $X_1, X_2….X_n$ 的FIRST集合</strong></p><ul><li>将 $FIRST(X_1, X_2…X_n)$加入 $FIRST(X_i)$中所有的非空串符号</li><li>如果非空串在 $FIRST(X_1)$中，再加入 $FIRST(X_2)$中的所有非 ε 符号，如果ε在 $FIRST(X_1)$ 和 $FIRST(X_2)$ 中，再加入 $FIRST(X_3)$ 中的所有非 ε 符号，以此类推</li><li>最后，如果对于所有的 i，ε都再 $FIRST(X_i)$ 中，那么将 ε 加入到 $FIRST(X_1. X_2…X_n)$ 中</li></ul><p><strong>FOLLOW集的计算</strong></p><p>不断应用下列规则，直到没有新的终结符或者空串可以被加入到任何FOLLOW集合中为止</p><ul><li>将 “$” 放入FOLLOW(S) 中，其中S是开始符号，$ 是输入右端的结束标记</li><li>如果存在一个产生式 A→αBβ，那么FIRST(β)中除了ε之外的所有符号都在FOLLOW(B)中</li><li>如果存在一个产生式 A→αB，或存在产生式 A→αBβ且FIRST(β)包含ε，那么FOLLOW(A)中的所有符号都在FOLLOW(B)中</li></ul><p>FIRST与FOLLOW集都计算出来之后就可以计算出SELECT集</p><h3 id="LL-1-文法的分析方法"><a href="#LL-1-文法的分析方法" class="headerlink" title="LL(1)文法的分析方法"></a>LL(1)文法的分析方法</h3><ul><li><p>递归分析方法</p><p>  在递归下降分析中，编写每一个非终结符对应的过程，根据预测分析表进行产生式的选择</p></li><li><p>非递归的预测分析法</p><p>  不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机，也叫表驱动的预测分析</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701333853447.png" alt="1701333853447.png"></p><p>  下推自动机与有穷自动机相比多了一个栈，也叫下推存储器，有了记忆的功能，比有穷自动机识别能力更强</p><p>  <strong>表驱动的预测分析法</strong></p><ul><li>输入：一个串w和文法G的分析表</li><li>输出：如果w在L(G)中，输出w的最左推导，否则给出错误指示</li><li><p>方法：最初，语法分析器的格局如下：输入缓冲区中是w$，G的开始符号位于栈顶，其下面是$。下面的程序使用预测分析表M生成了处理这个输入的预测分析过程</p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701334398917.png" alt="1701334398917.png"></p></li></ul></li></ul><p>对比</p><div class="table-container"><table><thead><tr><th></th><th>递归的预测分析</th><th>非递归的预测分析法</th></tr></thead><tbody><tr><td>程序规模</td><td>程序规模大，不需要载入分析表</td><td>主控程序规模小，须载入分析表</td></tr><tr><td>直观性</td><td>较好</td><td>较差</td></tr><tr><td>效率</td><td>较低</td><td>分析时间大约正比于待分析程序的长度</td></tr><tr><td>自动生成</td><td>较难</td><td>较容易</td></tr></tbody></table></div><p><strong>预测分析法实现步骤</strong></p><ol><li>改造文法</li><li>改造文法：消除二义性，消除左递归，消除回溯</li><li>求每个变量的 FIRST 集和 FOLLOW 集，从而求得每个候选式的 SELECT 集</li><li>检查是不是 LL(1) 文法。若是，构造预测分析表</li><li>对于递归的预测分析，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现表驱动的预测分析算法</li></ol><h3 id="预测分析中的错误检测"><a href="#预测分析中的错误检测" class="headerlink" title="预测分析中的错误检测"></a>预测分析中的错误检测</h3><p><strong>下面两种情况下可以检测到错误</strong></p><ul><li>栈顶的终结符和当前输入符号不匹配</li><li>栈顶非终结符号与当前输入符号在预测分析表对应项中的信息为空</li></ul><p><strong>预测分析中的错误恢复</strong></p><ul><li><p>恐慌模式：</p><ul><li><p>忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元集合中的某个词法单元</p><p>  效果依赖于同步集合的选取，集合的选取应该使得语法分析器能从实际遇到的错误中快速恢复</p></li><li><p>如果终结符在栈顶而不能匹配，一个简单的办法就是弹出此终结符</p></li></ul></li></ul><p>分析表的使用方法：（A表示栈顶的非终结符，a表示当前输入的符号，M表示预测分析表）</p><ul><li>分析表中synch表示根据响应非终结符的FOLLOW集得到的同步词法单元</li><li>如果 M[A, a] 是空的，表示检测到错误，根据恐慌模式，忽略输入符号a</li><li>如果 M[A, a] 是synch，则弹出栈顶的非终结符A，试图继续分析后面的语法成分</li><li>如果栈顶的终结符和输入符号不匹配，则弹出栈顶的终结符</li></ul><h3 id="自底向上的语法分析"><a href="#自底向上的语法分析" class="headerlink" title="自底向上的语法分析"></a>自底向上的语法分析</h3><ul><li>从分析树的底部向顶部方向构造分析树</li><li>可以看成是将输入串w归约为文法开始符号S的过程</li><li>语法分析采用最左归约方式</li><li><p>通用框架是：<strong>移入-归约分析</strong></p><p>  就是将输入符号串从左向右不断移入栈中，并且判断栈顶的符号串是否能规约成某个文法的左部，如果可以将其推出然后压入对应的文法的左部。语法分析器不断地重复这个过程直到它检测到一个语法错误，或者栈中包含了开始符号且输入缓冲区为空为止，完成了语法分析</p><ol><li>移入：将下一个输入符号移到栈的顶端</li><li>归约：被归约的符号串的右端必然处于栈顶。语法分析器在栈中确定这个串的左端，并决定用哪个非终结符来替换这个串</li><li>接收：宣布语法分析过程成功完成</li><li>报错：发现一个语法错误，并调用错误恢复子例程</li></ol></li></ul><h3 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h3><p>是最大的，可以构造出相应移入-归约语法分析器的文法类</p><ul><li>L：对输入进行从左到右扫描</li><li>R：反向构造出一个最右推导序列</li></ul><p>LR(k) 需要向前查看k个输入符号的LR分析，对于k=0和k=1这两种情况有实践意义</p><p><strong>基本原理</strong></p><ul><li>自顶向下分析的关键问题：如何正确的识别句柄</li><li>句柄是逐步形成的，用”状态”表示句柄识别的进展程度</li></ul><pre><code>| S→bBB  |          || ------ | -------- || S→·bBB | 移进状态 || S→b·BB | 待约状态 || S→bB·B | 待约状态 || S→bBB· | 归约状态 |S→bBBS→·bBB 移进状态</code></pre><p><strong>总体结构</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701341700518.png" alt="1701341700518.png"></p><p><strong>算法</strong></p><ul><li>输入：串w和LR语法分析表，该表描述了文法G的ACTION函数和GOTO函数<ul><li>ACTION函数参数：状态编号和输入符号，函数值对应语法分析动作</li><li>GOTO函数参数：状态编号和非终结符，函数值对应后继状态</li></ul></li><li>输出：如果w在L(G)中，则输出w的自底向上语法分析过程中的归约步骤，否则给出一个错误指示</li><li><p>方法：初始时，语法分析器栈中内容为初始状态 $s_0$，输入缓冲区中的内容为 w$。然后，语法分析器执行下面的程序</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701411816817.png" alt="1701411816817.png"></p></li></ul><h3 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0) 分析"></a>LR(0) 分析</h3><p><strong>LR(0)项目</strong></p><p>右部某位置标有圆点得到产生式称为相应文法的一个LR(0)项目，一般形式为： $A→\alpha_1·\alpha_2$</p><p>对于 $A→\varepsilon$ 只能是 $A→·$</p><p><strong>增广文法</strong></p><p>如果G是一个以S为开始符号的文法，则G的增广文法G’就是在G中加上新开始符号S’和产生式S’→S而得到的文法</p><p>目的是使文法开始符号仅出现在一个产生式的左边，使分析器只有一个可接收状态</p><p>把所有等价的项目组成一个项目集(I)，称为项目集闭包，每个项目集闭包对应着一个自动机的一个状态</p><p><strong>分析表构造</strong></p><p>需要构造函数</p><ul><li><p>CLOSURE函数</p><p>  计算给定项目集I的闭包</p><p>  $CLOSURE(I)=I\cup \{B→·\gamma |A→\alpha · B\beta\in CLOSURE(I), B→\gamma \in P\}$</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701414375782.png" alt="1701414375782.png"></p><p>  如果两个项目集除了展望符之外都相同，就说这两个项目集是同心的</p></li><li><p>GOTO函数</p><p>  返回项目集I对应于文法符号X的后继项目集闭包</p><p>  $GOTO(I,X)=CLOSURE(\{A→\alpha X·\beta|A→\alpha·X\beta \in I\})$</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701414504231.png" alt="1701414504231.png"></p></li></ul><p>构造LR(0)项集族——状态集</p><p>$C=\{I_0\}\cap \{I| \exist J \in C, X\in V_N\cup V_T, I=GOTO(J, X)\}$</p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701414693483.png" alt="1701414693483.png"></p><p>分析表构造算法</p><p>$M=(C, V_N\cup V_T,GOTO,I_0,F)$</p><p>初始状态： $I_0=CLOSURE(\{S’→·S\})$</p><p>终止状态集合： $F=\{CLOSURE(\{S’→S·\})$</p><ul><li>构造 G’ 的规范LR(0)项集族 $C=\{I_0, I_1….I_n\}$</li><li>令 $I_i$ 对应状态i。状态i的语法分析动作按照下面的方法决定<ul><li>$if\ A→\alpha·a\beta\in I_i \ and\  GOTO(I_i,a)=I_j\ then\ ACTION[i, a]=sj$</li><li>$if\ A→\alpha·B\beta\in I_i \ and\ GOTO(I_i,B)=I_j\ then\ GOTO[i, B]=j$</li><li>$if\ A→\alpha·\in I_i \ and\ A\not= S’\ then\ for\ \forall a\in V_T\cup \{$\}\ do\ ACTION[i,a]=rj$  (j是A→α的编号)</li><li>$if\ S’→S·\in I_i\ then\ ACTION[i,$]=acc$</li></ul></li><li>没有定义的所有条目都设置为 “error”</li></ul><p>分析过程中的冲突</p><ul><li>移进/归约冲突，也就是对于同一个输入符号，有了两种处理方式</li><li>归约/归约冲突，对于同一个需要归约的符号，有两种归约方式</li></ul><p>如果LR(0)分析表中没有语法分析动作冲突，那么给定文法就是 LR(0) 文法。不是所有的CFG都能进行LR(0)方法进行分析，CFG不总是 LR(0) 文法。</p><h3 id="SLR分析法"><a href="#SLR分析法" class="headerlink" title="SLR分析法"></a>SLR分析法</h3><p><strong>基本思想</strong></p><p>对于已知项目集I：</p><p>$m个移进项目\left\{\begin{aligned}&amp;A_1→\alpha_1 ·a_1\beta_1\\&amp;A_2→\alpha_2 · a_2 \beta_2\\&amp;…\\&amp;A_m→\alpha_m · a_m\beta_m\end{aligned}\right.$ $n个归约项目\left\{\begin{aligned}&amp;B_1→\gamma_1·\\&amp;B_2→\gamma_2 ·\\&amp;…\\&amp;B_n→\gamma_n ·\end{aligned}\right.$</p><p>如果集合 $\{a_1,a_2,…,a_m\}$ 和 $FOLLOW(B_1)$， $FOLLOW(B_2)$，… $FOLLOW(B_n)$两两不相交，仅通过FOLLOW集就可以化解冲突，则项目集I中的冲突可以按以下原则解决：</p><p>设a是下一个输入符号</p><ul><li>若 $a\in \{a_1, a_2,…a_m\}$，则移进a</li><li>若 $a\in FOLLOW(B_i)$，则用产生式 $B_i→\gamma_i$ 归约</li><li>此外报错</li></ul><p><strong>分析表构造算法</strong></p><p>$M=(C, V_N\cup V_T,GOTO,I_0,F)$</p><p>初始状态： $I_0=CLOSURE(\{S’→·S\})$</p><p>终止状态集合： $F=\{CLOSURE(\{S’→S·\})$</p><ul><li>构造 G’ 的规范LR(0)项集族 $C=\{I_0, I_1….I_n\}$</li><li>令 $I_i$ 对应状态i。状态i的语法分析动作按照下面的方法决定<ul><li>$if\ A→\alpha·a\beta\in I_i \ and\  GOTO(I_i,a)=I_j\ then\ ACTION[i, a]=sj$</li><li>$if\ A→\alpha·B\beta\in I_i \ and\ GOTO(I_i,B)=I_j\ then\ GOTO[i, B]=j$</li><li>$if\ A→\alpha·\in I_i \ and\ A\not= S’\ then\ for\ \forall a\in FOLLOW(A)\ do\ ACTION[i,a]=rj$  (j是A→α的编号)</li><li>$if\ S’→S·\in I_i\ then\ ACTION[i,$]=acc$</li></ul></li><li>没有定义的所有条目都设置为 “error”</li></ul><p><strong>存在的问题</strong></p><p>SLR只是简单的考察下一个输入符号b是否数据与归纳项目 A→α 相关联的FOLLOW(A)，但 $b\in FOLLOW(A)$ 只是归纳 α 的一个必要条件，而非充要条件，只能排除不合理的归约，不能选出正确的归约</p><h3 id="LR-1-分析法"><a href="#LR-1-分析法" class="headerlink" title="LR(1)分析法"></a>LR(1)分析法</h3><p><strong>基本思想</strong></p><ul><li>对于产生式 A→α 的归约，在不同使用位置，A会要求不同的后继符号</li><li>在特定位置，A的后继符号集合是 FOLLOW(A) 的子集</li></ul><p><strong>一般形式</strong></p><p>将一般形式为 [A→α·β,a] 的项称为 LR(1) 项，其中 A→αβ 是一个产生式，a是一个终结符（将$视为一个特殊的终结符），表示当前状态下，A后面要求紧跟的终结符，称为该项的<strong>展望符</strong></p><ul><li>LR(1) 中的1指的是项的第二个分量的长度</li><li>在形如 [A→α·β, a] 且 $\beta \not= \varepsilon$ 的项中，展望符 a 没有任何作用</li><li><p>但是一个形如 [A→α·β, a] 的项在只有一个输入符号等于 a 时才可以按照 A→α 进行归约</p><p>  这个 a 集合总是 FOLLOW(A) 的子集，而且通常是一个真子集</p></li></ul><p><strong>LR(1) 等价项目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[A→α·Bβ, a] &lt;--&gt; |B-&gt;γ∈P|B[B-&gt;·γ, b]</span><br></pre></td></tr></table></figure><p>其中 $b\in FIRST(\beta a)$，当 $\beta⇒^+\varepsilon$ 时，此时 b=a 叫继承的后继符，否则叫自生的后继符</p><p><strong>LR(1) 项目集闭包的计算</strong></p><ul><li><p>$CLOSURE(I)=I\cup \{[B→·\gamma , b] | [A→\alpha · B\beta , a]\in CLOSURE(I),B→\gamma \in P, b\in FIRST(\beta a)\}$</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701427554558.png" alt="1701427554558.png"></p></li><li><p>$GOTO(I,X)=CLOSURE(\{[A→\alpha X · \beta, a]|[A→\alpha · X \beta, a]\in I\})$</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701427687406.png" alt="1701427687406.png"></p></li><li><p>为文法构造规范LR(1)项集族的函数也要修改</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1701427748029.png" alt="1701427748029.png"></p></li><li><p>LR分析表构造算法</p><ul><li>构造 G’ 的规范LR(1)项集族 $C=\{I_0, I_1….I_n\}$</li><li>令 $I_i$ 对应状态i。状态i的语法分析动作按照下面的方法决定<ul><li>$if\ [A→\alpha·a\beta, b]\in I_i \ and\  GOTO(I_i,a)=I_j\ then\ ACTION[i, a]=sj$</li><li>$if\ [A→\alpha·B\beta, b]\in I_i \ and\ GOTO(I_i,B)=I_j\ then\ GOTO[i, B]=j$</li><li>$if\ [A→\alpha·,a]\in I_i \ and\ A\not= S’\ then\ for\ \forall a\in FOLLOW(A)\ do\ ACTION[i,a]=rj$  (j是A→α的编号)</li><li>$if\ S’→S·\in I_i\ then\ ACTION[i,$]=acc$</li></ul></li><li><p>没有定义的所有条目都设置为 “error”</p><p>如果其中没有语法分析动作冲突，给定文法就称为 LR(1) 文法</p></li></ul></li></ul><h3 id="LALR分析法"><a href="#LALR分析法" class="headerlink" title="LALR分析法"></a>LALR分析法</h3><p><strong>基本思想</strong></p><ul><li>寻找具有相同核心的 LR(1) 项集，并将这些项集合并为一个项集。所谓项集的核心就是其第一分量的集合</li><li>然后根据合并后得到的项集族构造语法分析表</li><li>如果语法分析表中没有语法分析动作冲突，给定的文法可称为 LALR(1) 文法，就可以根据该分析表进行语法分析</li><li>相当于是把 LR(1) 的状态项合并了，但是可能会出现归约-归约冲突，不会产生移进-归约冲突。合并后的展望符集合仍为 FOLLOW 集的子集</li></ul><p><strong>特点</strong></p><ul><li>LALR分析法可能会做多余的归并操作，但是绝对不会做错误的移进操作</li><li>合并同心项目集会节省空间，可能会推迟错误的发现</li><li>形式上与 LR(1) 相同</li><li>大小上与 LR(0)/SLR 相当</li><li>分析能力 SLR &lt; LALR(1) &lt; LR(1)</li></ul><h3 id="二义性文法的LR分析"><a href="#二义性文法的LR分析" class="headerlink" title="二义性文法的LR分析"></a>二义性文法的LR分析</h3><p><strong>二义性文法</strong></p><p>特点：</p><ul><li>每个二义性文法都不是LR的</li><li>某些类型的二义性文法在语言的描述和实现中很有用<ul><li>更简短，更自然</li></ul></li><li>会出现冲突，可以定义优先级和结合性来解决冲突</li></ul><h3 id="LR分析中的错误处理"><a href="#LR分析中的错误处理" class="headerlink" title="LR分析中的错误处理"></a>LR分析中的错误处理</h3><p><strong>错误语法检测</strong></p><ul><li>当LR分析其前妻在查询分析表并发现一个报错条目时，就检测到了一个语法错误</li></ul><p><strong>错误恢复策略</strong></p><ul><li>恐慌模式错误恢复<ol><li>从栈顶向下扫描，直到发现某个状态 $s_i$，它有一个对应于某个非终结符A的GOTO目标，可以认为从这个A推导出的串中包含错误</li><li>丢弃0个或多个输入符号，直到发现一个可能合法地跟在A之后的符号a为止</li><li>之后将 $s_{i+1}-GOTO(s_i,A)$ 压入栈中，继续进行语法分析</li></ol></li><li>短语层次错误恢复<ol><li>检查LR分析表中的每一个报错条目，并根据语言的使用方法来决定程序员所犯的何种错误最有可能引起这个语法错误</li><li>然后构造出适当的恢复过程</li></ol></li></ul><h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p><strong>概述</strong></p><p>语法制导翻译相当于是把语法分析，语义分析，中间代码生成合并成的步骤</p><p>语法制导翻译使用CFG来引导对语言的翻译，是一种面向文法的翻译技术</p><p><strong>基本思想</strong></p><ul><li>为CFG中的文法符号设置语义属性，用来表示语法成分对应的语义信息</li><li><p>文法符号的语义属性值是用与文法符号所在的产生式（语法规则）相关联的语义规则来计算的</p><p>  对于给定的输入串x，构建x的语法分析树，并利用于产生式（语法规则）相关联的语义规则来计算分析树中各结点对应的语义属性值</p></li></ul><p>将语义规则同语法规则联系起来要涉及两个概念  </p><h3 id="语法制导定义SDD"><a href="#语法制导定义SDD" class="headerlink" title="语法制导定义SDD"></a>语法制导定义SDD</h3><p>SDD是对CFG的推广</p><ul><li>将每个文法符号和一个语义属性集合相关两</li><li>将每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性</li></ul><p>栗子：如果X是一个文法符号，a是X的一个属性，则用X.a表示属性a在某个标号为X的分析书结点上的值</p><p><strong>特点</strong></p><ul><li>是关于语言翻译的高层次规格说明</li><li>隐蔽了许多具体实现细节，使用户不必显式地说明翻译发生的顺序</li></ul><p><strong>文法符号的属性</strong></p><ul><li><p>综合属性</p><p>  在分析树结点N上的非终结符A的综合属性只能通过<strong>N的子节点</strong>或<strong>N本身</strong>的属性值来定义</p><p>  终结符可以具有综合属性。终结符的综合属性值是由词法分析器提供的词法值，因此在SDD中没有计算终结符属性值的语义规则</p><p>  只有当所有的子节点被计算完之后才能计算</p></li><li><p>继承属性</p><p>  在分析树结点N上的非终结符A的继承属性只能通过<strong>N的父节点</strong>、<strong>N的兄弟节点</strong>或<strong>N本身</strong>的属性值来定义</p><p>  终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值</p><p>  属性值在即将出现的时刻进行计算</p></li></ul><p><strong>属性文法</strong></p><p>一个没有副作用的SDD有时也称为属性文法</p><ul><li>属性文法的规则仅仅通过其他属性值和常量来定义一个属性值</li></ul><p><strong>求值顺序</strong></p><p>SDD为CFG中的文法符号设置语义属性。对于给定的输入串x，应用语义规则计算分析树中各结点对应的属性值</p><p>语义规则建立了属性之间的依赖关系，在对语法分析树节点的一个属性求值之前，必须首先求出这个属性值所依赖的所有属性值</p><p><strong>依赖图</strong></p><ul><li>依赖图是一个描述了分析树种节点属性间依赖关系的有向图</li><li>分析树中每个标号为X的结点的每个属性a都对应着依赖图中的一个结点</li><li><p>如果属性X.a的值依赖于属性Y.b的值，则依赖图中有一条从Y.b的结点指向X.a的结点的有向边</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/20200731111105891.png" alt="20200731111105891.png"></p></li><li><p>在依赖图中，将综合属性放在左侧，继承属性放在右侧</p></li><li>图中最下面两个L为虚属性节点</li></ul><p><strong>属性值的计算顺序</strong></p><ul><li>可行的求值顺序是满足下列条件的结点序列 $N_1, N_2,…,N_k$：如果依赖图中有一条从结点Ni到Nj的边( $N_i→N_j$ ), 那么 i &lt; j（即：在节点序列中， $N_i$ 排在 $Nj$ 前面）。这样的排序将一个有向图变成了一个线性排序，这个排序称为这个图的·拓扑排序(topological sort)</li><li>对于只具有综合属性的SDD ，可以按照任何自底向上的顺序计算它们的值</li><li>对于同时具有继承属性和综合属性的SDD，不能保证存在一个顺序来对各个节点上的属性进行求值。有可能会出现环，就没有办法确定先计算哪一个属性了。如果依赖图中没有环，至少存在一个拓扑顺序</li></ul><h3 id="S-属性定义与L-属性定义"><a href="#S-属性定义与L-属性定义" class="headerlink" title="S-属性定义与L-属性定义"></a><strong>S-属性定义与L-属性定义</strong></h3><p><strong>S-属性定义</strong></p><ul><li>仅仅使用综合属性的SDD称为S属性的SDD，或S-属性定义，S-SDD</li><li>如果一个SDD是S属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值</li><li>S-属性定义可以自底向上的语法分析过程中实现</li></ul><p><strong>L-属性定义</strong></p><p>L-属性定义(也称为L属性的SDD或L-SDD)的直观含义：在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左</p><p>正式定义：一个SSD是L-属性定义，当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性：假设存在一个产生式 $A→X_1X_2…X_n$，其右部符号 $X_i$ 的继承属性仅依赖于下列属性：</p><ul><li>A的继承属性</li><li>产生式 $X_i$ 左边的符号 $X_1,X_2,…X_{i-1}$ 的属性</li><li>$X_i$ 本身的属性，但 $X_i$ 的全部属性不能在依赖图中形成环路</li></ul><p>每个S-属性定义都是L-属性定义</p><h3 id="语法制导翻译方案SDT"><a href="#语法制导翻译方案SDT" class="headerlink" title="语法制导翻译方案SDT"></a>语法制导翻译方案SDT</h3><p>SDT是在产生式右部嵌入了程序片段的CFG，这些程序片段称为语义动作。按照惯例，语义动作放在花括号内。</p><p>特点</p><ul><li>可以看作是对SDD的一种补充，是SDD的具体实施方案</li><li>显式地指明了语义规则的计算顺序，以便说明某些实现细节</li></ul><p>可以在语法分析过程中实现：</p><ul><li>基本文法可以使用LR分析技术，且SDD是S属性的</li><li>基本文法可以使用LL分析技术，且SDD是L属性的</li></ul><p><strong>将S-SDD转换为SDT</strong></p><p>方法：将每个于一动作都放在产生式的最后</p><p>实现：如果一个S-SDD的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析过程中实现</p><p>过程中需要扩展LR的语法分析栈：在分析栈中附加一个域来存放综合属性值，对于多个综合属性的存储就需要：</p><ul><li>使栈记录变得足够大</li><li>在栈记录中存放指针</li></ul><p><strong>将L-SDD转换为SDT</strong></p><p>方法：</p><ul><li>将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上</li><li>将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端</li></ul><p>实现：如果一个 L-SDD 的基本文法可以使用 LL分析技术，那么它的SDT可以在LL或LR语法分析过程中实现</p><h3 id="在非递归预测分析中进行翻译"><a href="#在非递归预测分析中进行翻译" class="headerlink" title="在非递归预测分析中进行翻译"></a>在非递归预测分析中进行翻译</h3><p><strong>扩展语法分析栈</strong></p><div class="table-container"><table><thead><tr><th>action</th><th>指向将被执行的语义动作代码的指针</th></tr></thead><tbody><tr><td>A</td><td>A的继承属性</td></tr><tr><td>Asyn</td><td>A的综合属性</td></tr></tbody></table></div><p>分析栈中每一个记录都对应着一段执行代码</p><ul><li>综合记录出栈时，要将综合属性值复制给后面特定的语义动作</li><li>变量展开式（即变量本身的记录出栈时），如果其含有继承属性，则要将继承属性值赋值给后面特定的语义动作</li></ul><h3 id="在递归预测分析中进行翻译"><a href="#在递归预测分析中进行翻译" class="headerlink" title="在递归预测分析中进行翻译"></a>在递归预测分析中进行翻译</h3><p>每一个非终结符都对应一个过程，可以把这个过程扩展为一个函数，函数的参数就是这个非终结符的各个继承属性，函数返回值就是非终结符的综合属性</p><p><strong>算法</strong></p><ul><li>为每个非终结符A构造一个函数，A的每个继承属性对应着该函数的一个形参，函数的返回值是A的综合属性值。对出现在A产生式中的每个文法符号的每个属性都设置一个局部变量</li><li>非终结符A的代码根据当前的输入决定使用哪个产生式</li><li>与每个产生式有关的代码执行如下动作：从左到右考虑产生式右部的词法单元，非终结符以及语义动作<ul><li>对于带有综合属性x的词法单元X，把x值保存在局部变量X.x中，然后产生一个匹配X的调用，并继续输入</li><li>对于非终结符B，产生一个右部带有函数调用的赋值语句 $B(b_1, b_2,…b_k)$，其中， $b_1,b_2, …b_k$ 是代表B的继承属性的变量，c是代表B的综合属性的变量</li><li>对于每个动作，将其代码复制到语法分析器，并把对属性的引用改为对相应变量的引用</li></ul></li></ul><h3 id="L属性定义的自底向上翻译"><a href="#L属性定义的自底向上翻译" class="headerlink" title="L属性定义的自底向上翻译"></a>L属性定义的自底向上翻译</h3><p>给定一个以LL文法为基础的L-SDD，由于该SDD的产生式的中间右部中间位置会嵌入一些语义动作，可以修改这个文法，把语义动作移动到产生式的末尾，并在LR语法分析过程中计算这个新文法之上的SDD。修改后的SDT，所有语义动作都位于产生式末尾。</p><h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><h3 id="类型表达式"><a href="#类型表达式" class="headerlink" title="类型表达式"></a>类型表达式</h3><ul><li>类型的结构用类型表达式来表示</li><li>基本类型是类型表达式<ul><li>integer</li><li>real</li><li>char</li><li>boolean</li><li>type_error</li><li>void</li></ul></li><li>可以为类型表达式命名，类型名也是类型表达式</li><li>将类型构造符作用于类型表达式可以构成新的类型表达式<ul><li>数组构造符 array</li><li>指针构造符 pointer</li><li>笛卡尔乘积构造符 x</li><li>函数构造符 →</li><li>记录构造符 record</li></ul></li></ul><h3 id="声明语句的翻译"><a href="#声明语句的翻译" class="headerlink" title="声明语句的翻译"></a>声明语句的翻译</h3><p><strong>局部变量的存储分配</strong></p><ul><li>对于声明语句，语义分析的主要任务就是收集标识符的类型等属性信息，并为每一个名字分配一个相对地址<ul><li>从类型表达式可以知道该类型在运行时刻所需的存储单元数量称为类型(type) 的宽度(width)</li><li>在编译时刻，可以使用类型的宽度为每一个名字分配一个相对地址(offset)</li></ul></li><li>名字的类型和相对地址信息保存在相应的符号表记录中</li></ul><p><strong>声明语句的SDT</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&P\rightarrow \{offset=0\}D\\&D\rightarrow T\ id;\{enter(id.lexeme,T.type,offset);offset=offset+T.width;\}D\\&D\rightarrow \varepsilon\\&T\rightarrow B\{t=B.type;\ w=B.width;\}\ C\{T.type=C.type;T.width=C.width;\}\\&T\rightarrow \uparrow T_1\{T.type=pointer(T_1.type);T.width=4;\}\\&B->int\{B.type=int;B.width=4;\}\\&B->real\{B.type=real;B.width=8\}\\&C\rightarrow\varepsilon \{C.type=t;C.width=w;\}\\&C\rightarrow [num]C_1\{C.type=aray(num.val,C_1.type);\ C.width =num.val*C_1.width;\}\end{aligned}\right.</script><ul><li>$enter(name, type, offset)$ 在符号表中为名字 name 的创建记录，将 name 的类型设置为 type ，相对地址设置为 offset</li></ul><h3 id="简单赋值语句的翻译"><a href="#简单赋值语句的翻译" class="headerlink" title="简单赋值语句的翻译"></a>简单赋值语句的翻译</h3><p><strong>赋值语句的翻译任务</strong></p><ul><li>基本文法<br>  - </li><li>赋值语句翻译的主要任务<ul><li>生成对表达式求值的三地址码</li></ul></li></ul><p><strong>赋值语句的SDT</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&S\rightarrow id=E;\{p=lookup(id.lexeme);if\ p==nil\ then\ error;\ S.code = E.code||gen(p=E.addr);\}\\&E\rightarrow E_1+E_2;\{E.addr=newtemp();\ E.coder =E_1.code||E_2.code||gen(E.addr=E_1.addr+E_2.addr);\}\\&E\rightarrow E_1*E_2;\{E.addr=newtemp();\ E.code=E_1.code||E_2.code||gen(E.addr=E_1.addr*E_2.addr);\}\\&E\rightarrow -E_1;\{E.addr=newtemp();\ E.code=E_1.code||gen(E.addr=nminus\ E_1.addr);\}\\&E\rightarrow (E_1);\{E.addr=E_1.addr;\ E.code=E_1.code\}\\&E\rightarrow id;\{E.addr=lookup(id.lexeme);\ if\ E.addr== nil\ then\ error;\ E.code='';\}\end{aligned}\right.</script><ul><li>$lookup(name)$ 查询符号表，返回 name 对应的记录</li><li>$gen(code)$ 生成三地址指令 code</li><li>$newtemp()$ 生成一个新的临时变量，返回t的地址</li></ul><p><strong>增量翻译</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&S\rightarrow id=E;\{p=lookup(id.lexeme);if\ p==nil\ then\ error;\ gen(p=E.addr);\}\\&E\rightarrow E_1+E_2;\{E.addr=newtemp();\ gen(E.addr=E_1.addr+E_2.addr);\}\\&E\rightarrow E_1*E_2;\{E.addr=newtemp();\ gen(E.addr=E_1.addr*E_2.addr);\}\\&E\rightarrow -E_1;\{E.addr=newtemp();\ Egen(E.addr=nminus\ E_1.addr);\}\\&E\rightarrow (E_1);\{E.addr=E_1.addr;\}\\&E\rightarrow id;\{E.addr=lookup(id.lexeme);\ if\ E.addr== nil\ then\ error;\ E.code='';\}\end{aligned}\right.</script><ul><li>$gen(code)$ 不仅要生成一个新的三地址指令，还要将它添加到至今为止已经生成的的指令序列之后</li></ul><p><strong>数组引用的翻译</strong></p><p><strong>赋值语句基本文法</strong></p><script type="math/tex; mode=display">S\rightarrow id=E;|L=E;\\E\rightarrow E_1+E_2|-E_1|(E_1)|id|L\\L\rightarrow id[E]|L_1[E]</script><p>将数组引用翻译成三地址码时要解决的主要问题是确定数组元素的存放地址，也就是数组元素的寻址</p><p>L 的综合属性</p><ul><li>L.type L生成的数组元素的类型</li><li>L.offset 指示一个临时变量，该临时变量用于累加公式中的 $i_j\times w_j$ 项，从而计算数组引用的偏移量</li></ul><p><strong>数组元素的寻址</strong></p><ul><li>一维数组<ul><li>假设每个元素宽度是 w，则元素 a[i] 的相对地址是 $base + i \times w$，其中 base 是数组的基地址， $i \times w$ 是偏移地址</li></ul></li><li>二维数组<ul><li>假设一行的宽度是 $w_1$，同一行中每个元素的宽度是 $w_2$，则数组元素 $a[i_1][i_2]$ 的地址就是 $base+i_1\times w_1+i_2\times w_2$</li></ul></li><li>k维数组<ul><li>数组元素 $a[i_1][i_2]…[i_k]$ 的相对地址就是 $base+\sum_{j=1}^{k}{i_j\times w_j}$</li></ul></li></ul><p><strong>数组引用的SDT</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&S\rightarrow id=E;\\&L=E;\{gen(L.array|L.offset|=E.addr;\\&E\rightarrow E_1+E_2 |-E_1|(E_1)|id\ \\&L\left\{\begin{aligned}&E.addr=newtemp();\\&gen(E.addr=L.array|L.offset|);\end{aligned}\right.\\&L\rightarrow id[E]\left\{\begin{aligned}&L.array=lookup(id.lexeme);\\&if\ L.array==nil\ then\ error;\\&L.type=L.array.type.elem;\\&L.offset=newtemp();\\&gen(L.offset=E.addr*L.type.width);\end{aligned}\right.\\&|L_1[E]\left\{\begin{aligned}&L.array=L_1.array;\\&L.type=L_1.type.elem;\\&t=newtemp()\\&gen(t=E.addr*L.type.width);\\&L.offset=newtemp();\\&gen(L.offset=L_1.offset+t);\end{aligned}\right.\end{aligned}\right.</script><h3 id="控制流语句翻译"><a href="#控制流语句翻译" class="headerlink" title="控制流语句翻译"></a>控制流语句翻译</h3><p><strong>控制流语句分类</strong></p><ul><li><p>顺序结构</p><p>  $P→S\\ S\rightarrow S_1S_2\\S\rightarrow id=E;|L=E;$</p></li><li><p>分支结构</p><p>  $if\ B\ then\ S_1\ else\ S_2$</p></li><li><p>循环结构</p><p>  $while\ B\ do\ S_1$</p></li></ul><p>对于一条语句，可以是赋值，分支和循环语句等</p><p><strong>分支语句的代码结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[B.code]--&gt;|true|C[S1.code]--&gt;D[S1.next]</span><br><span class="line">A--&gt;|false|B[S2.code]--&gt;E[S2.next]</span><br><span class="line">D--&gt;F[S.next]</span><br><span class="line">E--&gt;F</span><br></pre></td></tr></table></figure><p>其中 $\left\{\begin{aligned}&amp;S.next：是一个地址，该地址存放了紧跟着S代码之后的指令（S的后继指令）的标号\\&amp; B.true：是一个地址，该地址中存放了当B为真时控制流转向的指令的标号\\&amp;B.false：是一个地址，该地址中存放了当B为假时控制流转向的指令的标号\\&amp;布尔表达式B被翻译成由跳转指令构成的跳转代码\\&amp;用指令的标号标识一条三地址指令\end{aligned}\right.$</p><p><strong>控制流语句的SDT</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&P\rightarrow&\{S.next=newlabel();\}\\&&S\{label(S.next);\}\\&S\rightarrow&\{S_1.next=newlabel();\}S_1\\&&\{label(S_1.next);S_2.next=S.next;\}S_2\\&S\rightarrow id=E;|L=E;\\&S\rightarrow &if\ B\ then\ S_1\\&&|if\ B\ then\ S_1\ else \ S_2\\&&|while\ B\ do\ S_1\end{aligned}\right.</script><p>$newlable()$ 生成一个用于存放标号的新的临时变量L，返回变量地址</p><p>$label(L)$ 将下一条三地址指令的标号赋值给L</p><p><strong>if-then-else 语句的SDT</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&S\rightarrow &if \ B\ then\ S_1\ else\ S_2\\&S\rightarrow& if\{B.true=newlabel();B.false=newlabel();\}B\\&&then\{label(B.true);S_1.next=S.next;\}S_1\{gen(goto\ S.next);\}\\&&else\{label(B.false);S_2.next=S.next\}\end{aligned}\right.</script><p><strong>if-then 语句的SDT</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&S\rightarrow &if \ B\ then\ S_1\\&S\rightarrow& if\{B.true=newlabel();B.false=newlabel();\}B\\&&then\{label(B.true);S_1.next=S.next;\}S_1\end{aligned}\right.</script><p><strong>while-do 语句的SDT</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&S\rightarrow &while\ B\ do\ S_1\\&S\rightarrow& while\{S.begin=newlabel();label(S.begin);B.true=newlabel();B.false=S.next;\}B\\&&do\{label(B.true);S_1.next=S.begin;\}S_1\{gen(goto\ S.begin\}\end{aligned}\right.</script><h3 id="布尔表达式的SDT"><a href="#布尔表达式的SDT" class="headerlink" title="布尔表达式的SDT"></a>布尔表达式的SDT</h3><p><strong>布尔表达式的基本文法</strong></p><script type="math/tex; mode=display">B→B\ or\ B\\|B\ and\ B\\|not\ B\\(B)\\E\ relop\ E\\true\\false</script><p>优先级： $not&gt;and&gt;or$</p><p>relop：关系表达式，包括 $&lt;,≤,&gt;,≥,==,≠$ 等</p><p>在跳转代码中，逻辑运算符&amp;&amp;，|| 和 ! 被翻译成跳转指令。运算符本身不出现在代码中，布尔表达式的值时通过代码序列中的位置来表示的</p><p><strong>布尔表达式的SDT</strong></p><ul><li>$B→E_1\ relop\ E_2\\\{gen(if\ E_1.addr\ relop\ E_2.addr\ goto\ B.true);gen(goto\ B.false);\}$</li><li>$B→true\{gen(goto\ B.true);\}$</li><li>$B→false\{gen(goto\ B.false);\}$</li><li>$B→(\{B_1.true=B.true;\ B_1.false=B.false;\}B_1)$</li><li>$B→not\{B_1.true=B.false;\ B_1.false=B.true;\}B_1$</li></ul><p>$<strong>B→B_1\ or\ B_2$ 的SDT</strong></p><p>$B→\{B_1.true=B.true;\ B_1.false=newlabel();\}B_1\\or\{label(B_1.false);\ B_2.true=B.true;\ B_2.false=B.false;\}B_2$</p><p>$<strong>B→B_1\ and\ B_2$ 的SDT</strong></p><p>$B→\{B_1.true=B.true;\ B_1.false=newlabel();\}B_1\\and\{label(B_1.false);\ B_2.true=B.true;\ B_2.false=B.false;\}B_2$</p><h3 id="控制流翻译的例子"><a href="#控制流翻译的例子" class="headerlink" title="控制流翻译的例子"></a>控制流翻译的例子</h3><p><strong>控制流语句的SDT</strong></p><ul><li>$P→\{a\}S\{a\}$</li><li>$S→\{a\}S_1\{a\}S_2$</li><li>$S→id=E;\{a\}|L=E;\{a\}$</li><li>$E→E_1+E_2\{a\}|-E_1\{a\}|E_1\{a\}|id\{a\}|L\{a\}$</li><li>$L→id[E]\{a\}|L_1[E]\{a\}$</li><li>$S→if\{a\}B\ then\ \{a\}S_1\|if\{a\}B\ then \{a\}S_1\ else\ \{a\}S_2\|while\ \{a\}B\ do\ \{a\}S_1\{a\}$</li><li>$B→\{a\}B\ or\ \{a\}B|\{a\}B\ and\ \{a\}B\ and\{a\}B|not\ \{a\}B|(\{a\}B)\|E\ relop\ E\{a\}|true\{a\}|false\{a\}$</li></ul><p><strong>SDT的通用实现方法</strong></p><p>首先建立一棵语法分析树，然后按照从左到右的深度优先顺序来执行这些动作</p><h3 id="布尔表达式的回填"><a href="#布尔表达式的回填" class="headerlink" title="布尔表达式的回填"></a>布尔表达式的回填</h3><p>针对布尔表达式和控制流语句生成中间代码的时候，关键的问题是确定跳转指令的目标标号，生成跳转指令的时候，目标标号还不能确定。</p><p>之前的解决方法是，将存放标号的地址作为继承属传递到跳转指令生成的地方，但是这样做需要再做一次处理，将标号从具体的地址反复取出</p><p><strong>回填</strong></p><p>把一个由跳转指令组成的列表，以综合属性的形式进行传递</p><p>基本思想：生成一个跳转指令时，暂时不指定该跳转指令的目标标号。这样的指令都被放入由跳转指令组成的列表中。同一个列表中的所有跳转指令具有相同的目标标号，等到能确定正确的目标标号时，才去填充这些指令的目标标号</p><p><strong>非终结符B的综合属性</strong></p><ul><li><code>B.truelist</code>：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为真时控制流应该转向的指令的标号</li><li><code>B.falselist</code>：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当B为假时控制流应该转向的指令的标号</li></ul><p><strong>函数</strong></p><ul><li><code>makelist(i)</code> 创建一个只包含 i 的列表，i 是跳转指令的标号，函数返回指向新创建的列表的指针</li><li><code>merge(p1,p2)</code> 将 p1 和 p2 指针指向的列表进行合并，返回指向合并后的列表的指针</li><li><code>backpatch(p,i)</code> 将 i 作为目标标号插入到 p 所指列表中的各指令中</li></ul><p><strong>布尔表达式的回填翻译方法</strong></p><ul><li>$B\rightarrow E_1 ~ relop~E_2\\\{\\B.truelist=makelist(nextquad);\\B.falselist=makelist(nextquad+1);\\gen(if~E_1.addr~relop~E_2.addr~goto_);\\gen(goto_);\\\}$</li><li>$B→true\\\{\\B.truelist=makelist(nextquad);\\gen(goto_);\\\}$</li><li>$B→false\\\{\\B.falselist=makelist(nextquad);\\gen(goto_);\\\}$</li><li>$B→(B_1)\\\{\\B.truelist=B_1.truelist;\\B.falselist=B_1.falselist;\\\}$</li><li>$B→not~B_1\\\{\\B.truelist=B_1.falselist;\\B.falselist=B_1.truelist;\\\}$</li><li>$B→B_1~or~B_2\\B→B_1~or~M~B_2\\\{\\backpatch(B_1.falselist, M.quad);\\B.truelist = merge(B_1.truelist, B_2.truelist);\\B.falselist=B_2.falselist;\\\}\\M→\varepsilon\\\{M.quad=nextquad;\} 回填B_1.truelist的综合属性$</li><li>$B→B_1~and~B_2\\B→B_1~and~M~B_2\\\{\\backpatch(B_1.truelist, M.quad);\\B.falselist = merge(B_1.falselist, B_2.falselist);\\B.truelist=B_2.truelist;\\\}\\M→\varepsilon\\\{M.quad=nextquad;\}回填B_1.falselist的综合属性$</li></ul><p>其中标题非终结符 M 用于记录下一条指令的标号</p><p>$goto~_$ 表示跳转到 $S.nextlist$</p><h3 id="控制流语句的回填"><a href="#控制流语句的回填" class="headerlink" title="控制流语句的回填"></a>控制流语句的回填</h3><p><strong>综合属性</strong></p><p><code>S.nextlist</code> 指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是按照运行顺序紧跟在 S 代码之后的指令的标号</p><p><strong>翻译方法</strong></p><ul><li>$S→if~B~then~S_1\\S→if~B~then~M~S_1\\\{\\backpatch(B.truelist,M.quad);\\S.nextlist=merge(B.falselist,S_1.nextlist);\\\}$</li><li>$S→if~B~then~S_1~else~S_2\\S→if~B~then~M_1~S_1~N~else~M_2~S_2\\\{\\backpatch(B.truelist,M_1.quad);\\backpatch(B.falselist,M_2.quad);\\S.nextlist=merge(merge(S_1.nextlist,N.nextlist),S_2.nextlist);\\\}\\N→\varepsilon\\\{\\N.nextlist=makelist(nextquad);\\gen(goto_);\\\}$</li><li>$S→while~B~do~S_1\\S→while~M_1~B~do~M_2~S_1\\\{\\backpatch(S_1.nextlist,M_1.quad);\\backpatch(B.truelist,M_2.quad);\\S.nextlist=B.falselist;\\gen(goto~M.quad);\\\}$</li><li>$S→S_1S_2\\S→S_1~M~S_2\\\{\\backpatch(S_1.nextlist, M.quad);\\S.nextlist=S_2.nextlist\\\}$</li><li>$S→id=E;|L=E;\{S.nextlist=null\}$</li></ul><h3 id="SWITCH-语句的翻译"><a href="#SWITCH-语句的翻译" class="headerlink" title="SWITCH 语句的翻译"></a>SWITCH 语句的翻译</h3><p><strong>基本语法</strong></p><script type="math/tex; mode=display">switch~E\\begin\\case~V_1:S_1\\case~V_2:S_2\\...\\case~V_{n-1}:S_{n-1}\\default:S_n\\end</script><p><strong>翻译</strong></p><script type="math/tex; mode=display">switch~E\{t=newtemp();gen(t=E.addr);\}\\case~V_1:\{L_1=newlabel();gen(if~t~!=~V_1~goto~L_1);\}\\S_1\{next=newlabel();gen(goto~next);\}\\...\\default:\{label(L_{n-1});\}\\S_n\{label(next);\}</script><p><strong>第二种翻译</strong></p><p>在代码生成阶段，根据分支个数以及这些值是否在一个较小的范围内，这种条件跳转指令序列可以被翻译成最高效的n路分支</p><script type="math/tex; mode=display">switch~E\{t=newtemp();gen(t=E.addr);test=newtemp();gen(goto~test);\}\\case~V_1:\{L_1=newlabel();label(L_1);map(V_1,L_1);\}\\S_1\{next=newlabel();gen(goto~next);\}\\...\\default:\{L_n=newlabel();label(L_{n});\}\\S_n\{gen(goto~next);label(test);\\gen(if~t=V_1~goto~L_1);\\...\\gen(if~t=V_{n-1}~goto~L_{n-1});\\label(next)\\\}</script><p><strong>case指令</strong></p><p>指令 $case~t~V_i~L_i$ 和 $if~t=V_i~goto~L_i$ 的含义相同，但是 case 指令更加容易被最终的代码生成器探测到，从而对这些指令进行特殊处理</p><h3 id="过程调用语句的翻译"><a href="#过程调用语句的翻译" class="headerlink" title="过程调用语句的翻译"></a>过程调用语句的翻译</h3><p><strong>文法</strong></p><p>$S→call~id~(Elist)\\Elist→Elist,E\\Elist→E$</p><p>$call$ 过程调用关键字</p><p>$Elist$ 是过程参数表达式列表</p><p><strong>过程调用语句的SDD</strong></p><ul><li>$S→call~id~(Elist\\\{\\n=0;\\for~q中每一个t~do\\\{\\gen(param~t);\\n=n+1;\\\}\\gen(call~id.addr,n);\\\}$</li><li>$Elist→E\\\{将q初始化为只包含E.addr;\}$</li><li>$Elist→Elist_1,E\\\{将E.addr添加到q的队尾;\}$</li></ul><h2 id="运行存储分配"><a href="#运行存储分配" class="headerlink" title="运行存储分配"></a>运行存储分配</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>编译器在工作过程中，必须为源程序中出现的一些数据对象分配运行时的存储空间</li><li>对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的分配策略称为<strong>静态</strong>存储分配——编译时刻</li><li>如果不能在编译时完全确定数据对象的大小，就要采用动态存储分配的策略。即在编译时进产生各种必要的信息，而在运行时刻，再<strong>动态</strong>的分配数据对象的存储空间——运行时刻<ul><li>栈式存储分配</li><li>堆式存储分配</li></ul></li></ul><p><strong>运行时内存的划分</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1703644888799.png" alt="1703644888799.png"></p><ul><li>静态代码区：位于存储的低端，用于存储目标代码</li><li>静态数据区：存储编译时刻就可以确定的数据</li><li>动态数据区：为了使存储利用最大化，将栈和堆存放再动态数据区的两端</li><li>栈区：存放一种称为活动记录的数据结构，再过程调用时生成并进栈，在过程返回时出栈</li><li>堆区：在程序中支持用户代码控制分配对象空间，堆用于存放这些有着长生命周期的对象</li></ul><p><strong>活动记录</strong></p><ul><li>使用过程（或函数，方法）作为用户自定义动作的单元的语言，其编译器通常以过程为单位分配存储空间</li><li>过程体的每次执行称为该过程的一个活动</li><li>过程每执行一次，就为它分配一块连续的区域，用来管理过程一次执行所需的信息，这块连续存储区称为活动记录</li></ul><p>一般形式包含</p><ul><li>实参：调用过程传递给被调用过程的参数</li><li>返回值：被调用过程返回给调用过程的值</li><li>控制链：指向调用者的活动记录</li><li>访问链：用来访问存放于其他活动记录中的非局部数据</li><li>保存的机器状态：</li><li>局部数据：过程本身声明的局部数据</li><li>临时变量：存放过程中产生的一些变量</li></ul><h3 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h3><ul><li>在静态存储分配中，编译器为每个过程确定其活动记录在目标程序中的位置</li><li>这样，过程中每个名字的存储位置就确定了</li><li>因此，这些名字的存储地址可以被编译到目标代码中</li><li>过程每次执行时，它的名字都绑定同样的存储单元</li></ul><p><strong>静态存储分配的限制条件</strong></p><ul><li>数组上下界必须为常数</li><li>不允许过程的递归调用</li><li>不允许动态建立数据实体</li></ul><p>满足这些条件的语言 ：BASIC 和 FORTRAN 等</p><p><strong>常用的静态存储分配方法</strong></p><ul><li>顺序分配法<ul><li>按照过程出现的先后记录逐段分配存储空间</li><li>各过程的活动记录占用互不相交的存储空间</li><li>优点：处理简单</li><li>缺点：对内存空间的使用不够经济</li></ul></li><li>层次分配法<ul><li>通过对过程间的调用关系进行分析，凡属无相互调用关系并列过程，尽量使其局部数据共享存储空间</li><li>过程调用关系矩阵 <code>B[n][n]</code><ul><li><code>B[i][j]=1</code> 第 i 个过程调用第 j 个过程</li><li><code>B[i][j]=0</code> 第 i 个过程不调用第 j 个过程</li></ul></li><li><code>Units[n]</code> 用于存放各个过程所需要的内存量</li></ul></li></ul><h3 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h3><ul><li>有些语言使用过程，函数或方法作为用户自定义动作的单元，几乎所有针对这些语言的编译器都把它们的（至少一部分的）运行时刻存储以栈的形式进行管理，称为栈式存储分配</li><li>当一个过程被调用时，该过程的活动记录被压入栈中，当过程结束时，该活动记录被弹出栈</li><li>这种安排不仅允许活跃时段不交叠的多个过程调用之间共享空间，而且允许以如下方式为一个过程编译代码：它的非局部变量的相对地址总是固定的，和过程调用序列无关</li></ul><p><strong>活动树</strong></p><ul><li>用于描述程序运行期间控制进入和离开各个活动的情况的树称为活动树</li><li>树中每个结点对应于一个活动。根结点是启动程序执行的 main 过程的活动</li><li>在表示过程 p 的某个活动的结点上，其子结点对应于被 p 的这次活动调用的各个过程的活动。按照这些活动被调用的顺序，自左向右地显示它们。一个子结点必须在其右兄弟节点的活动开始之前结束</li></ul><p><strong>结论</strong></p><ul><li>每个活跃的活动都有一个位于控制栈中的活动记录</li><li>活动树的根的活动记录位于栈底</li><li>程序控制所在的活动的记录位于栈顶</li><li>栈中全部活动记录的序列对应于在活动树中到达当前控制所在的活动结点的路径</li></ul><p><strong>设计活动记录的一些原则</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1703647832974.png" alt="1703647832974.png"></p><ul><li>在调用者和被调用者之间传递的值一般被放在被调用者的活动记录的开始位置，这样它们可以尽可能地靠近调用者的活动记录</li><li>固定长度的项被放置在中间位置<ul><li>控制链，访问链，机器状态字</li></ul></li><li>早期不知道大小的项被放置在活动记录的尾部</li><li>栈顶指针寄存器 <code>top_sp</code> 指向活动记录中局部数据开始的位置，以该地址作为基地址</li></ul><h3 id="调用序列和返回序列"><a href="#调用序列和返回序列" class="headerlink" title="调用序列和返回序列"></a>调用序列和返回序列</h3><ul><li>过程调用和过程返回都需要执行一些代码来管理活动记录栈，保存或恢复机器状态等<ul><li>调用序列：实现过程调用的代码段。为一个活动记录在栈中分配空间，并在此记录的字段中填写信息</li><li>返回序列：恢复机器状态，使得调用过程能够在调用结束之后继续执行</li><li>一个调用代码序列中的代码通常被分隔到调用过程（调用者）和被调用过程（被调用者）中。返回序列也是如此</li></ul></li></ul><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1703662724476.png" alt="1703662724476.png"></p><p><strong>调用序列</strong></p><ul><li>调用者计算实际参数的值</li><li>调用者将返回地址（程序计数器的值）放到被调用者的机器状态字中。将原来的 <code>top_sp</code> 的值放到被调用者的控制链中。然后，增加 <code>top_sp</code> 的值，使其指向被调用者局部数据开始的位置</li><li>被调用者保存寄存器值和其它状态信息</li><li>被调用者初始化其局部数据并开始执行</li></ul><p><strong>返回序列</strong></p><ul><li>被调用者将返回值放到与参数相邻的位置</li><li>使用机器状态字段中的信息，被调用者恢复 <code>top_sp</code> 和其它寄存器，然后跳转到由调用者放在机器状态字段中的返回地址</li><li>虽然 <code>top_sp</code> 的值已经被减小，但是调用者仍然知道返回值相对于当前 <code>top_sp</code> 值的位置。因此，调用者可以使用那个返回值</li></ul><p><strong>调用者和被调用者之间的任务划分</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1703663140987.png" alt="1703663140987.png"></p><p><strong>变长数据的存储分配</strong></p><ul><li>在现代程序设计语言中，在编译时刻不能确定大小的对象将被分配在堆区。但是，如果它们是过程的局部对象，也可以将它们分配在运行时刻栈中。尽量将对象放置在栈区的原因：可以避免对它们的空间进行垃圾回收，也就减少了相应的开销</li><li>只有一个数据对象局部与某个过程，且当此过程结束时它变得不可访问，才可以使用栈为这个对象分配空间</li></ul><h3 id="非局部数据的访问"><a href="#非局部数据的访问" class="headerlink" title="非局部数据的访问"></a>非局部数据的访问</h3><ul><li>一个过程中除了可以使用过程自身定义的局部数据以外，还可以使用过程外定义的非局部数据</li><li>语言可以分为两种类型<ul><li>支持过程嵌套声明的语言：可以在一个过程中声明另一个过程<ul><li>过程可以使用自身的局部数据，也可以使用过程外围的局部数据</li></ul></li><li>不支持过程嵌套声明的语言：不可以在一个过程中声明另一个过程<ul><li>过程中使用的数据要么是自身局部数据，要么是所有过程之外的全局数据</li></ul></li></ul></li></ul><p><strong>无过程嵌套声明时的数据访问</strong></p><p>变量的存储分配和访问</p><ul><li>全局变量被分配在静态区，使用静态确定的地址访问它们</li><li>其它变量一定是栈顶活动的局部变量。可以通过运行时刻栈的 <code>top_sp</code> 指针访问它们</li></ul><p><strong>有过程嵌套声明时的数据访问</strong></p><p>嵌套深度</p><ul><li>过程的嵌套深度<ul><li>不内嵌在任何其它过程中的过程，嵌套深度为1</li><li>如果一个过程 p 在一个嵌套深度为 i 的过程中定义，则设定 p 的嵌套深度为 i+1</li></ul></li><li>变量的嵌套深度<ul><li>将变量声明所在过程的嵌套深度作为该变量的嵌套深度</li></ul></li></ul><p><strong>访问链</strong></p><ul><li>静态作用域规则：只要过程 b 的声明嵌套在过程 a 的声明中，过程 b 就可以访问过程 a 中声明的对象</li><li>可以在相互嵌套的过程的活动记录之间建立一种称为访问链的指针，使得内嵌过程可以访问外层过程中声明的对象</li><li>如果过程 b 在源代码中直接嵌套在过程 a 中，（b的嵌套深度比a的嵌套深度多1），那么 b 的任何活动中的访问链都指向最近的 a 的活动</li></ul><p><strong>访问链的建立方法</strong></p><ul><li>建立访问链的代码属于调用序列的一部分</li><li>假设嵌套深度为 nx 的过程 x 调用嵌套深度为 ny 的过程 y<ul><li>nx &lt; ny 的情况，外层调用内层<ul><li>y 一定是直接在 x 中定义的，也就是 ny = nx + 1</li><li>在调用代码序列中增加一个步骤：在 y 的访问链中放置一个指向 x 的活动记录的指针</li></ul></li><li>nx = ny 本层调用<ul><li>递归调用</li><li>被调用者的活动记录的访问链与调用者的活动记录的访问链是相同的，可以直接复制</li></ul></li><li>nx &gt; ny 内层调用外层<ul><li>过程 x 必定嵌套在某个过程 z 中，而 z 中直接定义了过程 y</li><li>从 x 的活动记录开始，沿着访问链经过 nx - ny + 1 步就可以找到离栈顶最近的 z 的活动记录。y 的访问链必须指向 z 的这个活动记录</li></ul></li></ul></li></ul><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>符号表的组织：为每个作用域（程序块）建立一个独立的符号表</p><p>为每个过程或作用域建立的符号表与编译时的活动记录是对应的。一个过程的非局部名字的信息可以通过扫描外围过程的符号表而得到</p><p><strong>标识符的基本处理方法</strong></p><ul><li>当在某一层的声明语句中识别处一个标识符（id的定义性出现）时，以此标识符查相应于本层的符号表<ul><li>如果查到，则报错并且发出诊断信息：id重复声明</li><li>否则，在符号表中加入新登记项，将标识符及有关信息填入</li></ul></li><li>当在可执行语句部分扫视到标识符时（id的应用性出现）<ul><li>首先在该层符号表中查找该id，如果找不到，则到直接外层符号表中去查，直到最外层为止，一旦找到，则在该表中取出有关信息并作相应处理</li><li>如果查遍所有外层符号表均未找到该id，则报错并发出诊断信息：id未声明</li></ul></li></ul><h3 id="符号表的建立"><a href="#符号表的建立" class="headerlink" title="符号表的建立"></a>符号表的建立</h3><ul><li><p>嵌套过程声明语句的文法</p><script type="math/tex; mode=display">  P\rightarrow D\\D\rightarrow D~D|proc~id;D~S|id:T;</script></li><li><p>允许嵌套过程声明的语句中，局部于每个过程的名字可以使用<strong>局部变量的存储分配</strong>方法分配地址，当看到嵌套的过程 p 时，应暂时挂起对外围过程 q 声明语句的处理</p></li></ul><p><strong>嵌套声明语句的 SDT</strong></p><script type="math/tex; mode=display">P\rightarrow M~D\{addwidth(top(tblptr),top(offset));\\pop(tblptr);\\pop(offset);\}\\M\rightarrow \varepsilon \{t=mktable(nil);\\push(t, tblptr);\\push(0,offset);\}\\D\rightarrow D_1~D_2\\D_p\rightarrow proc~id;N~D_1~S\{t=top(tblptr);\\addwidth(t,top(offset));\\pop(tblptr);\\pop(offset);\\enterproc(top(tblptr),id,lexeme,t);\}\\D_v\rightarrow id:T;\{enter(top(tblptr),id,lexeme,T.type,top(offset));\\top(offset)=top(offset)+T.width;\}\\N\rightarrow \varepsilon \{t=mktable(top(tblptr));\\push(t,tblptr);push(0,offset);\}</script><p><code>mktable(previous)</code> 创建一个新的符号表，并返回指向新表的指针。参数 <code>previous</code> 指向先前创建的符号表（外围过程的符号表）</p><p><code>enter(table,name,type,offset)</code> 在 <code>table</code> 指向的符号表中为名字 <code>name</code> 建立一个新表项</p><p><code>addwidth(table,width)</code> 将 <code>table</code> 指向的符号表中所有表项的宽度之和 <code>width</code> 记录在符号表的表头中</p><p><code>enterproc(table,name,newtable)</code> 在 <code>table</code> 指向的符号表中为过程 <code>name</code> 建立一条记录， <code>newtable</code> 指向过程 <code>name</code> 的符号表</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h3><p><strong>基本块</strong></p><p>是满足下列条件的最大连续三地址指令序列</p><ul><li>控制流只能从基本块的第一个指令进入该块。也就是说，没有跳转到基本块中间或末尾指令的转移指令</li><li>除了基本块的最后一个指令，控制流在离开基本块之前不会跳转或者停机</li></ul><p><strong>基本块的划分</strong></p><ul><li>关键是确定各个基本块的首指令，也就是基本块的第一条指令，一旦第一条指令确定下来，两条首指令之间的部分就是一个块</li><li>跳转指令能够跳转到一个块的第一条指令的，跳转指令的目标指令是一个首指令</li><li>紧跟在跳转指令之后的指令是首指令</li></ul><p><strong>基本块划分算法</strong></p><ul><li>输入：三地址指令序列</li><li>输出：输入序列对应的基本块列表，其中每个指令恰好被分配给一个基本块</li><li>方法：<ul><li>确定指令序列中那些指令是首指令<ol><li>指令序列的第一个三地址指令是首指令</li><li>任意一个条件或者无条件转移指令的目标指令是一个首指令</li><li>紧跟在一个条件或者无条件转移指令之后的指令是一个首指令</li></ol></li><li>每个首指令对应的基本块包括了从它自己开始，直到下一条首指令（不含）或者指令序列结尾之间的所有指令</li></ul></li></ul><p><strong>流图</strong></p><ul><li>流图的每一个结点都是基本块</li><li>从基本块 B 到基本块 C 之间有一条边当且仅当基本块 C 的第一个指令可能紧跟在 B 的最后一条指令之后执行，此时称 B 是 C 的前驱，C 是 B 的后继，两种判断方式<ul><li>有一个从 B 的结尾跳转到 C 的开头的条件或无条件跳转指令</li><li>按照原来的三地址语句序列中的顺序，C 紧跟在 B 之后，且 B 的结尾不存在无条件跳转指令</li></ul></li></ul><h3 id="常用代码优化方法"><a href="#常用代码优化方法" class="headerlink" title="常用代码优化方法"></a>常用代码优化方法</h3><p><strong>优化的分类</strong></p><ul><li>机器无关代码——针对中间代码</li><li><p>机器相关代码——针对目标代码</p></li><li><p>局部代码优化——单个基本块范围内的优化</p></li><li>全局代码优化——面向多个基本块的优化</li></ul><p><strong>常用代码优化方法</strong></p><ol><li>删除公共子表达式<ul><li>如果表达式 <code>x op y</code> 先前已经被计算过，并且从先前计算到现在其中变量的值没有改变，那么它的这次出现就是公共子表达式，可以删除此表达式，直接使用先前的计算结果，避免重复计算</li></ul></li><li>删除无用代码<ul><li>复制传播：常用的公共子表达式消除算法和其它的一些优化算法会引入一些复制语句（ <code>x=y</code> 的赋值语句），就是在 <code>x=y</code> 之后尽可能使用 y 代替 x，给删除无用代码带来了机会</li><li>无用代码：死代码，其计算结果永远不会被使用的语句，主要是以上的优化产生的</li></ul></li><li>常量合并<ul><li>如果在编译时刻推导出一个表达式的值是常量，就可以在使用该常量来代替这个表达式，即常量合并</li></ul></li><li>代码移动<ul><li>目的是减少循环中代码的数量，转换处理的是那些不管循环执行多少次都得到相同的结果的表达式（即循环不变计算），在进入循环之前就对它们求值</li><li>循环不变计算具有相对性，是相对于某个循环来说是循环不变计算的</li></ul></li><li>强度削弱<ul><li>用较快的操作代替较慢的操作</li><li>循环中的强度削弱：对于一个变量 x，如果存在一个常数 c 使得每次 x 被赋值时总是增加 c，那么 x 就称为<strong>归纳变量</strong>，可以在每次循环迭代中进行一次简单的增量运算（加或减）来计算</li></ul></li><li>删除归纳变量<ul><li>再沿着循环进行时，如果有一组归纳变量的值的变化保持步调一致，常常可以将这组变量删除为只剩下一个</li></ul></li></ol><h3 id="基本块的优化"><a href="#基本块的优化" class="headerlink" title="基本块的优化"></a><strong>基本块的优化</strong></h3><p>很多重要的局部优化技术首先把基本块转化成一个有向无环图</p><p><strong>基本块的DAG图</strong></p><ul><li>原理：基本块中的每条语句 s 都对应着一个内部结点 N<ul><li>N 的标号是 s 中的运算符，同时还有一个定值变量表被关联到 N，表示 s 是在此基本块内最晚对表中变量进行定值的语句</li><li>N 的子结点是基本块中在 s 之前，最后一个对 s 所使用的某个运算分量进行定制的语句对应的结点。如果 s 的某个运算分量在基本块内没有在 s 之前被定值，则这个运算分量对应的子结点就是代表该运算分量初始值的叶结点</li><li>在为语句 <code>x=y+z</code> 构造结点 N 的时候，如果 x 已经在某个结点 M 的定值变量表中，则从 M 的定制变量表中删除变量 x</li><li>对于形如 <code>x=y+z</code> 的三地址指令，如果已经有一个结点表示 <code>y+z</code> ，就不再图中添加新的结点，而是给已经存在的结点附加定值变量</li></ul></li><li>作用：<ul><li>用于删除公共子表达式——对于值已经改变的表达式，对应的是不同的结点，就不会做删除操作</li><li>用于删除无用代码——从一个 DAG 上删除所有没有附加活跃变量的根节点，重复应用这样的处理从而消除所有对应于无用代码的结点<ul><li>活跃变量：其值可能会在以后被使用的变量</li><li>根结点：没有父结点的结点</li></ul></li></ul></li></ul><p><strong>数组元素赋值指令的表示</strong></p><ul><li>对于 <code>a[j]=y</code> 的三地址指令，创建一个运算符 <code>[]=</code> 的结点，这个结点有三个字节点 <code>a, j, y</code></li><li>该结点没有定值变量表</li><li>该结点的创建将杀死所有已经建立的其值依赖于 a 的结点</li><li>一个被杀死的结点不能再获得任何定值变量，也就是不能成为一个公共子表达式</li></ul><p><strong>基本块的DAG可以获得有用信息</strong></p><ul><li>确定那些变量的值在该基本块中赋值前被引用过，在DAG中创建了叶结点的那些变量</li><li>确定那些语句计算的值可以在基本块外被引用，在DAG构造过程中为语句 s 创建的结点 N，在DAG构造结束时 x 仍然是 N 的定值变量</li></ul><p><strong>根据DAG重组基本块</strong></p><ul><li>对每个具有若干定值变量的结点，构造一个三地址语句来计算其中某个变量的值<ul><li>倾向于把计算得到的结果赋值给一个在基本块出口处活跃的变量（如果没有全局活跃变量的信息作为依据，就要假设所有变量都在基本块出口处活跃，但是不包含编译器为处理表达式而生成的临时变量）</li></ul></li><li>如果结点有多个附加的活跃变量，就必须引入复制语句，以便给每一个变量都赋予正确的值</li></ul><h3 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h3><p><strong>概念</strong></p><p>一组用来获取程序执行路径上的数据流信息的技术，在每一种数据流分析应用中，都会把每个程序点和一个数据流值关联起来</p><p><strong>应用</strong></p><ul><li>到达-定值分析</li><li>活跃变量分析</li><li>可用表达式分析</li></ul><p><strong>语句中的数据流分析模式</strong></p><ul><li>IN[s]：语句 s 之前的数据流值</li><li>OUT[s]：语句 s 之后的数据流值</li><li>$f_s$ ：语句 s 的传递函数<ul><li>一个赋值语句 s 之前和之后的数据流值得关系</li><li>传递函数两种风格：<ul><li>信息沿执行路径前向传播（前向数据流问题） $OUT[s]=f_s(IN[s])$</li><li>信息沿执行路径逆向传播（逆向数据流问题） $IN[s]=f_s(OUT[s])$</li></ul></li></ul></li><li>基本块中相邻两个语句之间的数据流值的关系<ul><li>$IN[s_{i+1}]=OUT[s_i]$</li></ul></li></ul><p><strong>基本块中的数据流分析模式</strong></p><ul><li>IN[B]：紧靠基本块 B 之前的数据流值</li><li>OUT[B]：紧随基本块 B 之后的数据流值</li><li>对于基本块中的语句 $s_1,..,s_n$，有<ul><li>$IN[B]=IN[s_1]$</li><li>$OUT[B]=OUT[s_n]$</li></ul></li><li>$f_B$ ：基本块 B 的传递函数<ul><li>前向数据流问题： $OUT[s]=f_B(IN[s])$，其中 $f_B=f_{sn}<em>…</em>f_{s1}$</li><li>逆向数据流问题： $IN[s]=f_B(OUT[s])$，其中 $f_B=f_{s1}<em>…</em>f_{sn}$</li></ul></li></ul><h3 id="到达定值分析"><a href="#到达定值分析" class="headerlink" title="到达定值分析"></a>到达定值分析</h3><p><strong>定值</strong></p><p>变量的定值是（可能）将一个值赋给该变量的语句</p><p><strong>到达定值</strong></p><p>如果存在一条从紧跟在 x 的定值 d 后面的点到达某一程序点 p 的路径，而且在此路径上 d 没有被杀死（如果此路径上有对变量 x 的其它定值 d’ ，则称定值 d 被定值 d’ 杀死了），则称定值 d 到达程序点 p</p><p>直观的讲，如果某个变量 x 的一个定值 d 到达点 p，在点 p 处使用的 x 的值可能就是由 d 最后赋予的</p><p><strong>用途</strong></p><ul><li>循环不变计算的检测：如果循环中含有赋值语句 <code>x=y+z</code> ，而 y 和 z 的所有可能的定值都在循环外，那么 <code>y+z</code> 就是循环不变计算</li><li>常量合并：如果对于一个变量的某次使用只有一个定值可以到达，并且该定值把一个常量赋给该变量，就可以把该变量替换为常量</li><li>判断变量 x 在 p 点上是否未经定值就被引用</li></ul><p><strong>生成与杀死定值</strong></p><p>对于定值 <code>d: u=v+w</code> 生成了一个对变量 u 的定值，并且杀死了程序中其它对 u 的定值</p><p><strong>到达定值的传递函数</strong></p><ul><li>$f_d$：定值 <code>d: u=v+w</code> 的传递函数<ul><li>$f_d(x)=gen_d \cup (x-kill_d)$ ——生成-杀死形式</li><li>$gen_d$ ： 由语句 d 生成的定值的集合 $gen_d=\{d\}$</li><li>$kill_d$ ：由语句 d 杀死的定值的集合（程序中所有其它对 u 的定值）</li></ul></li><li>$f_B$ ：基本块 B 的传递函数<ul><li>$f_B(x)=gen_B\cup (x-kill_B)$</li><li>$kill_B=kill_1\cup kill_2\cup…\cup kill_n$ 基本块 B 中各个语句杀死的定值的集合</li><li>$gen_b=gen_n\cup (gen_{n-1}-kill_n)\cup … \cup (gen_1-kill_1-kill_2-…-kill_n)$ 基本块中没有被块中各语句杀死的定值的集合</li></ul></li></ul><p><strong>到达定值的数据流方程</strong></p><ul><li>$IN[B]$ ：到达流图中基本块 B 的入口处的定值的集合</li><li>$OUT[B]$ ：到达流图中基本块 B 的出口处的定值的集合</li><li>$OUT[B]=\left\{\begin{aligned}&amp;\Phi&amp;&amp;B=ENTRY\\&amp;f_B(IN[B])=gen_B\cup (IN[B]-kill_B)&amp;&amp;B \not = ENTRY\end{aligned}\right.$</li><li>$IN[B]=\left\{\begin{aligned}&amp;\Phi&amp;&amp;B=ENTRY\\&amp;\cup_{P是B的一个前驱}OUT[P]&amp;&amp;B \not = ENTRY\end{aligned}\right.$</li><li>$gen_B$ 和 $kill_B$ 是可以直接从流图中计算出来的，在方程中作为已知量</li></ul><h3 id="到达定值方程的计算"><a href="#到达定值方程的计算" class="headerlink" title="到达定值方程的计算"></a>到达定值方程的计算</h3><p><strong>计算到达定值的迭代算法</strong></p><ul><li>输入：流图 G，其中每个基本块 B 的 $gen_B$ 和 $kill_B$ 都已计算出来</li><li>输出： $IN[B]~~OUT[B]$</li><li><p>方法：</p><p>  $OUT[ENTRY]=\Phi;\\for(除了ENTRY之外的每个基本块B)OUT[B]=\Phi;\\while(某个OUT值发生了改变)\~<del>~for(除ENTRY之外的每个基本块B)\{\\</del><del>~</del>~IN[B]=\cup_{P是B的一个前驱}OUT[P];\~<del>~</del><del>OUT[B]=gen_B\cup (IN[B]-kill_B)\\</del>~~\}$</p></li></ul><p><strong>引用—定值链</strong></p><ul><li>引用-定值链（ud链）是一个列表，对于变量的每一次引用，到达该引用的所有定值都在该列表中</li><li>建立<ul><li>如果块 B 中变量 a 的引用之前有 a 的定值，那么只有 a 的最后一次定值会在该引用的 ud链 中</li><li>如果块 B 中变量 a 的引用之前没有 a 的定值，那么 a 的这次引用的 ud链 就是 IN[B] 中 a 的定值的集合</li></ul></li></ul><h3 id="活跃变量分析"><a href="#活跃变量分析" class="headerlink" title="活跃变量分析"></a>活跃变量分析</h3><p><strong>活跃变量</strong></p><p>对于变量 x 和程序点 p，如果在流图中沿着从 p 开始的某条路径会引用变量 x 在 p 点的值，则称变量 x 在点 p 是活跃的，否则称变量 x 在点 p 不活跃</p><p><strong>活跃变量信息的主要用途</strong></p><ul><li>删除无用赋值<ul><li>无用赋值：如果 x 在点 p 的定值在基本块内的所有后继点都不被引用，且 x 在基本块出口之后又是不活跃的，那么 x 在点 p 得到定值就是无用的</li></ul></li><li>为基本块分配寄存器<ul><li>如果所有寄存器都被占用，并且还要申请一个寄存器，则应该考虑使用已经存放了死亡值得寄存器，因为这个值不需要保存到内存</li><li>如果一个值在基本块结尾处是死的就不必给它分配寄存器在结尾处保存这个值</li></ul></li></ul><p><strong>活跃变量的传递函数</strong></p><ul><li>逆向数据流问题： $IN[B]=f_B(OUT[B])$</li><li>$f_B(x)=use_B\cup (x-def_B)$：一个变量在基本块中的出现无非是定值和引用两种形式<ul><li>$def_B$：在基本块 B 中定值，但是定值前在 B 中没有被引用的变量的集合</li><li>$use_B$：在基本块 B 中引用，但是引用前在 B 中没有被定值的变量的集合</li></ul></li></ul><p><strong>活跃变量的数据流方程</strong></p><ul><li>$IN[B]$：在基本块 B 的入口处的活跃变量集合</li><li>$OUT[B]$：在基本块 B 的出口处的活跃变量集合</li><li>方程：<ul><li>$IN[B]=\left\{\begin{aligned}&amp;\Phi&amp;&amp;B=EXIT\\&amp;f_B(OUT[B])=use_B\cup (OUT[B]-def_B)&amp;&amp;B\not=EXIT\end{aligned}\right.$</li><li>$OUT[B]=\cup_{S是B的一个后继}IN[S]<del>~</del>B\not=EXIT$</li><li>其中 $use_B$ 和 $def_B$ 的值可直接从流图中计算出来，因此在方程中为已知量</li></ul></li></ul><p><strong>计算活跃变量的迭代算法</strong></p><ul><li>输入：流图G，其中每个基本块 B 的 $use_B$ 和 $def_B$ 都已经计算出来了</li><li>输出： $IN[B]~~OUT[B]$</li><li><p>方法：</p><p>  $IN[EXIT]=\Phi\\for(除EXIT之外的每个基本块B)IN[B]=\Phi;\\while(某个IN值发生了改变)\~~for(除EXIT之外的每个基本块B)\{\~<del>~OUT[B]=\cup_{S是B的一个后继}IN[S];\\</del><del>IN[B]=use_B\cup(OUT[B]-def_B);\\</del>\}$</p></li></ul><p><strong>定值-引用链</strong></p><ul><li>设变量x有一个定值d，该定值所有能够到达的引用 u 的集合称为 x 在 d 处的定值-引用链，简称du链</li><li>如果在求解活跃变量数据流方程中的 $OUT[B]$ 时，将 $OUT[B]$ 表示成从 B 的末尾处能够到达的引用的集合，那么，可以直接利用这些信息计算基本块 B 中每个变量 x 在其定值处的 du链<ul><li>如果 B 中 x 的定值 d 之后有 x 的第一个定值 d‘，则 d 和 d’ 之间 x 的所有引用构成 d 的 du链</li><li>如果 B 中 x 的定值 d 之后没有 x 的新的定值，则 B 中 d 之后 x 的所有引用以及 $OUT[B]$ 中 x 的所有引用构成 d 的 du 链</li></ul></li></ul><h3 id="可用表达式分析"><a href="#可用表达式分析" class="headerlink" title="可用表达式分析"></a>可用表达式分析</h3><p><strong>可用表达式</strong></p><p>如果从流图的首结点到达程序点 p 的每条路径都对表达式 <code>x op y</code> 进行计算，并且从最后一个这样的计算到点 p 之间没有再次对 x 或 y 定值，那么表达式 <code>x op y</code> 在点 p 是可用的</p><p><strong>直观意义</strong></p><p>在点 p 上， <code>x op y</code> 已经在之前被计算过，不需重新计算</p><p><strong>主要用途</strong></p><ul><li>消除全局公共子表达式</li><li>进行复制传播</li></ul><p><strong>可用表达式的传递函数</strong></p><ul><li>对于可用表达式数据流模式而言，如果基本块 B 对 x 或者 y 进行了（或可能进行）定值，且以后没有重新计算 <code>x op y</code> ，则称 B 杀死表达式 <code>x op y</code> 。如果基本块 B 对 <code>x op y</code> 进行计算，并且之后没有重新定值 x 或 y，则称 B 生成表达式 <code>x op y</code></li><li>$f_B(x)=e_gen_B\cup (x-e_kill_B)$<ul><li>$e_gen_B$：基本块 B 所生成的可用表达式的集合</li><li>$e_kill_B$：基本块 B 所杀死的 U 中的可用表达式的集合</li><li>U：所有出现在程序中一个或多个语句的右部表达式的全集</li></ul></li><li>$e_gen_B$ 的计算<ul><li>初始化 $e_gen_B=\emptyset$</li><li>顺序扫描基本块的每个语句： <code>z=x op y</code> ，下面的顺序不能变<ul><li>把 <code>x op y</code> 加入 $e_gen_B$ 中</li><li>从 $e_gen_B$ 中删除和 z 相关的表达式</li></ul></li></ul></li><li>$e_kill_B$ 的计算<ul><li>初始化 $e_kill_B=\Phi$</li><li>顺序扫描基本块的每个语句： <code>z = x op y</code><ul><li>从 $e_kill_B$ 中删除表达式 <code>x op y</code></li><li>把所有和 z 相关的表达式加入 $e_kill_B$ 中</li></ul></li></ul></li></ul><p><strong>可用表达式的数据流方程</strong></p><ul><li>$IN[B]$ ：在 B 的入口处可用的 U 中的表达式的集合</li><li>$OUT[B]$ ：在 B 的出口处可用的 U 中表达式的集合</li><li>方程：<ul><li>$OUT[B]=\left\{\begin{aligned}&amp;\Phi&amp;&amp;B=ENTRY\\&amp;f_B(IN[B])=e_gen_B\cup (IN[B]-e_kill_B)&amp;&amp;B\not=ENTRY\end{aligned}\right.$</li><li>$IN[B]=\cap_{P是B的一个前驱}OUT[P]<del>~</del>B\not=ENTRY$</li><li>$e_gen_B$ 和 $e_kill_B$ 的值可以直接从流图中计算出来，因此在方程中作为已知量</li></ul></li></ul><p><strong>计算可用表达式的迭代算法</strong></p><ul><li>输入：流图 G，其中每个基本块 B 的 $e_gen_B$ 和 $e_kill_B$ 都已计算出来</li><li>输出： $IN[B]~~OUT[B]$</li><li><p>方法：</p><p>  $OUT[ENTRY]=\Phi\\for(除ENTRY之外的每个基本块B)OUT[B]=U;\\while(某个OUT值发生了改变)\~~for(除ENTRY之外的每个基本块B)\{\~<del>~IN[B]=\cap_{P是B的一个前驱}OUT[P];\\</del><del>OUT[B]=e_gen_B\cup(IN[B]-e_kill_B);\\</del>\}$</p></li><li><p>为什么将 $OUT[B]$ 集合初始化为 U ——将 OUT 集合初始化为空集局限性太大</p><ul><li>例子：</li><li>如果 $OUT[B_2]^0=\Phi$，则 $IN[B_2]^1=OUT[B_1]^1\cap OUT[B_2]^0=\Phi$</li><li>如果 $OUT[B_2]^0=U$，则 $IN[B_2]^1=OUT[B_1]^1\cap OUT[B_2]^0=OUT[B_1]^1$</li></ul></li></ul><h3 id="支配结点和回边"><a href="#支配结点和回边" class="headerlink" title="支配结点和回边"></a>支配结点和回边</h3><p><strong>支配结点</strong></p><ul><li>概念：如果从流图的入口结点到结点 n 的每条路径都经过结点 d，则称结点 d 支配结点 n，记作 <code>d dom n</code> ，并且每个结点都支配自己，但是对于分支上的结点，只支配自己，一个结点可以有多个支配结点</li><li>支配结点树：通常使用支配结点树来表示流图中的支配关系，在树中，每个结点只支配自己和后代结点</li><li>直接支配结点：从入口处到达 n 的多有路径上，结点 n 的最后一个支配结点称为直接支配结点</li><li><p>寻找支配结点：是一个数据流问题</p><ul><li>$IN[B]$ ：在基本块 B 入口处的支配结点的集合</li><li>$OUT[B]$ ：在基本块 B 出口处的支配结点的集合</li><li><p>方程：</p><p>  $OUT[B]=\left\{\begin{aligned}&amp;\{ENTRY\}&amp;&amp;B=ENTRY\\&amp;IN[B]\cup \{B\}&amp;&amp;B\not= ENTRY\end{aligned}\right.$</p></li></ul></li></ul><p><strong>计算支配结点的迭代算法</strong></p><ul><li>输入：流图 G，G 的结点集是 N，边集是 E，入口结点是 ENTRY</li><li>输出：对于 N 中的各个结点 n，给出 D(n)，即支配 n 的所有结点的集合</li><li><p>方法：</p><p>  $OUT[ENTRY]=\{ENTRY\}\\for(除ENTRY之外的每个基本块B)OUT[B]=N;\\while(某个OUT值发生了改变)\~~for(除ENTRY之外的每个基本块B)\{\~<del>~IN[B]=\cap_{P是B的一个前驱}OUT[P];\\</del>OUT[B]=IN[B]\cup \{B\};\\\}$</p></li></ul><p><strong>回边</strong></p><p>假定流图中存在两个结点 d 和 n 满足 <code>d dom n</code> 。如果存在从结点 n 到 d 的有向边 n→d，那么这条边称为回边</p><h3 id="自然循环及其识别"><a href="#自然循环及其识别" class="headerlink" title="自然循环及其识别"></a>自然循环及其识别</h3><p><strong>自然循环</strong></p><p>从程序分析的角度来看，循环在代码中以什么形式出现并不重要，重要的是它是否具有易于优化的性质，是一种适合于优化的循环</p><p>满足以下性质：</p><ul><li>有<strong>唯一</strong>的入口结点，称为首结点，首结点支配循环中的所有结点，否则，它就不会成为循环的唯一入口</li><li>循环中至少有一条返回首结点的路径，否则，控制就不可能从循环中直接回到循环头，也就无法构成循环</li></ul><p>重要性质：</p><p>除非两个自然循环的首结点相同，否则，它们或者互不相交，或者一个完全包含在另一个里面</p><p>最内循环：不包含其它循环的循环</p><p>如果两个循环具有相同的首结点，把两个循环合并</p><p><strong>自然循环的识别</strong></p><ul><li>给定一个回边 n→d，该回边的自然循环为：d，以及所有可以不经过 d 而到达 n 的结点。d 为该循环的首结点</li></ul><p><strong>构造一条回边的自然循环算法</strong></p><ul><li>输入：流图 G 和回边 n→d</li><li>输出：由回边 n→d 的自然循环中的所有结点组成的集合</li><li><p>方法</p><p>  $stack=\Phi;loop=\{n,d\};push(stack, n);\\while~stack不为空~do\{\~~m=top(stack);pop(stack);\~~for(m的每一个前驱p\{\~<del>~if~p不在loop中~then\{\\</del><del>~~loop=loop=\cup \{P\};\\</del><del>~~push(stack, p);\\</del><del>\}\\</del>\}\\\}$</p></li><li><p>结点 d 在初始时刻已经在 loop 中，不会去考虑它的前驱，因此找到的都是不经过 d 而能到达 n 的结点</p></li></ul><h3 id="删除全局公共子表达式和复制语句"><a href="#删除全局公共子表达式和复制语句" class="headerlink" title="删除全局公共子表达式和复制语句"></a>删除全局公共子表达式和复制语句</h3><p><strong>删除全局公共子表达式</strong></p><p>可用表达式的数据流问题可以帮助确定位于流图中 p 点的表达式是否为全局公共子表达式</p><p><strong>删除全局公共子表达式算法</strong></p><ul><li>输入：带有可用表达式信息的流图</li><li>输出：修正后的流图</li><li>方法：对于语句 <code>s : z = x op y</code> ，如果 <code>x op y</code> 在 s 之前可用，那么执行如下步骤<ol><li>从 s 开始逆向搜索，但不穿过任何计算了 <code>x op y</code> 得到块，找到所有离 s 最近的计算了 <code>x op y</code> 的语句</li><li>建立新的临时变量 u</li><li>把步骤 1 中找到的语句 <code>w = x op y</code> 用 <code>u = x op y  w = u</code> 代替</li><li>用 <code>z = u</code> 代替 s</li></ol></li></ul><p><strong>删除复制语句</strong></p><ul><li>对于复制语句 <code>s: x = y</code> ，如果在 x 的所有引用点都可以用对 y 的引用代替对 x 的引用（复制传播），那么可以删除复制语句 <code>x = y</code></li><li>在 x 的引用点 u 用 y 代替 x （复制传播）的条件：复制语句 <code>s:x=y</code> 在 u 点可用</li></ul><p><strong>删除复制语句的算法</strong></p><ul><li>输入：流图 G，du链，个基本块 B 入口处的可用复制语句集合</li><li>输出：修改后的流图</li><li>方法：对于每个复制语句 <code>s : x = y</code> ，如果 <code>x op y</code> 在 s 之前可用，那么执行如下步骤<ol><li>根据 du 链找出该定值所能够到达的那些对 x 的引用</li><li>确定是否对于每个这样的引用， <code>x = y</code> 都在 $IN[B]$ 中（B 是包含这个引用的基本块），并且 B 中该引用的前面没有 x 或者 y 的定值</li><li>如果 <code>x = y</code> 满足步骤 2 的条件，删除 <code>x = y</code> ，并且把步骤 1 中找到的对 x 的引用用 y 代替</li></ol></li></ul><h3 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h3><ul><li>循环不变计算的检测</li><li>代码外提</li></ul><p><strong>循环不变计算检测算法</strong></p><ul><li>包括三种情况<ul><li>这个运算分量是个常数</li><li>这个分量的所有定制点都在循环之外</li><li>这个运算分量只有一个到达定值，并且是在循环内，并且该到达定值本身就是循环的一个不变计算</li></ul></li><li>输入：循环L，每个三地址指令的 ud 链</li><li>输出：L的循环不变计算语句</li><li>方法<ol><li>将下面这样的语句标记为“不变”，语句的运算分量或者是常数，或者其所有定值点都在循环 L 外部</li><li>重复执行步骤 3，直到某次没有新的语句可标记为“不变”为止</li><li>将下面这样的语句标记为 “不变”：先前没有被标记过，且所有运算或者是常数，或者其所有定值点都在循环 L 的外部，或者只有一个到达定值点，该定值是循环中已经被标记为”不变“的语句</li></ol></li></ul><p><strong>循环不变计算语句 <code>s:x = y op z</code> 的移动条件</strong></p><ol><li>s 所在的基本块是循环所有出口结点（有后继结点在循环外的结点）的支配结点</li><li>循环中没有其他语句对 x 赋值</li><li>循环中对 x 的引用仅由 s 到达</li></ol><p><strong>代码移动算法</strong></p><ul><li>输入：循环 L，ud 链，支配结点信息</li><li>输出：修改后的循环</li><li>方法：<ol><li>寻找循环不变计算</li><li>对于步骤 1 中找到的每个循环不变计算，检查是否满足上面的三个条件</li><li>按照循环不变计算找出的次序，把所有找到的满足上述条件的循环不变计算外提到前置首结点中。如果循环不变计算由分量在循环中定值，只有将定值点外提之后，该循环不变计算才可以外提</li></ol></li></ul><h3 id="作用于归纳变量的强度削弱"><a href="#作用于归纳变量的强度削弱" class="headerlink" title="作用于归纳变量的强度削弱"></a>作用于归纳变量的强度削弱</h3><p><strong>归纳变量</strong></p><p>对于一个变量 x，如果存在一个正的或负的常量 c，使得每次 x 被赋值时，它的值总是增加 c，则称 x 为归纳变量</p><p><strong>基本归纳变量</strong></p><p>如果循环 L 中的变量 i 只有形如 <code>i = i + c</code> 的定值（c是常量），则称 i 为循环 L 的基本归纳变量</p><p>如果 <code>j = c x i + d</code> ，其中 i 是基本归纳变量，c 和 d 是常量，则 j 也是一个归纳变量，称 j 属于 i 族</p><p>每个归纳变量都关联着一个三元组。如果 <code>j = c x i + d</code> ，其中 i 是基本归纳变量，c 和 d 是常量，则于 j 相关联的三元组是 <code>(i,c,d)</code></p><p><strong>归纳变量</strong></p><ul><li>输入：带有循环不变计算信息和到达定值信息的循环 L</li><li>输出：一组归纳变量</li><li>方法：<ol><li>扫描 L 的语句，找出所有基本归纳变量。在此要用到循环不变计算信息。与每个基本归纳变量 i 相关联的三元组 <code>(i,1,0)</code></li><li>寻找 L 中只有一次定值的变量 k，它具有下面的形式： <code>k=c&#39;xj+d&#39;</code> 。其中 c’ 和 d’ 是常量，j 是基本的或非基本的归纳变量<ol><li>如果 j 是基本归纳变量，那么 k 属于 j 族。k 所对应的三元组可以通过其定值语句确定</li><li>如果 j 不是基本归纳变量，假设其属于 i 族，k 的三元组可以通过 j 的三元组和 k 的定值语句来计算，为了保证对 k 进行赋值时，j 当时的值一定的关于 c *(i 当前值) + d 此时还要求：<ol><li>循环 L 中对 j 的唯一定值和对 k 的定值之间没有对 i 的定值</li><li>循环 L 外没有 j 的定值可以到达 k</li></ol></li></ol></li></ol></li></ul><p><strong>作用于归纳变量的强度削弱算法</strong></p><ul><li>输入：带有到达定值信息和已计算出的归纳变量族的循环 L</li><li>输出：修改后的循环</li><li>方法：对于每个基本归纳变量 i，对其族中的每个归纳变量 j： <code>(i,c,d)</code><ol><li>建立新的临时变量 t。如果变量 j1 和 j2 具有相同的三元组，则只为它们建立一个新的变量</li><li>用 j=t 代替对 j 的赋值</li><li>在 L 中紧跟定值 i=i+n 之后，添加 t=t+c*n。将 t 放入 i 族，其三元组为 <code>(i,c,d)</code></li><li>在前置节点的末尾，添加语句 <code>t=c*i</code> 和 <code>t=t+d</code> ，使得在循环开始的时候 <code>t=c*i+d=j</code></li></ol></li></ul><h3 id="归纳变量的删除"><a href="#归纳变量的删除" class="headerlink" title="归纳变量的删除"></a>归纳变量的删除</h3><ul><li>对于在强度削弱算法中引入的复制语句 j = t，如果在归纳变量 j 的所有引用点都可以用对 t 的引用代替对 j 的引用，并且 j 在循环的出口处不活跃，则可以删除复制语句 j = t</li><li>强度虚弱之后，有些归纳变量的作用只是用于测试。如果可以用对其它归纳变量的测试代替对这种归纳变量的测试，那么可以删除这种归纳变量</li></ul><p><strong>删除仅用于测试的归纳变量</strong></p><ul><li>对于仅用于测试的简单基本归纳变量 i，取 i 族的某个归纳变量 j（尽量使得 c，d 简单，即 c=1 或者 d=0 的情况）。把么个对 i 的测试替换成对 j 的测试<ul><li><code>(relop i x B)</code> 替换成 <code>(relop j c*x+d B)</code>，其中 x 不是归纳变量，并假设 c&gt;0</li><li><code>(relop i1 i2 B)</code>，如果能够找到三元组 <code>j1(i1, c, d)</code> 和 <code>j2(i2, c, d)</code> ，那么可以将其替换为 <code>(relop j1 j2 B)</code> (假设 c&gt;0)。否则测试的替换可能是没有价值的</li></ul></li><li>如果归纳变量 i 不再被引用，那么可以删除和它相关的指令</li></ul><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><h3 id="代码生成器的主要任务"><a href="#代码生成器的主要任务" class="headerlink" title="代码生成器的主要任务"></a>代码生成器的主要任务</h3><ul><li>指令选择：选择适当的目标机指令来实现中间表示(IR)语句</li><li>寄存器的分配和指派：把哪个值放在哪个寄存器中，寄存器是计算机中运算速率最快的计算单元，要比内存中的运行的快，但是寄存器数目是有限的</li><li>指令排序：按照什么顺序来安排指令的执行，来使运行效率更高</li></ul><h3 id="一个简单的目标机模型"><a href="#一个简单的目标机模型" class="headerlink" title="一个简单的目标机模型"></a>一个简单的目标机模型</h3><p><strong>三地址机器模型</strong></p><ul><li>加载，保存，运算，跳转等操作</li><li>内存按字节寻址</li><li>n 个通用寄存器 R0,…Rn-1</li><li>假设所有运算分量都是整数</li><li>指令之间可能有一个标号</li></ul><p><strong>主要指令</strong></p><ul><li>加载指令： <code>LD, dst, addr</code></li><li>保存指令： <code>ST dst, addr</code></li><li>运算指令： <code>OP dst, src1, src2</code></li><li>无条件跳转： <code>BR L</code></li><li>条件跳转指令： <code>Bcond r, L</code></li></ul><p><strong>寻址模式</strong></p><ul><li>变量名 a</li><li><code>a(r)</code> 就是 <code>contents(a所表示的地址 + contents(r))</code></li><li><code>c(r)</code> 就是 <code>contents(c常量偏移地址 + contents(r))</code></li><li><code>*r</code> 间接寻址 <code>contents(contents(contents(r)))</code></li><li><code>*c(r)</code> 就是 <code>contents(contents(c常量偏移地址 + contents(r)))</code></li><li><code>#c</code> 常数寻址，就是直接加载常数</li></ul><h3 id="指令选择"><a href="#指令选择" class="headerlink" title="指令选择"></a>指令选择</h3><p>为中间语句选择合适的目标指定序列</p><p><strong>运算语句的目标代码</strong></p><p>三地址语句 <code>x=y op z</code></p><p>目标代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LD R1, y</span><br><span class="line">LD R2, z</span><br><span class="line">OP R1, R1, R2</span><br><span class="line">ST x, R1</span><br></pre></td></tr></table></figure><p><strong>数组寻址语句的目标代码</strong></p><p>三地址语句 <code>b = a[i]</code></p><p>目标代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LD R1, i</span><br><span class="line">MUL R1, R1, a.width</span><br><span class="line">LD R2, a(R1)</span><br><span class="line">ST b, R2</span><br></pre></td></tr></table></figure><p>三地址语句 <code>a[i]=b</code></p><p>目标代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LD R1, b</span><br><span class="line">LD R2, i</span><br><span class="line">MUL R2, R2, a.width</span><br><span class="line">ST a(R2), R1</span><br></pre></td></tr></table></figure><p><strong>指针存取语句的目标代码</strong></p><p>三地址语句 <code>s=*p</code></p><p>目标代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LD R1, p</span><br><span class="line">LD R2, 0(R1)</span><br><span class="line">ST x, R2</span><br></pre></td></tr></table></figure><p>三地址语句 <code>*p=s</code></p><p>目标代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LD R1, p</span><br><span class="line">LD R2, s</span><br><span class="line">ST 0(R1), R2</span><br></pre></td></tr></table></figure><p><strong>条件跳转语句的目标代码</strong></p><p>三地址语句 <code>if x &lt; y goto L</code></p><p>目标代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LD R1, x</span><br><span class="line">LD R2, y</span><br><span class="line">SUB R1, R1, R2</span><br><span class="line">BLTZ R1, M </span><br></pre></td></tr></table></figure><p>其中 M 是标号为 L 的三地址指令所产生的目标代码中的第一个指令的标号</p><p><strong>过程调用和返回的目标代码</strong></p><ul><li><p>静态存储分派：在活动记录存储过程中使用的是绝对地址</p><p>  三地址语句 call callee</p><p>  目标代码</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ST callee.staticArea, #here + 20</span><br><span class="line">BR callee.codeArea</span><br></pre></td></tr></table></figure><p>  其中 staticArea 是 callee 的活动记录在静态区中的起始位置</p><p>  codeArea 是 callee 的目标代码在代码区中的起始位置</p><p>  <code>#here+20</code> 就是跳转指令 BR 的下一条地址</p><p>  三地址语句：return</p><p>  目标代码</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BR *callee.staticArea</span><br></pre></td></tr></table></figure></li><li><p>栈式存储分配：在活动记录存储过程中使用的是相对地址，只有运行中才能知道地址，通常存放在寄存器 SP 中</p><p>  三地址语句：call callee</p><p>  目标代码</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD SP, SP, #caller.recordsize</span><br><span class="line">ST 0(SP), #here + 16</span><br><span class="line">BR callee.codeArea</span><br></pre></td></tr></table></figure><p>  三地址语句：return</p><p>  目标代码</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被调用过程：BR *0(SP)</span><br><span class="line">调用过程：SUB SP, SP, #caller.recordsize</span><br></pre></td></tr></table></figure></li></ul><h3 id="寄存器的选择"><a href="#寄存器的选择" class="headerlink" title="寄存器的选择"></a>寄存器的选择</h3><p>有效的利用寄存器对代码生成很重要</p><p><strong>三地址语句的目标代码生成</strong></p><p>对每个形如 <code>x = y op z</code> 的三地址指令 I，执行如下动作</p><ul><li>调用函数 <code>getreg(I)</code> 来为 x，y，z 选择寄存器，把这些寄存器成为 Rx，Ry，Rz</li><li>如果 Ry 中存放的不是 y，则生成指令 <code>LD Ry, y‘</code> 。y’ 是存放 y 的内存位置之一</li><li>类似的，如果 Rz 中存放的不是 z，则生成指令 <code>LD Rz, z&#39;</code></li><li>生成目标指令 <code>OP Rx, Ry, Rz</code></li></ul><p><strong>寄存器描述符</strong></p><p>记录每个寄存器当前存放的是哪些变量的值</p><p><strong>地址描述符</strong></p><p>记录运行时每个名字的当前值存放在哪个或哪些位置</p><p>该位置可能是寄存器，栈单元，内存地址或者是它们的某个集合</p><p>这些信息可以存放在该变量名对应的符号表条目中</p><p><strong>基本块的收尾处理</strong></p><p>对于一个在基本块出口处可能活跃的变量 x，如果它的地址描述符表明它的值没有存放在 x 的内存位置上，则生成指令 <code>ST x, R</code> （R是在基本块结尾处存放 x 值的寄存器）</p><p><strong>管理寄存器和地址描述符</strong></p><p>当代码生成算法生成加载，保存和其它指令时，它必须同时更新寄存器和地址描述符</p><h3 id="寄存器选择函数-getreg-设计"><a href="#寄存器选择函数-getreg-设计" class="headerlink" title="寄存器选择函数 getreg 设计"></a>寄存器选择函数 getreg 设计</h3><p><strong>寄存器选择函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[开始]--&gt;B&#123;y在某R中&#125;--&gt;|Y|C[结束]</span><br><span class="line">B--&gt;|N|D&#123;有空R吗&#125;--&gt;|Y|C</span><br><span class="line">D--&gt;|N|E(计算每个候选的R的费用（需要生成保存指令的个数），选择费用最低一个)--&gt;C</span><br></pre></td></tr></table></figure><p><strong>计算R的费用</strong></p><p><code>x = y op z</code> 中对 Ry 的选择</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[开始]--&gt;B[cost=0</span><br><span class="line">n=R中存放的变量 v 的个数 </span><br><span class="line">i=1]--&gt;C&#123;vi是否还保存在R在外的某处&#125;--&gt;|Y|D[cost++]--&gt;E&#123;i==n?&#125;--&gt;|y|F[输出cost]--&gt;G((结束))</span><br><span class="line">C--&gt;|N|H&#123;vi是x?&#125;--&gt;|Y|I&#123;x是z?&#125;--&gt;|Y|J&#123;vi在此之后是否还使用&#125;--&gt;|Y|D</span><br><span class="line">J--&gt;|N|E</span><br><span class="line">I--&gt;|N|E</span><br><span class="line">H--&gt;|N|J</span><br><span class="line">E--&gt;|N|L[i++]--&gt;C</span><br></pre></td></tr></table></figure><p>对于寄存器 Rx 的选择与 Ry 类似，区别之处在于</p><ul><li>因为 x 的一个新值正在被计算，因此只存放了 x 的值的寄存器对 Rx 来说总是可接受的，即使 x 就是 y 或者 z 之一（机器中允许一个指令中两个寄存器相同</li><li>如果 y 在这条指令之后不再使用，且（在必要时加载 y 之后）Ry 仅仅保存了 y 的值，那么 Ry 同时也可以用作 Rx。对 Z 和 Rz 也有类似的选择</li><li>对于复制指令 x = y，选择好 Ry 之后可以直接 Rx = Ry</li></ul><h3 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h3><p><strong>窥孔</strong></p><p>程序上的一个小的滑动窗口</p><p><strong>窥孔优化</strong></p><p>就是在优化的时候，检查目标指令的一个滑动窗口（即窥孔），并且只要有可能就在窥孔内使用更快或更短的指令来替换窗口中的指令序列，有些窥孔优化也适用于中间代码的优化</p><p><strong>具有窥孔优化特点的程序变换的例子</strong></p><ul><li>冗余指令删除<ul><li>消除冗余的加载和保存指令</li><li>消除不可达代码：一个紧跟在无条件跳转之后的不带标号的指令可以被删除</li></ul></li><li>控制流优化<ul><li>在代码中出现跳转到跳转指令的指令时，某些条件下使用一个跳转指令来代替</li></ul></li><li>代数优化：利用代数规则优化<ul><li>代数恒等式：消除无用的运算指令</li><li>强度削弱<ul><li>对于乘数是 2 的幂的定点数乘法（除法），用移位运算实现代家低</li><li>除数为常量的浮点数除法可以通过乘数为该常量倒数的乘法来求近似值</li></ul></li></ul></li><li>机器特有指令的使用<ul><li>充分利用目标系统的某些高效的特殊指令来提高代码效率</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/Design-Pattern">GitHub - Luo25177/Design-Pattern</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a><strong>设计原则</strong></h3><ol><li>依赖倒置原则<ul><li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定)，稳定的东西不应该依赖于变化的东西</li><li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)，稳定的东西不应该依赖于变化的东西</li><li>解决: 创建抽象类，之后的类依赖抽象类</li><li>依赖：例如A依赖B，在编译A的时候只有B存在才能编译成功 编译式依赖</li></ul></li><li>开放封闭原则<ul><li>对扩展开放，对更改关闭</li><li>类模块应该是可以扩展的，但是不可以修改</li></ul></li><li>单一职责原则<ul><li>一个类应该仅有一个引起它变化的原因，一个类不能放太多功能，也就是不能有太多的责任</li><li>变化的方向隐含着类的责任</li></ul></li><li>Liskov替换原则<ul><li>子类必须能够替换它们的基类(is-a)</li><li>继承表达类型抽象</li></ul></li><li>接口隔离原则<ul><li>不应该强迫客户程序依赖他们不用的方法</li><li>接口应该小而完备</li><li>真正有必要暴漏出去的方法才做成 public</li></ul></li><li>优先使用对象组合而不是类继承<ul><li>类继承通常为”白箱复用”，对象组合通常为”黑箱复用”</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高，父类对子类开放的太多</li><li>而对象组合只要求被组合的对象具有良好定义的接口，耦合度比较低</li></ul></li><li>封装变化点<ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧的产生不良影响，从而出现高层次的封装</li></ul></li><li>针对接口编程，而不是针对实现编程<ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li><li>客户程序无需获取对象的具体类型，只需要知道对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现”高内聚，松耦合”的类型设计方案</li></ul></li></ol><h3 id="设计模式是为了让程序具有更好的"><a href="#设计模式是为了让程序具有更好的" class="headerlink" title="设计模式是为了让程序具有更好的"></a>设计模式是为了让程序具有更好的</h3><ol><li>代码重用性，相同功能的代码不用多次编写</li><li>可读性，编程规范性，便于其他程序员阅读和理解</li><li>可扩展性，当需要增加新的功能时，非常方便</li><li>可靠性，当我们增加新的功能时对原来的功能没有影响</li></ol><h3 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h3><ol><li>单一职责原则<br>一类代码只负责一项职责<br>提高类的可读性可维护性<br>降低变更引起的风险</li><li>接口隔离原则<br>客户端不应该依赖不需要的接口，即一个类对另一个类的依赖应该建立最小的接口上</li><li>依赖倒转(转置)原则<br>高层模块不应该依赖底层模块<br>抽象不应该依赖细节，抽象的相较于细节的比较稳定<br>中心原则面向接口编程</li><li>里氏替换原则<br>子类中尽量不要重写父类的方法</li><li>开闭原则<br>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是修改代码，对扩展开放，对修改关闭</li><li>迪米特法则<br>一个类除了对外提供的public方法以外，不对外泄露任何信息<br>只与直接的朋友通信<br>降低类之间的耦合程度</li><li>合成复用原则<br>尽量使用合成/聚合的方式，而不是使用继承</li></ol><h3 id="抽象向下"><a href="#抽象向下" class="headerlink" title="抽象向下"></a>抽象向下</h3><ol><li>封装</li><li>继承</li><li>多态</li></ol><p>基类的析构函数写成虚函数</p><h2 id="C-的四种转换类型"><a href="#C-的四种转换类型" class="headerlink" title="C++的四种转换类型"></a>C++的四种转换类型</h2><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><strong>const_cast</strong></h3><p>去掉类型的 <code>const</code> 或者 <code>volatile</code> 属性</p><ul><li><code>const_cast&lt;目标类型&gt;(标识符)</code></li></ul><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>无条件转换，静态类型转换</p><ul><li>基类和子类之间的转换：其中子类指针转化为父类指针是安全的，但是父类指针转换为子类指针是不安全的</li><li>基本数据类型转换， <code>enum,struct,int char,float</code> 等， <code>static_cast</code> 不能进行无关类型(如非基类和子类)指针之间的转换</li><li>把任何类型的表达式转化为 <code>void</code> 类型</li><li><code>static_cast</code> 不能去掉类型的 <code>const</code>， <code>volatile</code> 属性</li></ul><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>有条件转换，动态类型转换，运行时检查类型安全(转换失败返回null)</p><ul><li>有条件转换，动态类型转换，运行时检查类型安全（转换失败返回NULL）：</li><li>将一个基类对象指针（或引用） <code>cast</code> 到继承类指针， <code>dynamic_cast</code> 会根据基类指针是否真正指向继承类指针来做相应处理， 即会作出一定的判断。</li><li>若对指针进行 <code>dynamic_cast</code> ，失败返回 <code>null</code> ，成功返回正常 <code>cast</code> 后的对象指针；</li><li>若对引用进行 <code>dynamic_cast</code> ，失败抛出一个异常，成功返回正常 <code>cast</code> 后的对象引用。</li><li><code>dynamic_cast</code> 在将父类cast到子类时，父类必须要有虚函数，否则编译器会报错。</li><li><code>dynamic_cast</code> 主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。</li><li>在类层次间进行上行转换时， <code>dynamic_cast和static_cast</code> 的效果是一样的；</li><li>在进行下行转换时， <code>dynamic_cast</code> 具有类型检查的功能，比 <code>static_cast</code> 更安全。</li></ul><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>仅重新解释类型，但是没有进行二进制的转换</p><ul><li>仅重新解释类型，但没有进行二进制的转换：</li><li>转换的类型必须是一个指针，应用、算术类型、函数指针或者成员指针。</li><li>在比特级别上进行转换，可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。但不能将非 <code>32bit</code> 的实例转成指针。</li><li>最普通的用途就是在函数指针类型之间进行转换。</li><li>很难保证移植性。</li></ul><h2 id="类的继承特点"><a href="#类的继承特点" class="headerlink" title="类的继承特点"></a>类的继承特点</h2><div class="table-container"><table><thead><tr><th>类成员\继承方式</th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td>基类的public成员</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的protected成员</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的private成员</td><td>在派生类中不可见</td><td>在派生类中不可见</td><td>在派生类中不可见</td></tr></tbody></table></div><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元函数: 如果在本类以外的其他地方定义的函数, 在类体重用 friend 进行声明. 此函数就称为本类的有元函数, 友元函数可以访问这个类中的私有成员</p><p>友元类: 类 A 将另一个类 B 声明为其友元类, 友元类 B 中的所有函数都是 A 类的友元函数, 可以访问 A 类中的所有成员</p><ul><li>友元关系不能被继承。</li><li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li><li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</li></ul><hr><h1 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h1><p>子类可以使用父类指针来表示，所以类一般都声明为指针，指针具有多态性，变量要声明成基类，虚函数是运行时依赖。</p><p><code>c++</code> 中构造函数如果调用虚函数的话就是一种静态绑定，不是动态绑定，原因：如果在基类的构造函数中调用虚函数的话，那么在子类创建时会先调用基类的构造函数，基类的构造函数会调用子类重写的虚函数，那就会造成子类未完成构造函数但是却调用自身的虚函数，违背了规则。但是在其他的语言 <code>jave，c#</code> 中构造函数调用虚函数是一种动态绑定</p><p>模板类是编译式多态，虚函数是运行式多态，也就是说模板类运行时性能高于基于虚函数的类，有了泛型编程的迭代器就不再使用虚函数的迭代器了</p><h2 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h2><h3 id="模板模式-template"><a href="#模板模式-template" class="headerlink" title="模板模式 template"></a><strong>模板模式 template</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406223604450.png" alt="20200406223604450.png"></p><ul><li>封装不变的部分，将不变的部分抽取出来；</li><li>扩展可变部分，将可变的设置抽象方法，让具体子类来实现。</li><li>抽取的公共代码，便于后期维护</li><li>行为有基类来控制，具体操作有子类实现。<br>就是先定义一个通用的基类，然后在对应创建子类，子类复写基类的方法</li></ul><h3 id="策略模式-strategy"><a href="#策略模式-strategy" class="headerlink" title="策略模式 strategy"></a><strong>策略模式 strategy</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406223743348.png" alt="20200406223743348.png"></p><ul><li>就是当遇到相同的目的的算法，但是每一个都不通用，就可以写一个基类算法来减少if-else语句的使用，子类的算法都是继承自基类</li><li>基类写对应的算法的抽象，在子类里直接重载该算法</li><li>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换。使得算法可独立于使用它的客户程序而变化</li></ul><h3 id="观察者模式-observer"><a href="#观察者模式-observer" class="headerlink" title="观察者模式 observer"></a><strong>观察者模式 observer</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406223838139.png" alt="20200406223838139.png"></p><p>对于一个持续运行的程序，需要用的另一个观察者的类来观察程序中运行的情况，可以随意添加多个观察者。创建一个基类观察者，子类观察者都依附于它，并且在对应的项目结构体中引用一个基类的观察者变量，之后可以转换为子类观察者</p><p>定义对象间的一种一对多（<strong>变化</strong>）的依赖关系，以便当一个对象（<strong>Subject</strong>）的状态发生改变时，所有依赖于它的对象都能得到通知并自动更新</p><ul><li>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标于观察者，从而使二者之间的依赖关系达到松耦合</li><li>目标发出通知时，无需指定观察者，通知会自动传播</li><li>观察者会自己决定是否需要订阅通知，目标对象对此一无所知</li></ul><h2 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h2><h3 id="装饰模式-decrote"><a href="#装饰模式-decrote" class="headerlink" title="装饰模式 decrote"></a><strong>装饰模式 decrote</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200405220429862.png" alt="20200405220429862.png"></p><p>创建一个基类，然后在基类的基础上创建装饰类，各个装饰类里含有一个基类，可以之后传入装饰类里对应的类，类的多态，运行时装配</p><p>其实就是在创建基类，每一个子类和对应的装饰都应该依赖于基类，可以创建一个装饰者基类，让所有的装饰者都依赖于它，在装饰者里可以引用一个基类，以便在使用的时候可以转化为其他的装饰类或者是其他的子类。</p><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）</p><p>Decorator 模式应用的要点在于解决<strong>主体类在多个方向上的扩展功能</strong></p><h3 id="桥模式-bridge"><a href="#桥模式-bridge" class="headerlink" title="桥模式 bridge"></a><strong>桥模式 bridge</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406115540814.png" alt="20200406115540814.png"></p><p>在设计中如果责任划分的不清晰，使用继承得到的加过往往是随着需求变化的，子类极具膨胀，同时充斥着重复代码，关键是划清责任</p><p>要实现一定的功能，但是每一个子类都继承自父类，但是不能够完全继承父类的所有功能，而子类的子类又要调用父类的其他功能，这时候就可以简化</p><p>就是对象间的组合关系，抽象的基类沿着各自的子类变化。Bridge 模式使用“ <strong>对象间的组合关系</strong> ”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化</p><h2 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h2><h3 id="工厂模式-factory"><a href="#工厂模式-factory" class="headerlink" title="工厂模式 factory"></a><strong>工厂模式 factory</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406123133241.png" alt="20200406123133241.png"></p><p>隔离类对象使用者和具体类型之间的耦合关系，同样要求这些“易变类”拥有“稳定的接口”。在创建对象时，尽量避免new，从而避免创建对象中的紧耦合，从而支持对象创建的稳定。定义一个创建对象的接口，让子类来决定实例化哪个类，使一个类延迟化实现，主要是针对没有什么关联性的对象的创建</p><p>工厂模式旨在解决“单个对象” 的需求变化，但是创建方法和参数相同</p><h3 id="抽象工厂-abstract-factory"><a href="#抽象工厂-abstract-factory" class="headerlink" title="抽象工厂 abstract_factory"></a><strong>抽象工厂 abstract_factory</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406143418783.png" alt="20200406143418783.png"></p><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类</p><p>与工厂模式不同之处在于，可以处理<strong>一系列相互依赖的对象</strong>的创建工作，不同系列的对象之间不能互相依赖</p><h3 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a><strong>原型模式 prototype</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406145115826.png" alt="20200406145115826.png"></p><p>相当于把工厂模式里的基类和工厂基类合并到一起，通过克隆自己来创建对象</p><p>与工厂模式的不同之处在于使用时创建一个原型对象，通过克隆原型对象来使用，使用原型实例创建指定对象种类，然后拷贝指定对象创建类型使用原型克隆的方法，可以灵活动态创建拥有某些稳定接口的新对象，所做的工作就是注册一个新的对象，然后再任何需要的地方 clone</p><p>使用<strong>原型实例</strong>指定创建对象的种类，然后通过<strong>拷贝</strong>这些原型来创建新的对象</p><h3 id="构建器-builder"><a href="#构建器-builder" class="headerlink" title="构建器 builder"></a><strong>构建器 builder</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406151348724.png" alt="20200406151348724.png"></p><p>在设计程序中，有时候面临着“一个复杂对象”的创建工作，通常各个部分的子对象用一定的算法构成，由于需求的变换子对象也经常面临着一些剧烈的变化，但是将他们组合到一起就会比较稳定。</p><p>提供一种封装机制来隔离出负载对象的各个部分的变化，将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示，构建过程是稳定的，但是创建的不同表示是动态的</p><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）</p><p>缺点是难以应对“分步骤构建算法”的需求变动</p><h2 id="对象性能模式"><a href="#对象性能模式" class="headerlink" title="对象性能模式"></a>对象性能模式</h2><p>只有这两种模式是为了解决性能问题，降低对象创建个数</p><h3 id="单件模式-singleton"><a href="#单件模式-singleton" class="headerlink" title="单件模式 singleton"></a><strong>单件模式 singleton</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406153527896.png" alt="20200406153527896.png"></p><p>模式中的实例构造器可以设置为protected 以允许子类派生，模式一般不要支持拷贝构造方法和 clone 接口，因为这有可能导致多个对象实例，违背 Singleton 模式的初衷</p><p>面向对象设计模式使用抽象类来解决问题，但是有时候抽象类中的虚函数可能会带来巨大的成本，必须谨慎处理。在软件系统中，有些特殊的类必须保证他们在系统中只存在一个实例才能保证正确性以及良好的效率，处理方式：</p><ol><li>单锁 会出现多线程时，代价太大</li><li>双检查锁 会出现内存读写 <code>reorder</code> 解决方法: c++11 出现 <code>volite</code> 关键字来避免该变量创建时 <code>reorder</code></li></ol><h3 id="享元模式-flyweight"><a href="#享元模式-flyweight" class="headerlink" title="享元模式 flyweight"></a><strong>享元模式 flyweight</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406154613171.png" alt="20200406154613171.png"></p><p>采用<strong>对象共享</strong>的做法来降低系统中对象的<strong>个数</strong>，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象<strong>状态</strong>（最好状态不可更改）的处理</p><p>创建之后对象状态不能更改，要注意对象状态的处理，尽可能实现只读的方式，在系统中采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行代价，运用共享的技术有效的支持大量细粒度的对象。</p><p>其实就是把创建过的对象放入对象池中，但是有些对象是不支持享元模式的，就是防止重复创建，有些对象被多个对象使用就没必要重复创建浪费空间了，可以只创建一个存入对象池中，如果已经创建了就不再创建而是调用之前创建好的</p><h2 id="接口隔离模式"><a href="#接口隔离模式" class="headerlink" title="接口隔离模式"></a>接口隔离模式</h2><p>在组建构建过程中，某些接口之间直接依赖常常会带来很多问题，采用添加一层间接接口(稳定)来隔离本来相互紧密关联的接口，软件设计的核心是间接思想</p><h3 id="门面模式-facade"><a href="#门面模式-facade" class="headerlink" title="门面模式 facade"></a><strong>门面模式 facade</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406164137493.png" alt="20200406164137493.png"></p><p>为子系统中的一组接口提供一个一致（<strong>稳定</strong>）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（<strong>复用</strong>）（隔离变化和稳定）</p><p>防止外部的对象与命令的对象直接紧耦合，所以提出间接层，添加接口来把客户类与内部系统本身的类隔离起来，以至于外部看不到内部的对象，最终的实现上无论内部怎么改变，但是外部所看到的接口是不变的，简化了外部系统与内部的交互。</p><p>facade 设计模式组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单功能的集合，从客户程序的角度看，该模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果，内部子系统的任何变化不会影响到接口的变化。</p><h3 id="代理模式-proxy"><a href="#代理模式-proxy" class="headerlink" title="代理模式 proxy"></a><strong>代理模式 proxy</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406165510496.png" alt="20200406165510496.png"></p><p>在面向对象时，有些对象由于某种原因（例如对象的创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，在不失去透明操作对象的同时来管理这些对象特有的复杂性为其他对象提供代理或者接口。</p><p>代理模式的实现方法或者实现粒度都相差很大，又可能对某个单个对象做copy之类的技术，实现细粒度的控制，也有可能对组件模块提供抽象代理层，在架构层做proxy</p><p>为其他对象提供一种代理以控制（<strong>隔离</strong> ，即使用接口）对这个对象的访问</p><h3 id="适配器-adapter"><a href="#适配器-adapter" class="headerlink" title="适配器 adapter"></a><strong>适配器 adapter</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2020050113333475.png" alt="2020050113333475.png"></p><p>适配器的目的就是为了移植不同类型的接口转移为其他的接口来达到实现接口匹配的配置，让原本接口不匹配的类可以一起工作</p><p>实际上组合一个类，支持实现的一个类，适配器就是为了改变一些旧的已经存在的类的接口来实现类的接口统一</p><p><code>public</code> 继承是共有接口， <code>protect,private</code> 都是实现继承，但是不继承接口</p><h3 id="中介者-mediator"><a href="#中介者-mediator" class="headerlink" title="中介者 mediator"></a><strong>中介者 mediator</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406173151833.png" alt="20200406173151833.png"></p><p>用一个中介对象来封装（<strong>封装变化</strong>）一系列的对象交互。中介者使各对象不需要显式的相互引用（<strong>编译时依赖 -&gt; 运行时依赖</strong> ），从而使其耦合松散（<strong>管理变化</strong>），而且可以独立地改变它们之间的交互</p><p>在软件构建过程中，经常会出现多个对象互相交互关联的情况，就是两个类相互依赖或者紧密依赖，而且这种引用关系经常会面临不断地变化，这种情况下可以使用一个中介者来改善类之间的紧耦合关系 从而来抵御改变的类</p><p>用一个中介类来封装一系列的对象交互（封装变化），中介者使各个对象之间不需要显示的相互引用（编译式依赖），转变为运行式依赖，而且可以独立的改变它们之间的交互，主要是为了解决对象之间直接的耦合关系。可以提供一个中介，让参与这些相互依赖的对象之间减少紧耦合，这个中介与这些对象需要时相互依赖的关系，以后需要相互调用的时候，就可以先调用中介通过中介来调用对应的目标，但是者之间需要一个通用的调用消息规范。中介中可以添加观察者模式，宗旨就是直接依赖关系转化为相互依赖关系。facade 解决的是系统内与系统外的隔离，中介者解决的是系统内类之间的依赖关系，多个对象出现各种依赖原则</p><h2 id="状态变化模式"><a href="#状态变化模式" class="headerlink" title="状态变化模式"></a>状态变化模式</h2><h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a><strong>状态模式 State</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406202242155.png" alt="20200406202242155.png"></p><p>在组建构建过程中，某些对象的状态经常发生变化，对这些变化要进行有效的管理并且高层不受影响，软件构件过程中，某些对象的状态的改变其行为也会随之改变，状态类型也会发生改变</p><p>state模式将所有与一个特定状态相关的行为都放入一个state的子类对象中，在对象状态切换时，切换相应的对象，但是同时维持state的接口，这样实现了具体操作与状态转换之间的解耦，为不同的状态引入不同的对象使得状态转变变得更加明确，而且保证不会出现不一致的情况，因为转换是原子性的，要么彻底转换过来，要么不转换</p><p>在之后就没必要更改已经写好的状态器，但是可以不断地新增加子类，内部可以无限变化，但是对于外部的接口是固定的，不用太过于计较它们之间的差异性，需要注意它们之间共同的东西，把共同的相似的东西结合到一起，如果state没有实例变量，那么各个上下文可以共享同一个state对象，从而节省对象的开销</p><h3 id="备忘录-Memento"><a href="#备忘录-Memento" class="headerlink" title="备忘录 Memento"></a><strong>备忘录 Memento</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406203835970.png" alt="20200406203835970.png"></p><p>在软件构造中，某些对象的状态转换中，可能由于某些需求,在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后可以把对象恢复到这个原先保存的状态</p><p>备忘录存储原发起对象内部状态，在需要时回复原发器的状态，核心是信息隐藏，即原发器需要对外部隐藏信息，也要保持封装性，同时又要把状态保存到外界。</p><p>采用效率较高，又容易正确实现的序列化方案来实现Memento模式</p><h2 id="数据结构模式"><a href="#数据结构模式" class="headerlink" title="数据结构模式"></a>数据结构模式</h2><p>在一些组件内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用，这时候将这些特定的数据结构封装在内部，在外部提供一些统一的接口来实现与特定数据结构无关的访问</p><h3 id="组合模式-composite"><a href="#组合模式-composite" class="headerlink" title="组合模式 composite"></a><strong>组合模式 composite</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406205814663.png" alt="20200406205814663.png"></p><p>在软件某些情况下，客户代码过多的依赖与对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来代码维护性，扩展性等弊端。</p><p>方式：将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有<strong>一致性</strong>（稳定）</p><p>Composite 模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转换为“一对一”的关系，使得客户的代码可以一致的（复用）处理对象和对象容器，无需关心处理的是单个的对象还是组合的对象容器，客户代码将与纯粹的抽象接口而不是对象内部的实现结构，从而更能对应变化，其实就是一种多类型的递归调用</p><h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a><strong>迭代器 iterator</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406211152758.png" alt="20200406211152758.png"></p><p>迭代器，在软件构建过程中，集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不爆露其内部结构的同时，可以让外部的客户代码透明的访问其中包含的元素，同时这种透明遍历为同一种算法在多种集合对象中进行操作提供了可能，提供一种方法顺序访问一个集合对象中的各种元素，而又不暴露该对象内部的实现</p><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又<strong>不暴露</strong>（稳定）该对象的内部表示</p><p>通过迭代器来隔离实现与应用，访问一个对象无需暴漏其内部表示，迭代堕胎，为遍历不同的集合结构体重一个统一的接口，从而支持同样的算法在不同的遍历结构上进行操作，遍历时有必要关注迭代器自身的问题，可能会导致问题</p><h3 id="职责链-Chain-of-Resposibilty"><a href="#职责链-Chain-of-Resposibilty" class="headerlink" title="职责链 Chain of Resposibilty"></a><strong>职责链 Chain of Resposibilty</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406212924906.png" alt="20200406212924906.png"></p><p>相当于是链表，在软件构件过程中，一个请求可能被多个对象处理，但是每个请求在运行中只能有一个接收者，如果显式制定的话，就会形成紧耦合，请求时不指定具体的接收者，使多个对象都有机会处理请求，避免请求的发送者和接收者之间的紧耦合关系，将这些对象连成一条链，就相当于一个链表，沿着这条链处理请求，直到有对象都处理完请求</p><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</p><p>职责链的应用场景在于一个请求可能有多个接收者，但是最终的接收者只有这一个这时候请求发送者与接收者的耦合可能出现”变化脆弱“的症状吗，所以需要解耦合</p><h2 id="行为变化模式"><a href="#行为变化模式" class="headerlink" title="行为变化模式"></a>行为变化模式</h2><p>在组件构建过程中，组件行为的变化经常导致组件本身剧烈的变化，行为变化模式将组件之间的行为和变化解耦合，从而支持组件行为的变化，实现两者之间的松耦合</p><h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a><strong>命令模式 Command</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406214504166.png" alt="20200406214504166.png"></p><p>在软件构建过程中，行为请求者与行为实现者通常呈现出紧耦合的关系，但在某些场合，比如需要对行为进行记录，撤销，事务等处理，这种无法抵御变化的紧耦合是不合适的，将请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及可以撤销的操作</p><p>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化。对请求排队或记录请求日志，以及支持可撤销的操作</p><p>根本的目的是将行为请求者与行为实现者解耦，在面向对象中，常见的手段是将行为对象抽象为对象，实现Command接口的具体命令对象具体的command有时候需要保存一些额外的状态信息，同时在使用命令模式的同时也可以使用composite模式将多个指令封装</p><h3 id="访问器-Visitor"><a href="#访问器-Visitor" class="headerlink" title="访问器 Visitor"></a><strong>访问器 Visitor</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406220227848.png" alt="20200406220227848.png"></p><p>在软件构件的过程中，由于需求的改变，其次是类结构层次中常常需要增加新的行为或者方法，如果直接在基类中更改，对子类来说是一种负担，会破坏原有设计，再不更改类结构层次的条件下在运行时透明的添加新的行为动作， <code>visitor</code> 主要是利用双重分发，在不更改原先类的层次结构时透明的为各个类动态的添加功能</p><p>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（<strong>稳定</strong>）各元素的类的前提下定义（<strong>扩展</strong>）作用于这些元素的新操作（变化）</p><p>缺点：在需要基类稳定的同时，也需要相关的子类也要稳定，visitor类想要写下来时需要基类的所有子类必须确定下来并且稳定，需要确定它们的数目，visitor基类稳定的前提时element所有子类都需要稳定，这个模式的条件极其苛刻</p><h2 id="领域规则模式"><a href="#领域规则模式" class="headerlink" title="领域规则模式"></a>领域规则模式</h2><p>在特定领域中，某些变化虽然频繁，但是可以抽象为某种规则，这时候结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方法</p><h3 id="解析器-Interpreter"><a href="#解析器-Interpreter" class="headerlink" title="解析器 Interpreter"></a><strong>解析器 Interpreter</strong></h3><p><img src="/Blog_ButterFly/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200406222304558.png" alt="20200406222304558.png"></p><p>将领域内的问题表达为某种语法规则下的句子，然后构建一个解释器来解释遮掩的句子，在这个领域内，只要符合这个规则，解释器就能够解释，从而达到解决问题的目的</p><p>interpreter模式的应用场合时interpreter的难点，只有满足<strong>业务规则频繁变化并且类似的结构不断出现并且容易抽象为语法规则问题</strong>才适合使用interpreter模式<br>使用interpreter模式来表示文法规则，从而可以使面向对象技巧来方便的扩展文法，比较适合简单的文法表示，对于复杂的文法表示interpreter会产生较大的类层次接口，需要求助于语法分析生成器额工具</p><h2 id="两种手段分解-amp-抽象"><a href="#两种手段分解-amp-抽象" class="headerlink" title="两种手段分解&amp;抽象"></a>两种手段分解&amp;抽象</h2><h3 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h3><ul><li>静态→动态</li><li>早绑定→晚绑定</li><li>继承→组合,组合一个指针，可以指向该类的子类,是一种松耦合,指针指向是灵活的</li><li>编译时依赖→运行时依赖</li><li>紧耦合→松耦合</li></ul><p>设计模式的宗旨：管理变化，提高服用</p><h3 id="不用设计模式的情况"><a href="#不用设计模式的情况" class="headerlink" title="不用设计模式的情况:"></a>不用设计模式的情况:</h3><ol><li>代码可读性很差</li><li>需求理解还很浅</li><li>变化没有显现</li><li>不是系统的关键依赖点</li><li>项目没有复用价值</li><li>项目将要发布时</li></ol><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ol><li>不要为模式而模式</li><li>关注抽象类&amp;接口</li><li>清理变化点和稳定点</li><li>审视依赖关系</li><li>要有Framework和Application的区域隔离思维</li><li>良好的设计是演化的结果</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><div class="table-container"><table><thead><tr><th>设计模式</th><th>定义</th></tr></thead><tbody><tr><td>Template</td><td>定义一个抽象的基类，并且其中定义了一类系统的特定的统一的方法，然后在子类里分别复写里面的某些方法，还可以实现子类自己的特定的方法</td></tr><tr><td>Strategy</td><td>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td></tr><tr><td>Observer</td><td>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都能得到通知并自动更新</td></tr><tr><td>Decorator</td><td>通过对象组合来给一个对象增加一些额外的职责，生成比子类更加灵活</td></tr><tr><td>Bridge</td><td>将一个具有多个特点的类进行分离，每种特点都自成一类，各自可以独立的变化。最后组合到一起</td></tr><tr><td>Factory</td><td>定义一个用于创建对象的接口，让子类决定实例化哪一个类。延迟类的实现</td></tr><tr><td>Abstract Factory</td><td>提供一个接口，让该接口负责创建一系列相关或者相互依赖的对象，无需指定它们具体的类</td></tr><tr><td>Prototype</td><td>先创建一些原型类的实例，然后通过拷贝这些原型来创建新的对象</td></tr><tr><td>Builder</td><td>将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。类似于构建过程相同但是其中的步骤不一致，就能构建出不同的对象</td></tr><tr><td>Singleton</td><td>一个类只有一个实例，并且提供一个全局访问的点</td></tr><tr><td>Flyweight</td><td>运用共享技术使得有效地支持大量细粒度的对象</td></tr><tr><td>Facade</td><td>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td></tr><tr><td>Proxy</td><td>为某一对象提供一种代理以控制对这个对象的访问，隔离接口，使用代理的接口，并且可以在代理中添加一些其它的功能。只能做一个对象的代理</td></tr><tr><td>Mediator</td><td>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖 → 运行时依赖 ），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互</td></tr><tr><td>Adapter</td><td>将一个类的接口转成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</td></tr><tr><td>Memento</td><td>在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态</td></tr><tr><td>State</td><td>允许一个对象在其内部状态改变时改变它的行为，从而使对象看起来似乎修改了其行为</td></tr><tr><td>Composite</td><td>将对象组合成树形结构以表示部分-整体的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）</td></tr><tr><td>Iterator</td><td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</td></tr><tr><td>Chain of Responsibility</td><td>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</td></tr><tr><td>Command</td><td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。对请求排队或记录请求日志，以及支持可撤销的操作</td></tr><tr><td>Visitor</td><td>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作</td></tr><tr><td>Interpreter</td><td>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 程序员的自我涵养 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个笔记是跟着 jyy 老师学的，有兴趣的话可以看看原视频，讲的很不错</p><p><strong>读手册，读手册，读手册</strong></p><p><a href="http://jyywiki.cn/pages/OS/2022/demos/su.c">http://jyywiki.cn/pages/OS/2022/demos/</a></p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ol><li>操作系统是服务于程序的，程序就是状态机，计算机每执行一条指令计算机的内存和寄存器都会发生变化</li><li>操作系统=对象(文件，进程，管道)+API(操纵对象的API)</li><li>用简单的硬件实现对象和API，操作系统可以用c程序实现</li><li>广义的操作系统：基于下层的支撑为上层提供服务</li></ol><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序就是状态机，作为一个状态机是没有办法自己销毁自己的，只能以死循环或者以一个系统调用（告诉操作系统该销毁了）结束，程序的状态机模型</p><ul><li>状态 = 堆 + 栈</li><li>初始状态 = <code>main</code> 的第一条语句</li><li>迁移 = 执行第一条语句</li></ul><p>任何 C 程序都可以改写成非复合语句的 C 代码，所有程序都是运行在计算机上的，计算机就相当于是状态机，C程序的所有代码都会被推入栈中，之后在运行过程中依次调用，每执行一条指令计算机的状态也会发生改变，指令是从pc取出来的，确定性的指令，状态是一条直线</p><h3 id="系统调用-syscall"><a href="#系统调用-syscall" class="headerlink" title="系统调用 syscall"></a>系统调用 <code>syscall</code></h3><p>这个指令就是把系统完全交给操作系统，任其修改，实现操作系统中的和其他对象交互</p><ol><li>读写文件</li><li>操作系统状态</li><li>改变进程</li><li>创建/销毁进程</li></ol><p>程序 = 计算 + <code>syscall</code> + 计算</p><h3 id="代码实现最小的-helloworld"><a href="#代码实现最小的-helloworld" class="headerlink" title="代码实现最小的 helloworld"></a>代码实现最小的 helloworld</h3><p>可以先利用 C 语言写一个自认为最小的 helloworld 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gcc 静态编译 <code>gcc -static a.c</code> ，再使用 <code>ojbdump -d a.out</code> 查看会发现它的代码量其实很多，可使用 <code>ls -l a.out</code> 或者 <code>size a.out</code> 来查看代码大小，所以这个肯定不是最小的 helloworld</p><p>由于只打印字符串，所以可以将 <code>printf</code> 优化为 <code>puts</code> ，重新编译之后发现代码大小并没有什么变化，所以可知编译器已经把 <code>printf</code> 优化为 <code>puts</code> 了</p><p>接下来可以去除程序中的符号表，使用 <code>nm</code> 指令查看程序中的符号表，对于尽可能小的文件，符号表就显得可有可无了，所以可以去掉符号表，使用 <code>strip</code> 指令或者是再编译中去除符号表，两种方法效果是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nm a.out</span><br><span class="line">strip a.out</span><br><span class="line">gcc -s a.c</span><br></pre></td></tr></table></figure><p>最终得到的文件也非常大，所以这里可以使用汇编语言来重写程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   // write(</span><br><span class="line">  movq $1,         %rdi   //   fd=1,</span><br><span class="line">  movq $st,        %rsi   //   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   //   count=ed-st</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   // exit(</span><br><span class="line">  movq $1,         %rdi   //   status=1</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure><p>这里直接使用系统调用代替掉标准库，但是这个代码是不能直接编译的，会产生未定义 <code>main</code> 函数的结果，但是可以静态编译为可重定位目标文件，再经过链接得到可执行目标文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.s</span><br><span class="line">ld a.o</span><br></pre></td></tr></table></figure><p>最后可以得到可执行目标文件 <code>a.out</code> ，事实上这个并不会是最小的 <code>helloworld</code> 代码，毕竟这里的大小也有 4700 多字节</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译器是将高级语言编译为机器语言的工具</p><h3 id="正确的编译"><a href="#正确的编译" class="headerlink" title="正确的编译"></a>正确的编译</h3><p>正确的编译就是所有不可优化的代码都正确的编译到汇编代码上就是正确的编译，在C代码与汇编代码中，只有不可以优化的部分是完全相同的，其他部分可以不相同，因为现代编译器会对指令进行重排，以此来优化程序的性能</p><h3 id="编译优化的前提"><a href="#编译优化的前提" class="headerlink" title="编译优化的前提"></a>编译优化的前提</h3><ul><li>内联汇编也会参与优化，其它的优化可能不会跨过带着障碍的 <code>asm volatile</code></li><li>Eventual memory consistency 即需要保证最终磁盘的一致性</li><li>调用外部CU =回写可见内存</li></ul><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="comment">// asm volatile(&quot;nop&quot; : : &quot;r&quot;(x) : &quot;memory&quot; ); // compiler barrier</span></span><br><span class="line">    <span class="comment">// __sync_synchronize();</span></span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果两个a++ 之间没有这两种语句，那么就会优化为 a+=2</span></span><br><span class="line"><span class="comment">// 实际上就是在执行完一条 a++ 语句之后要访问内存了，就必须先把 a 的值写入内存</span></span><br></pre></td></tr></table></figure><h3 id="C语言代码的第一条指令"><a href="#C语言代码的第一条指令" class="headerlink" title="C语言代码的第一条指令"></a>C语言代码的第一条指令</h3><p>可以利用 gdb 来寻找 C 语言程序的第一条指令，进入调试之后，使用 <code>starti</code> 指令，可以看到第一条指令为 <code>_start</code> 函数的指令 <code>mov %rsp, %rdi</code></p><p>使用 <code>info proc mappings</code> 打印进程内存。并且在 <code>main</code> 函数之前调用了 <code>ld-linux-x86-64.so</code> 加载 <code>libc</code> 之后就对 <code>libc</code> 完成了初始化</p><p>对于一个程序，可以创建 <code>attribute</code> 函数分别在 <code>main</code> 函数构建之前和构建之后运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__attribute__((constructor)) <span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">goodbye</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;goodbye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;this is main\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line">hello!</span><br><span class="line">this is main</span><br><span class="line">goodbye!</span><br></pre></td></tr></table></figure><p>可以通过使用 <code>strace</code> 工具查看程序用到了哪些系统调用， <code>strace a.out</code> 可以看到代码运行过程中调用的系统 API。也可以使用 <code>strace -f gcc -c a.c &amp;| vim -</code> 查看编译过程调用的 API 并且使用 vim 查看，在其中使用命令 <code>:%!grep execve</code> 查看编译过程中调用了哪些其它的进程，为了方便查看，可以使用 <code>set nonu</code> 不显示行号，使用 <code>:%!grep:%s/, /\\\\\\\\r /g</code> 把逗号空格换成换行</p><p>在 gdb 中可以使用 <code>info proc *</code> 查看当前进程的信息</p><p>也可以使用 <code>strace xedit</code> 来查看图形化界面的系统调用</p><p>窗口管理器调用的 API 主要是管理设备和屏幕 <code>read/write/mmap</code>，进程之间的通信 <code>send/recv</code></p><p>任务管理器调用的 API 主要是访问操作系统提供的进程对象 <code>readdir/read</code></p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="多处理器编程"><a href="#多处理器编程" class="headerlink" title="多处理器编程"></a>多处理器编程</h3><p>c 语言的多线程库 <code>pthread.h</code> 库是动态链接库，所以编译时需要动态链接 <code>-lpthread</code></p><p>使用 <code>man 7 pthread</code> 来查看多线程库的手册</p><p>多处理器中的线程的代码同时执行同一条指令就会出现错误，这时候可以对进程加锁</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>从程序执行开始，初始状态和过程状态都确定，这就是一个固定的程序，但是对于并发，程序会有一定的随机性，进程会共用程序的状态</p><h3 id="并发程序的基本单位：线程"><a href="#并发程序的基本单位：线程" class="headerlink" title="并发程序的基本单位：线程"></a>并发程序的基本单位：线程</h3><p>线程是共享内存的多个数据流，使用 <code>thread.h</code> 中的函数创建一个多线程的程序，但是在编译时需要加上 <code>-lpthread</code> ，多线程是共享内存的，但是每个线程都具有独立的堆栈</p><p>可以使用 <code>top</code> 指令查看 CPU 的占有率。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>单线程：程序运行时可能被中断切换到另一个程序执行</li><li>多线程：程序并发执行</li><li>原子性互斥，互斥锁，进程锁，原子锁</li><li>实现原子性：实现两个API<ol><li><code>lock(&amp;lk)</code></li><li><code>unlock(&amp;lk)</code></li></ol></li></ul><p>99% 的并发问题都可以使用一个队列完成，把大任务切分成可以并行的小任务，除去不可并行的其他的可以获得线性的，这就是说，实际上多线程并发程序实际上不是同时执行的，线程是在一个进程中轮换着执行的，所以也就可以使用一个队列完成</p><p>对于下面的代码，这是一个多线程执行累加的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREAD 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> T_FREE = <span class="number">0</span>, T_LIVE, T_DEAD, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> id, status;</span><br><span class="line">  <span class="type">pthread_t</span> thread;</span><br><span class="line">  <span class="type">void</span> (*entry)(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">tpool</span>[<span class="title">NTHREAD</span>], *<span class="title">tptr</span> =</span> tpool;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">wrapper</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> =</span> (<span class="keyword">struct</span> thread *)arg;</span><br><span class="line">  thread-&gt;entry(thread-&gt;id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span> *fn)</span> &#123;</span><br><span class="line">  assert(tptr - tpool &lt; NTHREAD);</span><br><span class="line">  *tptr = (<span class="keyword">struct</span> thread) &#123;</span><br><span class="line">    .id = tptr - tpool + <span class="number">1</span>,</span><br><span class="line">    .status = T_LIVE,</span><br><span class="line">    .entry = fn,</span><br><span class="line">  &#125;;</span><br><span class="line">  pthread_create(&amp;(tptr-&gt;thread), <span class="literal">NULL</span>, wrapper, tptr);</span><br><span class="line">  ++tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREAD; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> &amp;tpool[i];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;status == T_LIVE) &#123;</span><br><span class="line">      pthread_join(t-&gt;thread, <span class="literal">NULL</span>);</span><br><span class="line">      t-&gt;status = T_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">  join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tsum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码会发生数据竞争，最终的输出结构应该是 <code>200000000</code> 的，但是由于数据竞争，这个数据是不确定的，有时候甚至 <code>&lt;N</code> ，但是对于不同的编译优化等级结果是不一样的</p><ul><li>对于O1优化，相当于是每一个进程分别进行优化，每个进程优化之后就是 sum = 1000000，最后结果为 sum = 1000000</li><li>对于O2优化，程序优化之后，两个ADD很接近，容易出现错误，一般会输出结果为 200000000</li></ul><p>对于程序的处理都是有顺序的 <code>fetch(取)-&gt;issue(发行)-&gt;execute(执行)-&gt;commit(提交)</code></p><p>当前的电脑可以同时处理多条issue指令，乱序执行，可以在一个时钟周期里取出多条指令同时执行</p><p>对于多处理器，无法满足单处理器 <code>eventual memory consistency</code> 的执行，在多处理器上可能无法序列化，甚至会有多条代码在一个时钟周期里执行。在写入时会发生 <code>cache miss(缓存未命中)</code>，如果 x 发生 <code>cache miss</code> 那么就会让 读取 y 先开始。满足尽可能的执行 UOP 的原则，最大化处理器性能</p><h3 id="宽松内存模型"><a href="#宽松内存模型" class="headerlink" title="宽松内存模型"></a>宽松内存模型</h3><p>宽松内存模型目的是使单个处理器的执行更加高效</p><p>例如 ARM / RISC-V 是一个分布式系统，相当于是没有共享内存，每一个线程有一个单独的内存，单独的内存之间又有交互，而对于X86结构的处理器，每一个线程都有一个单独的存放数据的堆栈，可以延迟任意长时间之后再写入内存</p><p>多处理器编译：不原子，乱序编译，不立即可见</p><p>并发程序 = 多个执行流，共享内存的状态机</p><h3 id="线程互斥算法"><a href="#线程互斥算法" class="headerlink" title="线程互斥算法"></a>线程互斥算法</h3><p>互斥：保证两个线程不能同时执行同一段代码</p><p>假设一个内存的读/写可以保证运行顺序，原子完成，终端代码输出重定向 &gt; 文件 可以把输出结果导出到文件里，如果两个线程同时执行这段代码就会导致最终输出到文件中的内容式乱的，所以如果保证两个线程不同时执行这一段代码，并且都会及时更新这个文件的写入指针，那就会写入的比较号</p><p>对于下面的 <code>python</code> 的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">thread</span>:</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> true:</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">g = thread()</span><br><span class="line">g.__next__()</span><br></pre></td></tr></table></figure><p>这个代码是个死循环，但是是可以返回的，通过 <code>yield</code> 来返回。每一个执行这段代码的都相当于是一个多线程，相当于是C#里的协程，直接运行的话会很乱，但是利用 <code>_next__()</code> 函数就能够保留这个线程的状态来不断运行</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>一把排他性的锁，共享内存实现互斥，实现互斥的方式：不能同时读/写共享内存</p><ul><li><code>load</code> 的时候不能写</li><li><code>store</code> 的时候不能读</li></ul><p>这里用到了内联汇编，在执行这条代码的时候其他指令都不运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lock addq $1, %0&quot;</span>: <span class="string">&quot;+m&quot;</span>(sum))</span>;<span class="comment">// 就是在这条代码运行时其他代码都不运行</span></span><br></pre></td></tr></table></figure><p>这就会实现锁的互斥了</p><p>当前的CPU存在 1 级缓存和 2 级缓存，如今的x86架构还是有很大缺点，例如多线程中每个CPU里都有一个数据 m，当一个 CPU 要 lock 时，并且要读取 m，那就需要将所有 CPU 中的 m 剔除</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *addr, <span class="type">int</span> newval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span> : <span class="string">&quot;+m&quot;</span>(*addr), <span class="string">&quot;=a&quot;</span>(result) : <span class="string">&quot;1&quot;</span>(newval))</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="type">int</span> got = xchg(&amp;locked, NOPE);</span><br><span class="line">    <span class="keyword">if</span>(got == NOPE)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    assert(got == NOPE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;<span class="keyword">while</span>(xchg(&amp;locked, <span class="number">1</span>));&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;xchg(&amp;locked, <span class="number">0</span>)&#125;</span><br><span class="line"><span class="comment">// 在这里locked = 0 是没有锁的状态</span></span><br></pre></td></tr></table></figure><p>这里也用到了原子交换代码，自旋锁就是如果没拿到锁就会快速地不断请求锁，所以就是以一种紧凑的循环来实现等待锁的</p><p><strong>原子指令的模型</strong></p><ul><li>保证之前的 store 都写入内存</li><li>保证 load/store 不与原子指令乱序，如果想要实现长临界区的互斥需要用到系统调用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syscall(SYSCALL_lock, &amp;lk)</span><br><span class="line">    <span class="comment">// 如果申请失败就转到别的线程</span></span><br><span class="line">syscall(SYSCALL_unlock, &amp;lk)</span><br><span class="line">    <span class="comment">// 释放锁，如果有别的线程就可以唤醒</span></span><br></pre></td></tr></table></figure><h3 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h3><p>当其它进程正在持有锁的时候，这个进程请求锁，那就会得不到锁，然后进入 <code>sleep</code> 直到另外的进程释放掉锁并且</p><h3 id="两种互斥锁的比较"><a href="#两种互斥锁的比较" class="headerlink" title="两种互斥锁的比较"></a>两种互斥锁的比较</h3><ul><li>自旋锁<ul><li>在xchg成功之后进入线程</li><li>xchg 失败之后进入等待，浪费cpu</li></ul></li><li>睡眠锁<ul><li>上锁失败就进入系统调用睡眠——系统会调用其它进程</li><li>即便上锁成功也需要进出内核</li></ul></li></ul><h3 id="两种互斥锁结合"><a href="#两种互斥锁结合" class="headerlink" title="两种互斥锁结合"></a>两种互斥锁结合</h3><ul><li>一条原子指令，上锁成功立即返回</li><li>上锁失败，执行系统调用睡眠，这一部分可以是模拟操作系统来执行睡眠</li><li>性能优化的思路： 关注 average case 而不是关注 worst case</li></ul><h3 id="futex"><a href="#futex" class="headerlink" title="futex"></a>futex</h3><p>先在用户空间自旋</p><ul><li>如果获得锁，直接进入</li><li>如果未能获得锁，系统调用</li><li>解锁之后也需要系统调用</li><li>软件不够，硬件来凑(自旋锁)</li><li>用户不够，内核来凑(互斥锁)</li><li>fast/slow paths： 性能优化的重要途径</li></ul><h3 id="并发编程：同步"><a href="#并发编程：同步" class="headerlink" title="并发编程：同步"></a>并发编程：同步</h3><p>同步实现的方式：条件变量，信号量</p><p>同步就是在某一时刻共同达到相互已知的状态，互斥相当于是竞争，同步相当于是协作</p><h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><ul><li>生产者生产一定量的资源，只有当资源数量 &lt; n 的时候才能够创造资源</li><li>消费者消费资源，只有当资源数量 &gt; 1的时候才能消费资</li><li>有一个集中管理者，便于对全部的资源进行管理和分配，实际上就是把资源放入栈中，消费者取出资源，集中分配的速度就是程序运行的速度</li></ul><p>这个就类似于操作系统的这个结构</p><h3 id="条件变量-API"><a href="#条件变量-API" class="headerlink" title="条件变量 API"></a>条件变量 API</h3><ul><li><code>wait(cv, mutex)</code><ul><li>调用时保证获得互斥锁</li><li>未满足条件，释放互斥锁，进入睡眠状态</li></ul></li><li><code>signal/notify(cv)</code><ul><li>如果有线程正在等待，唤醒其中的一个</li></ul></li><li><code>breadcast/notifyAll(cv)</code><ul><li>唤醒正在等待的所有线程<br>对于等待函数，如果在判断条件之后等待，当再次被唤醒的时候就会没有再次的判断，导致程序出现错误</li></ul></li></ul><p><strong>正确的打开方式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span>(!cond)&#123;</span><br><span class="line">    cond_wait(&amp;cv, &amp;mutex);</span><br><span class="line">    <span class="comment">// cond_wait 调用的时候释放了锁，被唤醒之后又去抢占锁，这是隐式做的</span></span><br><span class="line">&#125;</span><br><span class="line">assert(cond); <span class="comment">// 在等待结束之后条件一定成立，并且互斥锁还在自己手上</span></span><br><span class="line"><span class="comment">// 互斥锁保证了条件变量在执行过程中是成立的</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// 只要有任何线程满足条件，调用</span></span><br><span class="line"><span class="comment">// broadcast(&amp;cv)</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// argc代表外部传参的数量 其中就包括让程序运行的字符串</span></span><br><span class="line">    <span class="comment">// argv就是外部传入的参数，一般argv[0] 是让程序运行的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量设计的重点：考虑到每一单位的资源是什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">creator</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;empty); <span class="comment">// 判断如果有空位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    V(&amp;fill); <span class="comment">// 填满空位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;fill); <span class="comment">// 判断如果已经满了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    V(&amp;empty); <span class="comment">// 创造一个空位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号量有两种信号量，也就是empty 和 fill，这一点上和条件变量很像，但是如果是多种变量的话不容易实现<br>对于信号量并不总是非常好用，而且在于判断和创建中应该十分小心，因为是凭空创建的<br>程序的进出不一定是配对的，有可能导致死锁</p><h3 id="多线程问题：死锁"><a href="#多线程问题：死锁" class="headerlink" title="多线程问题：死锁"></a>多线程问题：死锁</h3><p>例如：每一个线程需要两个条件才能触发，每一个都已经达到了自己的第一个条件，但是没有达到第二个条件，所有线程都处于等待的状态，导致程序无法进行 ——死锁(哲学家吃饭问题)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex); <span class="comment">// 先锁上，在查看是否两个条件都满足</span></span><br><span class="line"><span class="keyword">while</span>(!(cond1&amp;&amp;cond2))</span><br><span class="line">&#123;</span><br><span class="line">    wait(&amp;cv,&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">cond1 = cond2 = <span class="literal">false</span>; <span class="comment">// 将两个条件都置为false</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line">cond1 = cond2 = <span class="literal">true</span>;<span class="comment">// 相当于把两个条件都还回去</span></span><br><span class="line">broadcast(&amp;cv);<span class="comment">// 向需要条件的所有线程广播</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><ul><li>条件变量：<code>broadcast</code> 性能低，但是不使用 <code>broadcast</code> 容易出错</li><li>信号量：在管理多种资源就不好用了</li></ul><h3 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h3><p>主要挑战是</p><ul><li>计算需要容易并行化<ul><li>机器-线程两级任务分解</li></ul></li><li>生产者-消费者解决一切两级任务分解</li><li>线程间的通信<ul><li>通信不仅发生在节点/线程之间，还发生在任何共享的内存访问中</li></ul></li></ul><h3 id="数据中心程序"><a href="#数据中心程序" class="headerlink" title="数据中心程序"></a>数据中心程序</h3><p><strong>特点</strong></p><ul><li>强调数据和存储，互联网</li><li>算法/系统对HPC和数据中心的意义，追求数据的快速，关注的中心是数据</li></ul><p><strong>挑战</strong></p><p>在服务很多地理环境的前提下</p><ul><li>数据要保持一致 consisty</li><li>服务时刻保持可用 avaliablity</li><li>容忍机器离线 partition tolerance<br>用好计算机的指标： QPS， tall latency</li></ul><h3 id="线程-threads"><a href="#线程-threads" class="headerlink" title="线程 threads"></a>线程 threads</h3><p>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。</p><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p><p>一个进程可以有很多线程，每条线程并行执行不同的任务。</p><p>在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</p><h3 id="协程-coroutines"><a href="#协程-coroutines" class="headerlink" title="协程 coroutines"></a>协程 coroutines</h3><p>协程与子例程一样，协程（coroutine）也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛</p><p>协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。</p><p>一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</p><h3 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h3><ul><li>同一时间会有很多请求达到服务器</li><li>计算部分<ul><li>需要利用好多处理器<ul><li>线程-&gt;<code>mandelbrot set</code></li><li>协程-&gt;一人出力，他人摸鱼</li></ul></li></ul></li><li>I/O 部分<ul><li>在系统调用上block（例如请求另一个服务器或者磁盘<ul><li>线程-&gt;一人干等，他人围观</li><li>协程-&gt;每个线程都占用可观的操作系统资源</li></ul></li></ul></li><li>Go &amp; Goroutine 多处理器并行和轻量级开发都有协程，在Go 和 Goroutine 中，一个cpu调用一个线程 <code>Go Worker</code>，可以自由调度 <code>goroutine</code>，每个线程中存在多个协程<br>对于Go语言，执行到 <code>blocking API</code> 时Go Worker 会改为 <code>non-blocking</code> 版本的<ul><li>成功-&gt; 立即继续执行</li><li>失败-&gt; 立即 <code>yield</code> 到另一个需要CPU的 <code>goroutine</code><br>\r 退格<br>rust 语言 Go 语言</li></ul></li><li>浏览器中的并发编程：Ajax(Asynchronous JavaScript + XML)<ul><li>HTML （DOM tree) + CSS</li><li>通过JavaScript 可以改变它</li><li>通过JavaScript 可以建立连接本地和服务器</li></ul></li></ul><h3 id="人机交互程序"><a href="#人机交互程序" class="headerlink" title="人机交互程序"></a>人机交互程序</h3><ul><li>特点<ul><li>没有太多的计算<ul><li>DOM Tree 不至于太大</li><li>DOM Tree 有浏览器帮助</li></ul></li><li>没有太多的 I/O<ul><li>主要就是网络请求</li></ul></li></ul></li></ul><h3 id="单线程-事件模型"><a href="#单线程-事件模型" class="headerlink" title="单线程+事件模型"></a>单线程+事件模型</h3><ul><li>一个线程，全局的事件队列，按顺序执行</li><li>耗时的API调用会立即返回<ul><li>条件满足时间队列里增加一个事件</li></ul></li></ul><h3 id="异步事件模型-promise"><a href="#异步事件模型-promise" class="headerlink" title="异步事件模型 promise"></a>异步事件模型 promise</h3><ul><li>好处<ul><li>开发模型简单<ul><li>函数执行是原子的(不能并行)，减少了并发的bug的可能性</li></ul></li><li>API 依然可以打开<ul><li>适合网页这种大部分时间在渲染和网络请求的场景中<ul><li>javaScript 代码只负责描述 DOM Tree</li></ul></li></ul></li></ul></li><li>坏处<ul><li>Callback hell<ul><li>代码嵌套太多，维护性差，promise: 描述 workflow 的嵌入式语言</li></ul></li></ul></li></ul><h2 id="并发的bug和应对"><a href="#并发的bug和应对" class="headerlink" title="并发的bug和应对"></a>并发的bug和应对</h2><h3 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h3><p>在某一些特定的地方使用 assert 函数来判断是否正确 <code>assert(cond)</code></p><p>堆栈溢出：当栈的内存不够时，栈会发生上溢出或者下溢出，这会导致指针的位置漂移，产生不好的结果</p><h3 id="栈溢出检查"><a href="#栈溢出检查" class="headerlink" title="栈溢出检查"></a>栈溢出检查</h3><p><code>Canary</code> 一种针对栈溢出攻击的防护手段</p><p>牺牲一些内存单元来预警 memory error 发生，在使用栈的时候不要全部占用完所有的内存，在栈的开头和结尾填入自定义的数值，再检查是否是上溢出还是下溢出</p><p>在函数退栈返回前，程序会比对栈上的 <strong>canary副本</strong> 和原始的 <strong>canary</strong> ，若二者不同，则说明发生了栈溢出，这时程序会直接崩溃</p><h3 id="lockdep"><a href="#lockdep" class="headerlink" title="lockdep"></a>lockdep</h3><p>lockdep规约</p><ul><li>为每一个锁确定唯一的 “allocation.site”<ul><li>aassert 同一个allocation site 的锁存在全局唯一的上锁顺序<br>检查方法-printf</li></ul></li><li>记录所有观察到的上锁顺序<ul><li><code>x-&gt;y,y-&gt;x,x-&gt;z</code></li></ul></li><li>检查是否存在 <code>x-&gt;y ^ y-&gt;x</code></li></ul><h3 id="threadsanitizer"><a href="#threadsanitizer" class="headerlink" title="threadsanitizer"></a>threadsanitizer</h3><p>运行时的数据竞争检查</p><ul><li>为所有事件建立 happens-before 关系图</li><li>对于发生在不同线程并且至少有一个是写的 x, y 检查是否存在 <code>x-&gt;y^y-&gt;x</code></li></ul><h3 id="AddressSanitizer-非法内存访问"><a href="#AddressSanitizer-非法内存访问" class="headerlink" title="AddressSanitizer 非法内存访问"></a>AddressSanitizer 非法内存访问</h3><ul><li>overflow</li><li>underflow</li><li>use-after-free</li><li>use-after-return</li></ul><h3 id="MemorySanitizer-未初始化的读取"><a href="#MemorySanitizer-未初始化的读取" class="headerlink" title="MemorySanitizer 未初始化的读取"></a>MemorySanitizer 未初始化的读取</h3><h3 id="UBSanitizer-未定义的行为"><a href="#UBSanitizer-未定义的行为" class="headerlink" title="UBSanitizer 未定义的行为"></a>UBSanitizer 未定义的行为</h3><ul><li>偏离方向的指针</li><li>有符号的整数溢出</li></ul><h3 id="低配版-lockdep"><a href="#低配版-lockdep" class="headerlink" title="低配版 lockdep"></a>低配版 lockdep</h3><ul><li>统计当前spin count<ul><li>如果超过某个明显不正常的数值就报告</li></ul></li><li>配合调试器和线程backtrace诊断死锁</li></ul><h3 id="低配版-Sanitizer"><a href="#低配版-Sanitizer" class="headerlink" title="低配版 Sanitizer"></a>低配版 Sanitizer</h3><p>内存分配要求：已分配内存 S = 总内存 - 未分配内存</p><ul><li><code>kalloc(s)</code> 返回的内存必须位于未分配的内存</li><li><code>thread-local-allocation</code> + 并发的 free 还是容易出错<br>分配时不能出现一点已经被分配的内存<br>释放时也不能出现一点已经被释放的内存</li></ul><h3 id="并发bug-死锁"><a href="#并发bug-死锁" class="headerlink" title="并发bug-死锁"></a>并发bug-死锁</h3><p>线程之间互相等待，都在等待着对方持有的锁，上自旋锁的时候需要关闭中断，否则可能会出现错误</p><p><strong>死锁产生的必要条件</strong></p><ol><li>互斥：一个资源每次只能被一个进程调用</li><li>请求与保持：一个进程请求阻塞时，不放开当前已有的资源</li><li>不剥夺：进程以获得的资源不能强行剥夺</li><li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li></ol><p><strong>AA-Deadlock</strong></p><p>在操作系统中一个线程就可以发生死锁。也就是中断持有 CPU，但是拿不到锁，所以在等待。而进程持有锁但是得不到 CPU 所以也等待</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">os_run</span><span class="params">()</span>&#123;</span><br><span class="line">    spin_lock(&amp;list_lock);<span class="comment">//之后关闭中断</span></span><br><span class="line">    spin_lock(&amp;xx);</span><br><span class="line">    spin_unlock(&amp;xx); <span class="comment">//此时之后开启中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">os_interpreter</span><span class="params">()</span>&#123; <span class="comment">// 中断函数调用锁</span></span><br><span class="line">    spin_lock(&amp;list_lock);</span><br><span class="line">    spin_unlock(&amp;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ABBA-Deadlock</strong> — <code>lock_ordering</code></p><ul><li>任何时刻系统中的锁都是有限的</li><li>严格按照固定的顺序获得所有锁。其实就是当最快的线程获得了编号靠前的锁之后，对于其他线程来说，就已经被卡死在这里，当然要想走到这一步的线程在之前的锁的争取上是获得胜利的，所以整个线程进度图就像是一棵树，释放锁时也需要按照一定的顺序释放，从前往后或者从后往前，可以保证所有线程有序的进行。所以最好的锁是封装锁，外部的看不到，也能很好的避免死锁</li></ul><h3 id="并发bug-数据竞争"><a href="#并发bug-数据竞争" class="headerlink" title="并发bug-数据竞争"></a>并发bug-数据竞争</h3><p>不同的线程同时访问统一段内存，并且其中至少有一个是写<br>对于两个同时读写，慢的一方会把快的一方存入的数据覆盖掉<br>使用互斥锁保护好共享数据，消灭数据竞争<br>出现bug的原因:</p><ol><li>上错了锁</li><li>忘记上锁 原子性违反</li></ol><h3 id="其他的并发bug"><a href="#其他的并发bug" class="headerlink" title="其他的并发bug"></a>其他的并发bug</h3><ul><li>互斥锁 ———— 原子性</li><li>条件变量 ———— 同步</li><li>忘记上锁 —— 违反原子性</li><li>忘记同步 —— 顺序违反</li><li>非法内存访问</li><li>未初始化的读取</li><li>数据竞争</li></ul><h2 id="操作系统的状态机模型"><a href="#操作系统的状态机模型" class="headerlink" title="操作系统的状态机模型"></a>操作系统的状态机模型</h2><h3 id="bare-metal-约定"><a href="#bare-metal-约定" class="headerlink" title="bare-metal 约定"></a>bare-metal 约定</h3><p>实现操作系统的前提是软件与硬件之间存在某种约定</p><ul><li>CPU RESET之后，处理器处于某个特定的状态<ul><li>pc指针一般指向一段 memory-mapped ROM<ul><li>ROM 存储了厂商提供的固件</li><li>pc reset 之后，应当指向一个特定的位置，可以不断的从中读取到指令，这就相当于把硬件和软件链接起来</li></ul></li></ul></li><li>Fireware 固件，厂商提供代码<ul><li>有用户数据加载到内存<ul><li>例如存储介质上的第二级loader</li><li>或者直接加载操作系统</li></ul></li><li>用户数据从内存读取</li></ul></li></ul><h3 id="CPU-RESET"><a href="#CPU-RESET" class="headerlink" title="CPU RESET"></a>CPU RESET</h3><p>整个计算机都是一个状态机</p><ul><li>从PC指针处读取指令，译码，执行</li><li>从 firmware 开始执行<ul><li>ffff0 通常是一条向firmware 跳转的jmp指令</li></ul></li></ul><h3 id="firmware-BIOS-vs-UEFI"><a href="#firmware-BIOS-vs-UEFI" class="headerlink" title="firmware: BIOS vs UEFI"></a>firmware: BIOS vs UEFI</h3><ul><li>都是主板/主板上外插设备的软件抽象<ul><li>支持系统管理内存运行</li></ul></li><li>legacy BIOS(基础的I/O系统)</li><li>UEFI(未定义的可扩展硬件)</li></ul><h3 id="firmware作用"><a href="#firmware作用" class="headerlink" title="firmware作用"></a>firmware作用</h3><ul><li>代码直接储存在硬件中<ul><li>CPU RESET 之后会执行</li><li>加载512个字节到内存中(Legacy BIOS)</li></ul></li><li>放置一些绝对安全的代码<ul><li>BIOS中断(打印Hello world字符)</li><li>ARM Trust Firmware<ul><li>BOOST LEVEL</li><li>U-BOOST</li></ul></li></ul></li><li>有点像操作系统的系统调用，可以完成一些读取磁盘，写字符等基础操作，加载操作系统</li></ul><h3 id="firmware-Legacy-BIOS-约定"><a href="#firmware-Legacy-BIOS-约定" class="headerlink" title="firmware:Legacy BIOS 约定"></a>firmware:Legacy BIOS 约定</h3><p>Legacy BIOS把第一个可引导的设备的第一个扇区加载到物理内存的7c00位置</p><ul><li>此时处理器处于16-bits位置上</li><li>启动磁盘的第一个512个字节叫做主引导扇区MBR，这个指引扇区由 firmware 搬运到特定的内存</li><li>其他没有任何约束</li><li>windows 系统的AB磁盘都是软盘，从c开始才是磁盘</li></ul><h3 id="计算机操作系统的启动过程"><a href="#计算机操作系统的启动过程" class="headerlink" title="计算机操作系统的启动过程"></a>计算机操作系统的启动过程</h3><p>BIOS并不会接受所有的磁盘，如果将非引导磁盘插入软驱的时候，BIOS 会报错</p><p>BIOS选择的标准是：检查软盘的第一个启动扇区（第一个可启动磁盘的前512个字节），如果是以55aa结束，那它就是一个引导扇区，BIOS会把这512个字节装载0:7c00(也可能是07c0:0) 处，然后将控制权彻底交给这段引导代码，到此为止，计算机不再由BIOS控制，而是被操作系统的一部分控制，之后这一部分代码就会加载后面部分的代码</p><ul><li>按下开机键，cpu开始执行bios，bios是位于rom上的一段程序，并且在出厂的时候就被写死在rom里。</li><li>bios的作用是检查计算机的硬件，即硬件自检，然后bios会调入磁盘0号扇区的内容，把0号扇区调入到内存，开始执行。</li><li>0号扇区内存储的内容是MBR，主引导扇区，大小只有512B，前446B是代码，后面的是硬盘分区表，这里存储的是硬盘里的分区信息，分区的起始地址</li><li>对于磁盘分区，其中对于windows有个C盘，与其他分区不同之处在于，这个分区的0号扇区内是存放着分区引导程序的，可以引导该分区的操作系统。所以进入MBR之后就可以选择进入的操作系统了，如果要执行windows就把windows的引导扇区调入内存开始执行，就会启动windows了，之后电脑就交由操作系统来管理了</li></ul><h3 id="firmware-病毒"><a href="#firmware-病毒" class="headerlink" title="firmware 病毒"></a>firmware 病毒</h3><p>不仅仅伤害软件，并且伤害硬件</p><ul><li>intel 430TX(Pentium)芯片组允许写入Flash ROM<ul><li>只要向Flash BIOS写入特定的序列，Flash ROM就变为可写<ul><li>ROM 是用来写保护的<br>  CIH 病毒程序会不断复制自己，会对软盘上的内容进行修改<br>  这种病毒不会一上来就发病，每年的4月26号就会打开ROM的写系统，然后写入垃圾<br>  这种病毒造成的损害没有办法通过重启来修复</li></ul></li></ul></li></ul><p><strong>解决办法</strong></p><ul><li>更换一块ROM</li><li>CPU更换为Risc-V的CPU，这个CPU上电之后还原ROM</li></ul><h3 id="firmware-UEFI"><a href="#firmware-UEFI" class="headerlink" title="firmware:UEFI"></a>firmware:UEFI</h3><p>彻底解决了类似CIH的病毒</p><h3 id="系统加载流程"><a href="#系统加载流程" class="headerlink" title="系统加载流程"></a>系统加载流程</h3><ul><li>盘必须按GPT(GUID Partition Table) 方式格式化</li><li>预留一个FAT32分区(fsblk/fdisk)可以看到</li><li>firmware加载任意大小的PE可执行文件.efi<ul><li>没有legacy bios 512字节限制</li><li>EFI 应用可以返回firmware<ul><li><strong>优点</strong></li><li>设备驱动框架</li><li>更多功能-只启动信任的操作系统</li></ul></li></ul></li></ul><p>UEFI 加载器也不再仅仅加载是 512 字节的 MBR，而是能加载任意 GPT 分区表上的 FAT 分区中存储的应用。今天的计算机默认都通过 UEFI 引导。</p><h3 id="模拟方案-QEMU"><a href="#模拟方案-QEMU" class="headerlink" title="模拟方案 QEMU"></a>模拟方案 QEMU</h3><p>是一种模拟处理器软件，在GNU/LINUX上使用广泛，甚至能够达到电脑的速度</p><p><strong>User mode</strong></p><p>用户模式，能够启动那些为中央处理器编译的LINUX程序</p><p><strong>System mode</strong></p><p>系统模式，可以模拟一整台电脑系统，包括中央处理器和周边设备</p><h3 id="真机方案-JTAG"><a href="#真机方案-JTAG" class="headerlink" title="真机方案 JTAG"></a>真机方案 JTAG</h3><p>一系列物理寄存器，可以实现gdb调试</p><h3 id="操作系统-状态机"><a href="#操作系统-状态机" class="headerlink" title="操作系统-状态机"></a>操作系统-状态机</h3><p>firmware 和 boot loader 加载工作</p><ul><li>初始化全局变量和栈；分配堆区</li><li>为main函数传递参数<br>进入c代码之后，遵循C语言的形式语义，还有一些行为补充 AbstractMachine<br>C语言 volatlie<br>如果变量不声明为 volatile 的话，编译器不会想到它这个变量可能会被外部程序修改，所以在编译之后运行的时候，这个变量就会被保存在寄存器中，但是外部的中断程序不能更改寄存器内的变量，加上 volatile 是易变的，改变量就会被外部中断所改变</li></ul><h3 id="AbstractMachine"><a href="#AbstractMachine" class="headerlink" title="AbstractMachine"></a>AbstractMachine</h3><ul><li>TRM+MPE<ul><li>等同于多线程处理器</li><li>IOE API 完全是普通的库函数<ul><li>同一设备数据竞争 = undefined behavior</li></ul></li></ul></li><li>CET<ul><li>允许创建多个执行流 + M2</li><li><code>yield</code> 主动切换，会被中断被动打断</li><li><code>on_interrupt</code> 会拦截中断事件</li></ul></li><li>VME<ul><li>允许创建一个“经过地址翻译的执行模式”</li><li>通过CET API 管理</li></ul></li><li><p>观察make编译程序的过程</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">make -nB \\\\\\\\</span><br><span class="line">| grep -ve <span class="string">&#x27;^\\\\\\\\(\\\\\\\\#\\\\\\\\|echo\\\\\\\\|mkdir\\\\\\\\|make\\\\\\\\)&#x27;</span> \\\\\\\\</span><br><span class="line">| sed <span class="string">&quot;s#$AM_HOME#\\\\\\\\$AM_HOME#g&quot;</span> \\\\\\\\</span><br><span class="line">| sed <span class="string">&quot;s#$PWD#.#g&quot;</span> \\\\\\\\</span><br><span class="line">| vim -</span><br><span class="line">    - make -nB (RTFM)</span><br><span class="line">    - grep 文本过滤，省略一些干扰项</span><br><span class="line">        - echo(提示信息), mkdir 建立目录， make(sub-goals)</span><br><span class="line">    - sed 输出更易读</span><br><span class="line">        - 将绝对路径替换为相对路径</span><br><span class="line">    - vim - 在vim 中查看</span><br></pre></td></tr></table></figure></li></ul><h3 id="编译器和现代CPU"><a href="#编译器和现代CPU" class="headerlink" title="编译器和现代CPU"></a>编译器和现代CPU</h3><p>现在的CPU允许同一时间执行两条甚至是多条代码</p><p>一条指令周期执行一条代码</p><h3 id="trace和调试器"><a href="#trace和调试器" class="headerlink" title="trace和调试器"></a>trace和调试器</h3><p>程序执行 = 状态机执行</p><p>观察方式：<code>strace / gdb</code></p><p>使用 <code>strace -T</code> 可以获得系统调用所花费的时间</p><p>每一条指令的 side-effect 有限，一般只能访问一次内存或者改变几个寄存器的数值</p><ul><li>只记录初始状态和每条指令前后状态的 diff(指令之后状态的改变)</li><li>正向执行 Sn -&gt; Sn+1</li><li>反向执行 Sn -&gt; Sn-1</li><li>使用GDB回溯调试不适用于某些指令(syscall)</li></ul><p>我们需要记住，从一个初始状态到执行结束期间，执行了多少条不确定的指令，还要记录对应指令结束之后的结果，还要记住例如random和syscall之后的结果</p><p>(指令数目+非确定指令的结果+非确定指令) * N</p><p>在CPU中执行的绝大多数指令都是确定的，只需要记录很少部份的不确定性的指令</p><p>如果要记录计算机的系统的执行，只需要记录所有的I/O指令(memory map/inport IO)+所有时候发生的中断</p><p>对于一个确定的程序，只需要记录一个初始状态，后面都可以 replay 复现所有的结果</p><p><strong>record &amp; replay</strong></p><ul><li>单线程 应用程序<ul><li><code>syscall</code>, <code>rdrand</code>, <code>rdtsc</code></li></ul></li><li>单处理器 操作系统<ul><li>中断<br>对于record可以只记录不确定的部分，确定的运行的部分可以不记录</li></ul></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>状态机执行需要时间，对象需要空间</p><p>需要理解时间花在那里，什么对象占用空间</p><p><strong>性能摘要</strong></p><p>性能摘要需要对程序执行性能影响最小，往往不需要full trace</p><p>隔一段时间暂停程序观察运行情况</p><ul><li>中断</li><li>记录record<ul><li>执行语句</li><li>函数调用栈</li><li>服务请求</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;cli&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 关掉中断指令，但是实际上是不允许自己的程序关掉中断的，会触发异常</span></span><br></pre></td></tr></table></figure><p><code>perf list</code>, <code>perf stat</code>, <code>perf record</code>, <code>perf report</code>(需要手动安装perf)<br><strong>实际性能优化</strong><br>大部分情况</p><ul><li>80%时间消耗在集中的几处代码</li><li>L1 小内存分配时的lock contention<br>SMT solver<br>model-checker 自动分析程序执行</li></ul><h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><h3 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h3><p><code>CPU reset -&gt; firmware -&gt; boot loader -&gt; (kernel _start()) OS -&gt; .....</code></p><p>然后操作系统会加载第一个程序 <code>RTFSC</code> ，然后 <code>linux kernel</code> 会进入后台，成为中断/错误处理程序</p><p>从第一个开始依次执行访问，查找启动操作系统的文件</p><ul><li><code>/sbin/init</code></li><li><code>/etc/init</code></li><li><code>/bin/init</code></li><li><code>/bin/sh</code></li></ul><p>操作系统执行之后，操作系统会执行一个程序，但是这个程序不会返回，并且操作系统的所有进程都会被 <code>init</code> 函数调用 <code>fork</code> 系统调用来启动</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a><code>fork()</code></h3><p><code>fork()</code>进程是条系统调用：本来只有一个执行的进程，之后会变为两个产生分支，其实就是通过 <code>fork()</code> 来创建进程</p><p><code>fork()</code> 作用就是将整个程序这个状态机完全的复制一份，执行完毕之后，系统中会出现完全一样的进程，内存的每一个字节都一样，寄存器也一样，除了 <code>fork()</code> 的返回值不一样，每个进程都有一个不一样的编号，每一个进程都无法访问其他的进程， <code>fork()</code> 返回的是创建出来的进程的进程编号，但是被创建出来的返回值是0，之后操作系统就进入了并发系统</p><p>执行fork的程序会将自身的整个状态机完全复制一份，除了返回值不同，父进程会返回子进程的oid，子进程返回0，其他部分都不变，连进程中的文件描述符也会复制一遍，但是那个文件对象只有那一个。</p><p>对于子进程要执行 execve 的指令时，会重置子进程的状态机，但是如果子进程中含有复制过来的文件描述符的话，并不会重置文件描述符，而是保留不变，是因为每个进程中都含有一个文件描述符表用于存储它的文件描述符，当一个进程执行 execve 状态机重置的时候，它的文件描述符应该被关掉而不是被子进程继承下去，防止出现父进程有权限而子进程无权限处理文件而发生安全问题的情况</p><ul><li>操作系统就是状态机的管理者</li><li>虚拟化就是操作系统可以管理很多状态机，每次选择一个状态机执行一步</li><li><code>fork()</code> 函数甚至能把函数内部状态全部复制一份。使用不当导致 <code>fork bomb</code> ：无休止创建进程的程序</li><li>不停的创建程序，系统还是会挂掉的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:()&#123; :|:&amp; &#125;;:</span><br><span class="line"></span><br><span class="line">fork()&#123; <span class="comment">// bash：允许冒号作标识符</span></span><br><span class="line">    fork | fork &amp;</span><br><span class="line">&#125;;fork <span class="comment">// 相当于递归调用fork() 函数，无限制的创建线程</span></span><br></pre></td></tr></table></figure><p><code>fork</code> 是完全复制状态机，完全复制一个进程，甚至连缓冲区内部数据都能复制</p><ul><li><code>tty</code> ： line buffer 如果看到 <code>\n</code> 就会把缓冲区内的所有东西写出来，其实就是 <code>\n</code> 清除缓冲区， <code>fflash(stdout)</code> 。清除缓冲区</li><li><code>pipe</code> ：full buffer 如果看到写满 4096 字节之后，把这个页面整个丢给管道给另外的程序，或者打印出来。其实就是写入管道的话，缓冲区内的数据也会被写入管道，但是对于tty中打印的话，最终缓存区内部的数据没有被打印出来，两种缓冲模式不同。进程结束之后，C代码不会立即结束，会将缓冲区的所有内容清空</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\\\\\\\\\\\\\\\\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread_num</span></span><br><span class="line"><span class="comment">对于 tty 中：</span></span><br><span class="line"><span class="comment">1. thread_num 1 i = 0</span></span><br><span class="line"><span class="comment">fork-&gt;thread_num 2</span></span><br><span class="line"><span class="comment">终端显示 hello * 2</span></span><br><span class="line"><span class="comment">缓冲区 null</span></span><br><span class="line"><span class="comment">2. thread_num 2 i = 1</span></span><br><span class="line"><span class="comment">fork-&gt; thread_num 4</span></span><br><span class="line"><span class="comment">终端显示 hello * 6</span></span><br><span class="line"><span class="comment">缓冲区 null</span></span><br><span class="line"><span class="comment">对于 pipe:</span></span><br><span class="line"><span class="comment">1. thread_num 1 i = 0</span></span><br><span class="line"><span class="comment">fork-&gt;thread_num 2</span></span><br><span class="line"><span class="comment">终端显示 null</span></span><br><span class="line"><span class="comment">缓冲区 hello\\\\\\\\\\\\\\\\n * 2</span></span><br><span class="line"><span class="comment">2. thread_num 2 i = 1</span></span><br><span class="line"><span class="comment">fork-&gt;thread_num 4</span></span><br><span class="line"><span class="comment">终端显示 null</span></span><br><span class="line"><span class="comment">缓冲区 hello\\\\\\\\\\\\\\\\n hello\\\\\\\\\\\\\\\\n *4</span></span><br><span class="line"><span class="comment">3.终端显示 hello * 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>fork搜索并行化</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/alphago.png" alt="alphago.png"></p><p><em>这个就体现出了一种回溯的新的算法，可以将运行的时间复杂度为 o(n) n是深度</em></p><p>每次搜索都fork一个新的进程，甚至连回溯的结果都不要了，直接只有对的进程能操作实现，并且最关键的是fork创建出来的子进程对原来的系统内存中并不会影响到</p><p><strong>fork跳过初始化</strong></p><p>只初始化一次，然后其他的所有进程都直接复制父进程，这样的子进程就不需要再次初始化了</p><p>例如 Android 是通过java代码开发的，是一个<strong>Java Virtual Machine</strong>，涉及到大量的类加载，所以可以只初始化一次然后全员使用，打开应用就相当于fork了一个进程，并且把相关的权限设置之后就可以开始运行</p><p><strong>fork备份和容错</strong></p><p>可以使用fork创建一个快照，也就是存档，当主进程crash了，就启动快照重新执行，并且在启动快照时再次复制一份进程</p><p>当运行并发程序时，可以在运行的时候经常fork新的进程，然后进程跑死之后，直接启动子进程，并且更改子进程的环境，启动的时候也要fork子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个小栗子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line">jmp_buf buf;</span><br><span class="line"><span class="type">void</span> <span class="title function_">F2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;F2()\n&quot;</span>);</span><br><span class="line">    longjmp(buf,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">F1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    F2();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;F1()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> jmpret = setjmp(buf); <span class="comment">// 相当于跳回了这一步</span></span><br><span class="line">    <span class="keyword">if</span>(!jmpret)</span><br><span class="line">    &#123;</span><br><span class="line">        F1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;继续执行main\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork——Unix时代的产物</strong></p><p>fork + execve 只有内存和文件描述符，并且文件描述符指向的只有管道和终端</p><p>线程是属于进程的，如果一个进程中有两个线程，其中进程执行fork指令，当然肯定是进程中的某一个线程执行的fork指令，此时复制进程时并不会把所有的线程都复制，而是<strong>只复制执行 fork 指令的线程，</strong>如今的 linux 操作系统并不能很可靠的执行每一个线程的复制，线程的创建实际上是通过一个 clone 的系统调用来执行的，fork也只是某一种clone的变体，也可以把没有复制过来的进程给捞过来</p><h3 id="execve"><a href="#execve" class="headerlink" title="execve()"></a><code>execve()</code></h3><p>指令在系统中创建各种各样的线程，每当创建一个线程之后都会进行判断。作用：重置状态机为某个函数初始状态，这个函数还可以传入参数 <code>argc</code> 和 <code>argv[]</code>，还可以传入环境变量 <code>envp[]</code> 。</p><p>对于 main 函数，完整的 main 函数： <code>int main(int argc, char* argc[], char* envp[])&#123;&#125;</code> export 可以更改环境变量的值，也可以自己创建环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line">//if(pid == 0)&#123;</span><br><span class="line">//    error handling;</span><br><span class="line">//&#125;</span><br><span class="line">if(pid &gt; 0)&#123;</span><br><span class="line"> wait/continue; //该程序是父进程，可以选择等待或者继续执行</span><br><span class="line"> // 如果是等待，就相当于是同步，继续就相当于是创造一个进程的后台执行</span><br><span class="line">&#125;</span><br><span class="line">if(pid == 0)&#123;</span><br><span class="line"> execve(); // 重置状态机，重置为某一个程序的初始状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>strace</code> 查看程序的系统调用会发现：每一个程序开始所执行的第一个系统调用都是 <code>execve()</code>函数。实际上就是，对于 Linux 系统来说，每次运行一个程序都是调用的fork来创建新的线程，之后再通过 <code>execve()</code> 函数来初始化线程</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1698478392584.png" alt="1698478392584.png"></p><p>由于 main 函数是被 <code>libc_start_main</code> 函数调用的，所以 main 函数的栈帧在低地址处</p><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a><code>exit()</code></h3><p>当执行<code>exit()</code>时，整个系统中所有的东西都保持不变，只有执行<code>exit()</code>程序的线程被销毁</p><ul><li><code>_exit(int statue)</code>函数销毁当前状态机，并且允许有一个返回值</li><li>子进程终止会通知父进程</li><li>对于多线程<ul><li>删除一个线程</li><li>删除一个总线程之后，其他的线程也跟着结束</li></ul></li></ul><p><strong>结束当前进程的四个方式</strong></p><ul><li><code>return, exit, _exit_, syscall</code><ul><li><code>return</code> 结束函数运行，会调用 <code>atexit()</code></li><li><code>exit(0)</code> 是存在于libc的库函数<ul><li>执行的时候会调用 <code>atexit</code> ，将缓冲区中的东西写出去</li><li><code>atexit(func)</code> 执行的时候会调用括号里的函数</li></ul></li><li><code>_exit(0)</code>存在于 <code>glibc</code> 库里<code>syscall wrapper</code><ul><li>相当于系统调用函数，直接终止整个进程所有线程，不会调用<code>atexit</code></li></ul></li><li><code>syscall(SYS_exit,0)</code><ul><li>执行 <code>exit</code> 系统调用函数终止当前线程</li><li>不会调用<code>atexit()</code></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    atexit(func);</span><br><span class="line"></span><br><span class="line">    if(argc&lt;2)return EXI_NUM;</span><br><span class="line">    if(strcmp(argv[1], &quot;exit&quot;))exit(0);</span><br><span class="line">    if(strcmp(argv[1], &quot;_exit&quot;))_exit(0);</span><br><span class="line">    if(strcmp(argv[1], &quot;__exit&quot;))sys_call(SYS_exit,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="waitpid-pid-t-pid-int-statusp-int-options"><a href="#waitpid-pid-t-pid-int-statusp-int-options" class="headerlink" title="waitpid(pid_t pid, int *statusp, int options);"></a><code>waitpid(pid_t pid, int *statusp, int options);</code></h3><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除，此时进程被保持在一种已终止的状态中，直到被它的父进程回收。把一个已经终止运行但是还没被回收的额进程称为僵死进程，虽然没有在运行，但是仍然在消耗系统的内存资源。</p><p>Linux 系统中父进程可以通过该函数来等待它的子进程终止或者停止</p><p><strong>pid</strong></p><ul><li>如果 <code>pid &gt; 0</code> 那就是这个子进程的ID</li><li>如果 <code>pid = -1</code> 表示等待的是由父进程创建的所有的子进程组成的集合</li></ul><p><strong>statusp 指向status的指针</strong></p><p>非空的，放入导致返回的子进程的状态信息</p><ul><li><code>WIFEXITED(status)</code> 如果是 <code>exit</code> 或者 <code>return</code> 终止为 <code>true</code></li><li><code>WIFSIGNALED(status)</code> 如果是因为一个未捕获的信号终止 <code>true</code></li><li><code>WEXITSTATUS(status)</code> 可以提取程序返回值，前提是正常终止程序 <code>WIFEXITED(status)=1</code></li><li><code>WTERMSIG(status)</code> 获取子进程因信号终止的信号，前提是<code>WIFSIGNALED(status)=1</code>信号终止</li><li><code>WIFSTOPPED(status)</code> 当子进程接收到停止信号时 <code>true</code></li><li><code>WSTOPSIG(status)</code> <code>WIFSTOPPED</code>为 <code>true</code> 时，获得导致子进程停止的信号类型</li><li><code>WIFCONTINUED(status)</code>子进程接收到 <code>SIGCONT</code>信号继续执行时 <code>true</code></li></ul><h3 id="程序的地址空间"><a href="#程序的地址空间" class="headerlink" title="程序的地址空间"></a>程序的地址空间</h3><p>在c语言中， <code>char* p</code> 与 <code>intptr_t</code> 可以相互转换</p><ul><li>可以指向任何地方，对于这些地方的权限行为，完全取决于pmap的结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    unsigned *p;</span><br><span class="line">    p = (void *)main;</span><br><span class="line">    p = (void *)0x12013990; // 非法的地址</span><br><span class="line">    printf(&quot;%x/n&quot;,*p);</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果为 fa1e0ff3</span><br></pre></td></tr></table></figure><ul><li>合法的地址(可读或者可写)<ul><li>代码(main,%rip会从此处取出待执行的指令)，只读</li><li>数据(static int x), 读写</li><li>堆栈(int y)，读写</li><li>运行时分配的内存，读写</li><li>动态链接库</li></ul></li><li>非法的地址<ul><li>NULL，一些乱七八糟的地址，导致 segmentation fault</li></ul></li></ul><p><strong>查看进程地址空间</strong> <code>pmap report memory of a process</code> 查看一个进程的地址空间<br>通过gdb来查看当前被调试的进程的进程号 info inferiors<br>之后可以使用 <code>pmap</code> + 进程号(或者 vim /proc/进程号/maps) 来查看进程的地址空间<br>输出的地址和后面会跟上读或写的权限</p><p><strong>操作系统提供查看进程地址空间的机制</strong><code>RTFM: /proc/[pid]/maps(man 5 proc)</code></p><ul><li>权限<ul><li>r 可读</li><li>w 可写</li><li>x 可执行</li><li>p</li></ul></li><li>进程地址空间的每一段<ul><li>地址和权限</li><li>对应的文件: <code>offset</code>, <code>dev</code>, <code>inode</code>, <code>pathname</code><br>对于静态的链接的代码，地址一般都是 4000000 左右<br>但是对于动态链接的代码，地址一般都是 5555555 左右<br>当然这都是调试器所生成的地址，对于操作系统，每次运行程序都会有一个地址空间随机化，可以保证程序每次被加载到一个随机的地方，提升程序的安全性，但是调试器会把这个特性关掉( address space layout randomization )</li></ul></li><li>这个可以通过<code>readelf -l a.out |&amp; vim -</code>来查看并且验证着一个部分，实际上对于elf文件中说明了在那个地址，分配多少内存，系统的执行权限</li><li>在这个里面，有几个没有文件的指令，但是分配了内存，这个就是用来对于为一些文件里为初始化的部分进行初始化 可以通过查看手册<code>man 5 proc</code>来查看其他的含义</li></ul><h3 id="系统调用syscall"><a href="#系统调用syscall" class="headerlink" title="系统调用syscall"></a>系统调用syscall</h3><p>执行这条指令之后，系统会进入内核代码，这会带来权限开销或者额外的指令开销</p><ul><li>vdso 只读的系统调用也许可以不陷入内核中，这样运行会更快<ul><li>示例 time<ul><li>时间：内核维护 秒级时间</li></ul></li><li>gettimeofday()</li></ul></li><li>vvar</li><li>anon 已分配内存</li><li>stack 程序堆栈</li><li>mmap 虚拟内存映射 (<a href="https://zhuanlan.zhihu.com/p/640169233">mmap详细介绍</a>)</li></ul><h3 id="mmap-的原理"><a href="#mmap-的原理" class="headerlink" title="mmap 的原理"></a>mmap 的原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br></pre></td></tr></table></figure><p><strong>工作过程</strong></p><p>memory map 内存映射文件的方法，就是将一个文件或者其他的对象映射到进程的地址空间，实现文件磁盘地质和进程虚拟地址空间中一段虚拟地址的的一一对应关系，实现这样的映射关系之后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页到对应的文件磁盘中，进程就实现了不需要对文件进行 read 或者 write 就完成了文件的读写，内核空间对这段区域的修改也反映用户空间，从而实现不同进程间的文件共享</p><p>可以把文件的某一段，当作内存一样来访问。将文件映射到物理内存，将进程虚拟空间映射到那块内存</p><p><strong>特点</strong></p><p><code>mmap</code> 向应用程序提供的内存访问接口是内存地址连续的（虚拟内存），但是对应的磁盘文件的 <code>block</code> 可以不是地址连续的</p><ol><li><code>mmap</code> 提供的内存空间是虚拟空间（虚拟内存），而不是物理空间（物理内存），因此完全可以分配远远大于物理内存大小的虚拟空间（例如 16G 内存主机分配 1000G 的 <code>mmap</code> 内存空间）</li><li><code>mmap</code> 负责映射文件逻辑上一段连续的数据（物理上可以不连续存储）映射为连续内存，而这里的文件可以是磁盘文件、驱动假造出的文件（例如 DMA 技术）以及设备</li><li>mmap 由操作系统负责管理，对同一个文件地址的映射将被所有线程共享，操作系统确保线程安全以及线程可见性</li><li>mmap 的设计很有启发性。基于磁盘的读写单位是 block（一般大小为 4KB），而基于内存的读写单位是地址（虽然内存的管理与分配单位是 4KB）</li></ol><p><strong>虚拟内存地址转换</strong></p><p>虚地址就是虚拟空间的地址，虚地址通过转换得到实地址，转换方式课程内也讲得很清楚，虚地址头部包含了页号（段地址和段大小，看存储模式：页存储、段存储，段页式），剩下部分是偏移量，经过MMU转换成实地址。</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled.png" alt="Untitled"></p><p><strong>内存的存储方式</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%201.png" alt="Untitled"></p><p>虚拟地址头部为页号，通过查询页表得到物理页号，页号*偏移量就能得到物理地址</p><p>虚拟地址头部为段号，段表中找到段基地址加上偏移量得到实地址</p><p><strong>原理</strong></p><p>mmap创建一个新的 vm_area_struct 结构，并且将其与文件/设备的物理地址相连</p><p><strong>vm_area_struct</strong></p><p>linux中使用 vm_area_struct 来表示一个独立的虚拟内存区域，一个进程可以使用多个vm_area_struct来表示不同类型的虚拟内存地址（堆，栈，代码段，MMAP区域等）</p><p>vm_area_struct结构中包含了区域起始地址。同时也包含了一个vm_opt指针，其内部可引出所有针对这个区域可以使用的系统调用函数。从而，进程可以通过vm_area_struct获取操作这段内存区域所需的任何信息。</p><p>进程通过vma操作内存，而vma与文件/设备的物理地址相连，系统自动回写脏页面到对应的文件磁盘上（或写入到设备地址空间），实现内存映射文件。</p><p><strong>内存映射文件的原理</strong></p><p>首先创建虚拟区间并完成地址映射，此时还没有将任何文件数据拷贝至主存。当进程发起读写操作时，会访问虚拟地址空间，通过查询页表，发现这段地址不在物理页上，因为只建立了地址映射，真正的数据还没有拷贝到内存，因此引发缺页异常。缺页异常经过一系列判断，确定无非法操作后，内核发起请求调页过程。</p><p>最终会调用nopage函数把所缺的页从文件在磁盘里的地址拷贝到物理内存。之后进程便可以对这片主存进行读写，如果写操作修改了内容，一定时间后系统会自动回写脏页面到对应的磁盘地址，完成了写入到文件的过程。另外，也可以调用msync()来强制同步，这样所写的内存就能立刻保存到文件中。</p><p><strong>实现过程</strong></p><ol><li><p>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</p><p> 调用mmap→在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址→为此虚拟区域分配一个vm_area_struct，对这个结构进行初始化，将其插入到进程的虚拟地址区域链表或者树中</p></li><li><p>调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</p><p> 为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。通过该文件的文件结构体，链接到 <code>file_operations</code>模块，调用内核函数mmap不同于用户空间库函数。内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。通过 <code>remap_pfn_range</code>函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中</p></li><li><p>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</p><p> 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。<br> 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。<br> 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。<br> 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p><p> <strong>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</strong></p><p> <strong>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了</strong></p></li></ol><h3 id="Linux操作系统的shell"><a href="#Linux操作系统的shell" class="headerlink" title="Linux操作系统的shell"></a>Linux操作系统的shell</h3><p>shell 功能的实现：</p><p>linux 系统下, 有一个系统级的打开文件表 (Open File Table).</p><p>而每个进程的 PCB (Process Control Block) 中都有一个文件描述符表 (File Descriptor Table), 进程就是通过文件描述符表中的文件描述符对文件进行操作的。每个文件描述符指向打开文件表中的一个文件，不同的文件描述符可以指向同一个文件。其中文件描述符是从0开始的整数</p><p>0：标准输入文件</p><p>1：标准输出文件</p><p>2：标准错误文件</p><p>对于 shell 就是首先把指令翻译为一棵树，然后从树的头节点开始执行指令。下面介绍一些指令</p><ol><li><p>exec</p><p> 其中execve是内核级别的系统调用，其他的<code>execl, execle, execlp, execv, execvp</code>都是调用该系统调用</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[ ], <span class="type">char</span> *<span class="type">const</span> envp[ ])</span>;</span><br><span class="line">函数执行成功没有返回值，失败返回<span class="number">-1</span></span><br><span class="line">参数</span><br><span class="line">filename 表示文件路径 filename 其实也是可执行的指令，在linux中，echo，cat之类的指令都有存在对应的文件，但是cd是没有执行文件的</span><br><span class="line">argv 是利用数组指针来传递给执行文件，也就是filename，以<span class="literal">NULL</span>结尾</span><br><span class="line">最后表示传递给执行文件的新环境变量数组</span><br></pre></td></tr></table></figure><p> exec系列的系统调用是把当前程序替换成要执行的程序，并且使用fork来产生一个和当前进程一样的进程，通常会运行另一个程序同时保留原程序运行的方法是调用fork+exec</p></li><li><p>redir</p><p> 重定向 &gt; 的运行顺序是：先创建一个进程，然后将文件描述符重定向，然后执行execve指令</p><p> 将信息输出到某一个文件中，如果文件存在需要使用!参数进行强制覆盖，可以使用&gt;&gt;追加到文件末尾，使用END停止重定向</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; &#123;file&#125;</span><br><span class="line">ls! &gt; &#123;file&#125;</span><br><span class="line">ls &gt;&gt; &#123;file&#125;</span><br></pre></td></tr></table></figure><p> 重定向的原理就是修改文件描述符的指向</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span> <span class="comment">// 系统调用创建文件描述符oldfd的拷贝并且返回，使用尽可能小的未使用的文件描述符，成功返回之后，新旧描述符可以替换使用</span></span><br><span class="line">ind <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span> <span class="comment">// 与上一个基本相同，可以指定返回的文件描述符为newld，如果newld已经打开就关闭它</span></span><br><span class="line"><span class="comment">// 代码实现重定向</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;filename&quot;</span>,O_CREAT|O_TRUNC|O_WRONLY, <span class="number">0666</span>); <span class="comment">// 打开文件，也生成一个文件描述符，oldfd</span></span><br><span class="line">dup2(fd,newfd);</span><br><span class="line">close(fd);</span><br><span class="line">system(<span class="string">&quot;echo hello&quot;</span>);</span><br><span class="line"><span class="comment">// 其中open的参数中，O_TRUNC 表示 &gt;，如果改为 O_APPEND 可以实现 &gt;&gt; 的功能</span></span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./a.out &gt; /etc/a.txt</span><br><span class="line"><span class="comment">// 会出现错误，因为根据重定向代码执行的顺序，是先创建进程，然后重定向文件描述符(打开文件)，最后才执行execve指令</span></span><br><span class="line"><span class="comment">// 文件如果需要sudo权限的话，在打开文件时需要sudo权限，但是此时还未获得sudo权限，就会出错</span></span><br></pre></td></tr></table></figure></li><li><p>list</p><p> 一个列表，实现原理：调用fork生成一个进程，然后该进程递归处理list左侧的指令，等待左侧指令执行结束之后，再执行右侧的指令</p></li><li><p>pipe</p><p> <img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/h8nlv3997i.png" alt="h8nlv3997i.png"></p><p> 管道中是由两个端口组成的，一端是标准输入端，另一端是标准输出端，先执行左侧的指令，左侧指令的输出会进入到标准输入端，输入到右侧指令中，作为右侧指令的数据输入</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syscall(SYS_pipe, p);</span><br><span class="line">系统中对于管道会创建两个文件描述符，一个管道的读口pipefd[<span class="number">0</span>]管道的标准输出，一个是管道的写口pipefd[<span class="number">1</span>]管道的标准输入</span><br><span class="line">assert(syscall(SYS_pipe, p) &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (syscall(SYS_fork) == <span class="number">0</span>) &#123; <span class="comment">// 创建一个和当前进程一样的进程，其中文件描述符也会复制一份</span></span><br><span class="line">  syscall(SYS_close, <span class="number">1</span>); <span class="comment">// 关闭编号为1的文件描述符也就是标准输出</span></span><br><span class="line">  syscall(SYS_dup, p[<span class="number">1</span>]); <span class="comment">// 拷贝文件描述符 相当于是把关掉的文件描述符指向了管道的写口</span></span><br><span class="line">  syscall(SYS_close, p[<span class="number">0</span>]); <span class="comment">// 关闭文件描述符</span></span><br><span class="line">  syscall(SYS_close, p[<span class="number">1</span>]); <span class="comment">// 关闭文件描述符</span></span><br><span class="line">  runcmd(pcmd-&gt;left);<span class="comment">// 执行左侧的指令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (syscall(SYS_fork) == <span class="number">0</span>) &#123; <span class="comment">// 右侧指令的执行也创建一个进程</span></span><br><span class="line">  syscall(SYS_close, <span class="number">0</span>); <span class="comment">//  关闭编号为0的文件描述符 标准输入端口</span></span><br><span class="line">  syscall(SYS_dup, p[<span class="number">0</span>]); <span class="comment">// 拷贝文件描述符</span></span><br><span class="line">  syscall(SYS_close, p[<span class="number">0</span>]);</span><br><span class="line">  syscall(SYS_close, p[<span class="number">1</span>]);</span><br><span class="line">  runcmd(pcmd-&gt;right); <span class="comment">// 执行右侧的指令</span></span><br><span class="line">&#125;</span><br><span class="line">syscall(SYS_close, p[<span class="number">0</span>]); <span class="comment">// 关闭文件描述符</span></span><br><span class="line">syscall(SYS_close, p[<span class="number">1</span>]);</span><br><span class="line">syscall(SYS_wait4, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 等待左侧和右侧的指令执行结束之后再继续</span></span><br><span class="line">syscall(SYS_wait4, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p> <img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iygw7l007l.png" alt="iygw7l007l.png"></p></li><li><p>back</p><p> 后台执行</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (syscall(SYS_fork) == <span class="number">0</span>) runcmd(bcmd-&gt;cmd); <span class="comment">// 直接在后台执行，不等待程序执行结束</span></span><br></pre></td></tr></table></figure></li><li><p>系统调用fork</p><p> fork就相当于是创建一个和自己一摸一样的进程出来，而exec是把当前的进程改变成目标进程</p></li></ol><p>不同的 shell 对同样的指令处理优先级是不一样的</p><p>tmux 的实现是不同的终端，把用户的输入全部捕捉下来，然后再转发给对应的终端。执行 tty 可以看到当前的终端编号</p><p>对于有输出的指令，终端会判断输出的位置是否为终端，如果不是终端，就会输出到对应文件中</p><h3 id="Ctrl-c的退出机制"><a href="#Ctrl-c的退出机制" class="headerlink" title="Ctrl-c的退出机制"></a>Ctrl-c的退出机制</h3><p>是因为系统中的信号系统，当按下Ctrl-c时，终端会给前台程序发送一个信号，它收到信号之后会出现对应的操作，ctrl-c会发送一个SIGINT的信号，ctr+-会发送一个SIGQUIT的信号，如果一个进程没有注册SIGINT信号的话，默认程序退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (signum) &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGINT:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Received SIGINT!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGQUIT:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Received SIGQUIT!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果在程序中使用 <code>fork</code>指令拷贝一个进程的话，这时候两个进程一模一样，甚至连signalhandler 信号中断都是一样的，在终端中执行ctrl-c的话，终端会发送一个 group 指令，杀死所有 fork 生成的子进程。</p><p>任何时刻都只能有一个前台的进程，也就是聚焦到某个进程上，这时候的 ctrl-c 只对前台进程有效，不会对后台进程有效，可以实现 <code>handle</code> ，当程序接收到 ctrl-c 的时候回到系统后台执行</p><p>当执行一个程序的时候，shell 会把前台交给这个程序，此时 shell 就不能读到终端的输入指令了，应该是在 wait，程序如果是&amp;执行的话，还可以再读，shell 也相当于是一个进程组</p><h3 id="libc-的实现"><a href="#libc-的实现" class="headerlink" title="libc 的实现"></a>libc 的实现</h3><p>库分为静态 <code>lib</code> 和动态 <code>lib</code></p><ol><li>静态 lib  导出声明和实现都放在lib中。编译后所有代码都嵌入到宿主程序。</li><li>动态 lib  相当于一个h文件，是对实现部分（.dll文件）的导出部分的声明。编译后只是将导出声明部分编译到宿主程序中，运行时候需要相应的dll文件支持。</li></ol><p><a href="[RTFM libc](https://www.gnu.org/software/libc/manual/2.38/html_mono/libc.html">手册</a>)(<a href="https://sourceware.org/newlib/">RTFSC Newlib</a>)</p><p>操作系统内核就是一个C程序</p><p>不同位数的系统下，数据类型的长度是不一样的，所以就出现了 <code>int32_t</code> 之类的数据</p><p>标准库只对标准库内部数据的线程安全性负责</p><p><strong>封装</strong></p><ol><li><p>系统调用</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">execve的一个小demo</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"> <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span>,&#125;;</span><br><span class="line"> <span class="keyword">if</span>(execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)&#123; <span class="comment">// 系统调用</span></span><br><span class="line">  perror(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 同样的功能实现 libc的封装结果</span></span><br><span class="line"> <span class="comment">// system(&quot;echo hello world&quot;);</span></span><br><span class="line"> <span class="comment">// execlp(&quot;echo&quot;, &quot;echo&quot;, &quot;hello&quot;, &quot;world&quot;, NULL);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计算</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用 排序和寻找</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size,<span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base,<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size,<span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libc/c++封装</span></span><br><span class="line">sort(xs.begin(), xs.end(), [] (<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;...&#125;);</span><br><span class="line">xs.sort(lambda key=...)</span><br></pre></td></tr></table></figure></li><li><p>文件描述符</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE* f;<span class="comment">//其实也是一个文件描述符</span></span><br><span class="line"><span class="comment">// 使用了stdarg.h的参数列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vasprintf</span><span class="params">(<span class="type">char</span> **ret, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用存在popen 和pclose 存在缺陷</span></span><br></pre></td></tr></table></figure></li><li><p>操作系统状态，环境变量之类的</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ; <span class="comment">// 封装出来的环境变量，在程序运行过程中被赋值</span></span><br><span class="line"></span><br><span class="line">err, error, perror, </span><br><span class="line">warn(<span class="string">&quot;%s&quot;</span>, filename);</span><br></pre></td></tr></table></figure></li><li><p>地址空间</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libc 中实现了内存的分配和释放</span></span><br><span class="line"><span class="built_in">malloc</span>(s);</span><br><span class="line"><span class="comment">// 返回一段大小为s的区间</span></span><br><span class="line"><span class="comment">// 必要时会向操作系统申请额外的[L,R)空间</span></span><br><span class="line"><span class="comment">// 内存不足时拒绝请求</span></span><br><span class="line"><span class="built_in">free</span>(l,r);</span><br><span class="line"><span class="comment">// 给定l，删除[l, r)的内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//！ 多线程的不能保证正确性与安全性Scalability</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>wordLoad分析</strong></p><p>O(n)大小的对象分配后至少有Ω(n)的读写操作，否则就是 performance bug (不应该分配那么多)，设计优化时要保证所有线程都能够独立申请和分配内存(针对malloc, free)</p><ul><li>越小的对象创建/分配越频繁<ul><li>字符串，临时对象等，生存周期可长可短</li></ul></li><li>较为频繁地分配中等大小的对象<ul><li>较大的数组，复杂的对象，有更长的生存周期</li></ul></li><li>低频率的大对象<ul><li>巨大的容器，分配器，很长的生存周期</li></ul></li><li>并行，并行，再并行<ul><li>所有分配都会在所有处理器上发生</li><li>使用链表/区间树不一定是一个好想法</li></ul></li></ul><p><strong>Fast and Slow</strong></p><ul><li><p>fast Path</p><ul><li>性能好，并行度极高，覆盖大部分情况</li><li><p>有小概率失败</p><p>设计：</p></li><li><p>不需要上锁/no contention</p></li><li>所有进程都事先分配一些内存，然后各自在自己已有的内存中不断分配小内存，如果自己的内存不够了，就从全局的内存中再分配一点（slow path），一般的话需要内存对齐为 $2^k$ 个字节（不在意一点浪费）</li><li>把内存中的大小内存，按照递增的方式排列，然后每一个大小对应的内存中都指向了一个链表，这个链表里全都是该大小的元素，就这样串起来，以便于对内存的分配，分配速度几乎为O(1)</li></ul></li><li>slow Path<ul><li>不在乎多快</li><li>但是能把困难的事情做好</li></ul></li></ul><p><strong>实现小内存快速分配的小内存链表 Segregated List</strong></p><p>分配：Segregated List （Slab）</p><ul><li>每一个slab里的所有对象都一样大<ul><li>每个线程都拥有每个对象大小的slab</li><li>fast Path 立即在线程本地分配完成</li><li>slow path pgalloc</li></ul></li><li>实现<ul><li>全局大链表</li><li>per-page小链表</li></ul></li><li>回收<ul><li>直接归还到slab中</li><li>归还时的内存可能是另一个线程持有的slab 需要per-slab锁</li></ul></li></ul><p><strong>实现大内存的快速分配</strong></p><p>如果想要分配一个很大的内存空间，那就 first fit 或者 best fit</p><p>只需要一个数据结构来堆内存进行管理，例如：区间树，线段树….</p><p><strong>malloc的实现</strong></p><p>使用了 brk 系统调用和 mmap 系统调用来实现内存分配，前提是堆里面空闲空间不足，分配小内存时使用brk线性增长堆空间，分配大内存使用mmap添加一块内存区域映射</p><p><strong>创建文件描述符</strong></p><p>方法： <code>int open(const char *pathname, int flags);</code></p><p>文件描述符相当于是指向操作系统内对象的指针</p><ul><li>对象只能通过操作系统允许的方式访问</li><li>从0开始编号</li><li>可以通过 <code>open</code> 获取， <code>close</code> 释放， <code>dup</code> 复制</li><li>对于数据文件，文件描述符会记住上次访问的文件位置</li><li><code>dup</code> 的两个文件描述符是共享offset的</li></ul><p><strong>copy on write</strong></p><p>操作系统的内存安排虚拟化为很多页面，内存地址被映射成很多虚拟界面，在进程中申请的内存的<strong>页面都是属于操作系统的</strong>，在进程执行过程中，系统会给予这个进程对它所申请的页面一定的权限，当进行fork指令复制进程之后，系统会把子进程也指向父进程的页面，也就是父子进程共享页面，操作系统会对该页面的引用数量进行计数，这时操作系统会把两个进程写的权限抹掉，这时<strong>如果进程中对该页面有写的动作时，该操作会向系统发送一个 <code>page fault</code> 的错误，系统知道父子进程都是使用的同一个页面，所以会开始把这个页面拷贝一份</strong>，并且把读写的权限重新还给该进程，再重新写入，并且该页面的引用数量减少1。如果是调用指令 <code>fork-execve</code> 时，那就会把子进程直接重置，绝大多数页面是不需要拷贝的，这样做的话就能减少系统的开销，只会复制写入的那一页，其他的不写如的话不会复制，所以进程占用的内存的统计是一个伪命题</p><p>例如对于 libc 文件，操作系统中的所有进程调用的都是同一个libc，并且这些进程对于libc都是只读的权限（写的话会出大问题）</p><h3 id="ptrace-进程调试"><a href="#ptrace-进程调试" class="headerlink" title="ptrace 进程调试"></a>ptrace 进程调试</h3><p>linux中提供的一个进程调试的工具，其实就是GDB的核心技术</p><p>提供了父进程可以观察和控制其子进程执行的能力，并且允许父进程检查和替换子进程的内核镜像包括寄存器的值</p><p><strong>原理（调试已经运行的进程）</strong></p><p>当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="comment">// request：指定调试的指令，指令的类型很多，如：PTRACE_TRACEME、PTRACE_PEEKUSER、PTRACE_CONT、PTRACE_GETREGS等等，下面会介绍不同指令的作用。</span></span><br><span class="line"><span class="comment">// pid：进程的ID</span></span><br><span class="line"><span class="comment">// addr：进程的某个地址空间，可以通过这个参数对进程的某个地址进行读或写操作。</span></span><br><span class="line"><span class="comment">// data：根据不同的request指令，有不同的用途</span></span><br></pre></td></tr></table></figure><p><strong><code>ptrace</code> 的使用</strong></p><ol><li>用<code>PTRACE_ATTACH</code>或者<code>PTRACE_TRACEME</code> 建立进程间的跟踪关系</li><li><code>PTRACE_PEEKTEXT</code>, <code>PTRACE_PEEKDATA</code>, <code>PTRACE_PEEKUSR</code>等读取子进程内存/寄存器中保留的值</li><li><code>PTRACE_POKETEXT</code>, <code>PTRACE_POKEDATA,</code> <code>PTRACE_POKEUSR</code>等把值写入到被跟踪进程的内存/寄存器中</li><li>用<code>PTRACE_CONT</code>，<code>PTRACE_SYSCALL</code>,<code>PTRACE_SINGLESTEP</code>控制被跟踪进程以何种方式继续运行</li><li><p><code>PTRACE_DETACH</code>,<code>PTRACE_KILL</code>脱离进程间的跟踪关系</p><p> ptrace的一些tips：</p></li></ol><ul><li>进程状态 <code>TASK_TRACED</code> 用以表示当前进程因为被父进程跟踪而被系统停止。</li><li>如在子进程结束前，父进程结束，则 <code>trace</code> 关系解除。</li><li>利用 <code>attach</code> 建立起来的跟踪关系，虽然ps看到双方为父子关系，但在”子进程“中调用getppid()仍会返回原来的父进程id。</li><li>不能attach到自己不能跟踪的进程，如 <code>non-root</code> 进程跟踪 <code>root</code> 进程。</li><li>已经被 <code>trace</code> 的进程，不能再次被 <code>attach</code>。</li><li>即使是用 <code>PTRACE_TRACEME</code>建立起来的跟踪关系，也可以用DETACH的方式予以解除。</li><li>因为进入/退出系统调用都会触发一次 <code>SIGTRAP</code>，所以通常的做法是在第一次（进入）的时候读取系统调用的参数，在第二次（退出）的时候读取系统调用的返回值。但注意 <code>execve</code>是个例外。</li><li>程序调试时的断点由 <code>int 3</code>设置完成，而单步跟踪则可由 <code>ptrace(PTRACE_SINGLESTEP)</code>实现</li></ul><p>通过ptrace实现单步调试的方式有两种</p><ol><li>父进程执行fork创建一个子进程，通过ptrace设置子进程为PF_PTRACED 标记，然后执行execve加载被调试的程序，父进程可以对子进程进程调试</li><li>通过ptrace attach到指定的pid来完成对进程的调试</li></ol><h3 id="GDB的实现"><a href="#GDB的实现" class="headerlink" title="GDB的实现"></a>GDB的实现</h3><p><code>GDB</code>是<code>GNU</code>发布的一个强大的程序调试工具，用以调试<code>C/C++</code>程序，可以使程序员在程序运行的时候观察程序在内存/寄存器中的使用情况。这个是基于ptrace系统调用来实现的</p><p><strong>原理</strong></p><p>是利用ptrace系统调用，在被调试程序和gdb之间建立跟踪关系。然后所有发送给被调试程序的信号(除SIGKILL)都会被gdb截获，gdb根据截获的信号，查看被调试程序相应的内存地址，并控制被调试的程序继续运行。</p><p><strong>实现</strong></p><ol><li><p>建立调试关系</p><ul><li><p><code>gdb ./helloworld</code> 开始执行一个程序</p><p>  利用 <code>fork+execve</code> 执行被测试的程序，子程序在 <code>execve</code> 之前调用<code>ptrace(PTRACE_TRACEME)</code> 设置自己的调试模式是 <code>PTRACE_TRACEME</code> ，之后阻塞运行，而父进程（gdb）收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。</p></li><li><p><code>gdb pid</code></p><p>  调用 <code>ptrace(OTRACE_ATTACH, pid, ...)</code> 使自己变成被调试程序的父进程，这种使用attach建立起来的跟踪关系可以调用 <code>ptrace(PTRACEE_DETACH, pid, ...)</code> 解除，并且要有对应的权限</p></li></ul></li><li><p>断点</p><p> 设置断点 <code>break linenumber</code> 当运行到 linenumber 那一行时，被调试的程序就会停止</p><p> <strong>原理</strong></p><p> 在指定位置插入断点指令，当被调试的程序运行到断点的时候，产生 <code>SIGTRAP</code> 信号，该信号被 gdb 捕获并且进行断点命中判定，当gdb 判断出此次的 <code>SIGTRAP</code> 信号是断点命中之后就会转入等待用户进行下一步处理，否则继续。</p><p> <strong>断点的设置原理</strong></p><p> 在程序中设置断点，就是先将该位置原来的指令保存，然后向该位置写入 <code>int 3</code> ，当程序执行到 <code>int 3</code> 的时候，就会发生软中断，内核会给子进程发出 <code>SIGTRAP</code> 的信号，当然这个信号会被转发给父进程，然后用保存的指令替换掉它，等待恢复运行</p><p> <strong>断点命中判定</strong></p><p> gdb把所有断点位置都保存到一个链表中，命中判定就是把被调试程序当前停止位置和链表中的位置进行比较，看是否是断点产生的信号还是无关信号</p></li><li><p>单步跟踪</p><p> 就是指在调试程序的时候，让程序运行一条指令/语句之后停下来</p><p> gdb 中常用的指令有 next, step, nexti, stepi</p><p> 单步跟踪又常分为语句单步（step，next）和指令单步（nexti，stepi）。</p><p> 在linux上，指令单步可以通过 <code>ptrace</code> 来实现，调用 <code>ptrace(PTRACE_SINGLESTEP, pid, ...)</code> 指令可以使被调试的进程在每执行完一条指令之后就触发一个 <code>SIGTRAP</code> 信号，让 gdb 运行</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个小栗子</span></span><br><span class="line">child = fork();</span><br><span class="line"><span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">     execl(<span class="string">&quot;./HelloWorld&quot;</span>, <span class="string">&quot;HelloWorld&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ptrace(PTRACE_ATTACH,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">     wait(&amp;val);</span><br><span class="line">     <span class="keyword">if</span>(WIFEXITED(val))</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     count++;</span><br><span class="line">     ptrace(PTRACE_SINGLESTEP,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total Instruction number= %d/n&quot;</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> gdb能让我们很容易的检测，修改被调试的进程，比如通过行号，函数名，变量名，实现：</p><ol><li>需要在编译的时候提供足够的信息，如在<code>gcc</code>时加入<code>-g</code>选项，这样<code>gcc</code>会把一些程序信息放到生成的<code>ELF</code>文件中，包括函数符号表，行号，变量信息，宏定义等，以便日后<code>gdb</code>调试，当然生成的文件也会大一些。</li><li><p>需要对ELF文件格式，进程的内存镜像以及程序的指令码十分熟悉</p><p><code>ptrace</code>可以实时监测和修改另一个进程的运行</p></li></ol></li><li><p>gdb 为何知道执行到那里出错了</p><p> gdb 通过内存中的信息来打印出对应的错误的，根本原因是 运行的二进制文件中有一些能帮助debugger 分析程序运行的状态的信息</p><p> 在编译的过程中就会生成 drawf 调试信息，允许对于任意一段内春定义一个 f ，这个f可以是turing complete，如果 PC 指针位于这段代码的内存之中的话，就可以生成一些对于变量的信息和程序运行到哪一步了，gcc 也会生成 debug info 便于在调试过程中可以把对应的指令反向编译为c语言以便查看（当然有时候也会生成一些错误的debug info）</p><p> gcc 编译过程中使用 -O2，选项 -g -S 可以查看嵌入汇编语言的debug info，可以使用 <code>readelf -w</code> 来查看调试信息，错误信息是怎么产生的，可以看一下函数调用的栈。当进行函数调用的时候，系统会把当前的寄存器内的数据存入栈中</p></li></ol><h3 id="创建进程-POSIX-Spawn"><a href="#创建进程-POSIX-Spawn" class="headerlink" title="创建进程 POSIX Spawn"></a>创建进程 POSIX Spawn</h3><p>函数是在 fork 之后设计出来的，其背后使用的方法就是 clone</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">posix_spawn</span><span class="params">(<span class="type">pid_t</span> *pid, <span class="type">char</span> *path,</span></span><br><span class="line"><span class="params">   <span class="type">posix_spawn_file_actions_t</span> *file_actions,</span></span><br><span class="line"><span class="params">   <span class="type">posix_spawnattr_t</span> *attrp,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> * argv[], <span class="type">char</span> * envp[])</span>;</span><br><span class="line"><span class="comment">// pid 返回的进程号</span></span><br><span class="line"><span class="comment">// path 程序(重置的状态机)</span></span><br><span class="line"><span class="comment">// file_actions : open, close, dup</span></span><br><span class="line"><span class="comment">// attrp 信号，进程组等信息</span></span><br><span class="line"><span class="comment">// argv, envp 同execve相似</span></span><br></pre></td></tr></table></figure><p><strong>fork in the road</strong></p><ul><li>Fork不简单</li><li>Fork 会连带着标准库一起都 fork，libc的buffer被复制了一份，但是很可能不是用户想要的行为，就会比较麻烦</li><li>Fork 线程不安全</li><li>Fork 不安全，fork的指针指向的内存地址是不变的 -打破了内存分配随机化</li><li>Fork 很慢</li><li>Fork doesn’t scale</li><li>Fork 鼓励内存过度分配</li></ul><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><ul><li><p>可执行文件是最重要的操作系统对象，elf，是一个描述了状态机的初始状态+迁移的数据结构</p><p>  这个数据结构的定义位于 <code>/usr/include/elf.h</code></p></li><li><p>寄存器 大部分由ABI规定，操作系统负责设置</p></li><li>地址空间 二进制文件+ABI共同决定</li></ul><p>execve 在执行可执行文件的时候，会将系统进程状态机重置，这个可执行文件就是为了描述状态及重置之后的状态，状态就是寄存器和内存的地址空间，一般的寄存器的数值都为0，但是有一些状态 rip，就是进程的初始状态</p><p>操作系统上可执行的文件的满足的条件：</p><ul><li>具有执行(x)权限</li><li>加载器能识别的可执行文件</li></ul><p><code>execve</code> 决定了一个文件能不能执行，对于一个文件可以通过 <code>strace</code> 来查看执行的结果，不能执行的文件 <code>execve</code> 会返回相应的报错 <code>execve = -1</code></p><ul><li>没有执行权限的 a.c: execve = -1, EACCESS</li><li>有执行权限的 a.c: execve = -1, ENOEXEC</li></ul><h3 id="She-bang"><a href="#She-bang" class="headerlink" title="She-bang"></a>She-bang</h3><p>在一个文本的最前端加上一行 <code>#!</code> 开头的后面是一个可执行文件</p><p>把这个文本添加权限为可执行文件后，执行时系统会调用 execve 并且<strong>把第一个参数替换为 #! 后面的可执行文件，并且把这个文件作为第二个参数填入 execve 中，并且 #! 后面的可执行文件能且只能传一个参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 对于任意一个文件，后缀不限制，可以把它变为可执行文件</span><br><span class="line"><span class="comment">#！/usr/bin/python3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>) </span><br></pre></td></tr></table></figure><p><strong>(</strong><a href="https://www.gnu.org/software/binutils/">Binutils</a><strong>)</strong></p><ul><li>objdump 把代码中的一部分disassemble 反汇编</li><li>objcopy 把里面的代码数据等二进制的部分拷贝出来</li><li>nm 把文件中的一些符号打印出来</li><li>readelf 显示被执行文件的信息</li><li>addr2line 显示文件</li></ul><h3 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h3><p><strong>过程</strong></p><p>编译器生成文本汇编代码→汇编器生成二进制指令序列</p><p>对于生成的汇编代码，如果有一行指令未知，那就会先填上0，但是最终生成的文件中这一部分是要填上的，使得assertion满足</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assert(</span><br><span class="line">  (<span class="type">char</span> *)hello ==</span><br><span class="line">    (<span class="type">char</span> *)main + <span class="number">0xf</span> + <span class="comment">// call hello 的 next PC</span></span><br><span class="line">    *(<span class="type">int32_t</span> *)((<span class="type">uintptr_t</span>)main + <span class="number">0xb</span>) <span class="comment">// call 指令中的 offset</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 也被写在文件里</span></span><br><span class="line">Offset            Type      Sym. Name + Addend</span><br><span class="line"><span class="number">00000000000b</span>  R_X86_64_PLT32  hello - <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这个重填的值为 S+A-P (P = main  + 0x0b，这个就是预编译之后的main函数调用hello函数的地方所出现的) （在下面的地址无关代码有详细解释）</p><p>gcc 编译器相当于是把c语言指令编译为了指令+内存寄存器的状态机</p><p><strong>预处理 cpp</strong></p><p>c→预处理之后的文件</p><p><strong>编译器 gcc</strong></p><p>c→汇编</p><p><strong>汇编器 as</strong></p><p>汇编→状态机容器</p><ul><li>一一对应翻译成二进制代码 section, symbol, debug info</li><li>不能决定的要留下之后怎么办的信息 relocation</li></ul><p><strong>链接器 ld</strong></p><p>合并所有容器，得到一个完整的状态机</p><p>elf本身就是一个容器数据结构，包含了必要的信息</p><h3 id="可执行文件的加载"><a href="#可执行文件的加载" class="headerlink" title="可执行文件的加载"></a>可执行文件的加载</h3><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%202.png" alt="Untitled"></p><p>可执行文件就是一个描述了状态机初始状态的数据结构</p><p>不同于内存里的数据结构，指针都被偏移量代替</p><p>数据结构各个部分的定义位于 <code>/usr/include/elf.h</code></p><p><strong>ELF文件加载器</strong></p><p>作用：解析数据结构+复制到内存中+跳转，创建进程运行时的初始状态，还需要设置一些运行时状态</p><p><strong>符号重定位</strong></p><p>c/c++程序的编译是以文件为单位进行的，因此每个 c/cpp 文件也叫作一个编译单元(translation unit), 源文件先是被编译成一个个目标文件, 再由链接器把这些目标文件组合成一个可执行文件或库，链接的过程，其核心工作是解决模块间各种符号(变量，函数)相互引用的问题，对符号的引用本质是对其在内存中具体地址的引用，因此确定符号地址是编译，链接，加载过程中一项不可缺少的工作，这就是所谓的符号重定位。本质上来说，<strong>符号重定位要解决的是当前编译单元如何访问「外部」符号这个问题。</strong></p><p>程序在编译的时候，是以源文件为单位来进行的，编译器此时并没有全局的视野，因此对于一个编译单元内的符号是没有办法确定地址的，所以在编译的过程中，未知的符号就会先给0，而对于可执行文件，程序加载的地址是固定的或者是可以预期的，因此在链接的时候，会完成符号重定位，如果可执行文件引用了动态链接库的函数，该模块的起始地址无法确定，只能延迟重定位</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p><strong>优点</strong></p><p>在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行。</p><p><strong>缺点</strong></p><ol><li>浪费内存空间。在多进程的操作系统下，同一时间，内存中可能存在多个相同的公共库函数。</li><li>程序的开发与发布流程受模块制约。 只要有一个模块更新，那么就需要重新编译打包整个代码。</li></ol><p><strong>步骤</strong></p><p>解析数据结构+复制到内存+跳转</p><p>要解决的问题就是将几个目标文件链接起来成为一个可执行文件，现在的链接器一般都采用两步链接</p><ol><li><p>地址与空间分配，扫描所有输入的目标文件，合并它们的各个节，更新节表和全局符号表</p><p> 链接器会为目标文件分配地址和空间，不仅仅是指在输出的可执行文件中的空间，也是在装载后的虚拟地址中的虚拟地址空间。但像.bss这样的节来说，分配空间的意义只限于虚拟地址空间。用 <code>objdump -h</code>可以看到链接前后的虚拟地址的分配情况，其中VMA表示虚拟地址（Virtual Memory Address），LMA表示加载地址（Load Memory Address），正常情况下这两个值是一样的。</p><p> 链接前，目标文件中的所有节的VMA都是0，此时虚拟空间还没有被分配。等到链接后，可执行文件中的各个节都被分配到了相应的虚拟地址。</p><p> 输入文件中的各个节的虚拟地址确定以后，链接器开始计算各个符号的虚拟地址。因为各个符号在节内的相对位置是固定的，它们的地址也已经是确定的了，也就是节的虚拟首地址加上该符号在节内的偏移量。这样链接器就可以更新全局符号表了。</p></li><li><p>符号解析与重定位，利用上一步搜集到的信息，读取文件中节的数据，重定位信息，进行符号解析与重定位，调整代码中的地址等</p><p> ELF 文件中有一个重定位表的结构，专门用来保存与重定位相关的信息，它在ELF文件中往往是一个或者多个节。rel 就是表示存储的是重定位表。使用 <code>objdump -r</code> 指令可以查看目标文件的重定位表，每个要被重定位的地方都有一个叫做重定位入口，重定位入口的偏移表示该入口在要被重定位的节点中的位置</p><p> 不同的机器寻址方式可能不同，这样导致重定位时的修正方式也是不同的。</p><ul><li>绝对寻址  <code>保存在被修改位置的值 + 符号的实际地址</code></li><li>相对寻址  <code>保存在被修改位置的值 + 符号的实际地址 - 被修正的位置的地址</code></li></ul></li></ol><ul><li><p><strong>强弱符号和强弱引用</strong></p><p>  当多个目标文件中含有相同名字的全局符号的定义时，这些目标文件在链接时将会出现符号重定义的错误。这种符号可以被称为<strong>强符号</strong>（Strong Symbol）。当然还有一些符号的定义可以被称为<strong>弱符号</strong>（Weak Symbol）。</p><p>  对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。GCC的<strong>attribute</strong>((weak))可以用来定义任何一个强符号为弱符号。强符号和弱符号都是针对符号的定义来说的，而不是符号的引用。针对强弱符号的概念，链接器会按照如下规则处理：</p><ol><li>不允许强符号被多次定义，否则会报重定义错误</li><li>如果一个符号在某个目标文件中为强符号，在其它文件中都为弱符号，那么选择强符号</li><li><p>如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个，可以使用 -fno-common 的编译选项来使编译器对于重定义的符号报错</p><p>在目标文件中对外部目标文件的符号引用在链接过程中也要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种引用被称为强引用（Strong Reference），与之相应的还有一种弱引用（Week Reference）。在处理弱引用时，如果该符号未被定义，则链接器对该引用不报错，默认其为0或者某个特殊的值，以便于程序代码能够识别。在GCC中可以使用<strong>attribute((weakref))</strong> 这个扩展关键字来声明一个引用为弱引用。</p><p>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使程序可以使用自定义版本的库函数；或者程序可以对某些扩展模功能模块的引用定义为弱引用，当我们的扩展模块与程序链接在一起时，功能模块就可以正常使用；如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序更加容易剪裁和组合。</p></li></ol></li><li><p><strong>COMMON块</strong></p><p>  ELF文件的基本结构中，未初始化的全局变量和局部静态变量存储在.bss节中，其实现在的编译器生成的目标文件中，未初始化的全局变量往往并没有被放在.bss节中。</p><p>  现在的编译器和链接器都支持一种叫做COMMON块（Common Block）的机制，这种机制最早来源于Fortran，早期的Fortran没有动态分配空间的机制，程序员必须事先声明他所需要的临时使用空间的大小。Fortran把这种空间叫做COMMON块，当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那一块为准。</p><p>  现代的链接机制在处理弱符号的时候，采用的就是和COMMON块一样的机制。当有一强符号时，最终输出结果中的符号所占空间与强符号的相同，但若有弱符号的大小大于强符号，链接器会输出警告。导致需要COMMON块这种机制的根本原因是链接器不支持符号类型，也就无法判断各符号的类型是否一致。</p><p>  当编译器将一个编译单元编译成目标文件时，如果该编译单元中包含了弱符号，那么该弱符号最终所占的空间大小此时是未知的，也就不能为它在.bss节分配空间，只有链接器在链接的时候才能确定该弱符号的大小，它可以在最终输出文件的.bss节为其分配空间。所以总体看来，未初始化的全局变量最终还是被放在.bss节中的。GCC的编译选项-fno-common和扩展关键字<strong>attribute</strong>((nocommon))允许我们将未初始化的全局变量不以COMMON块的形式处理，那么它就相当于一个强符号了。</p><p>  静态链接库实际上是一组目标文件的集合，即很多目标文件压缩打包后形成的一个文件。gcc在执行静态链接时，会自动找到我们的目标文件所引用的目标文件所在的和所依赖的静态链接库，并把它们链接进来。为了减小空间的浪费，静态链接库中的每个目标文件往往只包含一个函数。</p><p>  符号重定位既指在当前目标文件内进行重定位，也包括在不同目标文件，甚至不同模块间进行重定位。但是对于同一个文件中的，编译时就能知道相对地址，但是x86上的mov之类访问程序中数据段的指令要求操作数必须是绝对地址。而对于函数调用一般是相对地址调用，但是计算相对地址也只能在当前目标文件内进行，跨目标文件之间的调用编译器也做不到，只能等到链接时或者加载时才能进行相对地址的计算，因此重定位过程必不可少。但是对于动态链接即使是当前目标文件内，如果是全局非静态函数，那么它也是需要进行重定位的</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/uTools_1694173594662.png" alt="uTools_1694173594662.png"></p><p>  引用的hello函数的地址为12 <main+0x12>. 显然这个地址是错的，编译器当前并不知道 hello 这个函数最后会被分配到哪个地址上，因此在这儿只是随便用一个假的来代替，等着到接下来链接时，再把该处地址进行修正</main+0x12></p><p>  编译器编译文件时时，会建立一系列表项，用来记录哪些地方需要在重定位时进行修正，这些表项叫作“重定位表”(relocatioin table)</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/uTools_1694173818770.png" alt="uTools_1694173818770.png"></p><p>  如上最后一行，这条记录记录了在当前编译单元中，哪儿对 hello 进行了引用，其中 offset 用于指明需要修改的位置在该段中的偏移，TYPE 则指明要怎样去修改，因为 cpu 的寻址方式不是唯一的，寻址方式不同，地址的形式也有所不同，这个 type 用于指明怎么去修改, value 则是配合 type 来最后计算该符号地址的。</p><p>  最后在可执行文件中，该地址就被链接成了对应的代码地址</p></li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接库的调用也是相当于是查表</p><p><strong>共享库shared libraries</strong></p><p>为了避免像静态库那种每次执行程序都需要把对应的库文件中的代码段复制到该进程的地址空间中，共享库应运而生</p><p>是一种特殊的可重定位目标文件，linux中通常用 <code>.so</code> 的后缀，windows中 <code>dll</code> 为后缀。</p><p>共享库在运行或者被加载时，可以被加载到任意的内存地址，还可以和在内存中的程序链接起来，这个过程就是动态链接</p><p>创建一个共享库需要用到 <code>-shared</code> 的编译选项表示生成共享库，并且需要用到 <code>-fpic</code> 来生成位置无关代码，这样共享库才能被加载到任意的内存</p><p>对共享库进行引用编译之后，生成的可执行目标文件中并没有包含共享库中的代码，只是复制了符号表和一些重定位信息，当可执行文件加载运行时，就会发现可执行程序中存在一个 <code>interp</code> 的 <code>section</code>，其中包含了动态链接器的路径名称。实际上这个动态链接器也是一个共享目标文件，接下来加载器会将这个动态链接器加载到内存中运行，然后由动态链接器执行重定位代码和数据的工作</p><p>具体流程</p><ol><li>将libc.so 的代码和数据重定位到某个内存段</li><li>然后将重定位动态链接库中的代码和数据段到另一个内存段</li><li>重定位动态链接库中的定义的符号引用</li><li>操作完成之后，动态链接器将控制权给程序，从此刻开始共享库的位置就是固定的了</li></ol><p>应用程序也可能在它运行的时候要求动态链接器加载和链接某个共享库，而无需在编译时链接</p><p>对于软件可以利用共享库的更新来实现软件的更新，运行的时候将加载新的共享库，是一种热更新。也可以实现高性能web服务器。并且对于修改和更新来说不需要停止现在的进程</p><p><strong>优点</strong></p><p>解决了静态链接的缺陷，更适应现代的大规模的软件开发，只编译一部分不用重新链接，动态库加载比较快，可以支持多个进程之间共享，对整个系统来说可以大大减少对内存的使用</p><p><strong>缺点</strong></p><ol><li><p>结构复杂。</p><p> 对于静态链接来说，系统只需要加载一个文件（可执行文件）到内存即可，但是在动态链接下，系统需要映射一个主程序和多个动态链接模块，因此，相比于静态链接，动态链接使得内存的空间分布更加复杂。</p><p> 不同模块在内存中的装载位置一定要保证不一样。</p></li><li><p>由于是运行时加载，可能会影响程序的前期执行性能。</p></li><li>引入了安全问题，这也是我们能够进行PLT HOOK的基础。</li></ol><p>动态链接就是在编译的时候，对于一些不知道的文件地址会先填入0，之后等加载的时候再对地址进行填入。动态链接相当于是查表</p><p><strong>原理 (</strong><a href="https://blog.csdn.net/shenhuxi_yu/article/details/71437167">可以看看这篇文章</a><strong>)</strong></p><p>动态链接就是对组成程序的目标文件等到程序运行的时候才进行链接，也就是把链接这个过程推迟到了运行时再进行，在动态链接下，一个程序被分成了若干个文件，有程序的主要部分，即可执行文件和程序所依赖的共享对象。很多时候我们也把这些部分称为模块，即动态链接下的可执行文件和共享对象都可以看做是程序的一个模块</p><p>其实就是加载时重定位，动态加载</p><p>对于加载时重定位，linux下的ELF文件主要支持两种方式：加载时符号重定位以及地址无关代码</p><ul><li><p>加载时符号重定位</p><p>  原理很简单，它与链接时重定位是一致的，只是把重定位的时机放到了动态库被加载到内存之后，由动态链接器来进行。</p><p>  链接完成之后，一些地址仍然是假地址，这些地址在动态库加载完成之后会被动态链接器进行重定位，最终修改为正确的地址，这看起来跟静态链接很像，但是有几个关键的不同之处</p><ol><li>因为<strong>不允许对可执行文件的代码段进行加载时符号重定位</strong>，因此如果<strong>可执行文件</strong>引用了动态库中的<strong>数据符号</strong>，则在该可执行文件内对符号的重定位必须在链接阶段完成，为做到这一点，链接器在构建可执行文件的时候，会在当前可执行文件的数据段里分配出相应的空间来作为该符号真正的内存地址，等到运行时加载动态库后，再在动态库中对该符号的引用进行重定位：把对该符号的引用指向可执行文件数据段里相应的区域。</li><li><p>ELF 文件对调用动态库中的<strong>函数</strong>采用了所谓的”延迟绑定”(lazy binding)策略，只有当该函数在其第一次被调用发生时才最终被确认其真正的地址，因此我们不需要在调用动态库函数的地方直接填上假的地址，而是使用了一些跳转地址作为替换，这样一来连修改动态库和可执行程序中的相应代码都不需要进行了</p><p>加载时重定位实际上是一个<strong>重新修改</strong>动态库中数据符号地址的过程(函数符号的地址因为延迟绑定的存在不需要在代码段中重定位)，但我们知道，不同的进程即使是对同一个动态库（stdout/errno/environ等）也很可能是加载到不同地址上，因此当以加载时重定位的方式来使用动态库时，该动态库就没法做到被各个进程所共享，而只能在每个进程中 copy 一份：因为符号重定位后，该动态库与在别的进程中就不同了，可见此时动态库节省内存的优势就不复存在了。</p><p><strong>缺陷</strong></p></li><li><p>它不能使动态库的指令代码被共享</p></li><li>程序启动加载动态库后，对动态库中的符号引用进行重定位会比较花时间，特别是动态库多且复杂的情况下</li></ol></li><li><p>地址无关代码（PIC）</p><p>  主要是为了克服一些加载时重定位的缺点，实现原理如下</p><ol><li><p>模块内部符号的访问</p><p> 在这里指的是：static类型的变量和函数，这种类型的符号比较简单，对于static函数来说，因为在动态库编译完成之后，它在模块内的相对地址就已经确定了，并且x86上函数调用只用到相对地址，此时连重定位都不需要进行，编译时就能确定地址，但是对于访问数据来说，需要用到绝对地址，但是动态库未被加载时，绝对地址是无法得知的</p><p> ELF 使用了一个小技巧，根据当前 IP 值来动态计算数据的绝对地址。当动态库编译好之后，库中的数据段，代码段的相对位置就已经固定了，此时对任意一条指令来说，该指令的地址与数据段的距离都是固定的，那么，只要程序在运行时获取到当前指令的地址，就可以直接加上该固定的位移，从而得到所想要访问的数据的绝对地址了</p><p> 一般来说 x86 没有执行可以获取当前的 IP 值，因此会使用一个小技巧来通过函数调用来获取 IP 值（x86_64下不用这么麻烦），这个技巧原理在于进行函数调用的时候，将返回地址压到栈上，此时通过读出栈上的数值就能获得下一条指令的地址了，之后经过计算就可以得到地址</p></li><li><p>模块间符号的访问</p><p> 模块间的符号访问比模块内的符号访问要麻烦很多，因为动态库运行时被加载到哪里是未知的，为了能使得代码段里对数据及函数的引用与具体地址无关，只能再作一层跳转，ELF 的做法是在动态库的数据段中加一个表项，叫作 GOT(global offset table), GOT 表格中放的是数据全局符号的地址，该表项在动态库被加载后由动态加载器进行初始化，动态库内所有对数据全局符号的访问都到该表中来取出相应的地址，即可做到与具体地址了，而该表作为动态库的一部分，访问起来与访问模块内的数据是一样的。</p><p> 事实上，ELF 文件中还包含了一个重定位段，里面记录了哪些符号需要进行重定位，模块间的函数调用在实现原理上是一样的，也需要经过一个类似 GOT 的表格进行跳转，但在具体实现上，ELF 为了实现所谓延迟绑定而作了更精细的处理。其中PIC 也可在编译可执行文件时指定，此时可执行文件中的代码对外部符号的引用方式会改变，不再是直接(绝对地址或相对地址)引用该符号，而是也通过 GOT 来间接的引用。</p></li><li><p>延迟加载</p><p> 动态库是在进程启动的时候加载进来的，加载后，动态链接器需要对其作一系列的初始化，如符号重定位(动态库内以及可执行文件内)，这些工作是比较费时的，特别是对函数的重定位，很多时候，一个动态库里可能包含很多的全局函数，但是我们往往可能只用到了其中一小部分而已，而且在这用到的一小部分里，很可能其中有些还压根不会执行到，因此完全没必要把那些没用到的函数也过早进行重定位，具体来说，就是应该等到第一次发生对该函数的调用时才进行符号绑定 — 此谓之延迟绑定。</p><p><strong>实现步骤</strong></p></li><li><p>建立一个GOT.PLT 表，该表会存放全局函数的实际地址，但是在最开始的时候里面存放的不是真实的地址而是一个跳转</p></li><li>对于每一个全局函数，链接器生成一个与之相对应的影子函数 hello@plt</li><li><p>所有对于hello的调用，都是换成 hello@plt，每一个都时这样子的，就相当于是定义了一个函数来代替 call hello</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello@plt:</span><br><span class="line">jmp *(hello@got.plt)</span><br><span class="line">push index</span><br><span class="line">jmp _init</span><br></pre></td></tr></table></figure><p>其中第一条指令就是跳转，跳转到 got.plt 中所指向的真实地址，但是如果是函数的第一次调用，那么 got.plt 中存放的是 hello@plt 中的第二条指令，这就意味着第一次调用的时候第一条指令什么都没做，直接继续运行。第二条指令的作用是把当前要调用的函数在 got.plt 中的编号作为参数传给 _init()，而_init() 这个函数则用于把 hello 进行重定位，然后把结果写入到 got.plt 相应的地方，最后直接跳过去该函数。</p></li></ol></li></ul><h3 id="ELF-文件格式"><a href="#ELF-文件格式" class="headerlink" title="ELF 文件格式"></a>ELF 文件格式</h3><p><img src="https://img-blog.csdnimg.cn/1595760dc9094bd781dbb4dfa29414ae.png" alt="https://img-blog.csdnimg.cn/1595760dc9094bd781dbb4dfa29414ae.png"></p><p>ELF为可执行可链接格式文件。ELF目标文件可以用于程序的链接，也可以用于程序的执行。<strong>可重定位目标文件对应连接视图，而可执行目标文件对应执行视图。</strong></p><p>ELF 文件格式分为两种</p><ul><li><strong>可重定位目标文件a：</strong>主要由不同的节组成，节是 ELF 文件中具有相同特征的最小可处理单位，必须具有节头表来链接程序，可重定位目标文件格式主要包含代码部分和数据部分，ELF(executable and linkable format)可重定位目标文件由由 ELF 头、节头表（用于描述各个节）和各个节组成</li><li><strong>可执行目标文件b：</strong>主要由不同的段组成，多个节合并后映射到一个段中，必须具有程序头表</li></ul><p><strong>ELF具体结构解析</strong></p><p><img src="https://img-blog.csdnimg.cn/fcc5c2e7f85f484c8a2ebee7b2336b4a.png" alt="https://img-blog.csdnimg.cn/fcc5c2e7f85f484c8a2ebee7b2336b4a.png"></p><p><strong>节头表</strong></p><p>包含文件中各节的说明信息，每个节在该表中都有一个与之对应的项，每一项都指定了节名和节大小等信息</p><p><strong>程序头表</strong></p><p>指示系统如何创建进程的存储器映像</p><p><strong>ELF头</strong></p><p>使用指令 <code>readelf -h filename</code> 来显示程序的ELF头信息</p><p>最开始的16个字节表示的数据</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1698396086293.png" alt="1698396086293.png"></p><p>前4个字节表示ELF的魔数，与ASCII码中的DEL控制符，字符E，字符L以及字符F对应，加载的时候会确定魔数是否正确，不正确就拒绝加载。第7位表示ELF文件的版本号，通常都是1</p><p>其中的 Type 表示文件类型：</p><ul><li>REL 可重定位文件</li><li><p>可执行文件</p><p>  ELF文件头描述了文件的总体格式，其中有一项是程序的入口，就是程序运行时要执行的第一条指令的地址</p></li><li><p>分享文件</p></li></ul><p>位于目标文件的起始位置，包含文件结构说明信息，32位系统对应的结构与64位对应的结构不一样</p><p>以下是32位系统对应的数据结构，占用52个字节，64位系统对应的数据结构占用64个字节</p><p><img src="https://img-blog.csdnimg.cn/ca7879b90f51460cb15d27883be54538.png" alt="https://img-blog.csdnimg.cn/ca7879b90f51460cb15d27883be54538.png"></p><ul><li><code>e_ident</code>: 长度为 16 字节的序列，最开始 4 个字节为魔数，用来确定文件的类型或格式。在加载或读取文件可通过魔数确认文件类型是否正确。第一个字节为 0x7F， 随后 3 个字节分别为 ‘E’, ‘L’, ‘F’， 后 12 个字节包含一些标识信息，标示 32 位还是 64 位，大端还是小端等。</li><li><code>e_type</code> : 说明文件是可重定位文件，还是可执行文件，共享库文件等</li><li><code>e_machine</code> : 指定机器结构类型，如 IA-32、SPARC V9等</li><li><code>e_version</code> :占4字节，表示版本信息</li><li><code>e_entry</code> : 用于指定系统将控制权转移到的起始虚拟地址</li><li><code>e_ensize</code> : 为 ELF 头的大小</li><li><code>e_phoff</code> :指明程序头表在文件中的偏移</li><li><code>e_shoff</code> : 指出节头表在文件中的偏移量</li><li><code>e_flags</code> :关于处理器的一些标志，这里不做具体介绍</li><li><code>e_ehsize</code> :指明文件头大小</li><li><code>e_phentsize</code> :指明程序头表中每个条目的大小</li><li><code>e_phnum</code> : 指明程序头表中有多少条目，也就是多少个段</li><li><code>e_shentsize</code>: 表示节头表中一个表项的大小，所有表项大小相同</li><li><code>e_shnum</code>: 表示节头表中的项数。</li><li><code>e_shstrndx</code> ：用来指明字符串表对应条目在节头表上的索引</li></ul><p>因此 <code>e_shentsize</code> 和 <code>e_shnum</code> 共同指定了节头表的大小。在可重定位文件中只有 ELF 头在文件中固定在开始位置，其他部分位置由 ELF 头和节头表指出，顺序也不固定。</p><p><strong>节</strong></p><p><code>readelf -S filename</code> 来查看节的内容</p><p>是ELF文件中的主体信息，包含了链接过程所用的代码信息，包括指令，数据，符号表和重定位信息。ELF文件主要包括以下几个节</p><ul><li>.text 目标代码部分 紧跟在ELFheader之后，存放的是已经编译好的机器代码</li><li>.rodata 只读数据，例如printf中的格式串和switch语句中的跳转表都存于此</li><li>.data 已初始化的全局变量和静态变量的值</li><li>.bss 未初始化的全局变量和静态变量，但是被初始化为0的全局变量和静态变量也存放于此，未初始化的变量没有具体值，所以不占用实际的磁盘空间，只是一个占位符，在程序运行的过程中，会在内存中初始化变量</li><li><p>.symtab 符号表，程序中定义的函数名和全局静态变量名都属于符号，符号相关的信息保存在符号表中，链接时需要利用符号表中的信息来把目标文件都粘合到一起</p><p>  <code>readelf -s filename</code> 查看符号表内的符号</p><p>  其中Ndx表示存放的位置</p><p>  局部变量的信息不会存储在符号表中，会在程序运行过程中存放在栈中</p></li><li><p>.rel.text .text节相关的可重定位信息</p></li><li>.rel.data .data节相关的可重定位信息</li><li>.strtab 字符串表，包括 .symtab 节中的符号以及节头表中的表名。字符串表就是以 null 结尾的字符串序列</li><li>.debug 调试信息</li><li>.line 原始C程序的行号和.text section 中机器指令之间的映射</li><li>.comment 存放的是编译器版本信息</li></ul><p>利用 <code>objdump -s -d filename</code> 可以把这部分机器代码反汇编</p><p>对于可执行文件中的 <code>.init</code> 节定义了一个名为 <code>_init</code> 的函数，程序的初始化代码会调用这个函数进行初始化，其他部分基本与可重定位目标文件中的节是类似的，不过已经被重定位到最终的运行时内存地址上，所以可执行文件中不需要 <code>.rel</code> 的节。代码运行时，其中的代码段和数据段都会被加载到内存中执行，还有一部分内容（符号表，调试信息）不会被加载到内存中</p><p>对于任何一个段，链接器必须选择一个起始地址 <code>vaddr</code>，需要保证 <code>vaddr mod align == off mod align</code> ，这种对齐要求是优化的一种，使得程序在执行时，可执行文件中的段能高效地传送到内存中</p><p><strong>链接器上下文中有3种不同的符号</strong></p><ol><li>由该模块定义，可以被其他模块定义的全局符号</li><li>由外部模块定义，被该模块引用的外部符号</li><li>只由该模块定义和引用的局部符号</li></ol><p>区别局部变量和全局变量的是static</p><p>对于static 相当于是私有的函数和变量，是不能够被其他模块引用的，隐藏变量和函数声明，任何带有static属性的全局变量或者函数都是模块私有的</p><p><strong>节头表</strong></p><p>使用 <code>readelf -S filename</code> 对文件进行解析</p><p>节头表由若干表项组成，每个表项描述相应的一个节的名称、在文件中的偏移、大小、访问属性、对齐方式等，目标文件中每一个节都有一个表项与之对应。32 位可重定位文件对应的节头表数据结构如下图所示，每个表项占 40 字节，64 位每个占 64 位</p><p><strong>程序头表</strong></p><p>使用 <code>readelf -l filename</code> 命令显示可执行文件的程序头表信息</p><p>程序头表发挥了与节头表类似的功能，程序头表中的一个表项对应一个连续的存储段或节。程序头表表项大小和表项数分别由 ELF 头中的字段 <code>e_phentsize</code> 和 <code>e_phnum</code> 指定</p><p>32位系统程序头表中每个表项具有以下数据结构。</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%203.png" alt="Untitled"></p><ul><li><code>p_type</code> 描述存储段的类型或特殊节的类型。</li><li><code>p_offset</code> 指出本段首字节在文件中的偏移地址。</li><li><code>p_vaddr</code> 指出本段首字节的虚拟地址。</li><li><code>p_paddr</code> 指出本段首字节的物理地址。通常由操作系统动态确定，所以没啥用。</li><li><code>p_filesz</code> 指出本段在文件中的字节数</li><li><code>p_memsz</code> 指出本段在存储器中所占的字节数</li><li><code>p_flags</code> 指出存储权限。</li><li><code>p_align</code> 指出对齐方式，用一个模数表示，为 2 的正整数幂，例如页面大小为 4KB，则模数为 $2^{12}$</li></ul><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/uTools_1694516256224.png" alt="uTools_1694516256224.png"></p><p>图中给出的程序头表，有4个可装入段（Type = LOAD）。第一个可装入段对应可执行文件中的0x0000000000000000~0x00000000000005c7 字节的内容，被映射到虚拟地址从 0x0000000000000000 开始长度为 0x00000000000005c8 的字节的区域，按 0x1000 = 212 = 4KB 对齐，有可读权限（Flags = R）第四个可装入段对应可执行文件中第 0x0000000000002df0~0x0000000000003010 字节的内容，被映射到的虚拟地址从 0x0000000000002df0 开始长度为 0x228 字节的区域，前 0x220 字节存储的是 .data 中的数据，后 0x8 字节对应 .bss 节，被初始化为 0。有可读写执行权限。从1，4 可装入段可以看出，.data 节在可执行目标文件中占用了相应的磁盘空间，在存储器中也分配了相应大小的空间；而.bss 节在文件中不占用磁盘空间，但在存储器中要分配相应大小的空间。</p><p><strong>可执行文件的存储器映像</strong></p><p>对于 IA-32 + Linux 系统，只读代码段总是映射到从虚拟地址为 0x8048000 开始的一段区域；可读可写数据段总是映射到只读代码段后面按照 4KB 对齐的高地址上；运行时堆则在可读可写数据段后 4KB 对齐的高地址处；栈则是从高地址到低地址增长。</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%204.png" alt="Untitled"></p><h3 id="处理器的虚拟化"><a href="#处理器的虚拟化" class="headerlink" title="处理器的虚拟化"></a>处理器的虚拟化</h3><p>计算机的CPU会把1s的时间切成很多小片，以此来虚拟化为很多的CPU，实际上只有一个CPU</p><p>为什么死循环不能使计算机彻底卡死</p><ul><li>原理上<ul><li>cpu会利用mem[$pc]来取出pc地址里的指令然后执行</li><li>硬件会发生中断(类似于强行插入的ecall)</li><li>切换到操作系统代码执行</li><li>操作系统代码可以切换到另一个进程执行</li></ul></li><li>实际上<ul><li>操作系统每隔一段时间就会进入中断来保证操作系统的代码能被调用，以至于操作系统不能卡死，就是相当于对于运行的进程来说，可以每隔一段时间就能调用一个co_yeild()函数。</li><li>每隔一段时间都保存现场去执行其他的代码，操作系统具有选择下一条指令的权力</li></ul></li></ul><h3 id="程序的加载"><a href="#程序的加载" class="headerlink" title="程序的加载"></a>程序的加载</h3><ul><li>对于shell来说，收到指令之后就会在操作系统中使用 <code>fork()</code> 指令创建一个新进程</li><li>在子进程中使用 <code>execve()</code> 加载 <code>a.out</code>。操作系统内核中的加载器识别出 <code>a.out</code> 是一个动态链接文件，做出必要的内存映射，从 <code>ld-linux-x86-64.so</code> 的代码开始执行，把动态链接库映射到进程的地址空间中，然后跳转到 <code>a.out</code> 的 <code>_start</code> 执行，初始化 C 语言运行环境，最终开始执行 <code>main</code>。在linux中可以使用 <code>execve</code> 来把程序从磁盘中加载到内存中</li><li>程序运行过程中，如需进行输入/输出等操作 (如 libc 中的 <code>putchar</code>)，则会使用特殊的指令 (例如 x86 系统上的 <code>int</code> 或<code>syscall</code>) 发出系统调用请求操作系统执行。典型的例子是 <code>printf</code> 会调用 <code>write</code> 系统调用，向编号为 <code>1</code> 的文件描述符写入数据。</li><li>加载器将可执行文件中的代码和数据复制到内存中，然后将CPU的控制权转移到程序开头，随后程序开始执行</li></ul><p>每一个linux程序都有一个运行时内存镜像，如图所示，linux中代码段总是从 0x400000 处开始，然后是数据段，运行时 ‘堆’ 在数据段之后，运行时 ’堆‘ 的增长方向是从低地址到高地址，例如C语言中的malloc函数所申请的内存空间就属于堆内存中。堆后面的区域是为共享模块保留的，这个区域把堆和栈隔开了。用户栈的起始地址是 $2^{48}-1$，也是最大的合法用户地址，栈的增长方向是从高地址到低地址的。再向上从 $2^{48}$ 开始，是为操作系统的代码和数据保留的，这个内存空间对用户代码是不可见的。实际上由于数据段由地址对齐的要求，所以代码段和数据段之间是有间隙的。同时为了防止程序受到攻击，在分配栈，共享库以及堆的运行时地址时，链接器还会用到地址空间随机化的策略，但是相对空间是不变的。</p><p>当加载器运行时，它为程序创造图中得到所示内存镜像，根据程序头表的内容，加载器将可执行文件的section复制到内存相应的位置，之后加载器跳转到程序的入口处，也就是_start函数的地址，这个函数在系统目标文件 <code>ctrl.o</code> 中定义，对于所有的C程序都是一样的，该文件属于是C运行时库中的内容。接下来就是 <code>_libc_start_main()</code> 函数，位于libc.so</p><p>中，作用是初始化执行环境，然后调用用户层的 <code>main()</code> 函数。 <code>main()</code> 函数返回值交由 <code>_libc_start_main()</code> 函数处理，并且在需要的时候把控制权交还给操作系统</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1698417319164.png" alt="1698417319164.png"></p><p>函数启动运行过程</p><p><code>_start()</code> → <code>_libc_start_main()</code> → <code>main()</code> → <code>_libc_start_main()</code> → <code>Linux Kernel</code></p><h3 id="进程，线程，协程"><a href="#进程，线程，协程" class="headerlink" title="进程，线程，协程"></a>进程，线程，协程</h3><p><strong>进程</strong></p><p>是正在运行的程序的实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p><strong>线程</strong></p><p>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以有很多线程，每条线程并行执行不同的任务，他们共享进程所拥有的的资源，但线程拥有自己的栈空间。</p><p>对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是<strong>被操作系统所管理</strong>的，当发生进程（或线程）的切换，操作系统需要执行”用户态–&gt;内核态–&gt;用户态“切换操作，将切换内容(上下文)保存到内存中（或内核栈）中。<br><strong>协程</strong></p><p>协程是一种比线程更加轻量级的存在，<strong>协程可以理解为一个特殊的函数</strong>，这个函数可以在某个地方挂起去执行别的函数，并且可以返回挂起处继续执行。一个线程内可以由多个协程来交互运行，但是多个协程的运行绝对是串行的，也就是说同一时刻只有一个协程能运行，其他协程必须被挂起</p><p>协程不是被操作系管理的，而是是在用户态执行，完全由程序所控制的，根据程序员所写的调度策略，通过协作（而不是抢占）来进行切换的。协程的本质思想就是控制函数运行时的主动让出（yield）和恢复（resume）。每个协程有自己的上下文，其切换由自己控制，当前协程切换到其它协程是由当前协程自己控制的。有自己独立的存储空间</p><p><strong>对比</strong></p><ul><li>一个进程可以包含多个线程，一个线程可以包含多个协程</li><li>进程、线程都是由操作系统所管理的，存在用户态和内核态；而协程完全在用户态运行，自己实现调度</li><li>一个进程可以包含多个线程，一个线程可以包含多个协程</li><li>一个进程最少包含一个线程；但线程内可以不存在协程</li><li>当CPU存在多个内核时，一个进程的多个线程可以并行执行；但是一个线程中的多个协程一定是串行执行的</li><li>进程、线程、协程的切换都是上下文切换，区别如下<ul><li>进程的切换上下文：切换虚拟地址空间，切换内核栈和硬件上下文，切换内容保存在内存中</li><li>线程的切换上下文：切换内核栈和硬件上下文，切换内容保存在内核栈中 （主要是线程处于同一个进程中，不需要切换虚拟地址空间）</li><li>协程的切换上下文：切换硬件上下文，切换内容保存在用户态的变量（用户栈或堆）中（协程是属于用户态的，不需要切换内核栈，而且数据也存储在用户态的变量里）</li></ul></li><li>进程、线程、协程的调度开销程度： 进程 &gt; 线程 &gt;&gt; 协程</li><li>协程更适合应用于单核CPU等IO密集但是计算并不密集的场景中，可以快速实现调度，尽可能提高CPU的利用率</li></ul><p><strong>协程函数与普通函数的区别</strong></p><ul><li>普通函数执行完后会退出，并释放栈帧。</li><li>协程函数可以在运行过程中保存上下文(栈帧)，并主动切换到其它线程执行，还可以通过其它协程协作返回本函数继续执行。</li></ul><p><strong>特点</strong></p><ul><li>用户态 协程是在用户态实现调度</li><li>轻量级：协程不在内核调度，不需要内核态和用户态之间切换，使用开销比较小</li><li>非抢占：协程是由用户自己实现调度，并且同一时间只能有一个协程在执行，协程主动交出CPU资源</li></ul><p><strong>ucontext组件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Userlevel context.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ctx(uc_flags);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span> uc_stack;</span><br><span class="line">    <span class="type">mcontext_t</span> uc_mcontext;</span><br><span class="line">    <span class="type">sigset_t</span> uc_sigmask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> __<span class="title">fpregs_mem</span>;</span></span><br><span class="line">  &#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure><ul><li><code>uc_link</code> 指向后继上下文（即，当前协程运行结束后，接着要被恢复的下一个协程的上下文）</li><li><code>uc_stack</code> 为该上下文中使用的栈</li><li><code>uc_sigmask</code> 为该上下文中的阻塞信号集合（可通过<code>man sigprocmask</code> 命令查看相关信息）</li><li><code>uc_mcontext</code> 这个结构体依赖于机器且不透明，作用是保存硬件上下文，包括硬件寄存器的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing a signal stack.  */</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="type">void</span>  *ss_sp;     <span class="comment">/* Base address of stack */</span></span><br><span class="line">     <span class="type">int</span>    ss_flags;  <span class="comment">/* Flags */</span></span><br><span class="line">     <span class="type">size_t</span> ss_size;   <span class="comment">/* Number of bytes in stack */</span></span><br><span class="line"> &#125; <span class="type">stack_t</span>;</span><br></pre></td></tr></table></figure><ul><li><code>ss_sp</code>指针 指向的是协程的栈空间的起始地址，可以是用户级的栈变量指针，也可以是堆变量指针</li><li><code>ss_flags</code> flag，在协程使用中设置该值为0。具体作用参考<code>man sigaltstack</code></li><li><code>ss_size</code> 表示栈空间的大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getcontext, setcontext - get or set the user context</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getcontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setcontext</span><span class="params">(<span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>getcontext()</code> 函数初始化<code>ucp</code>结构体，将当前上下文保存在<code>ucp</code>中</li><li><code>setcontext()</code> 函数设置当前上下文为<code>ucp</code>所指向的上下文。 <code>ucp</code> 所指向的上下文应该是调用 <code>getcontext()</code> 或 <code>makecontext()</code> 获得的</li><li>返回值：当调用成功后， <code>getcontext()</code>返回0， <strong><code>setcontext()</code>不会返回</strong>。当调用失败时，两个函数都返回-1并设置合适的errno</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makecontext, swapcontext - manipulate user context</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">makecontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp, <span class="type">void</span> (*func)(), <span class="type">int</span> argc, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">swapcontext</span><span class="params">(<span class="type">ucontext_t</span> *oucp, <span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span>;</span><br></pre></td></tr></table></figure><p><code>makecontext()</code> 函数修改 <code>ucp</code> 指向的上下文，该上下文是之前通过调用 <code>getcontext()</code> 获取的，也就是说在调用 <code>makecontext()</code>之前需要调用 <code>getcontext()</code>。且在调用 <code>makecontext()</code>之前，调用者必须分配一个新的栈空间为该上下文，并将栈空间地址设置到 <code>ucp-&gt;uc_stack</code>，还要设置 <code>ucp-&gt;uc_link</code>指向一个后继协程的上下文。如果func协程上下文中 <code>uc_link</code>值为 <code>NULL</code>，则执行完该协程后，线程会退出</p><p><code>makecontext()</code> 函数将<code>ucp</code> 对应的上下文中的指令地址指向 <code>func</code>函数(协程)地址，<code>argc</code>表示<code>func</code>的入参个数，如果入参为空，该值设置为0。如果<code>argc</code>有值，入参为一系列 (int)整型的数据。</p><p><code>swapcontext()</code> 保存当前协程的上下文到<code>oucp</code>，然后激活(切换到) <code>ucp</code>所指向的上下文对应的协程。返回值：当调用成功后，<strong><code>swapcontext()</code> 不会返回</strong>；当调用失败后，返回-1并设置合适的 errno。<code>swapcontext()</code> 函数可以理解成为 <code>getcontext()</code> 和 <code>setcontext()</code> 函数的组合。</p><h3 id="单个处理器的调度"><a href="#单个处理器的调度" class="headerlink" title="单个处理器的调度"></a>单个处理器的调度</h3><p>系统中有多个进程/线程共享 CPU</p><ul><li>包括系统调用 (进程/线程的一部分代码在 syscall 中执行)</li><li>偶尔会等待 I/O 返回，不使用 CPU (通常时间较长)</li></ul><p><strong>Round-Robin 策略</strong></p><p>中断之后切换到下一个线程运行，如果下一个线程正在等待I/O返回，就继续尝试下一个，如果所有线程都不需要CPU，就调度idle线程执行</p><p>中断之间的线程被称为时间片</p><p><img src="https://jyywiki.cn/pages/OS/img/sched-rr.png" alt="https://jyywiki.cn/pages/OS/img/sched-rr.png"></p><p><strong>存在的问题</strong></p><p>系统里有两个进程</p><ul><li>交互式的进程</li><li>纯粹计算的进程</li></ul><p>round-robin</p><ul><li>交互式的进程使用很短的时间处理完数据之后等待用户输入<ul><li>主动让出CPU</li></ul></li><li>计算的进程要使交互式进程在有输入的时候可能被延时<ul><li>必须等待计算一圈之后再执行</li></ul></li></ul><p><strong>优先级策略</strong></p><p>unix niceness</p><ul><li>引入优先级 -20~19<ul><li>-20 极坏 优先级最高</li><li>19 极好 优先级最低</li><li>linux中 nice相差10， CPU的资源获取率相差10倍</li></ul></li><li>使用taskset指令设置进程的优先级</li></ul><p><strong>动态优先级策略</strong></p><ul><li>设置若干个 Round-Robin 队列<ul><li>每一个队列对应一个优先级</li></ul></li><li>动态优先级调整策略<ul><li>优先调度高优先级队列</li><li>对CPU的占用率高的程序可以把优先级给低一点</li><li>对CPU占用率较低的程序可以把优先级高一点</li></ul></li></ul><p><strong>CFS策略（complete fair scheduling）</strong></p><ul><li>为每一个进程记录精确的运行时间</li><li>中断/异常发生之后，切换到运行时间最少的进程执行<ul><li>下次中断/异常之后，当前进程可能就不是最小的了</li></ul></li><li><p>操作系统对物理时钟有着绝对的控制</p><p>  复杂性</p><ul><li><p>子进程继承父进程的 vruntime 已经运行的时间，就不会出现疯狂fork出现线程饥饿的情况了，并且父进程首先开始运行</p><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小栗子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;Child\n&quot;</span>; *s; s++)&#123;</span><br><span class="line">      <span class="built_in">putchar</span>(*s);</span><br><span class="line">      sleep(<span class="number">0.01</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;Parent\n&quot;</span>; *s; s++)&#123;</span><br><span class="line">      <span class="built_in">putchar</span>(*s);</span><br><span class="line">      sleep(<span class="number">0.01</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果是两个输出混杂在一起，但是首先输出的永远是父进程的输出</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>I/O</p><pre><code>例如程序sleep(1) 之后，它的vruntime 十分落后，如果要赶上其他进程的运行时间的话，就需要很多的CPU时间所以现在的不会给这个程序额外的vruntime了</code></pre></li><li><p>整数溢出</p><pre><code>假设系统中最近，最远的时刻差不超过数轴的一半，可以只比较它们的相对大小</code></pre><p><strong>CFS的数据结构</strong></p></li><li><p>需要维护vruntime的集合</p><ul><li>更新vruntime</li><li>取最小的 vruntime</li><li>进程创建/退出/睡眠/唤醒时插入/删除 t</li></ul></li></ul></li></ul><p><strong>MLFQ策略</strong></p><ul><li>producer/consumer 获得最高优先级 Round-Robin</li><li>while(1) 完全饥饿→需要定期把所有人优先级拉平</li></ul><h3 id="多处理器的调度"><a href="#多处理器的调度" class="headerlink" title="多处理器的调度"></a>多处理器的调度</h3><p>计算机系统是多核心，多线程的</p><p><strong>困难所在</strong></p><ol><li>多用户多任务<ul><li>既不能简单的分配线程到处理器：线程退出，处理器开始围观</li><li>也不能简单的把线程分配给有空的处理器：在处理器之间的迁移会导致 cache/TLB 全部白给</li><li>调度迁移可能过一会还得迁移回来，不迁移会造成处理器的浪费</li></ul></li><li>能效比：功率无法支撑所有电路同时工作，总有一部分得停下来</li><li>能耗<ul><li>软件可以配置CPU的工作模式</li><li>开关频率越低，能效越好</li><li>对于同一个进程的不同线程，如果分配到同一个CPU上的运行速度甚至比分配到多个CPU上的运行速度快</li></ul></li><li>非统一内存访问：内存共享只是假象，位于同一个/不同module性能差距可能很大</li><li>CPU Hot-plug：CPU的热插拔，对于进程运行的过程中，也许就会少一个CPU，有时会多一个CPU，代码太复杂…</li></ol><h3 id="操作系统设计"><a href="#操作系统设计" class="headerlink" title="操作系统设计"></a>操作系统设计</h3><p>操作系统=一组对象+访问对象的API</p><p>实现=一个C程序实现上面的设计</p><ul><li>windows Subsystem for linux(WSL)<ul><li>WSL1 直接使用windows加载文件</li><li>WSL2 虚拟机</li></ul></li><li>Linux Subsystem for Windows (Wine)</li></ul><h3 id="IPC-平台级中断处理器"><a href="#IPC-平台级中断处理器" class="headerlink" title="IPC-平台级中断处理器"></a>IPC-平台级中断处理器</h3><p><strong>minix系统，缺点主要存在于IPC。</strong>进程间通信是指在不同进程之间传播或者交换信息</p><ol><li><p>管道</p><p> 通常指无名管道，是 UNIX 上最古老的IPC形式</p><p> <strong>特点</strong></p><ol><li>是半双工的（数据只能一个方向流动），具有固定的读端和写端</li><li>只能用于具有亲缘关系的进程之间的通信</li><li>可以看作是一个特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li></ol></li><li><p>FIFO</p><p> FIFO，也称为命名管道，它是一种文件类型。</p><p> <strong>特点</strong></p><ol><li>FIFO可以在无关的进程之间交换数据，与无名管道不同。</li><li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li></ol></li><li><p>消息队列</p><p> 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p><p> <strong>特点</strong></p><ol><li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li><li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li><li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</li></ol></li><li><p>信号量</p><p> 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据</p><p> <strong>特点</strong></p><ol><li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li><li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li><li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li><li>支持信号量组。</li></ol></li><li><p>共享内存</p><p> 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p><p> <strong>特点</strong></p><ol><li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li><li>因为多个进程可以同时操作，所以需要进行同步。</li><li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li></ol></li></ol><h3 id="实时操作系统——RTOS"><a href="#实时操作系统——RTOS" class="headerlink" title="实时操作系统——RTOS"></a>实时操作系统——RTOS</h3><p>实时操作系统又称为即时操作系统，会按照排序运行，管理系统资源，并为开发应用程序提供一致的基础</p><p>实时操作系统与一般的操作系统最大的特色就是‘实时性’，如果有一个任务需要执行，实时操作系统会立马执行该任务，不会有较长时间延时，这种特性保证了每个任务的及时执行</p><p>实时性是RTOS的最大的优点</p><p><strong>实时性</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ad52ed726c9a906fd9956c287c5906f6.png" alt="ad52ed726c9a906fd9956c287c5906f6.png"></p><p>实时运算（Real-time computing）是计算机科学中对受到“实时约束”的计算机硬件和计算机软件系统的研究，实时约束像是从事件发生到系统回应之间的最长时间限制。实时程序必须保证在严格的时间限制内响应。</p><p>实时操作系统中都要包含一个<strong>实时任务调度器</strong>，这个任务调度器与其它操作系统的最大不同是强调：严格按照优先级来分配CPU时间，并且时间片轮转<strong>不是</strong>实时调度器的一个必选项。提出实时操作系统的概念，可以至少解决两个问题：一个是早期的CPU任务切换的开销太大，实时调度器可以避免任务频繁切换导致CPU时间的浪费； 另一个是在一些特殊的应用场景中，必须要保证重要的任务优先被执行。</p><p><strong>国外嵌入式实时操作系统</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cc1e77383e437968ccf34fa0ca42dce9.png" alt="cc1e77383e437968ccf34fa0ca42dce9.png"></p><ol><li><p><strong>VxWorks</strong></p><p> VxWorks 凭借良好的可靠性和实时性被广泛地应用在各种高精尖技术行业中，如卫星通讯、军事演习等。VxWorks 最大的缺点是价格昂贵，软件的开发和维护成本都非常高，一般只提供二进制代码，源代码是不提供的，支持的硬件数量有限。</p></li><li><p><strong>Linux</strong></p><p> Linux 开源操作系统使用免费、可自由修改，它的功能强大、设计完善，为运行不同计算机平台提供了准确有效的通信手段，在价格上极具竞争力，目前最为流行。Linux 的弊端在于提供实时性能需添加实时软件模块来实现调度策略、硬件中断异常和程序执行。因此，代码错误可能破坏操作系统从而影响整个系统的可靠性。</p></li><li><p><strong>Windows CE</strong></p><p> Windows CE（Wince）相对简易开发，周期短且内核完善，可灵活支持通信，GUI丰富且开发功能完善，能更大程度地控制调度机制。但 Wince的版权费用也不可避免存在价格不菲的缺点，没有考虑实时应用，很难支持多种硬件平台，无法做到可定制性，且对资源的要求更高，在网络功能方面应用很少</p></li></ol><p><strong>国内嵌入式实时操作系统</strong></p><p>主要是 intewell RTOS</p><h3 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h3><p>由于linux内核中存在pagecache，一般修改的文件数据并不会马上同步到磁盘，会缓存在内存的page cache中，我们把这种和磁盘数据不一致的页称为脏页，脏页会在合适的时机同步到磁盘。为了回写page cache中的脏页，需要标记页为<strong>脏（dirty）</strong></p><p>脏页跟踪是指内核如何在合适的时机记录文件页为脏，以便内核在进行脏页回写时，知道将哪些页面回写到磁盘。匿名页不需要跟踪脏页，因为不需要同步到磁盘；私有文件页也不需要跟踪脏页，因为映射的时候，可写页会映射为只读，写访问会发生写时复制，转变为匿名页；所以只有共享的文件页需要跟踪脏页。跟踪有两个层面：一个是页表项记录，一个是页描述符记录。</p><p>访问文件页的两种方式</p><ul><li><p><strong>通过mmap映射文件</strong></p><p>  过程</p><ol><li>通过mmap映射共享文件</li><li>第一次访问文件页时，发生缺页后读文件页到 page chche，如果是写访问则设置相应进程的页表项为脏，可写</li><li>脏页回写时，会通过反向映射机制，查找映射这个页的每一个vma, 设置相应进程的页表项为只读，清脏标记</li><li>假如第二次写访问这个文件页时，脏页的处理有两种情况<ol><li>page cache中的文件页还未回写到磁盘（3 之前）， 此刻，这个文件页依然是脏页。因为相应进程的页表项为脏、可写，所以可以直接写这个页</li><li>page cache中的文件页已经回写到磁盘（step3 之后）， 此刻，这个文件页不再是脏页。因为页表项为只读，所以写访问会发生写时复制缺页异常，异常处理中将处理共享文件页映射，重新将相应进程的页表项为设置为脏、可写</li></ol></li><li>对于mmap映射的共享文件页，因为这个文件页可能会被多个进程共享到多个vma中，所以通过页表项的脏标志位来跟踪脏页：第一次写访问发生缺页异常会读文件页到page cache中并设置进程的页表项的脏标志，回写之前（clear_page_dirty_for_io完成之前），页表项的脏标志是置位的，回写的时候（clear_page_dirty_for_io的调用）会通过反向映射机制将所有映射这个页的页表项的脏标志位清零并设置只读权限，回写之后（clear_page_dirty_for_io完成之后），再次的写访问会发生写时复制缺页异常，再次设置页表项的脏标志位，如此重复，从而跟踪了脏页</li></ol></li><li><strong>通过文件系统的write接口操作文件</strong><ol><li>通过write接口访问文件页时，会读取文件页到page cache,不会映射到任何进程地址空间，所有这种方式跟踪脏页是通过设置/清除页描述符脏标记来实现</li><li>第二次写访问文件页<ol><li>脏页回写之前，页描述符脏标志位依然被置位，等待回写, 不需要设置页描述符脏标志位。</li><li>脏页回写之后，页描述符脏标志位是清零的，文件写页调用链会设置页描述符脏标志位。</li></ol></li><li>对于直接通过write接口访问的文件页，因为这个文件页只会被读取到page cache中，并没有映射到任何进程地址空间，进程写访问是通过copy_from_user的方式，所以通过页描述符记录脏页。回写之前（clear_page_dirty_for_io完成之前），写文件的时候通过文件系统的写文件的调用链会设置页描述符脏标志位，回写的时候（clear_page_dirty_for_io的调用）会清除页描述符脏标志位，回写之后（clear_page_dirty_for_io完成之后），再次通过write接口写访问时，再次通过文件系统的写文件的调用链会再次设置页描述符脏标志位，如此重复，从而跟踪了脏页。</li></ol></li></ul><p>Linux在设计IO模块的时候，认为读写操作的紧迫性是不一样的，读操作的紧迫性要高于写操作。所以Linux的写默认是延迟的，因为这样不仅仅可以显著的提高效率</p><ul><li>写操作合并：多次写操作才会真正的发起一次写物理磁盘，大幅提升IO性能<ul><li>IO栈中还有通用块层和IO调度层，在具体的文件系统层有文件在文件系统中的逻辑块映射，也就是文件的文件块在磁盘上对应的磁盘块的地址，这时候在通用块层会把这些信息封装成BIO对象，然后提交到gendisk-&gt;request_queue，在提交的过程中，如果BIO和已有的request中的BIO在物理地址上是连续的，那么这些BIO就会合并成一个request。在IO调度层，一次request就意味着一次IO，因为这时候磁盘需要重新寻址，所以这个合并其实是在io调度层入队列的时候完成的</li><li>可以通过iostat查看物理盘IO情况，看到对应的监控指标等</li></ul></li><li>读操作比写操作更紧迫<ul><li>通常延迟写物理磁盘不会导致进程挂起，写到page cache然后修改该页的PG_dirty标志即可返回（如果open的时候设置了sync标志或者调用了fsync、sync函数，那么会将写page cache的内容封装成一个IO request放到IO调度层的request_queue中，然后由调度层的调度算法来写到物理磁盘）</li><li>如果读操作读的时候page cache中没有缓存数据，读操作就需要去读物理磁盘，此时就需要一些时间</li></ul></li></ul><p><strong>脏数据</strong>：事务对缓冲池中行记录的修改，并且还没有提交</p><p><strong>脏读</strong>：指的是在不同事务下，当前事务可以读取到另外事务未提交的数据，简单来说就是可以读到脏数据。</p><h3 id="VMA-virtual-memory-area"><a href="#VMA-virtual-memory-area" class="headerlink" title="VMA (virtual memory area)"></a>VMA (virtual memory area)</h3><p>在Linux中，每个segment用一个vm_area_struct（以下简称vma）结构体表示。vma是通过一个双向链表（早期的内核实现是单向链表）串起来的，现存的vma按起始地址以递增次序被归入链表中，每个vma是这个链表里的一个节点。</p><p>在用户空间可通过”/proc/PID/maps”接口来查看一个进程的所有vma在虚拟地址空间的分布情况，其内部实现靠的就是对这个链表的遍历</p><p>vma又通过<strong>红黑树</strong>（red black tree）组织起来，每个vma又是这个红黑树里的一个节点。为什么要同时使用两种数据结构呢？使用链表管理固然简单方便，但是通过查找链表找到与特定地址关联的vma，其时间复杂度是O(N)，而现实应用中，在进程地址空间中查找vma又是非常频繁的操作（比如发生page fault的时候）</p><p>使用红黑树的话时间复杂度是O(  )，尤其在vma数量很多的时候，可以显著减少查找所需的时间（数量翻倍，查找次数也仅多一次）。同时，红黑树是一种非平衡二叉树，可以简化重新平衡树的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> vm_start; <span class="comment">// 指向这个区域的起始地址</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> vm_end;  <span class="comment">// 指向这个区域的结束地址</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span> <span class="comment">// 双向链表</span></span><br><span class="line"> <span class="type">rb_node_t</span> vm_rb;  <span class="comment">// 红黑树的一个节点</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_flags; <span class="comment">// 属性 VM_READ读、VM_WRITE写、VM_EXEC执行、VM_SHARED共享</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span> <span class="comment">// 指向这个被映射的文件，进而可获得该文件的inode信息</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff; <span class="comment">// 这个段在该文件内的偏移</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span> </span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>机器指令模型中只有两种状态</p><ul><li>寄存器 (rax, rbx, ….., cr3)</li><li>物理内存</li></ul><p>存储当前状态的需求：</p><ul><li>可以寻址<ul><li>根据编号读写数据</li></ul></li><li>访问速度尽可能快<ul><li>甚至不惜规定状态在掉电之后丢失</li><li>memory hierarchy 存储器层次结构，内存阶层</li></ul></li></ul><p>持久化：对于需要保存的数据是以一串机械波 delay line memory ，并且相当于是在一根管道里不断循环，当检测到其中有1信号随时间损失，放大器就会补充能量，使之保存数据</p><h3 id="memory-hierarchy-存储器层次结构，内存阶层"><a href="#memory-hierarchy-存储器层次结构，内存阶层" class="headerlink" title="memory hierarchy 存储器层次结构，内存阶层"></a>memory hierarchy 存储器层次结构，内存阶层</h3><p>在计算机体系结构中，内存阶层根据<a href="https://baike.baidu.com/item/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/1528464?fromModule=lemma_inlink">响应时间</a>将计算机存储划分为一个<a href="https://baike.baidu.com/item/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7658029?fromModule=lemma_inlink">层次结构</a>。 由于响应时间，复杂性和容量是相关的，所以这些级别也可以通过它们的性能和控制技术来区分。 内存阶层影响计算机体系结构设计，算法预测以及涉及参考位置的较低级别编程结构的性能。</p><p>由于硬件技术的限制，我们可以制造出容量很小但很快的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>，也可以制造出容量很大但很慢的存储器，但不可能两边的好处都占着，不可能制造出访问速度又快容量又大的存储器。因此，现代计算机都把存储器分成若干级，称为内存阶层（MemoryHierarchy），按照离CPU由近到远的顺序依次是CPU寄存器、<a href="https://zhuanlan.zhihu.com/p/71956210">Cache</a>（缓存）、内存、硬盘，越靠近CPU的存储器容量越小但访问速度越快。大部分现今的<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/284033?fromModule=lemma_inlink">中央处理器</a>的速度都非常的快。大部分程式工作量需要内存存取。由于快取的效率和内存传输位于阶层中的不同等级，所以实际上会限制处理的速度，导致中央处理器花费大量的时间等待内存I/O完成工作。</p><p>大部分电脑的内存阶层都是如下</p><ul><li><a href="https://baike.baidu.com/item/%E6%9A%82%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">暂存器</a>–可能是最快的存取，但仅仅只有几百个字节。</li><li>第一级（L1）快取–通常存取只需要几个周期，通常是几十个KB。</li><li>第二级（L2）快取–比L1约有2到10倍较高延迟性，通常是几百个KB或更多。</li><li>第三级（L3）快取–（不一定有）比L2更高的延迟性，通常有数MB之大。</li><li><a href="https://baike.baidu.com/item/%E4%B8%BB%E5%86%85%E5%AD%98?fromModule=lemma_inlink">主内存</a>（<a href="https://baike.baidu.com/item/DRAM?fromModule=lemma_inlink">DRAM</a>）–存取需要几百个周期，但可以大到数个GB。</li><li>磁盘储存–需要成千上百个周期，但是容量非常的大.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">           ------</span><br><span class="line">             / Regs \              - 寄存器</span><br><span class="line">            ----------</span><br><span class="line">           / L1 cache \            - 一级缓存</span><br><span class="line">          --------------</span><br><span class="line">         /   L2 cache   \          - 二级缓存</span><br><span class="line">        ------------------</span><br><span class="line">       /     L3 cache     \        - 三级缓存</span><br><span class="line">      ----------------------</span><br><span class="line">     /     Main memory      \      - 内存</span><br><span class="line">    --------------------------</span><br><span class="line">   /       Local disks        \    - 本地磁盘</span><br><span class="line">  ------------------------------</span><br><span class="line"> /       Network storage        \  - 网络存储</span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure><p>对于进程，一旦crash之后，内存和寄存器中的所有状态都会丢失</p><h3 id="磁芯内存magnetic-core"><a href="#磁芯内存magnetic-core" class="headerlink" title="磁芯内存magnetic core"></a>磁芯内存magnetic core</h3><p><a href="https://baike.baidu.com/item/%E7%A3%81%E8%8A%AF%E5%AD%98%E5%82%A8%E5%99%A8/10189808?fromModule=lemma_inlink"><strong>磁芯存储器</strong></a>（英语：Magnetic Core Memory）是一种早期的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/786229?fromModule=lemma_inlink">计算机存储器</a>。磁芯存储器是利用<a href="https://baike.baidu.com/item/%E7%A3%81%E6%80%A7%E6%9D%90%E6%96%99/1116212?fromModule=lemma_inlink">磁性材料</a>制成之存储器，其原理为：将磁环（磁芯）带磁性或不带磁性之状态，用以代表1或0之比特，一长串1或0之组合就代表要存储之信息</p><p>磁芯存储器是一种<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">随机存取存储器</a>（Random Access Memory），在计算机中可担任主存的角色。比起真空管而言，磁芯存储器省电、也没有真空管的寿命问题。当计算机进入半导体时代后，仍然有一段相当的时间，磁芯存储器持续担任主存的角色。又由于磁芯存储器是非易失性存储器（Non-volatile Memory），它的一个特色是：即使死机或电源中断，只要没有发生错误的写入信号，则仍然可保有其内容。</p><h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><p><strong>磁</strong></p><p>读取：放大感应电流</p><p>写入：电磁铁磁化磁针</p><ol><li><p>磁带</p><p> 价格：非常低</p><p> 容量：非常高</p><p> 读写速度：</p><ul><li>顺序读取：勉强-需要等待定位</li><li><p>随机读取：几乎完全不行</p><p>可靠性：</p></li><li><p>存在机械部件，保存环境苛刻</p></li></ul></li><li>磁鼓<ul><li>用旋转的二维平面存储数据<ul><li>容量变小</li></ul></li><li>读写延迟不会超过旋转周期<ul><li>随机读写速度提升</li></ul></li></ul></li><li><p>磁盘</p><p> 二维平面上可以放置很多磁带</p><ul><li>价格低</li><li>容量高</li><li>顺序读写速度较高，随机读写速度勉强</li><li><p>可靠性 存在机械部件</p><p>调度方法</p></li><li><p>当今的磁盘上基本上都有cpu和Dram(dynamic random access memory)，基本上是有一个 system on chip ，并且当系统调用的时候会发出请求来调用某一个block的内容，SOC就会对应的返回该block的数据</p></li><li><p>[mq-deadline] none 读优先，写不至于饿死</p><p><strong>硬盘分类</strong></p></li><li><p>SSD</p><p>用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。固态硬盘在接口的规范和定义、功能及使用方法上与普通硬盘的完全相同，在产品外形和尺寸上也完全与普通硬盘一致。</p><p>优点：读写速度快；防震抗摔性；低功耗；无噪音；工作温度范围大；轻便</p><p>缺点：容量小；寿命有限；售价高</p></li><li><p>HHD</p><p>是既包含传统硬盘又有闪存（flashmemory）模块的大容量存储设备。闪存处理存储中写入或恢复最频繁的数据。</p><p>优点：应用中的数据存储与恢复更快，系统启动时间减少，功耗降低，生成热量减少，硬盘寿命延长，笔记本和PAD的电池寿命延长，工作噪声级别降低</p><p>缺点：硬盘中数据的寻道时间更长，硬盘的自旋变化更频繁，闪存模块处理失败，不可能进行其中的数据恢复，系统的硬件总成本更高</p></li><li><p>HDD</p><p>最基本的电脑存储器，我们电脑中常说的电脑硬盘</p><p>有磁头，马达，磁盘等一系列零件设备，搭载NAND flash芯片为存储设备，运行速度慢，功耗高，也不轻便</p></li></ul></li><li><p>软盘</p><p> 就是一个磁盘的盘片</p><ul><li>价格低</li><li>容量低</li><li>读写速率低</li><li>可靠性低</li></ul></li></ol><p><strong>坑-compact disk</strong></p><p>通过激光扫过表面，就能够把光盘上的坑的信息读出来，但是只能读不能写</p><p><strong>克服只读限制的方法</strong></p><ul><li>使用持久化数据结构，并且使用激光器烧出一个坑来</li><li>利用PCM来改变材料的反光特性</li></ul><p><strong>分析</strong></p><ul><li>价格低 （可以通过压盘复制）</li><li>容量高</li><li>顺序读写速度快，随机读取勉强，写入速度低</li><li>可靠性强</li></ul><p><strong>电</strong></p><ol><li><p><strong>Solid State Drive</strong></p><p> flash memory 闪存</p><p> 利用 floating gate 的充放电来实现 1-bit 信息的存储</p><p> <img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%205.png" alt="Untitled"></p><p> 通过上面施加正向或者反向电压来改变存储内部是否有电子，进而来记录 1-bit 的信息</p><p> 利用的是光刻，可以尽可能的小，借助的是01电路工艺，实际上就是一个大规模集成电路</p><ul><li>价格低</li><li>容量高(3D空间上每一个(x,y,z)) 都是1-bit</li><li>读写速度高：直接通过电路读写，由于电路级并行，容量越大速度越快，快到淘汰了旧的SATA接口标准（NVMe）</li><li>可靠性高</li></ul></li><li><p>USB Flash Disk U盘</p><p> 缺点：</p><p> 放电（erase）不可能做到100%放干净，经过数千/万次充放电之后，就再也无法擦除(dead cell: wear out)</p><p> 解决：</p><p> 软件定义磁盘，每一个SSD中都藏着一个完整的计算机</p><ul><li>FTL flash translation layer</li></ul></li></ol><p><strong>U盘，SD卡，SSD区别</strong></p><ul><li>U盘，SD卡，SSD都是NAND flash</li><li>但实际上软件/硬件系统的复杂程度不同，效率/寿命也不同<ul><li>典型的SSD<ul><li>CPU-on chip RAM 缓存，store buffer，操作系统</li><li>寿命：~1 PiB 数据写入1000年寿命</li></ul></li><li>SD卡<ul><li>SDHC标准未规定jjj</li><li>良心商家依然有ARM芯片</li></ul></li></ul></li></ul><p><strong>FTL性能，可靠性，安全性的难题</strong></p><ul><li>首先，（快速）格式化是没有用的</li><li>即使格式化后写入数据（不写满）<ul><li>同一个 logic block 被覆盖，physical block 依旧存储了数据（copy on write）</li><li>需要文件加密系统</li></ul></li></ul><h3 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h3><p><strong>I/O设备</strong></p><p>一个能与CPU交互交换数据的接口/控制器。每一组线都有自己的地址，CPU可以直接使用指令(in/out/MMIO)和设备交换数据，并且CPU不管设备具体·是怎么处理的</p><p><strong>总线：一个特殊的I/O设备</strong></p><p>提供设备的注册和地址到设备的转发，把收到的地址（总线地址）和数据转发到相应的设备上，这样的话CPU只需要直接连接一根总线就可以了</p><p><strong>中断控制器</strong></p><p>CPU有一个中断引脚</p><p>收到某一个特定的电信号就会触发中断（引脚低电平），CPU会保存5个寄存器，跳转到中断向量表对应的位置执行</p><ul><li>8259 PIC 可以设置中断屏蔽，中断触发等</li><li><p>APIC</p><ul><li><p>local APIC 中断向量表，IPI（处理器间的中断），时钟</p><ul><li><p>IPI 处理器间中断</p><p>  处理器间中断就是一个 CPU 向系统中的目标 <a href="https://baike.baidu.com/item/CPU/120556?fromModule=lemma_inlink">CPU</a>发送中断信号，以使目标CPU执行特定的操作。CPU将处理器间中断(IPI) 作为信号直接放在 APIC 总线上传输，并不通过 IRQ 中断线。Linux 在内核中使用了三种处理器间中断。CALL_FUNCTION_VECTOR：该中断被发往所有的 CPU，但不包括发送者。该中断促使目标 CPU 执行特定的操作，实际上就是运行一个随参数传递过来的函数。</p></li></ul></li><li><p>I/O APIC</p></li></ul></li><li>系统分发LRQ中断给CPU主要有两种方式</li></ul><ol><li><p>静态分发</p><p> 所有本地 APIC 都会被静态写入中断重定向表的表项中，IRQ 中断请求信号会发送给这些表项的列出的本地 APIC。然后本地 APIC 再将中断发送给目标 CPU。</p></li><li><p>动态分发</p><p> 在所有 CPU 正在执行的进程中，如果某个 CPU 正在执行的进程的优先级最低，IRQ 中断请求信号就传递给这个 CPU，这就是所谓的最低优先级模式。每个本地 APIC 内部都包含一个可编程任务优先级寄存器 TPR，该寄存器计算运行进程的优先级，以供中断分发参考使用。操作系统内核在<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/4566793?fromModule=lemma_inlink">进程切换</a>时都会对这个寄存器进行修改。如果多个 CPU 有相同的最低优先级，这种情况是可能的，此时系统就利用仲裁技术来分配 CPU 的负荷。在本地APIC 中有一个仲裁优先级寄存器中，初始化时会为每个 CPU 都分配一个 0—l5 范围内的值。当某 CPU接收到一个中断时，其仲裁优先级的值就自动设置为 0，而其他 CPU 的仲裁优先级都增加一。当仲裁优先级寄存器的值大于15 时，就将获取中断的那个 CPU 的前一个仲裁优先级加 l，作为当前 CPU 的仲裁优先级。因此，中断在 CPU 之间以轮转方式进行分发，并且各个 CPU 任务优先级相同。多 APIC 系统还处理 CPU 之间产生的处理器间中断。某 CPU 为了要向目标CPU 发送中断，它先要将中断向量和目标 CPU 的本地 APIC 的 ID 存入中断指令寄存器 ICR 中，然后经过 APIC 总线向目标 CPU 发送核间中断，目标CPU 接收中断，然后进行中断处理。处理器间中断(IPI)是 SMP 体系结构非常重要的组成部分，利用它可以进行 CPU 间的通信，有效地提升系统的效率。</p><p> <strong>中断没能解决的问题</strong></p><p> 程序进行大量的中断读写，就会非常浪费时间</p><p> <strong>Direct Memory Access (DMA)</strong></p><p> 是一个专门执行memcpy程序的CPU</p><p> 支持几种memcpy</p><ul><li>memory → memory</li><li>memory → device</li><li><p>deivce(register) → memory</p><ul><li>实现：把DMA控制器链接在总线和内存上</li></ul><p>DMA拷贝数据结束之后会发送一个中断信号来告诉CPU已经完成了</p></li></ul></li></ol><p><strong>DMA</strong></p><p>GPU 与 DMA 一样都是一个只做一件特别的事情的CPU，可以实现显示图形</p><p>一个完整的众核多处理器系统</p><ul><li>注重大量并行相似任务</li><li><p>程序保存在内存（显存）中</p><p>  nvcc（LLVM）分为两个部分</p><ul><li>main编译/链接成本地可执行的ELF</li><li>kernel编译成GPU指令</li></ul></li><li>数据也保存在内存（显存）中<ul><li>也可以输出到视频接口</li><li>也可以通过DMA传回系统内存</li></ul></li></ul><p><strong>设备驱动程序</strong></p><p>I/O设备的抽象——设备抽象成字节流或者字节序列，I/O设备的主要功能：输入和输出。能够读写的字节序列，在数据未就绪或者无数据时就会等待</p><p>操作系统：设备 = 支持各类操作的对象（文件）</p><ul><li>read 从设备某个指定的位置读出数据</li><li>write 向设备某个指定的位置写入数据</li><li>ioctl 读取/设置设备状态</li></ul><p>把系统调用（read/write/ioctl)翻译成与设备寄存器的交互，就是一段普通的代码。但是有可能会睡眠（未获得锁，等待其他操作唤醒）</p><p>缺点</p><ul><li>设备不仅仅是数据，还有控制</li><li>设备的附加功能和配置</li><li>所有设备的额外功能都是依赖于 ioctl</li></ul><p><strong>更多文件操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">  <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">  <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">  <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">  <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">  <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">  <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">  <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">  <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>unlocked_ioctl</code> 是BKL（big kernel lock 内核大锁）的产物<ul><li>单处理器时代只有ioctl</li><li>之后引入了BKL，ioctl执行时默认持有BKL</li><li>之后通过 <code>unlocked_ioctl</code> 避免🔓，ioctl被移除</li></ul></li><li><code>compact_ioctl</code> 机器字节的兼容性<ul><li>32-bit 程序在 64-bit 程序兼容</li></ul></li></ul><p><strong>存储设备的抽象</strong></p><p>磁盘的访问特性</p><ul><li>以数据块为单位访问<ul><li>传输有最小单元，不支持任意随机访问</li><li>最佳的传输模式与设备相关</li></ul></li><li>大量吞吐<ul><li>使用DMA传输数据</li></ul></li><li>应用程序不直接访问，抽象成一个文件<ul><li>访问者通常是文件系统</li><li>大量并发的访问，操作系统中的进程都要访问文件系统</li></ul></li></ul><h3 id="文件系统API"><a href="#文件系统API" class="headerlink" title="文件系统API"></a>文件系统API</h3><p><strong>为什么需要文件系统</strong></p><ul><li>设备在应用程序之间是共享的，需要保证写入操作i具有原子性，多个程序并行的时候可能会出现数据竞争</li><li>驱动设备，每一个驱动设备的调用的应用程序都是一系列对应的API的调用，全部由设备驱动负责调度和隔离</li><li>磁盘需要支持数据的持久化</li></ul><p><strong>文件系统：虚拟磁盘</strong></p><p>设计目标：</p><ol><li>提供合理的API使多个应用程序能共享数据</li><li>提供一定的间隔，隔离恶意/出错的程序</li></ol><p>存储设备的虚拟化</p><ul><li>磁盘 一个可以读写的字节序列</li><li>虚拟磁盘 一个可以读写的动态字节序列<ul><li>命名管理，虚拟磁盘的名称，检索和便利</li><li>数据管理，std::vector<char> 随机读写/resize</char></li></ul></li></ul><p>文件系统的根</p><p>文件系统可以虚拟为一棵文件树</p><p>有一个根节点</p><ul><li><p>windows：每个设备（驱动器）都是一棵树</p><p>  C盘开始，AB盘是软盘驱动器上的软盘</p><p>  优盘会分配新的盘符</p></li><li><p>Unix/Linux</p><p>  只有一个根目录</p><p>  unix允许任意目录挂载（mount）一个设备代表的目录树，可以把设备挂载到任何想要的位置</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source, <span class="type">const</span> <span class="type">char</span> *target,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">char</span> *filesystemtype, <span class="type">unsigned</span> <span class="type">long</span> mountflags,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>linux启动</strong></p><p>最初的文件系统的根并不是在设备上的，而是一个 initramfs，这里面的文件非常少，只有 init, bin(busybox)，这个文件系统存在于内存里面，之后执行启动的代码再把文件系统加载出来，再把文件挂载到指定位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/bin</span><br><span class="line">busybox mknod /dev/sda b <span class="number">8</span> <span class="number">0</span></span><br><span class="line">busybox mkdir -p /newroot</span><br><span class="line">busybox mount -t ext2 /dev/sda /newroot</span><br><span class="line">exec busybox switch_root /newroot/ /etc/init</span><br></pre></td></tr></table></figure><p><code>pivot_root</code> 可以实现根文件系统的切换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pivot_root new_root put_old</span><br><span class="line"><span class="comment">// 可以把旧的挂载点换成新的挂载点</span></span><br></pre></td></tr></table></figure><p><strong>文件的挂载</strong></p><ul><li>文件 = 磁盘上的虚拟磁盘</li><li>挂载文件 = 在虚拟磁盘上虚拟出的虚拟磁盘</li></ul><p>linux的处理方式：</p><ul><li>创建一个loopback回环设备</li><li>设备驱动把设备的read/write翻译成文件的read/write</li><li>lsblk 查看系统中的 block devices (strace)</li><li>strace 观察挂载的流程，通过 ioctl 来挂载文件<ul><li><code>ioctl(3, LOOP_CTL_GET_FREE)</code></li><li><code>ioctl(4, LOOP_SET_FD, 3)</code></li></ul></li></ul><p><strong>目录API</strong></p><ul><li>mkdir 创建一个空目录，可以设置访问权限</li><li>rmdir 删除一个空目录，没有递归删除的系统调用， rm -rf能遍历删除整个目录</li><li>getdents 返回count个目录项(ls, find, tree的底层)，以 . 开头的文件都会返回</li></ul><p><strong>硬（hard）链接</strong></p><p>允许一个文件被多个目录引用</p><ul><li>目录中仅存储指向文件数据的指针</li><li>不能链接目录</li><li>不能跨文件系统</li></ul><p>对于UNIX文件系统，所有的文件都是硬链接，删除链接的系统调用就被称为 unlink</p><p>可以避免磁盘的拷贝，只是一个指向文件数据的指针，减少磁盘内存消耗</p><p><strong>软（symbolic）链接</strong></p><p>就是在文件里存储一个跳转提示  <code>ln -s</code></p><ul><li>软链接也是一个文件<ul><li>当引用这个文件的时候就会去寻找另一个文件</li><li>另一个文件的绝对/相对路径以文本的形式存储在文件里</li><li>可以跨文件系统，可以链接目录</li></ul></li><li>类似快捷方式<ul><li>即使链接指向的地址不存在</li></ul></li></ul><p>其中使用了symlink的系统调用，但是对于这种软链接是有上限的，在内核代码中有声明</p><p>可以任意链接允许创建有向图</p><ul><li>允许创建任意的有向图</li><li>允许多次间接链接</li><li>可以创建软链接的硬链接，软链接也是文件</li><li>允许成环</li></ul><p>进程当前的工作目录：pwd 指令或者 $PWD 环境变量可以查看</p><p>chdir 系统调用可以修改 当前工作路径，对应shell中的cd，cd是shell的内部指令，也就是没有外部指令可以修改当前的工作目录</p><p><strong>文件API</strong></p><p>文件就是虚拟的磁盘，磁盘是一个字节序列，支持读写操作</p><p>文件描述符：</p><ul><li>通过 open/pipe 获得</li><li>通过 close 释放</li><li>通过 dup/dup2 复制</li><li>fork 时继承</li></ul><p>mmap 磁盘映射</p><p>使用open打开一个文件之后</p><ul><li>使用 MAP_SHARED 将文件映射到地址空间中</li><li>使用 MAP_PRIVATE 创建一个 copy-on-write 的副本</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>; </span><br><span class="line"><span class="comment">// 映射 fd 的 offset 开始的 length 字节</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>文件访问的游标</p><p>文件描述符不仅仅指向一个虚拟磁盘，而是指向了这个虚拟磁盘的一个具体的位置，这样的话，连续读写不需要指定文件读写的位置，如果一次写入太多，超过了虚拟磁盘的大小，虚拟磁盘就会自动扩容到写入的大小，并且写完之后，游标指向最后的位置</p><p>偏移量管理</p><p>操作系统的每一个API都可能和其他的API有交互</p><ol><li>open 获得一个独立的 offset</li><li>dup 两个文件描述符共享 offset</li><li>fork 父子进程共享 offset</li><li>execve 文件描述符不变</li><li>O_APPEND 方式打开的文件，偏移量始终在最后</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;./a.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="number">1000</span>;</span><br><span class="line">  <span class="type">void</span> *addr = mmap(<span class="literal">NULL</span>, len, PROT_WRITE | PROT_READ | PROT_EXEC, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(addr &lt; <span class="number">0</span>)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> offset = lseek(fd, <span class="number">2048</span>, SEEK_SET);</span><br><span class="line">  <span class="type">int</span> feedback = ftruncate(fd, <span class="number">500</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: test2.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Tue 03 Oct 2023 15:57:15 CST</span></span><br><span class="line"><span class="comment">// Description:</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;./a.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">char</span>* buf = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = write(fd, buf, <span class="number">5</span>);</span><br><span class="line">    ret = write(fd, buf, <span class="number">5</span>);</span><br><span class="line">    ret = write(fd, buf, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">      perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">char</span>* buf = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = write(fd, buf, <span class="number">6</span>);</span><br><span class="line">    ret = write(fd, buf, <span class="number">6</span>);</span><br><span class="line">    ret = write(fd, buf, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">      perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件系统的API</p><ul><li>目录<ul><li>mkdir, rmdir, link, unlink, open</li></ul></li><li>文件<ul><li>read, write, mmap, stat, open</li></ul></li><li>文件描述符<ul><li>lseek</li></ul></li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统可以抽象为一个数据结构，以block为基本单位，可以抽象为blockarray，blockset等数据结构</p><p>利用balloc函数分配block内存，对于分配出来的内存可以使用一个链表连接起来</p><p><strong>FAT文件系统File Allocation Table</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">balloc</span><span class="params">()</span>; <span class="comment">// 返回一个空闲可用的数据块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfree</span><span class="params">(<span class="type">int</span> id)</span>; <span class="comment">// 释放一个数据块</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">block</span> *&gt;</span> file; <span class="comment">// 文件</span></span><br><span class="line"><span class="comment">// 文件的名称、大小等保存在目录中</span></span><br></pre></td></tr></table></figure><p>很小的文件系统</p><ul><li>树状的目录结构</li><li>系统中以小文件为主</li></ul><p>文件实现方式</p><ul><li>struct block * 的链表</li></ul><p>使用链表存储数据有两种设计</p><ol><li>在每一个数据块之后放置指针<ul><li>优点：实现简单，无须单独开辟存储空间</li><li>缺点：数据的大小不是 $2^k$，单纯的lseek需要读取整块数据</li></ul></li><li><p>将指针集中存放在文件系统的某个区域</p><ul><li>优点：局部性好，lseek 更快</li><li><p>缺点：集中存放的数据损坏将导致数据丢失，对于这个区域，读写最频繁，所以最可能损坏</p><p>lseek需要遍历指针链表，解决：把存储的指针存储n份</p></li></ul></li></ol><p>FAT-12/16/32 即next指针的大小</p><p>FAT决定指针的类型大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CountofClusters &lt; <span class="number">4085</span>) &#123;</span><br><span class="line">  <span class="comment">// Volume is FAT12 (2 MiB for 512B cluster)</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CountofCluster &lt; <span class="number">65525</span>) &#123;</span><br><span class="line">  <span class="comment">// Volume is FAT16 (32 MiB for 512B cluster)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Volume is FAT32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于flash，上层是可以完全看到flash的状态，一旦有损坏就是全盘都怀掉了，会自动屏蔽这些 cluster，对于以前的文件系统，如果有一块 cluster 怀掉了，系统就不分配值一块内存，系统可以容忍这些错误</p><p>对于系统文件，会有指针指向文件的下一块内存，当指针的内容是0xff 的话，就是文件结束了，否则就是文件的下一块block的地址</p><p>目录文件</p><p>以普通文件的方式存储目录这个数据结构，里面有很多叫做directory entry的数据结构</p><p><img src="https://jyywiki.cn/pages/OS/img/FAT-dent.png" alt="https://jyywiki.cn/pages/OS/img/FAT-dent.png"></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1696469205035.png" alt="1696469205035.png"></p><p>对于当时的FAT文件系统中，如果next中存放的数据是0，就说明内存是free状态，如果是2～MAX，说明内存已经被分配，如果是(MAX+1)~0xff6，文件系统处于一个不正确的状态，FF7就是文件系统出错了，FF8～FFE 保留并且不能被使用，也许是被解释为一个分配了的内存，并且是文件的末端的一块区域，0xFFF区域被分配并且是文件末端的区域</p><p>格式化 = FAT表丢失，所有的文件内容都在，只是对于数据结构看来都是free block，本质上是 cluster 的分类和建立可能的后继关系</p><p>FAT性能</p><ul><li>小文件很合适</li><li>但是对于大文件的随机访问就很麻烦，4GB的文件跳到末尾（4kb cluster）需要多次操作，缓存可以解决，但是又引入了复杂的东西</li><li>在 FAT 时代，磁盘连续访问的性能更佳，但是时间久的磁盘会产生碎片，malloc也会产生碎片，但是对性能影响不大</li></ul><p>FAT可靠性</p><ul><li>维护若干个FAT副本，方式元数据损坏，但是每次写FAT都会把每个备份都给写一份</li><li>损坏的 cluster 在FAT中标记</li></ul><p><strong>ext2/UNIX 文件系统</strong></p><div class="table-container"><table><thead><tr><th>Summary</th><th>Findings</th></tr></thead><tbody><tr><td>Most files are small</td><td>Roughly 2K is the most common size</td></tr><tr><td>Average file size is growing</td><td>Almost 200K is the average</td></tr><tr><td>Most bytes are stored in large files</td><td>A few big files use most of the space</td></tr><tr><td>File systems contains lots of files</td><td>Almost 100K on average</td></tr><tr><td>File systems are roughly half full</td><td>Even as disks grow, file systems remain ~50% full</td></tr><tr><td>Directories are typically small</td><td>Many have few entries; most have 20 or fewer</td></tr></tbody></table></div><p>按照对象方式集中存储文件/目录元数据</p><ul><li>增强局部性（更容易缓存）</li><li>支持链接</li></ul><p>为大小文件区分 fast/slow path</p><ul><li>小的时候应该使用数组，不需要遍历，直接index访问</li><li>大的时候使用树 (tree) 快速随机访问</li></ul><p><strong>ext2磁盘镜像的格式</strong></p><p>磁盘分组：</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%206.png" alt="Untitled"></p><p>superblock：文件系统元数据</p><ul><li>文件 (inode) 数量</li><li>block group 信息</li></ul><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%207.png" alt="Untitled"></p><p>inode 统一存储，目录文件中存储文件名到inode编号的key-value mapping</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%208.png" alt="Untitled"></p><p><strong>ext2性能</strong></p><p>大文件随机读写性能提升明显</p><ul><li>支持链接</li><li>inode 在磁盘上连续存储，便于缓存/预取</li><li>依然出现碎片</li></ul><p>可靠性不好，存储inode的数据块一旦损坏是很严重的，文件系统会丢掉所有文件</p><h3 id="FTL-falsh-translation-layer-闪存转换层"><a href="#FTL-falsh-translation-layer-闪存转换层" class="headerlink" title="FTL (falsh translation layer) 闪存转换层"></a>FTL (falsh translation layer) 闪存转换层</h3><p>FTL(Flash Translation Layer)译为闪存转换层，是Flash Memory(存储介质)与Device Controller(设备主控器)之间的连接关系</p><p>在整个储存体系中，FTL起着翻译官的作用，它将Host(电脑、手机等)发送至Device(eMMC、SSD)的逻辑地址转换为写入Flash的物理地址(地址映射管理)。在进行地址转换的同时，FTL还兼顾Flash的管理，不仅需要对Flash上的各个Block进行擦写次数控制(磨损均衡)，还需要管理Flash上的无用数据(垃圾回收)</p><ol><li><p>地址映射管理概念</p><p> 不同于机械硬盘的磁头直接进行数据读写，SSD或者其它以Flash作为储存介质的硬盘无法直接进行数据读写操作。解决这个问题的办法，就是FTL层管理几张逻辑映射表做一个中间转换，Host给定一个逻辑地址，FTL根据这个逻辑地址在逻辑映射表上建立映射关系，连接到Flash上的物理地址。一般来说，FTL将逻辑地址处理后，建立的映射关系包含了Flash的Block编号、Page编号等，数据读取时便根据这些信息在Flash对应的位置上找到数据，传输至Host</p></li><li><p>磨损均衡概念</p><p> 以Flash为储存介质，其可编程次数是必须考虑的重点。拿目前的固态举例，多以TLC Flash为储存介质，其编程次数在1000-1500次之间，若对TLC Flash上的某些block擦除次数超过了次数限制，那么将导致坏块产生，所以FTL须实现磨损均衡，协调整个Flash上的Block，将使用次数少的Block拿出来分担使用次数多的Block的压力。通俗的说，磨损均衡就是以相对最优的选择使Flash上每个Block的擦除次数尽可能相同，以避免有些Block擦除次数过多成为坏块致使用户可用容量变小的问题。</p></li><li><p>垃圾回收概念</p><p> 因为储存原理的不同，删除SSD等以Flash为储存介质的硬盘上的数据时，只是删除了Host端的逻辑地址，而实际数据存在Flash的物理地址上，依旧霸占着空间(所以不要以为你的数据删除了就安全了，没进行垃圾回收时，他们依旧可以找回)，后续数据写进来只能写到其他Block(Page)上，这就可能造成一个Block上的8M数据只有2M是有效数据，其他的都是被删除了逻辑地址的“假数据”，久而久之，就会导致空Block不够用了。解决这个问题呢，就靠垃圾回收(GC)了，它功能就是找一个空Block(目的Block)，然后把那些“假数据”比较多的Block(源Block)上的有效数据搬移过来，再把源Block释放擦除，这样，一个目的Block可以容纳多个源Block的数据，达到强行一换多的目的，给用户腾出了更多的空间。</p></li></ol><h3 id="UNIX文件系统"><a href="#UNIX文件系统" class="headerlink" title="UNIX文件系统"></a>UNIX文件系统</h3><p>Unix系统采用树形文件结构、内核与外核的结合、设备与文件一样的管理机制和使用方法等技术和措施，使得Unix文件系统成为当代非常优秀的系统</p><p><strong>管理结构</strong></p><p>通过磁盘索引i节点，目录项来进行管理的，在文件被打开或者被引用之后还需要“内存索引i节点”，“用户文件描述表”，”文件表“。文件系统磁盘结构如图</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%209.png" alt="Untitled"></p><ul><li>引导块：引导块占用第0号物理块，不属于文件系统管辖，如果系统中有多个文件系统，只有根文件系统才有引导程序放在引导块中，其余文件系统都不使用引导块</li><li>管理块：主要管理磁盘结构中各部分区域的大小及资源(i节点，磁盘块)的使用情况与管理方式</li><li>i节点区：用于存放该文件系统全部磁盘i节点结构，磁盘索引节点包含文件的重要信息：文件所有者标识符；文件类型；文件存取许可权；文件联结数目；文件存取时间；文件长度；文件地址索引表。</li><li>数据区：存储文件数据</li></ul><p>Unix 的每个目录只存放文件名和i节点号，一共16个字节，而文件中除名字以外的信息都存放在i节点中，优点是系统各级目录的规模大大减小。在Unix文件系统中，为了提高系统效率，减少内存空间的占用，当打开一个文件时，只是将与该文件相联系的目录项和磁盘i节点拷贝到主存中，为了对打开的文件进行管理，因此又设置了打开文件管理机构，它又由下列三部分组成：</p><ul><li>活动i节点（内存i节点）反映文件当前活动情况，因此添加了一些项目：内存索引节点状态，设备号，索引节点号，内存索引节点的访问计数</li><li>打开文件表。i节点中只包含有文件的静态信息，但当一个文件被同一进程或不同进程、用同一或不同路径名、相同的或互异操作同时打开时，仅靠i节点就不能满足要求，因此，打开文件表记录了打开文件所需的一些附加信息：读写状态、引用计数、指向内存索引点的指针、读/写位置指针</li><li>用户文件描述符表。每个用户进程有一个用户文件描述符表，每一个表项就是一个指针，并指向打开文件表的一个表项，这个表的作用就是保证每个进程能够打开多个文件，或者对同一个文件以不同形式操作打开</li></ul><p><strong>物理结构</strong></p><p>采用的是索引文件结构，在索引节点中建立有13个地址项</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Untitled%2010.png" alt="Untitled"></p><p>对于长度不超过10个物理块的小型文件，可直接找到该文件所在的盘块号；对于中、大型文件采用一次或两次间接寻址；对超大型文件采用三次间接寻址。索引节点的优点是：索引节点占用的空间小，对小文件的索引速度快，同时又允许组织大型和超大型文件。文件最多可占用的物理块数可达到10+ 256+256^2+ 256^3个，其实就是按块来分配内存，如果较大的文件，就可以在一块的末尾处添加一个指针来指向下一块内存的地址，用来寻址</p><p>Unix 的统计数据表明，80%为小文件，20%为大文件(其中1%为超大文件)，这组数据就更加说明了 Unix 文件系统设计的精妙和科学。为了提高磁盘空间的利用率，允许文件在磁盘上不连续存放，且其寻址方式最多可达到三次。它的缺点是造成访问文件的寻道时间延长和多次访问磁盘。在非实时场合是可行的，但在实时场合，它的这一缺点就很突出。</p><p><strong>空闲磁盘块</strong></p><p>unix 文件系统通过管理块来管理空闲块，数据结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filsys</span>&#123;</span></span><br><span class="line"> <span class="type">int</span> S- isize; <span class="comment">// i节点区域总块数</span></span><br><span class="line"> <span class="type">int</span> S- fsize; <span class="comment">// 文件卷总块数</span></span><br><span class="line"> <span class="type">int</span> S- nfree; <span class="comment">// 直接管理的空闲块数</span></span><br><span class="line"> <span class="type">int</span> S- <span class="built_in">free</span>[<span class="number">100</span>]; <span class="comment">// 空闲块号栈</span></span><br><span class="line"> <span class="type">int</span> S- ninode; <span class="comment">// 直接管理的空闲i节点数</span></span><br><span class="line"> <span class="type">int</span> S- inode[<span class="number">100</span>]; <span class="comment">// 空闲i节点号栈</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>空闲块的管理方法是：将空闲块从后向前，若干个空闲块(如100个)分为一组(最后一组为99块)，每组最后一块作为索引表，用来登记下一组100的物理块号和块数，最前的一组物理块号和块数存放在管理块的s_free[100]和s_nfree中。这种对空闲块先分组，再把组与组进行链接的管理方法称为组链接法。对空闲块的分配和释放类似于栈，使用后进先出算法。但其管理机构分为两级，一级常驻内存(管理块的s-nfree和s-free[])，另一级则驻在各组的第一个盘块上。其优点是常驻内存的只有一个组，而不是将所有组的空闲表都调入内存，这样就大大的节省了内存空间，同时软件开销也小。缺点是可能导致物理块的利用率不均匀。例如：假设当前的s-nfree= 80，此时某进程释放一个文件块，其占用的物理块号为300，系统回收它后，s-nfree= 81，s-free[81]= 300。接着某用户又申请物理空间，文件系统总是从索引表中取最后一项的值，即s-free[81]出栈，将300号物理块又立即分配使用。可以想象，300号块还会面临再释放，再分配的可能。300号块多次被使用，而其它空闲块却未被分配使用，即有些物理块可能长期被使用，而有些物理块可能长期得不到使用，因此对外存储器的使用寿命不利。</p><p><strong>结构和共享</strong></p><p>Unix的文件系统采取多级树型目录结构，其优点是有效的解决了文件重名问题，又可以很方便地实现文件共享。基本文件系统和子文件系统是可安装和可拆卸的，但在多用户环境下，多用户间共享数据同样感到不方便，绝对路径名是文件的唯一符号名，用户难以用另外符号名使用共享文件，因此Uinx文件又提供了如下两种链接机制</p><ul><li>硬链接技术。如果想为文件 1.c 建立一个硬链接2.c，则只需将2.c的目录项指针指到文件1.c 的 inode，同时将i节点链接数加1即可。这样用户似乎是增加了一个物理拷贝，可实际却只有一个文件实体，当删除链接时，只要删除一个目录项和将链接数减1</li><li>符号链接技术。如果想为 usr/sxk/1.c 建立一个符合链接2.c，则 Unix 通过 read link 读出文件内容，即找到原文件路径名，再通过原文件路径名去打开文件。符号链接相当于给文件增加了一个别名。也可为目录建立符号链接，并且可以跨文件系统。Unix文件链接的优点是用很小的开销为多用户共享文件提供了有效方式，且能快速定位文件和目录；缺点是对多用户使用文件不能加以并发控制，易造成数据的不一致性。硬链接只适用于普通文件，而不适用于目录文件和不同文件系统</li></ul><p><strong>安全性</strong></p><p>Unix是多用户操作系统，且它的各种外围设备都由相应的文件表示，因此安全性就很重要，它的安全主要通过磁盘i节点的权限设置来实现，每个Unix文件和Unix目录，都有3个允许的比特位设置，分别定义文件所有者、分组和其他人的使用权限，如：允许读、允许写、允许执行、允许SUID、允许SGID等，系统对文件保护的支持是比较充分的，只要正确设置文件和目录的权限，文件安全是有保障的。但需要注意的是，权限为SGID和SUID的可执行文件。SGID(SUID)中的S指set，程序在运行时，其进程的EUID(Effective UserID)或EGID(Effective Group ID)会被设成文件拥有者的UID、GID，从而进程也具有了Owner或OwnerGroup的权限。因此，如果使用不当，SGID和SUID程序会给系统安全性带来极大的危害。另外，在Unix系统中还应当留意设备文件，谨防它成为不安全的后门。例如，如果某个用户拥有/dev/lmem的读写权限，他就可以使用debugger(或其它程序)修改优先级或其它属性，也可以读取系统缓冲区的数据。Unix中的日志文件能够记录操作系统的使用状况，通过分析日志文件可以发现攻击迹象。</p><h3 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h3><p><strong>结构</strong></p><p>磁盘的特点：</p><ul><li>可以原地重写</li><li>可以直接访问任意一块</li></ul><p>需要提供高级快捷磁盘访问，以便轻松存储，定位，提取数据。</p><ul><li>访问问题：如何让定义文件系统对用户的接口</li><li>存储问题：创建数据结构和算法，把逻辑文件系统映射到物理外存设备</li></ul><p>文件系统本身通常由许多不同层组成。每层实际利用更低层功能，创建新的功能，以用于更高层的服务</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9aea954263e74cc7ac1f3373b40574f4.png" alt="9aea954263e74cc7ac1f3373b40574f4.png"></p><p>设备驱动程序可以作为翻译器，输入作为高级指令，输出由底层的硬件特定指令组成</p><p>基础文件系统只需要向适当设备驱动程序发送命令就可以</p><p>逻辑文件系统通过文件控制块维护文件结构</p><p>文件控制块（FCB）包含有关文件的信息，包括所有者，权限，文件内容的位置</p><p>大多数操作系统支持多种不同的文件系统</p><ul><li>CD-ROM ISO9660 文件格式</li><li>Unix 文件系统（Unix File System）</li><li>Windows文件系统：FAT（File Allocation Table），FAT32, FAT64,NTFS（Windows NT File System）</li><li>Linux 文件系统：可扩展文件系统（Extended file system），分布式文件系统（Distributed File System）</li></ul><p><strong>实现</strong></p><p>磁盘上，文件系统信息有</p><ol><li>如何启动，存储地址</li><li>总的块数</li><li>空闲块的数目和位置</li><li>目录结构</li><li>各个具体文件的内容</li></ol><p>结构上分为：</p><ul><li>引导控制块（每个卷）可以包含从改卷引导操作系统所需要的信息，如果磁盘中没有操作系统，那么这块内容为空。UFS被称为引导块，NFS被称为分区引导扇区</li><li>卷控制块 包括卷的详细信息（分区的块数，块的大小，空闲块的数量和指针，空闲FCB的数量和指针。UFS被称为超级块，NTFS主控文件表</li><li>每个文件的FCB包含该文件的许多详细信息，有一个唯一的标识号，以便与目录条目相关联</li><li>每个文件系统的目录结构用于组织文件</li></ul><p>内存中的信息用于管理文件系统，并且通过缓存来提高性能，这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被卸载，这些结构包括：</p><ol><li>每个进程的打开文件表：包括一个指向系统的打开文件表中合适条目的指针和其他信息</li><li>整个系统的打开文件表：包括每个打开文件的FCB副本和其他信息</li></ol><p>创建一个新文件</p><ol><li>应用程序调用逻辑文件系统。逻辑文件系统指导目录结构的格式，它会分配一个新的FCB</li><li>系统将相应的目录信息读入内存</li><li>更新目录结构和FCB</li><li>将结果写回磁盘</li></ol><p>一旦文件被创建，就能用于I/O，不过，首先他要被打开。系统调用open()将文件名传到逻辑文件系统，系统调用open()：</p><ol><li>首先搜索整个系统的打开文件表，查看是否已经被打开，如果是，则在该进程的打开文件表创建一个条目，并指向现有整个系统的打开文件表。</li><li>否则，根据文件名搜索目录结构</li><li>找到后，它的FCB会复制到内存的整个系统的开放文件表中（该表还存放着打开该文件的进程数量），接下来，在该进程的打开文件表创建一个条目，并指向现有整个系统的打开文件表。</li></ol><p><code>Open()</code>返回值：文件描述符是一个非负整数。它是一进程打开文件表的索引值，指向系统范围内打开文件表相应条目</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/d33096ab75434e56b372c00a0ba96f22.png" alt="d33096ab75434e56b372c00a0ba96f22.png"></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/e63799df3b104e5cb6145bae0fbbdfb4.png" alt="e63799df3b104e5cb6145bae0fbbdfb4.png"></p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>数据结构和程序用于隔离基本的操作系统调用的功能与实现细节。因此，文件系统的实现有三个主要层构成。</p><ol><li>文件系统接口</li><li>虚拟文件系统 VFS，把文件操作与具体实现分开，虚拟文件系统提供了在唯一标识一个文件的机制。VFS基于vnode的文件表式结构，包含了一个数值表示符（文件描述符）来唯一表示网路上的一个文件</li></ol><p>VFS能区分不同本地文件系统，能区分本地文件系统和远程文件系统</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0dda6360ba6b465baa5c5a0e59503348.png" alt="0dda6360ba6b465baa5c5a0e59503348.png"></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f581a4e2f5b44209b97c6518f0eab0b0.png" alt="f581a4e2f5b44209b97c6518f0eab0b0.png"></p><p><strong>目录实现的方法</strong></p><ol><li>线性列表</li><li>哈希表</li></ol><p><strong>磁盘分配空间方式</strong></p><ol><li><p>连续分配</p><p> 每个文件在磁盘上占有一组连续的块。 文件的连续分配可以用文件第一块的磁盘地址和连续块的数量（即长度）来定义</p><p> 基于扩展的连续分配方案</p><ol><li>开始地址</li><li>块数</li><li>指向下一个扩展块的指针</li></ol></li><li><p>链接分配</p><p> 每个文件时磁盘块的链表，磁盘块分布在磁盘的任何地方，文件有起始块和结束块的定义，每一块磁盘的末尾有指向下一块磁盘地址的指针</p><p> 文件分配表：</p><p> 每个卷的开始部分用于存储文件分配表(File Allocation Table)，表中每个磁盘块都有一个FAT条目，并可通过块号索引。（未使用的块为0，使用的块包含下一个块儿号）</p><p> 目录条目含有文件首块号码，通过这个块号索引的FAT条目包含文件下一块的号码，这个链会继续下去，直到最后一块，最后一块的表条目值为文件结束值。</p></li><li><p>索引分配</p><p> 通过将所有指针放在一起，来做索引，文件用索引块来定义，每个文件都有索引块，索引块应尽可能小，也不能太小</p><ul><li>链接方案：可以将多个文件索引块链接起来</li><li>多层次索引：用第一层索引块指向一组第二层的索引块，第二层索引块再指向文件块</li><li><p>组合方案：用于基于UNIX的文件系统，将索引块的前15个指针存储在文件的i-node中。其中，前12个指针指向直接块，剩下3个指针指向间接块</p><p>  <img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0cab19b3020a47338fafd33555c3c020.png" alt="0cab19b3020a47338fafd33555c3c020.png"></p></li></ul></li></ol><p><strong>磁盘空闲空间管理</strong></p><ol><li><p>位向量</p><p> 表现为位图，每一块用一位表示，1表示空闲，0表示已分配</p></li><li><p>链表</p><p> 所有空闲块都用链表链接起来，并将指向第一个空闲快的指针保存在特殊位置，通知缓存在内存中，每个块有下一个块的指针</p></li><li><p>组</p><p> 将n个空闲块的地址保存在第一个空闲块中，这些空闲块中的前n-1个位控，最后一块中包含另外n个空闲块的地址</p></li><li><p>计数</p><p> 通常有多个连续块需要同时分配或释放，尤其是在使用连续分配时</p><ul><li>记录第一块的地址和紧跟第一块的连续的空闲块的数量</li><li>空闲空间表的每个条目包括磁盘地址和数量</li></ul></li></ol><p><strong>文件系统的性能和效率</strong></p><p>磁盘空间的有效使用（效率），取决于</p><ul><li>磁盘分配和目录管理算法</li><li>保留在文件目录条目中的数据类型</li></ul><p>改善性能的方法：缓存</p><ul><li>缓冲区缓存：一块独立内存，位于其中的块是马上需要使用的</li><li>页面缓存：将文件数据作为页而不是块来缓存。页面缓存使用虚拟内存技术，将文件数据作为页来缓存，比采用物理磁盘块来缓存更高效</li><li>板载高速缓存</li></ul><p>系统调用read()和write()会通过缓冲区缓存，然而，内存映射调用需要使用两个缓存，即页面缓存和缓冲区缓存。内存映射先从文件系统中读入磁盘块，并放入缓冲区缓存，由于虚拟内存系统没有缓冲区缓存接口，缓冲缓存内的文件必须复制到页面缓存中</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/a07a7491428b4af6bc3310faa05c6f4f.png" alt="a07a7491428b4af6bc3310faa05c6f4f.png"></p><p>采用统一缓冲缓存：统一使用缓冲器缓存来缓存进程也和文件数据</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0666c8c485fe492abe9a901901f0096b.png" alt="0666c8c485fe492abe9a901901f0096b.png"></p><p>文件的读入或写出一般是按顺序进行。所以，不适合采用LRU算法(<a href="https://blog.csdn.net/belongtocode/article/details/102989685">全面讲解LRU算法-CSDN博客</a>)，因为最近使用的页面最后才会用甚至根本不会再用</p><p>顺序访问可以通过马上释放和预先读取来加以优化：</p><ol><li>马上释放：请求下一页时马上释放上一页</li><li>预先读取：请求页之后得到下一页也一起读取</li></ol><p><strong>文件系统得到恢复</strong></p><p>目录信息一般事先保存在内存中以加快访问，有时会导致目录结构中的数据和磁盘块中的数据不一致。</p><p>解决：</p><ul><li>一致性检查：比较目录结构中的数据和磁盘块中的数据，尝试着去修正不一致</li><li>备份&amp;恢复：<ul><li>备份（backup）：利用系统程序来备份数据到其他的存储设备。软盘，磁带</li><li>恢复（recovery）：通过从备份来恢复丢失的文件或磁盘</li></ul></li></ul><p>基于日志结构的文件系统：</p><ul><li>文件创建涉及到目录结构修改，FCB分配，数据块分配等</li><li>所有元数据（meta data）的变化写入日志上，一旦这些修改写到日志，就认为已经提交了。</li><li>提交了的事务，并不一定马上完成操作</li><li>当整个提交的事务已经完成时，就从日志中删除事务条目</li><li>如果系统崩溃，日志文件可能还存在事务，它包含的任何事务虽然已经由操作系统提交了，但还没有完成到文件系统，必须重新执行。</li></ul><h3 id="持久数据的可靠性"><a href="#持久数据的可靠性" class="headerlink" title="持久数据的可靠性"></a>持久数据的可靠性</h3><p><strong>RAID磁盘阵列</strong></p><p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。RAID实际上是实现了，使用一些不那么可靠的磁盘来合成一个又大又快又可靠的磁盘</p><p>使用多个磁盘来作为一块磁盘系统，其中可以有很多备份，在读取的时候，可以是从多个磁盘分别读取一块，然后组成想要读取的一整块。读取速度可以快好几倍，但是写入的速度是不变的。也可以对于磁盘以一定的顺序来组成虚拟磁盘，这样的读取顺序就可以多个磁盘循环读取，顺序读写都可以并行执行。</p><p>RAID是一个反向的虚拟化</p><ul><li>进程：把一个CPU虚拟化为多个虚拟的CPU</li><li>虚拟内存：把一份内存通过MMU(<a href="https://zhuanlan.zhihu.com/p/354142930">Memory Management Unit 内存管理单元</a>)虚拟为多个地址空间</li><li>文件：把一个存储设备虚拟化为多个磁盘</li></ul><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-f19764545b5aef702dcf415aeaf4f53e_720w.png" alt="v2-f19764545b5aef702dcf415aeaf4f53e_720w.png"></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-b2b9390180a9e5bf186cab19c31192d9_720w.png" alt="v2-b2b9390180a9e5bf186cab19c31192d9_720w.png"></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-d96a366ea45552d769d9fd653e8122eb_720w.jpg" alt="v2-d96a366ea45552d769d9fd653e8122eb_720w.jpg"></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-aeb458ddba57d0e3742f6dc6a15b7756_720w.webp" alt="v2-aeb458ddba57d0e3742f6dc6a15b7756_720w.webp"></p><p>RAID4 专门留一块磁盘作为奇偶校验盘</p><p>例如：</p><p>${V1 V2 V3} → {A1 B1 C1 D1}$ ，其中 ${A1 B1 C1}$ 作为一个RAID0 任意</p><p>专门留存D盘作为校验盘 $D1 = V1 \bigoplus V2 \bigoplus V3$（异或）做奇偶校验，如果V1修改， $D1’ = D1 \bigoplus V1 \bigoplus V1’$</p><p>任意一个磁盘数据损坏，都可以通过其他的磁盘信息来获得它的信息</p><p>但是随机读写变成了很困难的事情，每次读写都需要修改奇偶校验盘，最终的速率会受限于奇偶校验盘</p><p>RAID5 提供了一些升级，就是把奇偶校验位融入到存储块中，这样可以有效的加快磁盘随机读写的速度</p><p><strong>系统崩溃</strong></p><p>磁盘没有故障，操作系统内部可能出现crash，也可能断电</p><p>即便只是append一个字节都涉及到了多处磁盘的修改：FAT，目录文件和数据的修改</p><p>磁盘不提供多块读写 all or notion 的支持，甚至为了性能，没有顺序保证，bwrite可能被乱序，所以磁盘还是提供了bflush等待已经写入的数据落盘，就可以避免磁盘乱序</p><p>事实上，磁盘乱序就会导致任何一个子集的写入丢失都有可能出现，文件系统进入了不一致的状态，根本原因是存储设备无法提供多次写入的原子性</p><p><strong>日志</strong></p><p>两个视角：</p><ol><li>存储实际的数据结构<ul><li>文件系统的直观表示</li><li>crash unsafe</li></ul></li><li>Append-only 记录所有历史操作<ul><li>重做所有操作得到数据结构的当前状态</li><li>容易实现崩溃一致性</li></ul></li></ol><p>两者融合也就得到了日志</p><ul><li>数据结构操作发生时，使用append-only 记录日志</li><li>日志落盘之后，更新数据结构，等待数据落盘之后删除日志</li><li>系统崩溃之后，检查日志中未完成的操作，重新执行一次 redo log</li></ul><p>实现原子性的 append</p><ol><li>定位到 journal 的末尾</li><li>bwrite TXBegin 和所有数据结构操作</li><li>bflush 等待数据落盘</li><li>bwrite TXEnd 表示log落盘，之后就可以开始写入数据了</li><li>bflush 等待数据落盘</li><li>将数据结构操作写入实际数据结构区域</li><li>数据落盘之后，删除日志</li></ol><p>优化：</p><ul><li>批处理<ul><li>多次系统调用得到Tx合并成一个，减少log大小</li><li>定期 写回</li></ul></li><li>checksum<ul><li>不使用TxBegin/TxEnd</li><li>直接标记Tx的长度和checksum</li></ul></li><li>Metadata journaling  元数据日志<ul><li>数据占磁盘写入的绝大部分，只对 inode 和 bitmap 做优化可以提高性能</li><li>保证文件系统的目录结构是一致的，但是数据可能丢失</li></ul></li></ul><h3 id="Andriod-操作系统"><a href="#Andriod-操作系统" class="headerlink" title="Andriod 操作系统"></a>Andriod 操作系统</h3><ul><li>linux + framework + JVM<ul><li>实际上是在linux/java上做的二次开发</li><li>并不完全是，android定义了应用模型</li></ul></li><li>支持java是一个非常高瞻远瞩的决定<ul><li>armv6 指令集</li></ul></li><li>实际上是app的运行环境</li></ul><p><strong>四大组件</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/android-activity.png" alt="android-activity.png"></p><ul><li>activity<ul><li>应用程序的UI界面</li><li>存在一个activity stack</li></ul></li><li>service<ul><li>无界面的后台服务</li></ul></li><li>broadcast<ul><li>接收系统消息，做出反应</li></ul></li><li>content provider<ul><li>可以在应用间共享数据存储</li></ul></li></ul><p><strong>PlatformAPI 之下：一个微内核</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/android-stack.png" alt="android-stack.png"></p><p>android内核的实现是在linux的基础上搭建出来的——一个微内核</p><ul><li>Remote Procedure Call (RPC)</li><li>注册机制<ul><li>每个应用程序可以注册函数，然后整个操作系统可以调用该函数</li></ul></li><li>基于内存共享实现<ul><li>通过代码把参数序列化，保存到一个共享内存页面中，然后在其他应用程序调用的时候，在两个应用之间做一个映射</li><li>就像是在一个程序里调用函数，然后再另一个进程中执行，最后返回到原来的程序中</li></ul></li><li>服务端线程池</li></ul><p>手机上有多个service用于服务，但是会出现优先级反转，导致低优先级的程序占据着线程不释放，高优先级的任务也必须等待该任务结束，特别是安装软件的时候，向操作系统注册的时候会特别卡顿</p><p>杀死一个Android进程</p><ul><li>Android 每一个 app 都有一个独立的uid（进程号）</li><li>遍历进程表，杀死找到的对应的uid的进程，每5ms连续杀死40次，防止数据竞争</li></ul><p>利用数据竞争保活</p><ul><li>杀死孤儿进程从而不会立即收到 SIGKILL 信号</li><li>在被杀死之后立即唤醒另一个进程</li><li>进程托孤机制——强行终止都杀不掉<ul><li>某一个进程fork一份进程，然后新的进程作为一个父进程创建一些子进程，然后释放掉父进程，就形成一些孤儿进程，孤儿进程之间会有死锁，一旦其中有一个进程被杀死了，另一个就会启动，重新fork一份上述的进程</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu指令</title>
      <link href="/Blog_ButterFly/2024/03/19/ubuntu%E6%8C%87%E4%BB%A4/"/>
      <url>/Blog_ButterFly/2024/03/19/ubuntu%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu关于安装的指令"><a href="#ubuntu关于安装的指令" class="headerlink" title="ubuntu关于安装的指令"></a>ubuntu关于安装的指令</h2><p><code>bus restart</code>重置输入法</p><p><code>sudo apt search package</code> 搜索包</p><p><code>sudo apt show package</code> 获取包的相关信息，如说明、大小、版本等  </p><p><code>sudo apt depends package</code> 了解使用依赖  </p><p><code>sudo apt rdepends package</code> 查看该包被哪些包依赖  </p><p><code>sudo apt-cache pkgnames</code> 执行pkgnames子命令列出当前所有可用的软件包 </p><p><code>sudo apt policy package</code> 使用policy命令显示软件包的安装状态和版本信息。</p><p><code>sudo apt install package</code> 安装包  </p><p><code>sudo apt install package=version</code> 安装指定版本的包  </p><p><code>sudo apt install package --reinstall</code> 重新安装包  </p><p><code>sudo apt -f install</code> 修复安装 <code>-f = --fix-missing</code>  </p><p><code>sudo apt remove package</code> 删除包</p><p><code>sudo apt purge package</code> 删除包，包括删除配置文件等</p><p><code>sudo apt autoremove</code> 自动卸载所有未使用的软件包</p><p><code>sudo apt source package</code> 下载该包的源代码   </p><p><code>sudo apt update</code> 更新apt软件源信息  </p><p><code>sudo apt upgrade</code> 更新已安装的包</p><p><code>sudo apt full-upgrade</code> 在升级软件包时自动处理依赖关系  </p><p><code>sudo apt dist-upgrade</code> 升级系统  </p><p><code>sudo apt dselect-upgrade</code> 使用dselect升级  </p><p><code>sudo apt build-dep package</code> 安装相关的编译环境  </p><p><code>sudo apt clean &amp;&amp; sudo apt autoclean</code> 清理无用的包</p><p><code>sudo apt clean</code> 清理已下载的软件包，实际上是清除 <code>/var/cache/apt/archives</code> 目录中的软件包</p><p><code>sudo apt autoclean</code> 删除已经卸载的软件包备份  </p><p><code>sudo apt-get check</code> 检查是否有损坏的依赖</p><p><code>sudo cp src dst</code> 复制文件到目标路径</p><p><code>sudo rm -r filename</code> 删除文件 </p><p><code>sudo mv src dst</code> 移动文件</p><p><code>bash filename/filename.sh</code> 运行filename shell脚本文件</p><p><code>lsb_realse -a</code> 查看ubuntu版本</p><p><code>ls -l</code> 查看文件信息</p><p><code>ls -lh</code> 查看文件大小</p><p><code>du -sh</code> 查看文件夹大小</p><p><code>unzip filename.zip</code> 解压文件</p><p><code>lsb_release -c</code> 查看自己的版本，如果与镜像源的版本不一致不能够下载</p><h2 id="镜像版本"><a href="#镜像版本" class="headerlink" title="镜像版本"></a>镜像版本</h2><h3 id="focal"><a href="#focal" class="headerlink" title="focal"></a>focal</h3><p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal main restricted universe multiverse</p><p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-security main restricted universe multiverse</p><p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-updates main restricted universe multiverse</p><p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-proposed main restricted universe multiverse</p><p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-backports main restricted universe multiverse</p><p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal main restricted universe multiverse</p><p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-security main restricted universe multiverse</p><p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-updates main restricted universe multiverse</p><p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-proposed main restricted universe multiverse</p><p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> focal-backports main restricted universe multiverse</p><h3 id="bionic"><a href="#bionic" class="headerlink" title="bionic"></a>bionic</h3><h3 id="eoan"><a href="#eoan" class="headerlink" title="eoan"></a>eoan</h3><h2 id="ubuntu-终端的-ctrl-指令"><a href="#ubuntu-终端的-ctrl-指令" class="headerlink" title="ubuntu 终端的 ctrl 指令"></a>ubuntu 终端的 ctrl 指令</h2><ul><li>Ctrl + B 向前移动</li><li>Ctrl + F 向后移动</li><li>Ctrl + -&gt; 向左跳跃单词</li><li>Ctrl + -&gt; 向右跳跃单词</li><li>Ctrl + U 删除光标左边的全部内容</li><li>Ctrl + K 删除光标右边的全部内容</li><li>Ctrl + H 删除光标前的一个字符</li><li>Ctrl + T 将光标右边的一个字符向后移动，一直按一直后移</li><li>Ctrl + L 将最新的命令移动到终端最上面</li><li>Ctrl + P 使用之前的命令</li><li>Ctrl + A 直接跳到命令的开头</li><li>Ctrl + E 直接跳到命令的结尾</li></ul><h2 id="ubuntu-终端可以做的一些配置"><a href="#ubuntu-终端可以做的一些配置" class="headerlink" title="ubuntu 终端可以做的一些配置"></a>ubuntu 终端可以做的一些配置</h2><ul><li>fish/zsh</li><li>vim</li><li>gcc</li><li>cmake</li><li>ctags</li><li>tmux</li></ul><h2 id="linux终端指令"><a href="#linux终端指令" class="headerlink" title="linux终端指令"></a>linux终端指令</h2><ol><li><code>crtl-l</code> 清屏</li><li><code>crtl-q</code> 清除正在写的一行</li><li><code>crtl-w</code> 删除正在写的一行的一个单词<br>通过命令行得到统计结果<br><code>./a.out | head -n 1000 | sort | uniq -c</code><br>使用 <code>gcc -static minhello.c</code> (静态编译)<br>使用 <code>objdump -d a.o</code>(出现的是预编译代码) 查看会发现 a.o 的代码量很大<br>使用 <code>ls -l a.out</code> 来查看 a.out 的大小，显示的数字就是代码的内存大小B<br>可以使用 <code>size a.out</code> 来查看代码的大小<br><code>rr record ./a.out</code> 记录a.out 的指令<br><code>timeout 3 ./a.out</code> 表示执行3秒该程序<br><code>env</code> 查看应用程序执行的环境变量 <code>env | grep path</code><ul><li>PATH 可执行文件的搜索路径</li><li>PWD 当前路径</li><li>HOME home目录</li><li>DISPLAY 图形输出</li><li>PS1 shell指示符<br>export 设置环境变量<br>使用gcc静态编译的时候会舍去动态链接相关的系统调用</li></ul></li><li><code>head</code> 指令<br>显示输出或者是显示读取的文件，可以通过通道来输出，也可以直接指令后面跟文件名，输出文件内容<ul><li><code>head -n num</code><br>显示num行</li><li><code>head -c num</code><br>显示num个字节</li></ul></li><li><code>uniq</code> 指令，只能用于判断相邻的两行是否相同来计算<ul><li><code>uniq -c</code> 计算重复次数</li><li><code>uniq -d</code> 仅显示重复的行</li><li><code>uniq -u</code> 仅显示不重复的行</li><li><code>uniq -s</code> 选项用于忽略比较的字符， 它将忽略指定数量的字符并将结果显示到标准输出</li></ul></li><li><code>cat</code> 指令，用于查看文件内容</li><li><code>free</code>查看系统的内存<ul><li>-b 以byte为单位显示内存使用情况</li><li><ul><li>k 以kb为单位显示内存使用情况</li></ul></li><li>-m 以mb为单位显示内存使用情况</li><li>-h 以合适的单位显示内存使用情况</li></ul></li><li>通道和多条命令 | </li><li>重定向 &gt; &lt;</li></ol><pre><code>| command &gt; file  | 将输出重定向到file                               || --------------- | ------------------------------------------------ || command &lt; file  | 将输入重定向到file                               || command &gt;&gt; file | 将输出以追加的方式重定向到file                   || n &gt; file        | 将文件描述为n的文件方重定向到file                || n &gt;&gt; file       | 将文件描述为n的文件以追加的方重定向到file        || n &gt;&amp; m          | 将输出文件m和n合并                               || n &lt;&amp; m          | 将输入文件m和n合并                               || &lt;&lt; tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入 || n &gt; m           | 重定向正确输出                                   || n 2&gt; m          | 重定向错误输出                                   || n &amp;&gt; m          | 重定向所有输出                                   |`echo hello &gt; /dev/pts/1` 可以把输出重定向到另一个终端</code></pre><ol><li>后台 &amp;</li><li><p><code>less/more</code>  用于查看内容 </p><ul><li>Up arrow – 向上移动一行</li><li>Down arrow – 向下移动一行</li><li>Space 或者 PgDn – 向下移动一页</li><li>b 或者 PgUp – Move one page up</li><li>g – 移到文件的开头</li><li>G – 移动到文件的末尾</li><li>ng – 移到第n行</li><li>-N - 显示行号</li></ul><p>文本中指令：</p><ol><li>/+content 查找对应的内容</li></ol></li><li><code>wc</code> 指令，用于查看文件<ul><li>l , —lines : 显示行数；</li><li>w , —words : 显示字数；</li><li>m , —chars : 显示字符数；</li><li>c , —bytes : 显示字节数；</li><li>L , —max-line-length : 显示最长行的长度；</li></ul></li><li><code>$(), &lt;()</code>预处理</li><li><p><code>tail</code> 指令</p><p>可以查看文件的内容默认显示文件的最后10行，格式： <code>tail [param] [filename]</code></p><ul><li>-f 循环读取</li><li>-q 不显示处理信息</li><li>-v 显示详细的处理信息</li><li>-c<num> 显示的字节数</num></li><li>-n<num> 显示文件的尾部n行内容</num></li><li>—pid=PID 与-f 一起使用，表示在进程ID为PID的进程死掉之后结束</li><li>-q, —quiet, —silent 从不输出给出文件名的首部</li><li>-s, —sleep-interval=S 与-f一起使用，表示在每次反复的间隔休眠S秒</li></ul></li><li><p><code>strace</code> 指令</p><p>在linux系统中，strace命令是一个集诊断，调试，统计于一体的工具，可以与其他命令搭配使用 查看手册 <code>man strace</code></p><p><strong>安装</strong></p><p>CentOS/EulerOS<code>yum install strace</code></p><p>Ubuntu <code>apt-get install strace -y</code></p><p><strong>指令格式</strong></p><p><code>strace [param] [api]</code></p><p><strong>参数</strong></p><ul><li>-c 统计每一个系统调用的所执行时间，次数和出错的次数等</li><li>-d 显示有关标准错误的strace本身的一些调试输出</li><li>-f 跟踪子进程，这些进程是由 <code>fork</code> 创建的</li><li>-i 在系统调用时打印指令指针</li><li>-t 跟踪的每一行都以时间为前缀</li><li>-tt 打印的时间包括微秒</li><li>-ttt 打印时间包括微秒，并且前导部分将打印为自该**以来的秒数</li><li>-T 显示花费在系统调用上的时间，记录每一个系统调用的开始和结束之间的时间差</li><li>-v 打印环境，统计信息，termios等调用的未缩写的版本，可获取所有详细信息</li><li>-V 打印strace的版本号</li><li>-e expr 限定表达式，用于修改跟踪的时间或者如何跟踪它们</li><li>-e trace=set 只跟踪指定的系统调用集，-c选项可以确定跟踪那些系统调用<ul><li>-e trace=file 跟踪所有以文件名作为参数的系统调用。</li><li>-e trace=process 跟踪涉及过程管理的所有系统调用。</li><li>-e trace=network 跟踪所有与网络相关的系统调用。</li><li>-e trace=signal 跟踪所有与信号相关的系统调用。</li><li>-e trace=ipc 跟踪所有与IPC相关的系统调用。</li></ul></li><li>-o 文件名 将跟踪输出写入文件名除了stderr标准错误</li><li>-p pid 使用进程id为pid 并且以pid的进程号开始跟踪，可以随时中断</li><li>-S 按指定条件对-c选项打印的直方图输出进行排序。</li></ul></li><li><p><code>linux的进程管理指令</code></p><ul><li><p>nohup</p><p>  不挂断地运行命令</p><p>  语法： <code>nohup command [args] [&amp;]</code></p><p>  默认情况下，当前目录会有一个 <code>nohup.out</code>文件，如果当前的目录不可写，那就定向输出到 <code>$HOME/nohup.out</code> 文件中，如果没有文件能创建或者打开以用于追加输出，那么 <code>command</code>指令不可调用</p><p>  <strong>参数</strong></p><p>  command：需要执行的指令</p><p>  args： 参数，可以指定输出文件</p><p>  &amp;：让命令可以后台运行，并且终端退出之后依旧可以运行</p><p>  2&gt;&amp;1 将标准错误定向输出到标准输出&amp;1</p></li><li><p>&amp;</p><p>  用在一个指令最后，可以把命令放到后台执行</p></li><li><p>jobs</p><p>  用于查看正在执行的后台进程，但是只能看到当前终端启动的进程，如果关闭当前终端之后，另一个终端下jobs无法看到该进程</p><ul><li>-l 显示进程号</li><li>-p 仅任务对应的显示进程号</li><li>-n 显示任务状态的变化</li><li>-r 仅输出运行状态running的任务</li><li>-s 仅输出停止状态stoped的任务</li></ul></li><li><p>ps</p><p>  用于查看当前系统运行的进程信息，操作字可以叠加使用</p><ul><li>a 显示所有程序</li><li>x 显示所有程序，不区分终端机</li><li>u 以用户为主的格式来显示</li><li>-f 显示程序间的关系</li><li>-e 显示所有程序</li><li>aux 观察系统所有进程数据</li><li>-ef 显示所有进程的基本信息</li></ul></li><li><p>kill</p><ul><li><code>kill -9 pid</code> 杀掉进程，不做善后工作</li><li><p><code>kill -15 pid</code> 调用destory等方法善后</p><p>优先使用-15</p></li></ul></li><li><p>ctrl+c 停止当前正在执行的进程，相当于直接kill掉</p></li><li>ctrl+z 将当前正在执行的进程放到后台，并且暂停执行，此时进程处于stop状态</li><li>fg 将后台中的进程调至前台继续运行。如果后台中有多个命令，可以用fg %jobnumbe将选中的命令调出，%jobnumber是通过jobs命令查到的后台任务的编号，不是进程的pid号</li><li>bg 将一个在后台暂停的命令，变成继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出。</li></ul></li><li><code>pmap linux的进程内存分析</code> 显示的是进程<ul><li>-x extended 显示扩展格式<ul><li>Address:  start address ofmap  映像起始地址</li><li>Kbytes: size of map in kilobytes  映像大小</li><li>RSS:  resident set size inkilobytes  驻留集大小</li><li>Dirty:  dirty pages (both sharedand private) in kilobytes  脏页大小</li><li>Mode:  permissions on map 映像权限</li><li>Mapping: 映像支持文件,[anon]为已分配内存[stack]为程序堆栈</li><li>Offset: offset into the file  文件偏移</li><li>Device:  device name(major:minor)  设备名</li></ul></li><li>-q quiet 显示设备格式</li><li>-d device 不显示首尾行</li><li>-V 版本号</li></ul></li><li><code>pidof</code> 查找某个进程的进程号</li><li><p><code>env</code> 打印出所有的环境变量，手册查看 <code>man 7 environ</code></p><p>其中定义了一个符号 <code>extern char **environ;</code></p></li><li><p>使用 <code>top</code> 指令查看cpu占有率</p></li><li><p><code>chmod</code> 指令，修改文件权限</p><p>格式 <code>chmod [command] filename</code></p><p>command 格式 <code>[ugoa...][+-=][rwxX....][...]</code></p><ul><li>u 表示文件拥有者，g 表示与文件拥有者属于同一群体的，o 表示其他以外的人，a 表示三者都可以</li><li><ul><li>表示增加权限，- 表示取消权限，= 表示设定权限</li></ul></li><li>r 可读，w 可写，x 可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li><li>-c 如果该文件权限确实已经更改，才显示其更改动作</li><li>-f 若该文件权限无法更改也不显示错误</li><li>-v 显示权限变更的详细资料</li><li>-R 对当前目录下的所有文件与子目录进行相同的权限变更（以递归的方式逐个变更）</li><li>—help 辅助说明</li><li>—version 显示版本</li></ul></li><li><p><code>Binutils</code>工具集<strong>(</strong><a href="https://www.gnu.org/software/binutils/">Binutils</a><strong>)</strong></p><ol><li><code>ld</code> GNU 链接器</li><li><code>as</code> GNU 汇编器 汇编代码→可执行文件</li><li><code>gold</code> 一种新的、更快的、仅限ELF的连接器。</li></ol><ul><li><code>objdump</code> 查看目标文件或者可执行的目标文件的构成的gcc工具，反汇编命令<ul><li>-a 显示文件头信息</li><li>-b 指定目标对象格式为BFDNAME</li><li>-C 将C++符号名逆向解析</li><li>-d 将代码段反汇编，显示可执行的部分的汇编内容</li><li>-D 将所有的部分反汇编</li><li>-S 将代码段反汇编的同时，将反汇编代码与源代码交替显示，但是需要 -g 编译参数，即需要调试信息</li><li>-s 显示所有请求部分的完整内容</li><li>-g 显示目标文件中的调试信息</li><li>-e 使用C标签样式显示调试信息</li><li>-G 显示(以原始形式)文件中的任何stab信息</li><li>-l 反汇编代码中插入文件名和行号，在输出中包括行号和文件名</li><li>-j section 仅反汇编指定的部分</li><li>-r 重定位条目显示</li><li>-R 动态重定位的条目显示</li><li>-h 显示指定部分的文件头，ELF头</li><li>-x 显示所有的文件头</li><li>-t 显示符号表的内容</li><li>-T 显示动态链接的符号表的内容</li><li>-i 列出文件支持的对象格式和体系结构</li><li>-f 显示整个文件头的内容</li><li>-F 在显示信息时包括文件偏移量</li><li>-I 添加DIR到源文件的搜索列表</li><li>-p 显示对象格式特定的文件头内容</li><li>-P 显示对象格式特定的内容</li></ul></li><li><code>objcopy</code> 可用于创建一个有特殊排列和格式的目标文件或者可执行文件。  <code>objcopy</code> 也可以将目标文件和可执行文件中的某些部分拷贝到新的文件中，或创建一个空的目标文件或可执行文件，复制二进制文件，并且可以在过程中变换<ul><li>-I 输入文件的格式为<bfdname></bfdname></li><li>-O 创建格式为<bfdname>的输出文件</bfdname></li><li>-B 当输出无arch时，输出arch</li><li>-F 设置输入输出文件格式都是 <bfdname></bfdname></li><li>-P 将修改的/访问的时间戳复制到输出</li><li>-D 在剥离档案时产生确定性输出</li><li>-j 仅复制 <name> 部分到输出</name></li><li>-R 从输出中移除 <name> 部分</name></li><li>-S 从输出中移除所有的标志和重定位信息</li><li>-g 移除所有的调试信息和选定部分</li><li>-N 不复制 <name> 标志</name></li><li>-K 不要剥离符号<name>以上翻译结果来自有道神经网络翻译（YNMT）· 通用场景</name></li><li>-L 强制符号<name>标记为本地</name></li><li>-G 本地化除<name>以外的所有符号</name></li><li>-W 强制符号<name>标记为弱值</name></li><li>-w 允许在符号比较中使用通配符</li><li>-x 删除所有非全局符号</li><li>-X 删除任何编译器生成的符号</li><li>-i 只从每个<number>字节中复制N</number></li><li>-b 在每个交错块中选择字节<num></num></li></ul></li><li><code>nm</code> 文本分析工具 来源于name的简写，用于列出指定文件中的符号（如常用的函数名，变量等，以及这些符号存储的区域）。显示指定文件中的符号信息，文件可以是对象文件，可执行文件或对象文件库。如果文件中没有包含符号信息，nm报告该情况，不把它解释为错误。<ul><li>-A/-o/—print-file-name：输出时加上文件名</li><li>-a/—debug-syms：输出所有符号，包含 <code>debugger-only symbols</code></li><li>-B/—format=bsd：bsd码显示，兼容 MIPS nm</li><li>-C/—demangle：将低级符号名解析为用户级名字，可以使得C++函数名更具备可读性</li><li>-D/—dynamic：显示动态符号，该选项只对动态目标（例如特定的共享库）有意义</li><li>-f format/—format=format：默认使用format格式输出。format可以选取 bsd，sysv 或 posix，默认为bsd</li><li>-g/—extern-only：只显示外部符号</li><li>l/–line-numbers: 对于每个符号，使用debug信息找到文件名和行号</li><li>-n/-v/–numeric-sort: 按符号对应地址的顺序排序，而非按符号名字字符顺序排序</li><li>-P/–portability: 按照POSIX2.0标准格式输出，等同于使用 -f posix</li><li>-p/–no-sort: 按照目标文件中遇到的符号顺序显示，不排序</li><li>-r/–reverse-sort: 反转排序</li><li>-s/–print-armap： 当列出库成员符号时，包含索引。索引的内容：模块和其包含名字的映射</li><li>-u/–undefined-only： 只显示未定义符号</li><li>–defined-only: 只显示定义了的符号</li></ul></li><li><code>addr2line</code> 将地址转换为文件名和行号</li><li><code>ar</code> 一个用于创建、修改和提取档案的实用程序</li><li><code>c++filt</code> 过滤器，过滤出要求编码的c++符号</li><li><code>dlltool</code> 创建用于构建和使用dll的文件</li><li><code>elfedit</code> 允许更改ELF格式文件</li><li><p><code>gprof</code> （<a href="https://blog.csdn.net/kentyu001/article/details/53886493">gprof使用和介绍</a>）可以显示程序运行的“flat profile”，包括每个函数的调用次数，每个函数消耗的处理器时间。也可以显示“调用图”，包括函数的调用关系，每个函数调用花费了多少时间。还可以显示“注释的源代码”，是程序源代码的一个复本，标记有程序中每行代码的执行次数。需要使用 -pg 的编译和链接选项</p><p>  编译完成之后需要先运行一下，程序会把运行的信息存储到 gmon.out 文件中，然后gprof 对该文件进行解析</p></li><li><p><code>gprofng</code></p></li><li><code>nlmconv</code></li><li><code>ranlib</code></li><li><code>readelf</code><ul><li>-S 对某个重定位目标文件的节头表进行解析</li></ul></li><li><code>size</code></li><li><code>strings</code></li><li><code>strip</code></li><li><code>windmc</code></li><li><code>windres</code></li></ul></li><li><code>pstree</code> 打开一个文件扫描目录<ul><li>-p 打印每一个进程的进程号</li><li>-n 按照pid从小到大输出一个进程的孩子</li></ul></li><li><code>grep+name</code> 过滤缓冲区，获得想要看到的内容所在的行的内容 </li><li><code>make clean</code> 删除编译生成的文件</li><li><code>strip</code> 丢弃目标文件中的符号</li><li><code>time</code> 指令，显示程序运行的时间</li><li><code>taskset -c 0,...</code> 表示把进程分配到几个cpu上</li><li><code>stat</code> 指令，显示文件或者文件系统的状态参数等</li><li><code>ulimit</code><ul><li>-a 查看当前所有限制</li><li>-c 设置最大core文件的大小，默认是0</li><li>-d 进程数据的最大段</li><li>-f 被 shell 创建的最大文件的大小限制</li><li>-l 被锁进内存的最大限制</li><li>-m 最大常驻尺寸集</li><li>-n 打开文件表述符最大数量限制</li><li>-s 最大栈尺寸</li><li>-t 一秒钟中最大 CPU 时间</li><li>-u 对单个用户最大数量的可执行的进程</li><li>-v  shell 可使用的最大虚拟内存的大小</li></ul></li><li>lsmod</li><li>insmod</li><li>mknod</li><li>lsblk 查看所有设备的挂载点</li><li>bash xx.sh 可以运行在bash中运行的脚本，xx.sh 内容就相当于是输入命令行的指令</li><li>mkfs.fat 格式化文件</li><li>hd hexdump 实用程序是一个过滤器，它以用户指定的格式显示指定的文件或标准输入(如果没有指定文件)</li><li>根目录 /proc 下有一些系统定义的结构体，可以查看内核数据结构的内容</li><li>ubuntu 安装驱动 <code>sudo ubuntu-drivers autoinstall</code></li><li><code>df -h</code> 查看磁盘使用情况</li><li><code>sort -nk num</code> 排序<ol><li><code>n</code> 就是对应的数据当作数字来排序</li><li><code>k</code> 表示按照列来排序</li><li><code>num</code> 就是指的第 <code>num</code> 列</li></ol></li><li><code>while true; do ./a.out; done</code> 指令就是不断执行 <code>./a.out</code> 程序</li></ol>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zsh使用</title>
      <link href="/Blog_ButterFly/2024/03/19/zsh%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/zsh%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 linux 终端命令行只需要一行指令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><h2 id="设置为默认终端"><a href="#设置为默认终端" class="headerlink" title="设置为默认终端"></a>设置为默认终端</h2><p>在linux终端输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s $(which fish)</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>是一个很不错的美化，曾经刚接触 linux 时就是用的这个（后来改用fish了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"># ~/.zshrc</span><br><span class="line"># Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.</span><br><span class="line"># Initialization code that may require console <span class="title function_">input</span> <span class="params">(password prompts, [y/n]</span></span><br><span class="line"><span class="params"># confirmations, etc.)</span> must go above this block; everything <span class="keyword">else</span> may go below.</span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="string">&quot;$&#123;XDG_CACHE_HOME:-$HOME/.cache&#125;/p10k-instant-prompt-$&#123;(%):-%n&#125;.zsh&quot;</span> ]]; then</span><br><span class="line">  source <span class="string">&quot;$&#123;XDG_CACHE_HOME:-$HOME/.cache&#125;/p10k-instant-prompt-$&#123;(%):-%n&#125;.zsh&quot;</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># If you come from bash you might have to change your $PATH.</span><br><span class="line"><span class="meta"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span></span><br><span class="line"></span><br><span class="line"># Path to your oh-my-zsh installation.</span><br><span class="line">export ZSH=<span class="string">&quot;$HOME/.oh-my-zsh&quot;</span></span><br><span class="line"></span><br><span class="line"># Set name of the theme to load --- <span class="keyword">if</span> <span class="built_in">set</span> to <span class="string">&quot;random&quot;</span>, it will</span><br><span class="line"><span class="meta"># load a random theme each time oh-my-zsh is loaded, in which case,</span></span><br><span class="line"><span class="meta"># to know which specific one was loaded, run: echo $RANDOM_THEME</span></span><br><span class="line"># See https:<span class="comment">//github.com/ohmyzsh/ohmyzsh/wiki/Themes</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;robbyrussell&quot;</span></span><br><span class="line"># ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br><span class="line"># ZSH_THEME=<span class="string">&quot;terminalparty&quot;</span></span><br><span class="line"></span><br><span class="line"># Set <span class="built_in">list</span> of themes to pick from when loading at random</span><br><span class="line"># Setting this variable when ZSH_THEME=random will cause zsh to load</span><br><span class="line"><span class="meta"># a theme from this variable instead of looking in $ZSH/themes/</span></span><br><span class="line"># If <span class="built_in">set</span> to an empty <span class="built_in">array</span>, this variable will have no effect.</span><br><span class="line"># ZSH_THEME_RANDOM_CANDIDATES=( <span class="string">&quot;robbyrussell&quot;</span> <span class="string">&quot;agnoster&quot;</span> )</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to use <span class="keyword">case</span>-sensitive completion.</span><br><span class="line"># CASE_SENSITIVE=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"># Uncomment the following line to use hyphen-insensitive completion.</span><br><span class="line"># Case-sensitive completion must be off. _ and - will be interchangeable.</span><br><span class="line"># HYPHEN_INSENSITIVE=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"># Uncomment one of the following lines to change the <span class="keyword">auto</span>-update behavior</span><br><span class="line"><span class="meta"># zstyle <span class="string">&#x27;:omz:update&#x27;</span> mode disabled  # disable automatic updates</span></span><br><span class="line"><span class="meta"># zstyle <span class="string">&#x27;:omz:update&#x27;</span> mode auto      # update automatically without asking</span></span><br><span class="line"><span class="meta"># zstyle <span class="string">&#x27;:omz:update&#x27;</span> mode reminder  # just remind me to update when it<span class="string">&#x27;s time</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line to change how often to auto-update (in days).</span></span></span><br><span class="line"><span class="string"><span class="meta"># zstyle &#x27;</span>:omz:update<span class="string">&#x27; frequency 13</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line if pasting URLs and other text is messed up.</span></span></span><br><span class="line"><span class="string"><span class="meta"># DISABLE_MAGIC_FUNCTIONS=&quot;true&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line to disable colors in ls.</span></span></span><br><span class="line"><span class="string"><span class="meta"># DISABLE_LS_COLORS=&quot;true&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line to disable auto-setting terminal title.</span></span></span><br><span class="line"><span class="string"><span class="meta"># DISABLE_AUTO_TITLE=&quot;true&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line to enable command auto-correction.</span></span></span><br><span class="line"><span class="string"><span class="meta"># ENABLE_CORRECTION=&quot;true&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line to display red dots whilst waiting for completion.</span></span></span><br><span class="line"><span class="string"><span class="meta"># You can also set it to another string to have that shown instead of the default red dots.</span></span></span><br><span class="line"><span class="string"><span class="meta"># e.g. COMPLETION_WAITING_DOTS=&quot;%F&#123;yellow&#125;waiting...%f&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"># Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)</span></span></span><br><span class="line"><span class="string"><span class="meta"># COMPLETION_WAITING_DOTS=&quot;true&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line if you want to disable marking untracked files</span></span></span><br><span class="line"><span class="string"><span class="meta"># under VCS as dirty. This makes repository status check for large repositories</span></span></span><br><span class="line"><span class="string"><span class="meta"># much, much faster.</span></span></span><br><span class="line"><span class="string"><span class="meta"># DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Uncomment the following line if you want to change the command execution time</span></span></span><br><span class="line"><span class="string"><span class="meta"># stamp shown in the history command output.</span></span></span><br><span class="line"><span class="string"><span class="meta"># You can set one of the optional three formats:</span></span></span><br><span class="line"><span class="string"><span class="meta"># &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"># or set a custom format using the strftime function format specifications,</span></span></span><br><span class="line"><span class="string"><span class="meta"># see &#x27;</span>man strftime<span class="string">&#x27; for details.</span></span></span><br><span class="line"><span class="string"><span class="meta"># HIST_STAMPS=&quot;mm/dd/yyyy&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Would you like to use another custom folder than $ZSH/custom?</span></span></span><br><span class="line"><span class="string"><span class="meta"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Which plugins would you like to load?</span></span></span><br><span class="line"><span class="string"><span class="meta"># Standard plugins can be found in $ZSH/plugins/</span></span></span><br><span class="line"><span class="string"><span class="meta"># Custom plugins may be added to $ZSH_CUSTOM/plugins/</span></span></span><br><span class="line"><span class="string"><span class="meta"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span></span><br><span class="line"><span class="string"><span class="meta"># Add wisely, as too many plugins slow down shell startup.</span></span></span><br><span class="line"><span class="string"><span class="meta">plugins=(git</span></span></span><br><span class="line"><span class="string"><span class="meta">    zsh-syntax-highlighting</span></span></span><br><span class="line"><span class="string"><span class="meta">    zsh-autosuggestions)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">source $ZSH/oh-my-zsh.sh</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># User configuration</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># export MANPATH=&quot;/usr/local/man:$MANPATH&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># You may need to manually set your language environment</span></span></span><br><span class="line"><span class="string"><span class="meta"># export LANG=en_US.UTF-8</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"># Preferred editor for local and remote sessions</span></span></span><br><span class="line"><span class="string"><span class="meta"># if [[ -n $SSH_CONNECTION ]]; then</span></span></span><br><span class="line"><span class="string"><span class="meta">#   export EDITOR=&#x27;</span>vim&#x27;</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   export EDITOR=<span class="string">&#x27;mvim&#x27;</span></span></span><br><span class="line"><span class="meta"># fi</span></span><br><span class="line"></span><br><span class="line"># Compilation flags</span><br><span class="line"><span class="meta"># export ARCHFLAGS=<span class="string">&quot;-arch x86_64&quot;</span></span></span><br><span class="line"></span><br><span class="line"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span><br><span class="line"><span class="meta"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="meta"># users are encouraged to <span class="keyword">define</span> aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"># For a full <span class="built_in">list</span> of active aliases, run `alias`.</span><br><span class="line">#</span><br><span class="line"># Example aliases</span><br><span class="line"><span class="meta"># alias zshconfig=<span class="string">&quot;mate ~/.zshrc&quot;</span></span></span><br><span class="line"><span class="meta"># alias ohmyzsh=<span class="string">&quot;mate ~/.oh-my-zsh&quot;</span></span></span><br><span class="line">source /opt/ros/noetic/setup.zsh</span><br><span class="line"></span><br><span class="line"># To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.</span><br><span class="line">[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh</span><br><span class="line">export PS1=<span class="string">&quot;$ &quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim使用</title>
      <link href="/Blog_ButterFly/2024/03/19/vim%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/vim%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个历史上最出色的编辑器，拥有自定义按键功能，并且可以大大提高工作效率</p><h2 id="在linux中的安装"><a href="#在linux中的安装" class="headerlink" title="在linux中的安装"></a>在linux中的安装</h2><p>在linux中只需要一行指令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><h2 id="linux-上的配置文件"><a href="#linux-上的配置文件" class="headerlink" title="linux 上的配置文件"></a>linux 上的配置文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; etc/vim/vimrc</span></span><br><span class="line"><span class="string">&quot;</span> the call to :runtime you can find below.  If you wish to change any of those</span><br><span class="line"><span class="string">&quot; settings, you should do it in this file (/etc/vim/vimrc), since debian.vim</span></span><br><span class="line"><span class="string">&quot;</span> will be overwritten everytime an upgrade of the vim packages is performed.</span><br><span class="line"><span class="string">&quot; It is recommended to make changes after sourcing debian.vim since it alters</span></span><br><span class="line"><span class="string">&quot;</span> the value of the <span class="string">&#x27;compatible&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">runtime! debian.vim</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.</span></span><br><span class="line"><span class="string">&quot;</span> This happens after /etc/vim/vimrc(.local) are loaded, so it will override</span><br><span class="line"><span class="string">&quot; any settings in these files.</span></span><br><span class="line"><span class="string">&quot;</span> If you don<span class="number">&#x27;</span>t want that to happen, uncomment the below line to prevent</span><br><span class="line"><span class="string">&quot; defaults.vim from being loaded.</span></span><br><span class="line"><span class="string">&quot;</span> let g:skip_defaults_vim = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Uncomment the next line to make Vim more Vi-compatible</span></span><br><span class="line"><span class="string">&quot;</span> NOTE: debian.vim sets <span class="string">&#x27;nocompatible&#x27;</span>.  Setting <span class="string">&#x27;compatible&#x27;</span> changes numerous</span><br><span class="line"><span class="string">&quot; options, so any other options should be set AFTER setting &#x27;compatible&#x27;.</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> compatible</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Vim5 and later versions support syntax highlighting. Uncommenting the next</span></span><br><span class="line"><span class="string">&quot;</span> line enables syntax highlighting by <span class="keyword">default</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">&quot;syntax&quot;</span>)</span><br><span class="line">syntax on</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; If using a dark background within the editing area and syntax highlighting</span></span><br><span class="line"><span class="string">&quot;</span> turn on this option as well</span><br><span class="line"><span class="string">&quot;set background=dark</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Uncomment the following to have Vim jump to the last position when</span><br><span class="line"><span class="string">&quot; reopening a file</span></span><br><span class="line"><span class="string">&quot;</span>au BufReadPost * <span class="keyword">if</span> line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &gt; <span class="number">1</span> &amp;&amp; line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &lt;= line(<span class="string">&quot;$&quot;</span>) | exe <span class="string">&quot;normal! g&#x27;\&quot;&quot;</span> | endif</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Uncomment the following to have Vim load indentation rules and plugins</span></span><br><span class="line"><span class="string">&quot;</span> according to the detected filetype.</span><br><span class="line"><span class="string">&quot;filetype plugin indent on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> The following are commented out as they cause vim to behave a lot</span><br><span class="line"><span class="string">&quot; differently from regular Vi. They are highly recommended though.</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> showcmd<span class="string">&quot; Show (partial) command in status line.</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> showmatch<span class="string">&quot; Show matching brackets.</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> ignorecase<span class="string">&quot; Do case insensitive matching</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> smartcase<span class="string">&quot; Do smart case matching</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> incsearch<span class="string">&quot; Incremental search</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> autowrite<span class="string">&quot; Automatically save before commands like :next and :make</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> hidden<span class="string">&quot; Hide buffers when they are abandoned</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> mouse=a<span class="string">&quot; Enable mouse usage (all modes)</span></span><br><span class="line"><span class="string">&quot;</span> Source a global configuration file <span class="keyword">if</span> available</span><br><span class="line"></span><br><span class="line">autocmd BufNewFile *.py,*.sh,*.java exec<span class="string">&quot;:call SetTitleJ()&quot;</span></span><br><span class="line">func SetTitleJ()</span><br><span class="line">call setline(<span class="number">1</span>,<span class="string">&quot;\#########################################################################&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;\# File Name: &quot;</span>.expand(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>, <span class="string">&quot;\# Author: Dragon&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">2</span>, <span class="string">&quot;\# mail: [beloved25177@126.com](mailto:beloved25177@126.com)&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">3</span>, <span class="string">&quot;\# Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">4</span>, <span class="string">&quot;\# Description:&quot;</span> )</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">5</span>, <span class="string">&quot;\#########################################################################&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">6</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">autocmd BufNewFile *.c,*.cpp,*.h exec<span class="string">&quot;:call SetTitleC()&quot;</span></span><br><span class="line">func SetTitleC()</span><br><span class="line">call setline(<span class="number">1</span>,<span class="string">&quot;\//------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;\// File Name: &quot;</span>.expand(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>, <span class="string">&quot;\// Author: Dragon&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">2</span>, <span class="string">&quot;\// mail: [beloved25177@126.com](mailto:beloved25177@126.com)&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">3</span>, <span class="string">&quot;\// Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">4</span>, <span class="string">&quot;\// Description:&quot;</span> )</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">5</span>, <span class="string">&quot;\//------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">6</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">autocmd BufNewFile *.md exec<span class="string">&quot;:call SetTitleM()&quot;</span></span><br><span class="line">func SetTitleM()</span><br><span class="line">call setline(<span class="number">1</span>,<span class="string">&quot;\&lt;!-- ########################################################################&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;\File Name: &quot;</span>.expand(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>, <span class="string">&quot;\Author: Dragon&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">2</span>, <span class="string">&quot;\mail: [beloved25177@126.com](mailto:beloved25177@126.com)&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">3</span>, <span class="string">&quot;\Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">4</span>, <span class="string">&quot;\Description:&quot;</span> )</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">5</span>, <span class="string">&quot;\######################################################################### --!&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+<span class="number">6</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">nmap &lt;space&gt;w :w!</span><br><span class="line">nmap L g_</span><br><span class="line">nmap H ^</span><br><span class="line">nmap &lt;space&gt;d dd</span><br><span class="line">nmap &lt;C-n&gt; :nohl</span><br><span class="line">nmap &lt;space&gt;s :w</span><br><span class="line">nmap &lt;C-x&gt; gb</span><br><span class="line">nmap &lt;space&gt;q :q</span><br><span class="line">nmap &lt;space&gt;r &lt;C-r&gt;</span><br><span class="line">nmap gh gt</span><br><span class="line">nmap g+ :!g++&lt;space&gt;%</span><br><span class="line">nmap gc :!gcc&lt;space&gt;%</span><br><span class="line">nmap K Ojj</span><br><span class="line">nmap dL dg_</span><br><span class="line">nmap yL yg_</span><br><span class="line">nmap cL cg_</span><br><span class="line">nmap dH d^</span><br><span class="line">nmap yH y^</span><br><span class="line">nmap cH c^</span><br><span class="line">nmap nm :nohlsearch</span><br><span class="line"></span><br><span class="line">vmap L g_</span><br><span class="line">vmap H ^</span><br><span class="line"></span><br><span class="line">imap jj &lt;Esc&gt;</span><br><span class="line">imap jk &lt;Esc&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt;C-A&gt; ggVGY</span><br><span class="line"><span class="built_in">map</span>! &lt;C-A&gt; &lt;Esc&gt;ggVGY</span><br><span class="line"></span><br><span class="line">vmap L g_</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> autowrite</span><br><span class="line"><span class="built_in">set</span> ruler                   <span class="string">&quot; 打开状态栏标尺</span></span><br><span class="line"><span class="string">set cursorline              &quot;</span> 突出显示当前行</span><br><span class="line"><span class="built_in">set</span> magic                   <span class="string">&quot; 设置魔术</span></span><br><span class="line"><span class="string">set guioptions-=T           &quot;</span> 隐藏工具栏</span><br><span class="line"><span class="built_in">set</span> guioptions-=m           <span class="string">&quot; 隐藏菜单栏</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string">set tabstop=2</span></span><br><span class="line"><span class="string">set softtabstop=2</span></span><br><span class="line"><span class="string">set autoindent</span></span><br><span class="line"><span class="string">set cindent</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">set noexpandtab &quot;</span> 不使用空格代替tab</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="built_in">set</span> backspace=<span class="number">2</span></span><br><span class="line">setlocal noswapfile <span class="string">&quot; 不要生成swap文件</span></span><br><span class="line"><span class="string">set shiftwidth=2 &quot;</span> 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 <span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> bufhidden=hide <span class="string">&quot; 当buffer被丢弃的时候隐藏它</span></span><br><span class="line"><span class="string">set backupcopy=yes &quot;</span> 设置备份时的行为为覆盖</span><br><span class="line"><span class="built_in">set</span> backspace=indent,eol,start <span class="string">&quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符</span></span><br><span class="line"><span class="string">set laststatus=2 &quot;</span> 显示状态栏 (默认值为 <span class="number">1</span>, 无法显示状态栏)</span><br><span class="line"><span class="built_in">set</span> autochdir <span class="string">&quot; 自动切换当前目录为当前文件所在的目录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if filereadable(&quot;</span>/etc/vim/vimrc.local<span class="string">&quot;)</span></span><br><span class="line"><span class="string">source /etc/vim/vimrc.local</span></span><br><span class="line"><span class="string">endif</span></span><br></pre></td></tr></table></figure><h2 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h2><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li><code>h j k l</code> 上 下 左 右</li><li><code>ctrl-y1</code> 上移一行</li><li><code>ctrl-e1</code> 下移一行</li><li><code>ctrl-u1</code> 上翻半页</li><li><code>ctrl-d1</code> 下翻半页</li><li><code>ctrl-f1</code> 上翻一页</li><li><code>ctrl-b1</code> 下翻一页</li><li><code>w</code> 跳到下一个词首，按标点或单词分割</li><li><code>W</code> 跳到下一个词首，以空格分割</li><li><code>e</code> 跳到下一个词尾，以标点分割</li><li><code>E</code> 跳到下一个词尾</li><li><code>b</code> 跳到上一个词，以标点分割</li><li><code>B</code> 跳到上一个词首</li><li><code>0</code> 跳至行首，不管有无缩进，就是跳到第0个字符</li><li><code>^</code> 跳至行首的第一个字符</li><li><code>$</code> 跳至行尾</li><li><code>gg</code> 跳至文首</li><li><code>G</code> 调至文尾</li><li><code>ngg/nG</code> 调至第n行</li><li><code>gd</code> 跳至当前光标所在的变量的声明处</li><li><code>fx</code> 在当前行向后找x字符，找到了就跳转到字符位置</li><li><code>;</code> 重复上一个f命令，而不用重复的输入fx</li><li><code>*</code> 查找光标所在处的单词，向下查找</li><li><code>#</code> 查找光标所在处的单词，向上查找</li></ul><h3 id="删除复制"><a href="#删除复制" class="headerlink" title="删除复制"></a>删除复制</h3><ul><li><code>dd</code> 删除光标所在行，应该说是剪切，删除之后 vim 的缓冲区中会存放删除的内容</li><li><code>dw</code> 删除一个字符</li><li><code>diw</code> 删除一个单词</li><li><code>dg_</code> 或 <code>D</code> 从当前位置删除到行末</li><li><code>x</code> 删除当前字符</li><li><code>X</code> 删除前一个字符</li><li><code>yy</code> 复制一行，会复制换行符</li><li><code>yw</code> 复制一个字符</li><li><code>yiw</code> 复制一个单词</li><li><code>yg_</code> 或 <code>Y</code> 复制到行末</li><li><code>p</code> 粘贴粘贴板的内容到当前光标之前</li><li><code>P</code> 粘贴粘贴板的内容到当前光标之后</li></ul><h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><ul><li><code>i</code> 从当前光标之前进入插入模式</li><li><code>I</code> 在行首进入插入模式</li><li><code>a</code> 追加模式，当前光标之后进入插入模式</li><li><code>A</code> 在行尾进入插入模式</li><li><code>o</code> 在当前行之下新加一行，并进入插入模式</li><li><code>O</code> 在当前行之上新加一行，并进入插入模式</li><li><code>Esc</code> 退出当前模式</li><li><code>v</code> 进入可视模式 visual mode，进入可视模式之后可以使用在普通模式的按键进行相应的操作</li><li><code>V</code> 进入行可视模式 line visual mode</li><li><code>ctrl-v</code> 进入块可视模式 block visual mode，但是要注意在 windows 中的 ideavim 中，默认是 <code>ctrl-q</code></li></ul><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li><code>J</code> 将下一行和当前行连接为一行</li><li><code>cc</code> 删除当前行并进入编辑模式</li><li><code>cw</code> 删除当前字符，并进入编辑模式</li><li><code>c$</code> 擦除从当前位置至行末的内容，并进入编辑模式</li><li><code>s</code> 删除当前字符并进入编辑模式</li><li><code>S</code> 删除光标所在行并进入编辑模式</li><li><code>xp</code> 交换当前字符和下一个字符</li><li><code>u</code> 撤销</li><li><code>r</code> 替换为输入的字符</li><li><code>R</code> 连续替换</li><li><code>ctrl+r</code> 重做</li><li><code>guw</code> 当前字符切换为小写</li><li><code>gUw</code> 当前字符切换为大写</li><li><code>guiw</code> 当前单词切换为小写</li><li><code>gUiw</code> 当前单词切换为大写</li><li><code>~</code> 切换当前字符的大小写</li><li><code>&gt;&gt;</code> 将当前行右移一个tab</li><li><code>&lt;&lt;</code> 将当前行左移一个tab</li><li><code>==</code> 自动缩进当前行</li><li><code>gg=G</code></li></ul><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><ul><li><code>/pattern</code> 向后搜索字符串pattern</li><li><code>?pattern</code> 向前搜索字符串pattern</li><li><code>&quot;\c&quot;</code> 忽略大小写</li><li><code>&quot;\C&quot;</code> 大小写敏感</li><li><code>n</code> 下一个匹配(如果是/搜索，则是向下的下一个，?搜索则是向上的下一个)</li><li><code>N</code> 上一个匹配(同上)</li><li><code>:%s/old/new/g</code> 搜索整个文件，将所有的old替换为new</li><li><code>:%s/old/new/gc</code> 搜索整个文件，将所有的old替换为new，每次都要你确认是否替换</li></ul><h3 id="退出文件"><a href="#退出文件" class="headerlink" title="退出文件"></a>退出文件</h3><ul><li><code>:w</code> 将缓冲区写入文件，即保存修改</li><li><code>:wq</code> 保存修改并退出</li><li><code>:wq!</code> 强制保存修改并退出</li><li><code>:x</code> 保存修改并退出</li><li><code>:q</code> 退出，如果对缓冲区进行过修改，则会提示</li><li><code>:q!</code> 强制退出，放弃修改</li></ul><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><ul><li><code>vim file1..</code> 同时打开多个文件</li><li><code>:args</code> 显示当前编辑文件</li><li><code>:next</code> 切换到下个文件</li><li><code>:prev</code> 切换到前个文件</li><li><code>:next!</code> 不保存当前编辑文件并切换到下个文件</li><li><code>:prev!</code> 不保存当前编辑文件并切换到上个文件</li><li><code>:wnext</code> 保存当前编辑文件并切换到下个文件</li><li><code>:wprev</code> 保存当前编辑文件并切换到上个文件</li><li><code>:first</code> 定位首文件</li><li><code>:last</code> 定位尾文件</li><li><code>ctrl+^</code> 快速在最近打开的两个文件间切换</li><li><code>:split</code> 或者 <code>:sp</code> 把当前文件水平分割</li><li><code>:split file</code> 把当前窗口水平分割，并且打开文件file</li><li><code>:vsplit[vsp] file</code> 把当前窗口垂直分割，并且打开文件file</li><li><code>:new file</code> 同 <code>split file</code></li><li><code>:close</code> 关闭当前窗口</li><li><code>:only</code> 只显示当前窗口, 关闭所有其他的窗口</li><li><code>:all</code> 打开所有的窗口</li><li><code>:vertical all</code> 打开所有的窗口, 垂直打开</li><li><code>:qall</code> 对所有窗口执行：q操作</li><li><code>:qall!</code> 对所有窗口执行：q!操作</li><li><code>:wall</code> 对所有窗口执行：w操作</li><li><code>:wqall</code> 对所有窗口执行：wq操作</li><li><code>ctrl-w h</code> 跳转到左边的窗口</li><li><code>ctrl-w j</code> 跳转到下面的窗口</li><li><code>ctrl-w k</code> 跳转到上面的窗口</li><li><code>ctrl-w l</code> 跳转到右边的窗口</li><li><code>ctrl-w t</code> 跳转到最顶上的窗口</li><li><code>ctrl-w b</code> 跳转到最底下的窗口</li></ul><p><strong>命令行中vim指令的参数</strong></p><ul><li><code>-o[n]</code> 以水平分屏的方式打开多个文件</li><li><code>-O[n]</code> 以垂直分屏的方式打开多个文件</li></ul><h3 id="多标签编辑"><a href="#多标签编辑" class="headerlink" title="多标签编辑"></a>多标签编辑</h3><ul><li><code>:tabedit file</code> 在新标签中打开文件file</li><li><code>:tab split file</code> 在新标签中打开文件file</li><li><code>:tabp</code> 切换到前一个标签</li><li><code>:tabn</code> 切换到后一个标签</li><li><code>:tabc</code> 关闭当前标签</li><li><code>:tabo</code> 关闭其他标签</li><li><code>gt</code> 到下一个tab</li><li><code>gT</code> 到上一个tab</li></ul><h3 id="buffer操作"><a href="#buffer操作" class="headerlink" title="buffer操作"></a>buffer操作</h3><ul><li><code>-</code> 非活动的缓冲区</li><li><code>=</code> 只读缓冲区</li><li><code>a</code> 当前被激活缓冲区</li><li><code>h</code> 隐藏的缓冲区</li><li><code>%</code> 当前的缓冲区</li><li><code>#</code> 交换缓冲区</li><li><code>+</code> 已经更改的缓冲区</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li><code>vim path/</code> 打开目录</li><li><code>h j k l</code> 左，下，上，右</li><li><code>-</code> 返回上一目录</li><li><code>enter</code> 进入目录或者文件</li><li><code>D</code> 删除目录或文件</li><li><code>R</code> 重命名目录或文件</li><li><code>ctrl+^</code> 回退上次操作</li><li><code>:q</code> 退出vim</li><li><code>c</code> 使当前打开的目录成为当前目录</li><li><code>d</code> 创建目录</li><li><code>%</code> 创建文件</li><li><code>gb</code> 转到上一个标记的文件夹</li><li><code>i</code> 改变目标文件列表方式时</li><li><code>^i</code> 刷新当前打开的目录，更改排列样式</li><li><code>mf</code> 标记文件</li><li><code>mu</code> unmark all marked files</li><li><code>mz</code> compress/decompress marked file</li><li><code>gh</code> 显示/不显示隐藏文件</li><li><code>^h</code> 标记隐藏文件列表</li><li><code>a</code> 转换显示模式，显示所有文件-只显示不隐藏文件-只显示隐藏文件</li><li><code>qf</code> 显示文件信息</li><li><code>qb</code> 列出被标记的文件历史</li><li><code>gi</code> 显示文件信息</li><li><code>md</code> 将标记的文件使用 <code>diff</code> 模式</li><li><code>me</code> 编辑标记的文件，只显示一个，其余放入 <code>buffer</code> 中</li><li><code>mm</code> 移动标记的文件到标记的文件目标路径中</li><li><code>mc</code> copy</li><li><code>mt</code> 移动到的目录</li></ul><p><strong>复制移动文件</strong></p><ol><li><code>mt</code> 移动到的目录</li><li><code>mf</code> 标记要移动的文件</li><li><code>mc</code> 移动/复制</li></ol><h3 id="其它一些小功能"><a href="#其它一些小功能" class="headerlink" title="其它一些小功能"></a>其它一些小功能</h3><ul><li><code>:set number</code> 显示行号</li><li><code>:set nonumber</code> 取消行号</li><li><code>:set relativenumber</code> 相对行号</li><li><code>:set hlsearch</code> 高亮搜索</li><li><code>:set nohlsearch</code> 取消高亮搜索</li><li><code>:set incsearch</code> 增量搜索</li><li><code>:set ignorecase</code> 忽略大小写</li><li><code>:set noignorecase</code> 取消忽略大小写</li><li><code>:set smartcase</code> 智能大小写</li><li><code>:set autoindent</code> 自动缩进</li><li><code>:set noautoindent</code> 取消自动缩进</li><li><code>:set smartindent</code> 智能缩进</li><li><code>:set wrap</code> 自动换行</li><li><code>:set nowrap</code> 取消自动换行</li><li><code>:set cursorline</code> 显示当前行</li><li><code>:set nocursorline</code> 取消显示当前行</li><li><code>:set cursorcolumn</code> 显示当前列</li><li><code>:set nocursorcolumn</code> 取消显示当前列</li><li><code>:set list</code> 显示不可见字符</li><li><code>:%!grep:%s/, /\\\\\\\\r /g</code> 把逗号空格换成换行</li><li><code>:%!grep execve</code> 在 VIM 中看编译过程中调用了哪些其他的程序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fish使用</title>
      <link href="/Blog_ButterFly/2024/03/19/fish%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/fish%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="fish安装"><a href="#fish安装" class="headerlink" title="fish安装"></a>fish安装</h2><p>可以使用指令安装 fish</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fish</span><br></pre></td></tr></table></figure><h2 id="将fish设置为默认终端"><a href="#将fish设置为默认终端" class="headerlink" title="将fish设置为默认终端"></a>将fish设置为默认终端</h2><p>只需要终端的一行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s $(which fish)</span><br></pre></td></tr></table></figure><h2 id="fish-个性化配置"><a href="#fish-个性化配置" class="headerlink" title="fish 个性化配置"></a>fish 个性化配置</h2><p>fish的配置基本上是通过一条指令来的</p><p><code>fish --config</code> 之后会打开一个网页，然后在其中可以自己选择好看的主题之类的</p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux使用</title>
      <link href="/Blog_ButterFly/2024/03/19/tmux%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/tmux%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="tmux安装"><a href="#tmux安装" class="headerlink" title="tmux安装"></a>tmux安装</h2><p>在 linux 命令行终端只需要一行指令就可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tmux</span><br></pre></td></tr></table></figure><h2 id="tmux-使用指令-针对于同一个窗口不同的分割操作"><a href="#tmux-使用指令-针对于同一个窗口不同的分割操作" class="headerlink" title="tmux 使用指令 针对于同一个窗口不同的分割操作"></a>tmux 使用指令 针对于同一个窗口不同的分割操作</h2><p>竖直分割窗口 crtl-b “<br>水平分割窗口 crtl-b %<br>关闭窗口 crtl-b &amp;<br>切换窗口 crtl-b 上下左右按键，或者 ;</p><p>tmux 窗口指令，针对于对不同的窗口操作<br>&amp; 关闭当前窗口<br>l 前后窗口间互相切换<br>. 修改当前窗口编号，相当于重新排序<br>f 在所有窗口中查找关键词<br>, 重命名当前窗口<br>w 列出所有窗口<br>% 水平分割窗口<br>“ 竖直分割窗口<br>n 选择下一个窗口<br>p 选择上一个窗口<br>0~9 选择 0~9 对应的窗口<br>空格 更改竖直与水平的窗格<br>x根据提示关闭 关闭当前窗格 或者直接 crtl-D 关闭<br>z 当前窗口全屏显示</p><p>tmux的分割窗口实现实际上是多个终端，并且可以通过echo对终端的文件进行操作，然后会出现在对应终端上 <code>/dev/pts/n</code></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#~/.tmux.conf</span><br><span class="line"><span class="meta">#tmux source-file ~/.tmux.conf</span></span><br><span class="line">#设置终端颜色为<span class="number">256</span>色  </span><br><span class="line"><span class="built_in">set</span> -g <span class="keyword">default</span>-terminal <span class="string">&quot;screen-256color&quot;</span>  </span><br><span class="line">#设置pan前景色  </span><br><span class="line"><span class="meta">#set -g pane-border-fg green  </span></span><br><span class="line">#设置status-bar颜色  </span><br><span class="line"><span class="built_in">set</span> -g status-fg white  </span><br><span class="line"><span class="built_in">set</span> -g status-bg black  </span><br><span class="line">#设置窗口列表颜色  </span><br><span class="line">#设置status bar格式  </span><br><span class="line"><span class="built_in">set</span> -g status-left-length <span class="number">40</span>  </span><br><span class="line"><span class="built_in">set</span> -g status-left <span class="string">&quot;#[fg=green]Session: #S #[fg=yellow]#I #[fg=cyan]#P&quot;</span>  </span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">&quot;#[fg=cyan]%b %d %R&quot;</span>  </span><br><span class="line"><span class="built_in">set</span> -g status-interval <span class="number">60</span>  </span><br><span class="line"><span class="built_in">set</span> -g status-justify centre </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g base-index         <span class="number">1</span>     # 窗口编号从 <span class="number">1</span> 开始计数</span><br><span class="line"><span class="built_in">set</span> -g display-panes-time <span class="number">10000</span> # PREFIX-Q 显示编号的驻留时长，单位 ms</span><br><span class="line"><span class="built_in">set</span> -g mouse              on    # 开启鼠标</span><br><span class="line"><span class="built_in">set</span> -g pane-base-index    <span class="number">1</span>     # 窗格编号从 <span class="number">1</span> 开始计数</span><br><span class="line"><span class="built_in">set</span> -g renumber-windows   on    # 关掉某个窗口后，编号重排</span><br><span class="line"></span><br><span class="line"># 启用活动警告</span><br><span class="line">setw -g monitor-activity on</span><br><span class="line"><span class="built_in">set</span> -g visual-activity on</span><br><span class="line"><span class="built_in">set</span> -g <span class="keyword">default</span>-command /bin/fish</span><br><span class="line"></span><br><span class="line"><span class="meta"># split panes using | and -</span></span><br><span class="line">bind l split-window -h #扩展窗口</span><br><span class="line">bind j split-window -v</span><br><span class="line">unbind <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">unbind %</span><br><span class="line"></span><br><span class="line">#移动扩展出的窗口</span><br><span class="line">bind C-k select-pane -U#向上</span><br><span class="line">bind C-j select-pane -D#向下</span><br><span class="line">bind C-h select-pane -L#向左</span><br><span class="line">bind C-l select-pane -R#向右</span><br><span class="line">bind b resize-pane -Z<span class="meta">#b全屏</span></span><br><span class="line"># Enable mouse <span class="title function_">mode</span> <span class="params">(tmux <span class="number">2.1</span> and above)</span></span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line"></span><br><span class="line">bind -T copy-mode-vi y send-keys -X copy-pipe-and-cancel &#x27;xclip -in -selection clipboard&#x27; #复制到系统剪切板</span><br><span class="line">bind-key -T copy-mode-vi C-h select-pane -L #复制模式时移动光标 </span><br><span class="line">bind-key -T copy-mode-vi C-j select-pane -D</span><br><span class="line">bind-key -T copy-mode-vi C-k select-pane -U</span><br><span class="line">bind-key -T copy-mode-vi C-l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="meta"># set -g prefix C-a</span></span><br><span class="line"><span class="meta"># unbind C-b</span></span><br><span class="line"><span class="meta"># bind C-a send-prefix</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-window-option -g mode-keys vi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb使用</title>
      <link href="/Blog_ButterFly/2024/03/19/gdb%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/gdb%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="gdb-功能"><a href="#gdb-功能" class="headerlink" title="gdb 功能"></a>gdb 功能</h3><ul><li>动态改变程序的执行环境。</li><li>自定义启动运行需要调试的程序。</li><li>在指定位置使用条件表达式设置断点。</li><li>在程序暂停时观察代码内变量值的变化。</li></ul><h3 id="开始前准备"><a href="#开始前准备" class="headerlink" title="开始前准备"></a>开始前准备</h3><p>主要是生成调试信息，在编译的时候，添加 <code>-g</code> 选项来生成调试信息，以此来使用 gdb 的调试</p><h2 id="gdb-外部指令"><a href="#gdb-外部指令" class="headerlink" title="gdb 外部指令"></a>gdb 外部指令</h2><ul><li><code>gdb 可执行文件名</code> 启动 gdb 调试</li><li><code>gdb --help</code> 查看指令帮助</li><li><code>man gdb</code> 查看 gdb 手册</li><li><code>gdb -x xxx</code> 在 gdb 启动时运行一些脚本</li><li><code>gdb --version</code> 查看 gdb 版本</li></ul><h2 id="gdb-内部指令"><a href="#gdb-内部指令" class="headerlink" title="gdb 内部指令"></a>gdb 内部指令</h2><h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><ul><li><code>r/run</code> 开始运行，会一直运行，直到断点</li><li><code>start</code> 开始运行，在 <code>main</code> 处会停下来</li><li><code>starti</code> 开始运行，在第一条指令处停下来</li><li><code>r/run param</code> 开始运行，会一直运行，直到断点，后面的 <code>param</code> 就是可执行文件后面需要跟的参数</li></ul><h3 id="运行中指令"><a href="#运行中指令" class="headerlink" title="运行中指令"></a>运行中指令</h3><ul><li><code>c/continue</code> 继续运行，一直运行，直到下一个断点</li><li><code>c/continue n</code> 继续运行，一直运行，会忽略 <code>n</code> 个断点</li><li><code>s/step</code> 单步，不进入函数内部</li><li><code>si/stepi</code> 单步进入，进入函数内部，是在机器层面的，单步到下一个机器指令</li><li><code>n/next</code> 单步，进入函数内部，是源码层面的下一行</li><li><code>ni/nexti</code> 单步，是机器指令层面的，单步到下一个机器指令</li><li><code>finish</code> 函数会继续执行完，并且打印返回值，然后等待接下来的指令</li><li><code>return</code> 函数不会继续执行下面的指令，直接返回</li><li><code>return expression</code> 直接返回，指定返回值为 <code>expression</code></li><li><code>u</code> 退出当前循环体</li><li><code>step, next, stepi, nexti</code> 后面加次数都表示执行一定次数该指令</li></ul><h3 id="调试中变量相关"><a href="#调试中变量相关" class="headerlink" title="调试中变量相关"></a>调试中变量相关</h3><ul><li><code>info args</code> 打印当前函数的参数名及值</li><li><code>info locals</code> 打印当前函数中所有局部变量及其值</li><li><code>set var arg=val</code> 设置变量的值</li><li><code>ptype arg</code> 查看 <code>arg</code> 的类型</li><li><code>disable mem addr</code> 禁用 <code>mem</code> 命令定义的内存区域</li><li><code>enable mem addr</code> 启用 <code>mem</code> 命令定义的内存区域</li><li><code>wha/whatis arg</code> 显示变量的类型</li><li><code>show arg</code> 可以显示历史中变量的最后十个值</li></ul><h3 id="断点和监视点"><a href="#断点和监视点" class="headerlink" title="断点和监视点"></a>断点和监视点</h3><p><strong>断点</strong></p><ul><li><code>b func_name</code> 在函数处添加断点</li><li><code>b *func_name</code> 在函数处添加断点，这里使用 <code>*</code> 的主要是为了使断点设置到汇编语言层的函数开头</li><li><code>b +n</code> 在当前位置的 <code>n</code> 个偏移处添加断点</li><li><code>b *addr</code> 在地址 <code>addr</code> 处添加断点</li><li><code>b filename: n</code> 在文件 <code>filename</code> 的 <code>n</code> 行号处添加断点</li><li><code>b filename:func_name</code> 在文件 <code>filename</code> 的 <code>func_name</code> 函数处添加断点</li><li><code>info b</code> 查看断点信息</li><li><code>ignore n nums</code> 忽略 <code>n</code> 号断点 <code>nums</code> 次</li><li><code>disable n</code> 临时禁用 <code>n</code> 号断点</li><li><code>enable n</code> 重新启用 <code>n</code> 号断点</li><li><code>enable n once</code> 重新启用 <code>n</code> 号断点，中断一次之后禁用断点</li><li><code>enable n delete</code> 重新启用 <code>n</code> 号断点，中断一次之后删除断点</li><li><code>clear func_name/n/*addr/filename:n/filename:function</code> 删除已经指定的断点</li><li><code>break point if condition</code> 测试给定条件，如果条件为真就暂停运行</li><li><code>condition n</code> 删除指定断点的出发条件</li><li><code>condition n con</code> 为指定断点添加出发条件</li></ul><p><strong>断点命令</strong></p><p>可以定义在断点中断后执行的命令，一般使用要在定义断点之后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b main</span><br><span class="line">commands n</span><br><span class="line">p *b</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>其中 <code>n</code> 就是断点号，也就是在对应断点号之后执行命令， <code>command</code> 需要与 <code>end</code> 对应结束</p><p><strong>监视点</strong></p><ul><li><code>watch expression</code> 表达式发生变化时暂停运行</li><li><code>awatch expression</code> 表达式被访问/被改变时暂停运行</li><li><code>rwatch expression</code> 表达式被访问时暂停运行</li><li><code>info watchpoints</code> 查看当前设置的观察点</li><li><code>delete</code> 删除所有断点和监视点</li><li><code>delete n</code> 删除 <code>n</code> 号断点或者监视点</li></ul><h3 id="窗口指令"><a href="#窗口指令" class="headerlink" title="窗口指令"></a>窗口指令</h3><ul><li><code>layout src</code> 显示源码</li><li><code>layout asm</code> 显示汇编代码</li><li><code>layout split</code> 显示源代码和汇编代码</li><li><code>layout regs</code> 显示寄存器</li><li><code>layout next</code> 切换到下一个布局模式</li><li><code>layout prev</code> 切换到上一个布局模式</li><li><code>info win</code> 显示窗口大小</li><li><code>focus next</code> 聚焦到下一个窗口</li><li><code>focus prev</code> 聚焦到上一个窗口</li><li><code>focus cmd</code> 聚焦到命令行</li><li><code>focus src</code> 聚焦到源码窗口</li><li><code>focus asm</code> 聚焦到汇编代码窗口</li><li><code>focus regs</code> 聚焦到寄存器窗口</li><li><code>refresh</code> 刷新所有窗口</li><li><code>winheight name +/- line</code> 调整 <code>name</code> 窗口高度<ul><li><code>reg</code> 寄存器</li><li><code>cmd</code> 命令行</li><li><code>src</code> 源码</li><li><code>asm</code> 汇编代码</li></ul></li><li><code>update</code> 更新源代码窗口和当前执行点</li><li><code>ctrl-l</code> 刷新窗口</li><li><code>ctrl-x + n</code> 也就是先按下 <code>ctrl-x</code> 然后再按 <code>n</code><ul><li><code>1</code> 单窗口模式，显示一个窗口</li><li><code>2</code> 双窗口模式，显示两个窗口</li><li><code>a</code> 回到传统模式，也就是退出 <code>layout</code></li></ul></li></ul><h3 id="寄存器指令"><a href="#寄存器指令" class="headerlink" title="寄存器指令"></a>寄存器指令</h3><ul><li><code>i/info reg/register</code> 显示寄存器的值，不包括浮点寄存器和向量寄存器的内容</li><li><code>i/info all-register/reg</code> 显示所有寄存器的内容</li><li><code>i regsiter/reg reg_name</code> 显示 <code>reg_name</code> 寄存器的内容</li><li><code>p/print $reg</code> 显示对应寄存器 <code>reg</code> 的值</li><li><code>set var $reg=n</code> 设置寄存器 <code>reg</code> 的值为 <code>n</code></li></ul><h3 id="栈帧操作"><a href="#栈帧操作" class="headerlink" title="栈帧操作"></a>栈帧操作</h3><ul><li><code>bt/backtrace</code> 查看栈回溯信息，执行该栈回溯命令后，会显示程序执行到什么位置，包含哪些帧等信息。每一帧都有一个编号，从 0 开始。0 表示当前正在执行的函数，1 表示调用当前函数的函数，以此类推。栈回溯是倒序排列的</li><li><code>bt/backtrace n</code> 只显示开头 <code>n</code> 个栈帧</li><li><code>bt/backtrace -n</code> 只显示最后 <code>n</code> 个栈帧</li><li><code>bt/backtrace full</code> 打印栈帧并打印局部变量的值</li><li><code>bt/backtrace full n</code> 打印开头的 <code>n</code> 个栈帧并打印局部变量的值</li><li><code>bt/backtrace full -n</code> 打印结尾的 <code>n</code> 个栈帧并打印局部变量的值</li><li><code>f/frame n</code> 切换栈帧为 <code>n</code> 号栈帧</li><li><code>f/frame addr</code> 切换为栈帧地址 <code>addr</code></li><li><code>up n</code> 切换栈帧为向上 <code>n</code> 个栈帧，跳到上一层函数</li><li><code>down n</code> 切换栈帧为向下 <code>n</code> 个栈帧，跳到下一层函数</li><li><code>info frame</code> 显示栈帧的信息</li><li><code>info frame n</code> 显示 <code>n</code> 号栈帧的信息</li><li><code>info stack</code> 查看堆栈使用情况</li><li><code>whe/where</code> 查看调用的堆栈</li><li><code>disas/disassemble</code> 反汇编当前的函数或者指定函数</li></ul><h3 id="显示指令"><a href="#显示指令" class="headerlink" title="显示指令"></a>显示指令</h3><ul><li><code>p/print /格式 arg/$reg</code> 用于指定显示格式</li><li><code>x /格式 addr</code> 用指定格式显示 <code>addr</code> 内存中的内容</li><li>格式<ul><li><code>x</code> 显示为 16 进制数字</li><li><code>d</code> 显示为 10 进制数字</li><li><code>u</code> 显示为无符号 10 进制数字</li><li><code>o</code> 显示为 8 进制数字</li><li><code>t</code> 显示为 2 进制数字 two</li><li><code>a</code> 显示为地址</li><li><code>c</code> 显示为字符</li><li><code>f</code> 显示为浮点小数</li><li><code>s</code> 显示为字符串</li><li><code>i</code> 显示为机器语言(仅在显示内存的X命令中可以使用)</li></ul></li><li><code>x /NFU addr</code> 其中 <code>N</code> 表示向下显示多少个， <code>F</code> 表示格式，如上， <code>U</code> 表示单位大小<ul><li><code>b</code> 字节</li><li><code>h</code> 半字</li><li><code>w</code> 字</li><li><code>g</code> 双字</li></ul></li><li><code>set print elements n</code> 设置打印的字节长度为 <code>n</code> ，其中 <code>n=0</code> 时表示不受限制</li><li><code>l/list n</code> 显示代码，默认显示 10 行，指定显示 <code>n</code> 行代码</li><li><code>display arg/$reg</code> 跟踪打印变量值或者寄存器值</li><li><code>undisplay n</code> 取消跟踪第 <code>n</code> 个跟踪变量的值</li><li><code>info display</code> 查看跟踪的变量号和对应的变量</li><li><code>disable display n</code> 禁用 <code>n</code> 号跟踪变量</li><li><code>enable display n</code> 启用 <code>n</code> 号跟踪变量</li></ul><h3 id="反向调试"><a href="#反向调试" class="headerlink" title="反向调试"></a>反向调试</h3><ul><li><code>record</code> 用于开始记录程序反向调试所需要的信息，其中包括保存程序的每一步每一行的结果等信息，而且反向调试只能到执行这条指令的位置，如果没有执行这条指令是没有办法进行反向调试的</li><li><code>record stop</code> 停止反向调试，反向调试的记录停止，就可以开始正常运行了</li><li><code>rc/reverse-continue</code> 开始反向运行，直到碰到一个断点</li><li><code>rs/reverse-step</code> 反向运行到上一次被执行的源代码行，会进入函数</li><li><code>rsi/reverse-stepi</code> 反向运行程序到上一条机器指令</li><li><code>rn/reverse-next</code> 反相运行到上一次被执行的源代码行，不会进入函数</li><li><code>rni/reverse-nexti</code> 反相运行到上一条机器指令</li><li><code>reverse-finish</code> 反向运行程序回到调用当前函数的地方</li><li><code>set exec-direction [forward|reverse]</code> 设置程序运行方向，就可以使用 <code>stop</code> 和 <code>continue</code> 等指令来执行反向的调试指令</li></ul><h3 id="抓取和释放进程"><a href="#抓取和释放进程" class="headerlink" title="抓取和释放进程"></a>抓取和释放进程</h3><ul><li><code>detach</code> 将正在调试的进程释放掉，不再进行调试，该进程会继续执行</li><li><code>attach pid</code> 可以调试已经启动的进程，或者调试陷入死循环而无法返回的控制台进程</li></ul><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><ul><li><code>q/quit</code> 退出当前调试</li><li><code>k/kill</code> 杀死当前正在调试的进程，不会退出，可以重新使用开始运行指令开始</li></ul><h3 id="其它一些操作"><a href="#其它一些操作" class="headerlink" title="其它一些操作"></a>其它一些操作</h3><ul><li><code>edit</code> 编辑文件或者函数</li><li><code>find dir xxx</code> 寻找 <code>dir</code> 路径下名为 <code>xxx</code> 的文件</li><li><code>dir</code> 用于指定源文件目录</li><li><code>print-object arg</code> 显示目标信息</li><li><code>sharelibrary</code> 加载共享的符号</li></ul><h2 id="gdb-初始化文件"><a href="#gdb-初始化文件" class="headerlink" title="gdb 初始化文件"></a>gdb 初始化文件</h2><p>linux 环境下初始化文件为 <code>.gdbinit</code> 文件，会在用户的主目录下寻找一个名为 <code>.gdbinit</code> 的文件，如果存在该文件，gdb 就会在启动之前将其作为命令文件运行，初始化文件和命令文件运行顺序如下</p><ol><li><code>~/.gdbinit</code></li><li>运行命令选项</li><li><code>./.gdbinit</code></li><li>通过 <code>-x</code> 选项给出的命令文件 <code>gdb -x xxx</code></li></ol><p>该文件的定义应遵循以下格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define &lt;command&gt;</span><br><span class="line">&lt;code&gt;</span><br><span class="line">end</span><br><span class="line">document &lt;command&gt;</span><br><span class="line">&lt;help text&gt;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在 <code>.gdbinit</code> 中可以写 gdb 的内部指令，gdb 会执行该指令的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout src</span><br></pre></td></tr></table></figure><p>但是一般来说，当在一个非 <code>home</code> 目录下添加一个 <code>.gdbinit</code> 时，就必须要在 <code>home</code> 目录下添加一个 <code>.gdbinit</code> 文件，并且此文件中必须声明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-auto-load-safe-path xxx/.gdbinit</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然 gdb 调试很强大，但是没有一个交互的页面其实也是有点难受的，但是 gdb 调试适用性很广。现在大部分都可以直接使用 vscode+cmake 来调试，其实很方便，能把所有变量都放在侧边栏以便调试确实很不错。但是丝毫不影响 gdb 的强大。</p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc使用</title>
      <link href="/Blog_ButterFly/2024/03/19/gcc%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/gcc%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>GCC（英文全拼：GNU Compiler Collection）是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件，由 Richard Stallman 于 1985 年开始开发。</p><p>GCC 原名为 GNU C语言编译器，因为它原本只能处理 C 语言，但如今的 GCC ，不仅可以编译 C、C++ 和 Objective-C，还可以通过不同的前端模块支持各种语言，包括 Java、Fortran、Ada、Pascal、Go 和 D 语言等等。</p><p>GCC支持多种硬件开发平台，还能进行跨平台交叉编译。此外，GCC是按模块化设计的，可以加入新语言和新CPU架构的支持。</p><h3 id="GCC、gcc、g-三者之间的关系"><a href="#GCC、gcc、g-三者之间的关系" class="headerlink" title="GCC、gcc、g++三者之间的关系"></a>GCC、gcc、g++三者之间的关系</h3><p>gcc（GUN C Compiler）是GCC中的c编译器，而g++（GUN C++ Compiler）是GCC中的c++编译器。</p><p>gcc和g++两者都可以编译c和cpp文件，但存在差异。gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库（gcc默认链接c库，g++默认链接c++库）。g++编译.c和.cpp文件都统一按cpp的语法规则来编译。所以一般编译c用gcc，编译c++用g++。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>只需要一行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br><span class="line">sudo apt install g++</span><br></pre></td></tr></table></figure><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>可以使用 <code>mingw</code> 来安装 <code>gnuc</code> 的工具</p><p><a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z/download">mingw</a></p><p>下载压缩包之后，解压到软件的位置，然后再添加系统环境变量</p><h2 id="gcc编译指令参数-gcc-option-file"><a href="#gcc编译指令参数-gcc-option-file" class="headerlink" title="gcc编译指令参数 gcc [option] file"></a>gcc编译指令参数 <code>gcc [option] file</code></h2><ol><li>-o 用于指定编译之后的文件名称</li><li>-g 在可执行文件中加入源码信息供gdb调试使用，但是并不是把整个源文件嵌入到可执行文件中，而是几条机器码对应几行源代码</li><li>-c 只生成目标文件 .o 文件</li><li>-Wall 通常gcc不会提示一些不重要的警告，加上之后会提示所有警告</li><li><p>-O 编译优化等级<br> gcc 编译有 -O0, -O1, -O2, -O3, -Os, -Ofast, -Og 等几个优化等级，对于前几个来说，随着数字变大，代码的优化程度也越高，但是某种程度上来说是牺牲可调试性能作为代价的，当然有些代码部分是不能进行优化的</p><ul><li>-O0 默认优化等级，实质上没有任何优化</li><li>-O1 最基本优化，短时间内生成可执行文件，主要对代码的分支，常量以及表达式进行优化</li><li>-O2 相对于-O1来说，增加了编译时间的基础上，提高了生成代码的执行效率</li><li>-Os 在-O2的基础上，去掉了导致最终可执行程序增大的优化，可以生成执行效率较高并且更小的执行程序</li><li>-O3 延长编译时间，在-O2基础上进行更多的优化，编译成的软件将生成更大体积更耗内存的二进制文件，增加编译失败的机会并且产生不可预知的程序行为，不建议使用</li><li>-Ofast 在-O3基础上添加一些非常规优化，通过打破一些国际标准来实现的，不仅以使用</li><li>-Og 在-O1的基础上去掉了一些影响调试的优化，如果最终为了调试可以使用这种优化方式</li></ul></li><li><p>-E 只做预处理而不编译</p></li><li>-S 生成汇编代码</li><li>-l 链接，告诉编译器去哪里寻找头文件，参数后紧跟库的名字告诉编译器要链接的库<ul><li>-lpthread 代表使用pthread库实现多线程，代表使用C++11的线程库</li><li>lm 代表使用数学库</li></ul></li><li>-L 告诉编译器去哪里寻找需要的库文件，但是即使库文件就在当前目录下，编译器也不会去找的，所以必须加此参数，除非你的库在默认的寻找目录里，默认目录可以用gcc -print-search-dirs查看。</li><li>-v 可以详细看到编译的过程</li><li>-share 这个选项将尽量使用动态库，生成文件较小，但是需要动态库</li><li>-static 这个将禁止使用动态库，编译出来的东西很大，不需要动态链接库就可以运行<ul><li>static-libgcc 静态链接，编译时使用，用于生成独立的可执行文件</li></ul></li><li>-f 有点怪没找到，好像是一些配置 ^-^?<ul><li>fPIE与-fpie是等价的。这个选项与-fPIC/-fpic大致相同，不同点在于：-fPIC用于生成动态库，-fPIE用与生成可执行文件。再说得直白一点：-fPIE用来生成位置无关的可执行代码。</li><li>fPIC与-fpic都是在编译时加入的选项，用于生成位置无关的代码(Position-Independent-Code)，生成动态库。这两个选项都是可以使代码在加载到内存时使用相对地址，所有对固定地址的访问都通过全局偏移表(GOT)来实现。-fPIC和-fpic最大的区别在于是否对GOT的大小有限制。-fPIC对GOT表大小无限制，所以如果在不确定的情况下，使用-fPIC是更好的选择</li><li>openmp 代表使用OpenMP多线程库</li><li>stack-protector-strong 启用栈保护功能</li></ul></li><li>-M 可以自动分析目标文件和源文件的依赖关系</li><li>-MM 可以自动分析目标文件和源文件的依赖关系，它将忽略由 <code>#include&lt;file&gt;</code> 造成的依赖关系</li><li>std=c++11 代表使用C++11的规范</li><li>-D 代表定义一个宏，例如-DDEBUG</li><li>-U 代表取消一个宏，例如-UDEBUG</li><li>Werror 代表将所有警告视为错误</li><li>Wno-* 代表取消某一类警告，例如-Wno-unused-variable表示取消未使用变量的警告<ul><li>Wno-format-nonliteral 忽略对printf格式化字符串的检查</li><li>Wno-unused-parameter 忽略未使用的参数</li></ul></li><li>Wl,<em>代表将</em>传递给连接器，例如-Wl,-rpath=./指定运行时动态链接库的搜索路径为当前目录<ul><li>Wl,—no-as-needed 静态链接，编译时使用，告诉编译器必须链接所有的库</li></ul></li><li>Wformat=2 检查printf格式化字符串的正确性</li><li>Wconversion 检查隐式类型转换</li><li>Wsign-conversion 检查有符号和无符号类型之间的转换</li><li>-s 从可执行文件中删除所有符号表和重定位信息.</li></ol><h3 id="gcc编译过程"><a href="#gcc编译过程" class="headerlink" title="gcc编译过程"></a>gcc编译过程</h3><ol><li><p>预处理</p><p> 将源文件处理为 <code>.i/.ii</code> 文件，处理各种预处理的指令，例如一些宏定义等</p></li><li><p>编译</p><p> 将预处理后的 <code>.i/.ii</code> 文件编译为 <code>.S/.asm</code> 文件，也就是汇编语言文件</p></li><li><p>汇编</p><p> 将 <code>.S/.asm</code> 文件处理为 <code>.o</code> 文件，也就是把汇编文件处理为机器码</p></li><li><p>链接</p><p> 将各种依赖的静态库/动态库文件， <code>.o</code> 文件，启动文件链接成最终可执行文件或者库文件</p></li></ol><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -S a.c</span><br><span class="line">gcc -S a.i</span><br></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c</span><br><span class="line">gcc -c a.s</span><br></pre></td></tr></table></figure><p>第二条处理汇编语言的指令，实际上是使用汇编器 <code>as</code> 将 <code>.s</code> 文件处理为 <code>.o</code> 文件的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as a.s -o a.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>其中有两个参数 <code>-L</code> 和 <code>-l</code> 用于指定链接的文件的地址和名称，使用 <code>-l</code> 可以省略库文件开头的 <code>lib</code> 和后缀</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -Ldir -lname</span><br></pre></td></tr></table></figure><h3 id="查看gcc编译过程"><a href="#查看gcc编译过程" class="headerlink" title="查看gcc编译过程"></a>查看gcc编译过程</h3><p>使用 <code>-v</code> 来查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PF粒子滤波器</title>
      <link href="/Blog_ButterFly/2024/03/19/PF%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/PF%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>对于一般的非线性/非高斯系统,解析求解的途径是行不通的。在数值近似方法中，蒙特卡罗仿真是一种最为通用、有效的手段，粒子滤波就是建立在蒙特卡罗仿真基础之上的，它通过利用一组带权值的系统状态采样来近似状态的统计分布。由于蒙特卡罗仿真方法具有广泛的适用性，由此得到的粒子滤波算法也能适用于一般的非线性/非高斯系统。但是，这种滤波方法也面临几个重要问题，如有效采样(粒子)如何产生、粒子如何传递以及系统状态的序贯估计如何得到等。</p><p>简单的理解，粒子滤波就是使用了大量的随机样本，采用 蒙特卡洛(MonteCarlo，MC)仿真技术完成 贝叶斯递推滤波 (Recursive Bayesian Filter) 过程。</p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a><strong>推导</strong></h3><p><strong>系统描述</strong></p><p>对于一个离散的开环系统</p><script type="math/tex; mode=display">x_k=Ax_{k-1}+Gw_{k-1}\\z_k=Cx_k+Hv_k</script><p>其中 $x_k$ 为 k 时刻的系统状态向量， $z_k$ 为 k 时刻的测量输出向量，这里是一个开环系统，不考虑系统的输入 $u$。 $w_k,v_k$ 分别是系统过程噪声和观测噪声，并且均为零均值高斯白噪声。犹豫贝叶斯滤波的递推形式是基于非线性系统的后验概率密度，因此这里并不需要假设噪声均为零均值白噪声。但是对于 KF，EKF，CKF，QKF 等需要假设过程噪声和测量噪声均为零均值高斯白噪声。因此基于贝叶斯滤波的粒子滤波可以处理非线性非高斯的状态估计问题。</p><p>定义 $1\sim k$ 时刻的 $x_k$ 的所有测量数据为</p><script type="math/tex; mode=display">z_{1:k}=\begin{bmatrix}z_1^T&z_2^T&...&z_k^T\end{bmatrix}^T</script><p>贝叶斯滤波问题就是计算 k 时刻状态 x 估计的置信程度，为此构造概率密度函数 $p(x_k|z^k)$ ，在给定初始分布 $p(x_0|z^0)=p(x_0)$ 之后，从理论上看，可以通过预测和更新两个步骤递推得到概率密度函数 $p(x_k|z^k)$ 的值，有点 KF 的样子。</p><p><strong>递推贝叶斯滤波</strong></p><ul><li><p>预测步： $p(x_{k-1}|y_{1:k-1})→p(x_k|y_{1:k-1})$</p><script type="math/tex; mode=display">  p(x_k|y_{1:k-1})=\int{p(x_k|x_{k-1})p(x_{k-1}|y_{1:k-1})dx_{k-1}}</script></li><li><p>更新步： $p(x_k|y_{1:k-1})→p(x_k|y_{1:k})$，根据观测到得数据 $y_k$ 来更新数据</p><script type="math/tex; mode=display">  p(x_k|y_{1:k})=\frac{1}{y_k}{p(x_k|x_{k})p(x_{k}|y_{1:k-1})dx_{k-1}}\\y_k=\int{p(y_k|x_k)p(x_k|y_{1:k-1})dx_k}</script></li><li><p>基于 $p(x_k|y_{1:k})$</p><p>  实际上各种滤波，估计就是求解 $p(x_k|y_{1:k})$ 的一阶矩（ $x_k$ 的估计）以及二阶矩（估计的协方差）</p><p>  上述的更新步公式描述了由 $k − 1$ 时刻后验概率密度函数向 $k$ 时刻后验概率密度函数递推的完整过程，从而构成了贝叶斯估计最优解的通用表示形式。进而通过后验分布 $p(x_k|z_{1:k})$ 可以得到不同准则条件下 x 的最优估计计划。</p><p>  例如：</p><ul><li><p>最小均方误差MMSE估计为</p><script type="math/tex; mode=display">  \hat{x}_k=E(x_k|z_k)=\int{x_kp(x_k|z_{1:k})}dx_k</script></li><li><p>最大后验MAP估计为</p><script type="math/tex; mode=display">  \hat{x}_k=\arg\underset{x_k}{\min}~p(x_k|z_{1:k})</script></li></ul></li></ul><pre><code>实际上粒子滤波就是基于蒙特卡洛技术，将上述递推的过程用大量采样的方式实现了</code></pre><p><strong>标准的粒子滤波PF</strong></p><p>核心思想是使用一组具有相应权值的随机样本(粒子)来表示状态的后验分布。</p><p>该方法的基本思路是选取一个重要性概率密度并从中进行随机抽样，得到一些带有相应权值的随机样本后，在状态观测的基础上调节权值的大小和粒子的位置，再使用这些样本来逼近状态后验分布，最后将这组样本的加权求和作为状态的估计值。粒子滤波不受系统模型的线性和高斯假设约束，采用样本形式而不是函数形式对状态概率密度进行描述，使其不需要对状态变量的概率分布进行过多的约束，因而在非线性非高斯动态系统中广泛应用。尽管如此，粒子滤波目前仍存在计算量过大、粒子退化等关键问题亟待突破。</p><p>粒子滤波实际上是上述基于递推贝叶斯滤波的 MMSE 估计的近似实现，而近似方法就是蒙特卡洛方法。</p><p>通常选择先验分布作为重要性密度函数，即</p><script type="math/tex; mode=display">q(x_k|x_{k-1}^{i},z_k)=p(x_k|x_{k-1}^i)</script><p>对该函数取重要性权值为</p><script type="math/tex; mode=display">w_k^i=w_{k-1}^ip(y_k|x_k^i)</script><p>该权值需要归一化为 $\overline{w}_k^i$</p><p><strong>步骤</strong></p><p><img src="/Blog_ButterFly/2024/03/19/PF%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%99%A8/420a2bd9b5e14a558dea20fd5b4f7bb2.png" alt="420a2bd9b5e14a558dea20fd5b4f7bb2.png"></p><ol><li>根据 $p(x_0)$ 采样得到 N 个粒子 $x_0^i\sim p(x_0)$</li><li>根据状态转移函数产生新的粒子为 $x_k^i\sim p(x_k|x_{k-1}^i)$</li><li>计算重要性权值 $w_k^i=w_{k-1}^ip(y_k|x_k^i)$</li><li>归一化重要性权值 $\overline{w}_k^i=\frac{w_k^i}{\sum_{j=1}^Nw_k^j}$</li><li>使用重采样方法对粒子进行重采样</li><li>得到 k 时刻的后验状态估计 $E(\hat{x}_k)=\sum_{i=1}^Nx_k^i\overline{w}_k^i$</li></ol><p><strong>重采样</strong></p><p>重采样机制是指对于权重较大的粒子序列进行复制，对于权重较小的粒子序列进行抛弃，通过重采样后，我们获得N个权重相等的粒子序列。通过重采样，我们可以避免之前重要性采样中由于权重迭代次数过多导致部分粒子权重很小，部分粒子权重很大的问题。重采样方法主要有系统重采样、残差重采样、多项式重采样等。为了减少计算量我们同时还引入了自适应重采样机制</p><p><img src="/Blog_ButterFly/2024/03/19/PF%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%99%A8/v2-35c8e9d9f26bbfe26fd11edf60e7ac54_720w.webp" alt="v2-35c8e9d9f26bbfe26fd11edf60e7ac54_720w.webp"></p><p><img src="/Blog_ButterFly/2024/03/19/PF%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%99%A8/20200324170000786.png" alt="20200324170000786.png"></p><ul><li>系统重采样，将 $(0,1)$ 区间均匀分为 N 份，并将所有粒子按照权重依次进行累加，对于累加后跨过 n 个区间分界点的粒子复制 n 份，对于跨国 0 个区间分类点的粒子抛弃，步骤如下<ol><li>在均匀分布 $U(0,1/N)$ 中采样 $U_0$</li><li>按照公式 $U_i=U_0+\frac{i-1}{N}$ 计算 N 个分界点</li><li>计算每个粒子采样次数 $N_i=\sum_{k=1}^{i-1}w_k\leq U_i\leq \sum_{k=1}^iw_k$</li></ol></li><li><p>多项式重采样</p><p>  另一种常用的方法是多项式重采样，多项式重采样算法首先利用重采样之前的粒子权值集合组成一个多项式分布即 $Mult(N;w_k(1),w_k(2),…,w_k(N))$，并从该多项式分布中抽样 N 次得到 N 个序号（其中每个序号取值为 0-N 之间的整数），然后，对应序号的粒子复制到一个新粒子集合中，该新粒子集合就是重采样后得到的粒子集合</p></li><li><p>自适应重采样</p><p>  在序列重要性采样中，我们引入重采样机制是为了解决粒子权重退化的问题，但是目前我们使用的方法是在每一代都进行重采样，这种重采样方法时间复杂度比较高，我们希望能够缩减重采样的次数，只在必要时进行重采样，这就是自适应重采样的思想。自适应重采样需要实现规定一个有效粒子的阈值，例如采样N个粒子，规定有效粒子大于 Neff 时不进行重采样，小于 Neff 时通过系统重采样等方法进行重采样。这个阈值通常根据研究问题所选定。</p></li></ul><p><strong>重采样步骤</strong></p><ul><li>t = 0 时刻<ul><li>初始化得到 N 个粒子 $x_0$</li><li>计算 $x_0$ 对应的权重 $w(x_0)$</li><li>根据权重进行重采样</li><li>获取 N 个权重相等的粒子</li></ul></li><li>t &gt; 0 时刻<ul><li>从提议分布 $q(x_t|x_{1:t-1})$ 中进行采样</li><li>计算 $x_t$ 对应的权重 $w(x_t)$</li><li>根据就权重进行重采样</li><li>获取 N 个权重相等的粒子</li></ul></li></ul><p><a href="https://blog.csdn.net/weixin_44044161/article/details/125445579">一篇博客彻底掌握：粒子滤波 particle filter (PF) 的理论及实践（matlab版）_粒子滤波 matlab-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
            <tag> Particle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字滤波器</title>
      <link href="/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数字滤波器"><a href="#数字滤波器" class="headerlink" title="数字滤波器"></a>数字滤波器</h1><p>数字滤波器按照最佳逼近特性可以分为<strong>巴特沃斯Butterworth</strong>，<strong>切比雪夫Chebyshev</strong>，<strong>贝塞尔Bessel</strong>，<strong>椭圆Elliptic</strong>滤波器。按照频带又可以分为<strong>低通，高通，带通，带阻</strong>滤波器，其中高通，带通和带阻滤波器都可以由低通滤波器由频率变换得到。</p><h1 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h1><p>当输入信号频率小于某一截止频率时，低通滤波器能够通过信号，使其保留低频分量，而将高于截止频率的部分信号阻止或者减弱</p><p>传递函数为</p><script type="math/tex; mode=display">G(s)=\frac{G_0w_c^n}{(s+w_c)^n}</script><p>这就是 n 阶低通滤波的传递函数，其中 $w_c$ 就是截至频率， $G_0$ 是通带增益或零频增益</p><h1 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h1><p>当输入信号频率大于某一截止频率时，高通滤波器能够通过信号，使其保留高频分量，而将低于截止频率的部分信号阻止或者减弱</p><p>传递函数为</p><script type="math/tex; mode=display">G(s)=\frac{G_0w_c^ns^n}{(s+w_c)^n}</script><p>这就是 n 阶高通滤波的传递函数，其中 $w_c$ 就是截至频率， $G_0$ 是通带增益或零频增益</p><h1 id="带通滤波器"><a href="#带通滤波器" class="headerlink" title="带通滤波器"></a>带通滤波器</h1><p>当输入信号在某个频率的范围內时，带通滤波器能够通过该信号，使其保留，对于高于或低于这个频率一定范围的频率的信号阻止或衰减</p><p>传递函数为</p><script type="math/tex; mode=display">G(s)=\frac{G_0w_cBs}{s^2+Bs+w_c^2}</script><p>其中 $w_c$ 为目标频率，B 为带通的频宽比，就是 $\frac{带宽}{w_c}$</p><h1 id="带阻滤波器"><a href="#带阻滤波器" class="headerlink" title="带阻滤波器"></a>带阻滤波器</h1><p>将信号同时作用于低通滤波和高通滤波，再将两个路线中的输出信号求和，就是带阻滤波器</p><p>传递函数为</p><script type="math/tex; mode=display">G(s)=\frac{s^n+w_c^n}{(s+w_c)^n}</script><p>其中 $w_c$ 为阻断频率</p><h1 id="巴特沃斯滤波器"><a href="#巴特沃斯滤波器" class="headerlink" title="巴特沃斯滤波器"></a><strong>巴特沃斯滤波器</strong></h1><p> Butterworth 滤波器因其在通带内的幅值特性具有最大平坦的特性而闻名，是四种经典滤波器中最简单的，巴特沃斯滤波器只需要两个参数表征，滤波器的阶数 n 和 -3dB 处的截止频率</p><p>巴特沃斯滤波器的特点是通频带内的频率响应曲线最大限度平坦，没有起伏，而在阻频带则逐渐下降为零。 在振幅的对数对角频率的波特图上，从某一边界角频率开始，振幅随着角频率的增加而逐步减少,趋向负无穷大。一阶巴特沃斯滤波器的衰减率为每倍频6分贝，每十倍频20分贝。二阶巴特沃斯滤波器的衰减率为每倍频12分贝、三阶巴特沃斯滤波器的衰减率为每倍频18分贝、如此类推。巴特沃斯滤波器的振幅对角频率单调下降，并且也是唯一的无论阶数，振幅对角频率曲线都保持同样的形状的滤波器。只不过滤波器阶数越高，在阻频带振幅衰减速度越快。其他滤波器高阶的振幅对角频率图和低阶数的振幅对角频率有不同的形状。</p><p>巴特沃斯低通滤波器的幅度平方函数定义为</p><script type="math/tex; mode=display">|H(j\lambda)|=\frac{1}{1+C^2\lambda^{2n}}</script><p>其中 C 为一常数参数，n 为滤波器阶数， $\lambda$ 为归一化低通截止频率</p><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a><strong>设计步骤</strong></h2><h3 id="设计巴特沃斯低通滤波器指标"><a href="#设计巴特沃斯低通滤波器指标" class="headerlink" title="设计巴特沃斯低通滤波器指标"></a>设计巴特沃斯低通滤波器指标</h3><ul><li>$w_p$ ：通带截止频率</li><li>$\alpha_p$ ：通带最小衰减，单位 dB</li><li>$w_s$ ：阻带开始频率</li><li>$\alpha_s$ ：阻带最大衰减，单位 dB</li></ul><h3 id="计算归一化频率"><a href="#计算归一化频率" class="headerlink" title="计算归一化频率"></a>计算归一化频率</h3><script type="math/tex; mode=display">\lambda_p=\frac{w_p}{w_p}=1\\\lambda_s=\frac{w_s}{w_p}</script><p>当 $\alpha=3dB$ 时， $w_p=w_c$ 为通常意义上的截至频率</p><h3 id="根据设计要求求出阶次-n-和参数-C"><a href="#根据设计要求求出阶次-n-和参数-C" class="headerlink" title="根据设计要求求出阶次 n 和参数 C"></a>根据设计要求求出阶次 n 和参数 C</h3><script type="math/tex; mode=display">C^2=10^{\frac{\alpha_p}{10}}-1\\n\geq\frac{\lg(a)}{\lg(\lambda_s)}</script><p>其中</p><script type="math/tex; mode=display">a=\sqrt{\frac{10^{\frac{\alpha_s}{10}}-1}{10^{\frac{\alpha_p}{10}}-1}}</script><p>注意，当 $\alpha_p=3dB$ 时，C=1</p><h3 id="利用-n-查表"><a href="#利用-n-查表" class="headerlink" title="利用 n 查表"></a>利用 n 查表</h3><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/20150125133854453.jpg" alt="20150125133854453.jpg"></p><p>此时的 $H(s)$ 即为归一化函数</p><h3 id="变换成需要的滤波器"><a href="#变换成需要的滤波器" class="headerlink" title="变换成需要的滤波器"></a>变换成需要的滤波器</h3><p>低通滤波器： $H(s)=H(\frac{s}{w_p})$</p><p>高通滤波器： $H(s)=H(\frac{w_p}{s})$</p><p>最终由于幅值原因，可以加上一个对应的增益，由于幅值的平方为 $|H(j\lambda)|=\frac{1}{1+C^2\lambda^{2n}}$，所以归为 1 时，增益为 $\sqrt{1+C^2\lambda^{2n}}$，其中 $\lambda=1$</p><h1 id="切比雪夫滤波器"><a href="#切比雪夫滤波器" class="headerlink" title="切比雪夫滤波器"></a>切比雪夫滤波器</h1><p>主要是在通带或阻带上频率响应幅度等波纹波动的滤波器</p><h2 id="I-型切比雪夫滤波器"><a href="#I-型切比雪夫滤波器" class="headerlink" title="I 型切比雪夫滤波器"></a>I 型切比雪夫滤波器</h2><p>在通带上频率响应幅度等波纹波动的滤波器称为 I 型切比雪夫滤波器</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/20210402192610503.png" alt="20210402192610503.png"></p><h2 id="II-型切比雪夫滤波器"><a href="#II-型切比雪夫滤波器" class="headerlink" title="II 型切比雪夫滤波器"></a>II 型切比雪夫滤波器</h2><p>在阻带上频率响应幅度等博文波动的滤波器称为 II 型切比雪夫滤波器，也叫做倒数切比雪夫滤波器，但是频率截止速度慢，也需要更多的元件</p><h2 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h2><script type="math/tex; mode=display">H(w)=\sqrt{\frac{1}{1+\varepsilon^2 T_n^2(\frac{w}{w_c})}}</script><p>其中</p><ul><li>$\varepsilon$ 是决定通带内波动幅度大小的波动系数，为小于 1 的正数</li><li>$w_c$ 为规范化的截止频率，可以表示为 $\frac{2\pi f}{f_s}$ 其中 f 为实际的截止频率， $f_s$ 为采样频率</li><li>$T_n(w)$ 是 n 阶切比雪夫多项式</li><li>$A$ 为阻带衰减系数，但是在此并没有出现</li></ul><p>通过双线性变换，可以将连续时间域的传递函数转换为离散时间域的传递函数：</p><script type="math/tex; mode=display">H(z)=H(s),s=\frac{2}{T_s}\frac{1-z^{-1}}{1+z^{-1}}\\\Downarrow\\H(z)=\sqrt{\frac{1}{1+\varepsilon^2 T_n^2(\frac{\frac{2}{T_s}\frac{z-1}{z+1}}{w_c})}}</script><h3 id="第一类切比雪夫多项式"><a href="#第一类切比雪夫多项式" class="headerlink" title="第一类切比雪夫多项式"></a>第一类切比雪夫多项式</h3><script type="math/tex; mode=display">T_0(x)=1\\T_1(x)=x\\T_{n+1}=2xT_n(x)-T_{n-1}(x)\\\Downarrow\\\sum_{n=0}^\infty T_n(x)t^n=\frac{1-tx}{1-2tx+t^2}</script><h3 id="第二类切比雪夫多项式"><a href="#第二类切比雪夫多项式" class="headerlink" title="第二类切比雪夫多项式"></a>第二类切比雪夫多项式</h3><script type="math/tex; mode=display">U_0(x)=1\\U_1(x)=2x\\U_{n+1}=2xU_n(x)-U_{n-1}(x)\\\Downarrow\\\sum_{n=0}^\infty U_n(x)t^n=\frac{1}{1-2tx+t^2}</script><h3 id="设计参数"><a href="#设计参数" class="headerlink" title="设计参数"></a>设计参数</h3><ul><li>通带波动系数 $\varepsilon$，波动系数越大，波动幅度越大</li><li>通带截止频率 $w_c$</li><li>滤波器阶次 $n$，为通带内等幅波动的次数，等于通带最大值和最小值个数。n 越大阻带衰减越快，阶数 n 影响过度带的带宽，同时也影响通带内波动的疏密</li></ul><h2 id="设计步骤-1"><a href="#设计步骤-1" class="headerlink" title="设计步骤"></a>设计步骤</h2><h3 id="设计参数-1"><a href="#设计参数-1" class="headerlink" title="设计参数"></a>设计参数</h3><ul><li>$w_p$ ：通带截止频率</li><li>$\alpha_p$ ：通带最小衰减，单位 dB</li><li>$w_s$ ：阻带开始频率</li><li>$\alpha_s$ ：阻带最大衰减，单位 dB</li></ul><h3 id="计算归一化频率-1"><a href="#计算归一化频率-1" class="headerlink" title="计算归一化频率"></a>计算归一化频率</h3><script type="math/tex; mode=display">\lambda_p=\frac{w_p}{w_p}=1\\\lambda_s=\frac{w_s}{w_p}</script><h3 id="根据设计要求求出阶次-n-和参数-varepsilon"><a href="#根据设计要求求出阶次-n-和参数-varepsilon" class="headerlink" title="根据设计要求求出阶次 n 和参数 $\varepsilon$"></a>根据设计要求求出阶次 n 和参数 $\varepsilon$</h3><script type="math/tex; mode=display">\varepsilon^2=10^{\frac{\alpha_p}{10}}-1\\n\geq\frac{arch(a)}{arch(\lambda_s)}\\a=\frac{\sqrt{10^{\frac{\alpha_p}{10}}-1}}{\varepsilon}</script><h1 id="贝塞尔滤波器"><a href="#贝塞尔滤波器" class="headerlink" title="贝塞尔滤波器"></a>贝塞尔滤波器</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>贝塞尔滤波器的传递函数为</p><script type="math/tex; mode=display">T_n(s)=\frac{B_n(0)}{B_n(s)}</script><p>所以贝塞尔模拟低通滤波器的幅值特性函数为</p><script type="math/tex; mode=display">|T_n(j\omega)|=|\frac{B_n(0)}{B_n(j\omega)}|</script><p>其中 $B_n(s)$ 为贝塞尔多项式，可以通过递推公式得到，如下</p><script type="math/tex; mode=display">B_0=1\\B_1=s+1\\B_n=(2n-1)B_{n-1}+s^2B_{n-2}</script><p>将其写作一般的 n 次多项式为</p><script type="math/tex; mode=display">B_n(s)=s^n+a_{n-1}s^{n-1}+...+a_0</script><p>由公式可以得到 $B_n(s)$ 的各项系数，如下图</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/1718259738275.png" alt="1718259738275.png"></p><p>由上述参数可以计算出贝塞尔幅值相应的极点，如下</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/1718259934344.png" alt="1718259934344.png"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>贝塞尔滤波器是具有线性相位响应的线性滤波器，在整个通频带具有恒定的群时延</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/20181218150914795.png" alt="20181218150914795.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="由滤波器的性能指标确定滤波器的阶数-N"><a href="#由滤波器的性能指标确定滤波器的阶数-N" class="headerlink" title="由滤波器的性能指标确定滤波器的阶数 N"></a>由滤波器的性能指标确定滤波器的阶数 N</h3><p>贝塞尔滤波器不像巴特沃斯和切比雪夫滤波器，有公式来计算滤波器的阶数，贝塞尔滤波器的阶数只能通过给定的性能指标通过已有的设计曲线查找得到，主要通过时延D和通带衰减来确定阶数 N</p><h3 id="计算模拟滤波器参数"><a href="#计算模拟滤波器参数" class="headerlink" title="计算模拟滤波器参数"></a>计算模拟滤波器参数</h3><p>贝塞尔滤波器的极点没有简单的计算公式，只能通过数值方法计算出来，所以滤波器系数通过计算零极点得到。也可以采用查表的方式直接根据滤波器的阶数确定传递函数的系数</p><script type="math/tex; mode=display">T_n(s)=\frac{B_n(0)}{B_n(s)}=\frac{a_0}{a_ns^n+a_{n-1}s^{n-1}+...+a_0}</script><h3 id="s-域频率变换"><a href="#s-域频率变换" class="headerlink" title="s 域频率变换"></a>s 域频率变换</h3><p>原型低通滤波器可以通过 S 域的频率变换得到模拟低通，高通，带通和带阻滤波器，对于低通到低通的变换，只需要做</p><script type="math/tex; mode=display">s=\frac{s}{\Omega_p}</script><p>得到</p><script type="math/tex; mode=display">T_n(s)=\frac{B_n(0)}{B_n(s)}=\frac{a_0}{\frac{a_n}{\Omega_p^n}s^n+\frac{a_{n-1}}{\Omega_p^{n-1}}s^{n-1}+...+a_0}</script><h3 id="双线性变换"><a href="#双线性变换" class="headerlink" title="双线性变换"></a>双线性变换</h3><p>双线性变换将模拟滤波器的传递函数转换到数字滤波器的传递函数。双线性变化法将 s 域的虚轴 映射到 z 域的单位圆上，将 s 域中左半平面的极点映射到单位圆内，是一种保角映射。具体变换方法为用 z 的分式替换 s</p><script type="math/tex; mode=display">s=\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}}</script><p>带入之后可以得到</p><script type="math/tex; mode=display">T_n(z)=\frac{a_0}{\frac{a_n}{\Omega_p^n}(\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}})^n+\frac{a_{n-1}}{\Omega_p^{n-1}}(\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}})^{n-1}+...+a_0}</script><p>最后可以化简为</p><script type="math/tex; mode=display">T_n(z)=\frac{b_nz^{-n}+...+b_1z^{-1}+b_0}{a_nz^{-n}+...+a_1z^{-1}+a_0}</script><h3 id="由差分方程递推计算滤波结果"><a href="#由差分方程递推计算滤波结果" class="headerlink" title="由差分方程递推计算滤波结果"></a>由差分方程递推计算滤波结果</h3><p>由上述 z 域的公式，可以得到离散的滤波器的方程</p><script type="math/tex; mode=display">Y(k)=\sum_{i=0}^{n}X(k-i)-\sum_{i=1}^{n}Y(k-i)</script><h1 id="椭圆滤波器"><a href="#椭圆滤波器" class="headerlink" title="椭圆滤波器"></a>椭圆滤波器</h1><p>又称考尔滤波器，是在通带和阻带等波纹的一种滤波器（它在通带和阻带的波动相同）。椭圆滤波器相比其他类型的滤波器，在阶数相同的条件下有着最小的通带和阻带波动。</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/20210402193417846.png" alt="20210402193417846.png"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>椭圆低通滤波器是一种零、极点型滤波器，它在有限频率范围内存在传输零点和极点</li><li>椭圆低通滤波器的通带和阻带都具有等波纹特性，因此通带，阻带逼近特性良好</li><li>对于同样的性能要求，它比前两种滤波器所需用的阶数都低，而且它的过渡带比较窄。</li><li>椭圆滤波器传输函数是一种较复杂的逼近函数,利用传统的设计方法进行电路网络综合要进行繁琐的计算, 还要根据计算结果进行查表, 整个设计， 调整都十分困难和繁琐。</li></ul><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>椭圆滤波器的传递函数为</p><script type="math/tex; mode=display">T_n(s)=\frac{B_n(0)}{B_n(\frac{s}{\omega_0})}</script><p>其中 $\omega_0$ 为期望截止频率</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>由于整个设计， 调整都十分困难和繁琐，使用 matlab 大大简化设计过程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[n, Wn] = ellipord(wp,ws,Rp,Rs);</span><br><span class="line">[b, a] = ellip(n, Rp, Rs, Wn);</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>wp</code> 通带 <code>0, wp</code> ，通带边界频率 $rad/s$</li><li><code>ws</code> 阻带 <code>ws, 1</code> ，阻带边界频率 $rad/s$</li><li><code>Rp</code> 通带最大波纹</li><li><code>Rs</code> 阻带最小衰减</li><li><code>n</code> 滤波器的阶数</li><li><code>Wn</code> 归一化的低通滤波器截止频率，如果阶数与截止频率不是通过上述函数 <code>ellipord</code> 计算出来的，可以假设截止频率为 $f$ ，则有 $W_n=\frac{2f}{f_s}$</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>对于一个周期信号 $sin(t)$，周期为 $2\pi$，其中混杂着随机信号 $\in [-0.05,0.05]$，采样周期为 0.1s，设计一个滤波器来使之很好的表示</p><h2 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h2><p>相对于目标信号来说，随机信号是一个高频的信号，所以阻高频</p><p>设定截止频率为 $w_c=\frac{2\pi}{T}=1$，选取适当的 $G_0$ 使信号幅值不变</p><script type="math/tex; mode=display">G(s)=\frac{G_0w_c^n}{(s+w_c)^n}=\frac{G_0 1^n}{(s+1)^n}</script><h3 id="一阶"><a href="#一阶" class="headerlink" title="一阶"></a>一阶</h3><script type="math/tex; mode=display">G(s)=\frac{1}{(s+1)}</script><h3 id="二阶"><a href="#二阶" class="headerlink" title="二阶"></a>二阶</h3><script type="math/tex; mode=display">G(s)=\frac{1^2}{(s+1)^2}</script><h2 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h2><p>相对于目标信号来说，随机信号是一个高频的信号，所以需要阻高频，相对来说高通滤波并不是一个很好的选择</p><p>但是如果选择截止频率为 $w_c=1$ 那么剩下的信号就几乎是随机的信号了，取通带增益为 1</p><script type="math/tex; mode=display">G(s)=\frac{G_0w_c^ns^n}{(s+w_c)^n}</script><h3 id="一阶-1"><a href="#一阶-1" class="headerlink" title="一阶"></a>一阶</h3><script type="math/tex; mode=display">G(s)=\frac{1s}{s+1}</script><h3 id="二阶-1"><a href="#二阶-1" class="headerlink" title="二阶"></a>二阶</h3><script type="math/tex; mode=display">G(s)=\frac{1^2s^2}{(s+1)^2}</script><p>最终得到的效果可想而知不咋地</p><h2 id="带通滤波"><a href="#带通滤波" class="headerlink" title="带通滤波"></a>带通滤波</h2><p>对于目标信号来说，只需要让目标信号通过就好</p><p>设定目标频率 $w_c=1$，取通带增益为 1</p><script type="math/tex; mode=display">G(s)=\frac{G_0w_cBs}{s^2+Bs+w_c^2}</script><h3 id="二阶-2"><a href="#二阶-2" class="headerlink" title="二阶"></a>二阶</h3><p>中心频率 $f_c=\frac{1}{6.28}$ 并且相对来说噪声的周期为 0.1s，频率为 $10$，所以带宽可以是 1，则 $B=\frac{1}{f_c}=6.28$， $w_c=1$</p><script type="math/tex; mode=display">G(s)=\frac{6.28s}{s^2+6.28s+1}</script><h2 id="带阻滤波"><a href="#带阻滤波" class="headerlink" title="带阻滤波"></a>带阻滤波</h2><p>对于目标信号来说，尽量阻断噪声就越好</p><p>所以设定阻断频率为噪声频率采样频率 $w_c=62.8$</p><script type="math/tex; mode=display">G(s)=\frac{s^n+w_c^n}{(s+w_c)^n}</script><h3 id="二阶-3"><a href="#二阶-3" class="headerlink" title="二阶"></a>二阶</h3><script type="math/tex; mode=display">G(s)=\frac{s^2+62.8^2}{(s+62.8)^2}</script><p>实际效果并不是很好，说明噪声频率并非是 62.8s，是一个不确定的数</p><h2 id="巴特沃斯滤波"><a href="#巴特沃斯滤波" class="headerlink" title="巴特沃斯滤波"></a>巴特沃斯滤波</h2><p>由于噪声为高频噪声，所以通带截止频率可以设置为信号频率 $w_p=1$，而阻带开始频率可以设置为大于信号频率小于噪声频率 $w_s=2$，也就是只接收目标信号。</p><p>设置通带最大衰减为 $\alpha_p=3$，阻带最小衰减 $\alpha_s=10$</p><h3 id="计算归一化频率-2"><a href="#计算归一化频率-2" class="headerlink" title="计算归一化频率"></a>计算归一化频率</h3><script type="math/tex; mode=display">\lambda_p=1\\\lambda_s=2</script><h3 id="根据设计要求求出阶次和参数"><a href="#根据设计要求求出阶次和参数" class="headerlink" title="根据设计要求求出阶次和参数"></a>根据设计要求求出阶次和参数</h3><script type="math/tex; mode=display">C^2=10^{0.3}-1\Rightarrow C=\sqrt{10^{0.3}-1}=0.9976283\\a=\sqrt{\frac{10^1-1}{10^{0.3}-1}}=3.007131879\\n=\frac{\lg(a)}{\lg(2)}=1.5883881392=2</script><h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><script type="math/tex; mode=display">H(s)=\frac{1}{1+1.4142136s+s^2}</script><p>作为低通滤波器为</p><script type="math/tex; mode=display">H(s)=\frac{w_p^2}{w_p^2+1.4142136w_ps+s^2}</script><p>带入为</p><script type="math/tex; mode=display">H(s)=\frac{1}{1+1.4142136s+s^2}</script><p>并且求出幅值为 $\sqrt{\frac{1}{1+C^2\lambda^{2n}}}=\frac{\sqrt{2}}{2}$，所以最终的传递函数乘上一个增益系数 $\sqrt{1+C^2\lambda^{2n}}=\sqrt{2}$，最终得到结果</p><script type="math/tex; mode=display">H(s)=\frac{1.4142136}{1+1.4142136s+s^2}</script><h2 id="切比雪夫滤波器-1"><a href="#切比雪夫滤波器-1" class="headerlink" title="切比雪夫滤波器"></a>切比雪夫滤波器</h2><p>由于噪声为高频噪声，所以通带截止频率可以设置为信号频率 $w_p=1$，而阻带开始频率可以设置为大于信号频率小于噪声频率 $w_s=2$，也就是只接收目标信号。</p><p>设置通带最大衰减为 $\alpha_p=3$，阻带最小衰减 $\alpha_s=10$</p><h3 id="计算归一化频率-3"><a href="#计算归一化频率-3" class="headerlink" title="计算归一化频率"></a>计算归一化频率</h3><script type="math/tex; mode=display">\lambda_p=1\\\lambda_s=2</script><h3 id="根据设计要求求出阶次和参数-1"><a href="#根据设计要求求出阶次和参数-1" class="headerlink" title="根据设计要求求出阶次和参数"></a>根据设计要求求出阶次和参数</h3><script type="math/tex; mode=display">\varepsilon^2=10^{0.3}-1\Rightarrow \varepsilon=\sqrt{10^{0.3}-1}=0.9976283=1\\a=\frac{\sqrt{10^{\frac{\alpha_p}{10}}-1}}{\varepsilon}=1\\n\geq\frac{arch(1)}{arch(2)}=\frac{0.648054}{0.265802}=2.4381\Rightarrow n=3</script><h3 id="I-型"><a href="#I-型" class="headerlink" title="I 型"></a>I 型</h3><script type="math/tex; mode=display">T_3(x)=2x^2-1\\\Downarrow\\H(s)=\sqrt{\frac{1}{1+\varepsilon^2(2\frac{s}{w_c}^2-1)^2}}\\\Downarrow \\H(s)=\sqrt{\frac{1}{4s^4-4s^2+2}}</script><h3 id="II-型"><a href="#II-型" class="headerlink" title="II 型"></a>II 型</h3><script type="math/tex; mode=display">U_3(x)=4x^2-1\\\Downarrow\\H(s)=\sqrt{\frac{1}{1+\varepsilon^2(4\frac{s}{w_c}^2-1)^2}}\\\Downarrow\\H(s)=\sqrt{\frac{1}{16s^4-8s^2+2}}</script><p>最终求得传递函数，也可以通过查表法来得到归一化后的传递函数</p>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QP二次规划</title>
      <link href="/Blog_ButterFly/2024/03/19/QP%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/"/>
      <url>/Blog_ButterFly/2024/03/19/QP%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><p>对于一个函数 $F:R^n→R^m$ 是一个将欧式 n 维空间的函数，该函数由 m 个实函数构成， $y_1(x_1,…,x_n),…,y_m(x_1,…,x_n)$</p><h3 id="Jacobian-矩阵"><a href="#Jacobian-矩阵" class="headerlink" title="Jacobian 矩阵"></a>Jacobian 矩阵</h3><p>函数 F 的偏导数组成一个 m 行 n 列的矩阵，就是 Jacobian 矩阵</p><script type="math/tex; mode=display">J_F(x_1,...,x_n)=\begin{bmatrix}\frac{\partial y_1}{\partial x_1}&...&\frac{\partial y_1}{\partial x_n}\\...&...&...\\\frac{\partial y_m}{\partial x_1}&...&\frac{\partial y_m}{\partial x_n}\end{bmatrix}</script><p>也可以表示为 $\frac{\partial(y_1,…,y_m)}{\partial (x_1,…,x_n)}$。如果对于一个 $p\in R^n$ ，函数 F 在 p 点可微，则 F 在这一点的导数由 $J_F(p)$ 给出</p><h3 id="Hessian-矩阵"><a href="#Hessian-矩阵" class="headerlink" title="Hessian 矩阵"></a>Hessian 矩阵</h3><p>如果 F 的所有二阶导数都存在，则 F 的 Hessian 矩阵为</p><script type="math/tex; mode=display">H_F(x_1,...,x_n)=\begin{bmatrix}\frac{\partial^2 F}{\partial x_1^2}&...&\frac{\partial^2 F}{\partial x_1\partial x_n}\\...&...&...\\\frac{\partial^2 F}{\partial x_n\partial x_1}&...&\frac{\partial^2 F}{\partial x_n^2}\end{bmatrix}</script><p>可以利用二阶导数的值判断梯度下降的速度</p><h2 id="二次规划-QP"><a href="#二次规划-QP" class="headerlink" title="二次规划 QP"></a>二次规划 QP</h2><p>二次规划(QP, Quadratic Programming)定义：目标函数为二次函数，约束条件为线性约束，属于最简单的一种非线性规划。说白了就是一种对于控制理论的一种优化，约束条件和线性规划问题的约束条件一样，都是线性等式或线性不等式。即</p><script type="math/tex; mode=display">\left\{\begin{aligned}&min\frac{1}{2}x^TGx+H^Tx&&\\&a_i^Tx\leq b_i&&i\in I=\{1...m\}\\&a_i^Tx=b_i&&i\in \varepsilon = \{m+1,...m+l\}\end{aligned}\right.</script><p>其中 $\varepsilon$ 表示等式约束的指标集， $I$ 表示不等式约束的指标集</p><p>一般二次规划问题可以分成以下几类</p><ul><li>凸二次规划问题：G半正定，问题有全局解</li><li>严格凸二次规划问题：G正定，问题有唯一全局解</li><li>一般二次规划问题：G不定，问题有稳定点或局部解</li></ul><h3 id="Language-乘数法"><a href="#Language-乘数法" class="headerlink" title="Language 乘数法"></a>Language 乘数法</h3><p>求函数 $f(x,y)$ 在条件 $\phi (x,y)=0$ 约束下的可能极值点，构造 language 函数，即</p><script type="math/tex; mode=display">L(x,y,\lambda)=f(x,y)+\lambda \phi(x.y)</script><p>求偏导得</p><script type="math/tex; mode=display">L_x=f_x+\lambda \phi_x\\L_y=f_y+\lambda \phi_y\\L_\lambda = \phi</script><p>令上式均为 0 可以解出 $x,y,\lambda$ 的值，其中的 $x,y$ 就是可能的极值点的坐标。对于多个约束条件可以引入多个 $\lambda$ ，求解与上述一致</p><h3 id="KKT-条件"><a href="#KKT-条件" class="headerlink" title="KKT 条件"></a>KKT 条件</h3><ol><li><p><strong>KKT 条件核心思想</strong></p><p> 对于一个不等式约束的方程</p><p> 最小化问题</p><script type="math/tex; mode=display"> \min f(x)\\g(x)\leq 0</script><p> 最大化问题</p><script type="math/tex; mode=display"> \max f(x)\\g(x)\geq 0</script><p> 首先先不考虑约束 $g(x)$，直接对 $f(x)$ 求导，最终能得到一个最优值 $x^\star $，接下来把最优值带入到约束中，会有三种情况</p><ul><li><p>满足 $g(x)$ 约束但是 $g(x)\not =0$</p><p>  正好满足约束，最优解为 $x^\star $，但是实际上这个约束并没有起作用，问题实际上转化为无约束优化问题，但是同样的构造 Language 函数</p><script type="math/tex; mode=display">  L(x,\lambda)=f(x)+\lambda g(x)</script><p>  由于此时约束无用，也就可以把 $\lambda=0$，最终实际上是把约束条件给转为 0，也就没有约束</p></li><li><p>$g(x)=0$</p><p>  最优解 $x^\star $ 使得约束为等号，正好在约束的边界上，此时就是 Language 乘数法所能解决的，构造函数</p><script type="math/tex; mode=display">  L(x,\lambda)=f(x)+\lambda g(x)</script></li><li><p>不满足 $g(x)$ 的约束</p><p>  显然此时不满足约束，结果被舍弃，最终的结果一定在满足约束条件的范围内</p><p>最终满足条件的两种情况中的 Language 方程可以统一为 $\lambda g(x^\star )=0$，这就是 KKT 条件的精髓</p></li></ul></li><li><p><strong>公式</strong></p><p> 首先给出一个仅含有不等式约束</p><script type="math/tex; mode=display"> \left\{\begin{aligned}\min f(x)\\g(x)\leq 0\end{aligned}\right.\Rightarrow KKT\left\{\begin{aligned}&\triangledown f(x^\star )+\lambda \triangledown g(x^\star )=0\\&\lambda g(x^\star )=0\\&\lambda\geq 0\\&g(x^\star )\leq 0 \end{aligned}\right.</script><p> 依旧需要引入 Language 函数</p><script type="math/tex; mode=display"> L(x,\lambda)=f(x)+\lambda g(x)</script><p> 对于上述 KKT 条件中</p><ul><li>1式：对拉格朗日函数求梯度(若X一维就是求导)，其中，下三角表示梯度</li><li>2式：核心公式 $\lambda=0$ 或 $g(x^\star )=0$，但是此处要求不能同时为 0</li><li>3式：Language 乘子 $\lambda$ 必须是正的</li><li><p>4式：原约束</p><p>上述中 1，2式可以求出最优的 $x^\star ,\lambda^\star $，但是由于 2 式需要两种情况，所以存在多个最优解，而3，4 式主要是验证先前的结果是否满足条件。一般问题的解析分为两种情况</p></li><li><p>$\lambda=0$ 计算 $x^\star $ 并且验证 4式条件</p></li><li><p>$\lambda\not=0$ 计算 $x^\star ,\lambda^\star $，并且验证3，4式条件</p><p>将不等式与等式条件推广，可以得到多个约束的公式</p><script type="math/tex; mode=display">\min f(x)\\g_i(x)\leq 0,i\in[1,m]\Rightarrow m 个不等式约束\\h_j(x)=0,j\in[1,n]\Rightarrow n个等式约束</script><p>对应的 Language 函数为</p><script type="math/tex; mode=display">L(x,\{\lambda_i\},\{\mu_j\})=f(x)+\sum_{i=1}^m\lambda_ig_i(x)+\sum_{j=1}^n\mu_jh_j(x)</script><p>其中的参数 $\{\lambda_i\},\{\mu_j\}$ 表示多个约束</p><p>对应的 KKT 条件为</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\triangledown f(x^\star )+\sum_{i=1}^m\lambda_i \triangledown g_i(x^\star )+\sum_{j=1}^n\mu_j\triangledown h_j(x^\star )=0\\&\lambda_i g_i(x^\star )=0,i\in[1,m]\\&\lambda_i\geq 0,i\in[1,m]\\&g(x^\star )\leq 0,i\in[1,m]\\&h_j(x^\star )=0,j\in [1,n] \end{aligned}\right.</script><p>这个实质上是几个不等式与等式约束，与之前的解法一致，利用等式求解，用不等式验证。由于上述公式中有 m 个 Language 乘子，每个都有两种情况，所以就是 $2^m$ 种。但是能解出最优解的一定是等式，而不等式是排除解的方法。</p></li></ul></li><li><p>充分性必要性说明</p><p> <strong>KKT 条件是判断某点是极值点的必要条件，不是充分条件。KKT 的解不一定是最优解，但是最优解一定满足 KKT 条件。</strong></p><p> 对于 <strong>凸规划</strong>，KKT 条件是<strong>充要条件</strong>，只要满足 KKT 条件，则一定极值点，并且得到的一定是全局最优解。</p><p> 凸规划是指目标函数为凸函数，不等式约束函数也为凸函数，等式约束函数是仿射的（理解为线性的也可以）。对于凹函数实际上就是凸函数加负号，本质是一样的。</p></li><li><p>Min/Max与 $\leq 0/\geq 0$ 的规定</p><p> 也就是</p><ul><li>如果目标为最小化Min问题，那么不等式约束就要整理为 $\leq 0$ 形式</li><li><p>如果目标为最小化Max问题，那么不等式约束就要整理为 $\geq 0$ 形式</p><p><img src="/Blog_ButterFly/2024/03/19/QP%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/v2-052b0104b46e31fa4d7a05e9c6f3d2b5_720w.webp" alt="v2-052b0104b46e31fa4d7a05e9c6f3d2b5_720w.webp"></p><p>由于梯度指的是函数下降的方向，所以垂直于等值线。如图在最优解点， $f(x^\star )$ 和 $g(x^\star )$ 梯度方向共线方向相反，这在数学上写法是</p><script type="math/tex; mode=display">-\triangledown f(x^\star )=\lambda \triangledown g(x^\star )\\\Downarrow\\\triangledown f(x^\star )+\lambda \triangledown g(x^\star )=0</script><p>这实际上就是 KKT 条件的第一个等式，而且由于 $g(x)$ 的梯度方向与 $f(x)$ 负梯度方向相同，这就是KKT条件中的一个条件 $\lambda ≥ 0$</p><p>但是如果对于最大化问题，约束为 $g(x)\leq 0$，此时 $g(x^\star )$ 梯度方向与 $f(x^\star )$ 方向相同，所以上述公式就变为 <strong>两项做差</strong> 或者 $\lambda&lt;0$，实际上结果是没有变化的。</p><p>对于两个约束来说</p><p><img src="/Blog_ButterFly/2024/03/19/QP%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/v2-978615fba2aa975e0f4f7f28fdfbc103_720w.webp" alt="v2-978615fba2aa975e0f4f7f28fdfbc103_720w.webp"></p><p>那就可以表示为向量相加的结果</p><script type="math/tex; mode=display">-\triangledown f(x^\star )=\lambda_1\triangledown g_1(x^\star )+\lambda_2 \triangledown g_2(x^\star )\\\Downarrow \\\triangledown f(x^\star )+\lambda_1\triangledown g_1(x^\star )+\lambda_2 \triangledown g_2(x^\star )=0</script><p>这也是 KKT 条件的第一个等式</p></li></ul></li><li><p><strong>正则性条件/约束规范说明</strong></p><p> KKT 条件对于目标函数和约束函数也是有要求的，目标函数和约束函数均可为连续可微函数。</p><p> 正则性条件/约束规范：以下方程组是线性独立的</p><script type="math/tex; mode=display"> \triangledown g_i(x^\star ):i\in I(x^\star )\cup \triangledown h_j(x^\star ):j\in[1,n]</script><p> 其中 $I(x^\star )$ 指的是起作用约束的集合</p></li></ol><p>下面的KKT，以后再来探索吧</p><p><a href="https://zhuanlan.zhihu.com/p/556832103">KKT条件，原来如此简单 | 理论+算例实践 - 知乎 (zhihu.com)</a></p><p><a href="https://www.bilibili.com/video/BV1LF411i768/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=db5379825ad45958538bdf4749e19b7a">最优化（3）KKT条件为什么用不了了_哔哩哔哩_bilibili</a></p><h1 id="QP——等式约束"><a href="#QP——等式约束" class="headerlink" title="QP——等式约束"></a>QP——等式约束</h1><h2 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a><strong>一般形式</strong></h2><script type="math/tex; mode=display">\left\{\begin{aligned}min\ \frac{1}{2}x^TGx+h^Tx\\A^Tx=b\end{aligned}\right.</script><p>其中 $b\in R^m,A\in R^{n\times m},rank(A)=m, n&gt;m$</p><p>其中 $G$ 是由二阶导构成的 hessian 矩阵</p><h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="变量消去法"><a href="#变量消去法" class="headerlink" title="变量消去法"></a>变量消去法</h3><p><strong>步骤</strong></p><ol><li>将 $x$ 分成基本变量 $x_B$与非基本变量 $x_N$ 两部分，利用等式约束将基本变量用非基本变量表示出来</li><li>再将基本变量带入目标函数，从而消去基本变量，把问题化为一个关于非基本变量的无约束最优化问题</li><li>最后求解无约束最优化问题的方法解之</li></ol><p><strong>具体步骤</strong></p><p>将 A 分块，使其包含一个 $m \times m$ 非奇异矩阵 $A_B,x,h$ 做对应的分块</p><script type="math/tex; mode=display">x=\begin{bmatrix}x_B\\x_N\end{bmatrix},A=\begin{bmatrix}A_B\\A_N\end{bmatrix},G=\begin{bmatrix}G_{BB}&&G_{BN}\\G_{NB}&&G_{NN}\end{bmatrix},h=\begin{bmatrix}h_B\\h_N\end{bmatrix}</script><p>所以等式约束 $A^Tx=b$ 转化为</p><script type="math/tex; mode=display">\begin{bmatrix}A_B\\A_N\end{bmatrix}^T\begin{bmatrix}x_B\\x_N\end{bmatrix}=b \rightarrow A_Bx_B+A_Nx_N=b</script><p>更换以下变量位置</p><script type="math/tex; mode=display">x_B=A_B^{-1}b-A_B^{-1}A_Nx_N</script><p>则</p><script type="math/tex; mode=display">x=\begin{bmatrix}x_B\\x_N\end{bmatrix}=\begin{bmatrix}A_B^{-1}b-A_B^{-1}A_Nx_N\\x_N\end{bmatrix}=\begin{bmatrix}A_B^{-1}\\0\end{bmatrix}+\begin{bmatrix}-A_B^{-1}A_N\\I\end{bmatrix}x_N=x_0+Zx_N</script><p>转变为一个 $x=x_0+Zx_N$ 的形式，将其带入目标函数，消去基本变量，问题变为一个关于非基本变量的无约束最优化问题</p><p>将上式带入目标函数中</p><script type="math/tex; mode=display">min\ f(x)=\frac{1}{2}x^TGx+h^Tx=\frac{1}{2}(x_0+Zx_N)^TG(x_0+Zx_N)+h^T(x_0+Zx_N)</script><p>其中除了 $x_N$ 其他都是已知的常数项，由于常数项不影响优化结果，所以优化过程中省略常数项。另外找到所有的 $x_N^TPx_N$ 和 $Qx_N$ 的形式的项，可得如下形式：</p><script type="math/tex; mode=display">\left\{\begin{aligned}min\ f(x)&=\frac{1}{2}x_N^TPx_N+\frac{1}{2}Z^Tx_N^TGx_0+\frac{1}{2}x_0^TGZx_N+\frac{1}{2}x_0^TGx_0+Qx_N\\P&=Z^TGZ\\Q&=x_0^TGZ+h^TZ\end{aligned}\right.</script><p>求最值实际上求 $\dot{f(x)}=0$ 即可，即</p><script type="math/tex; mode=display">\dot{f(x)} = \frac{1}{2}Z^T(G+G^T)Zx_N+\frac{1}{2}Z^T(G+G^T)x_0+Q^T=0</script><p>如果想要有唯一最优解，必须满足 $Z^T(G+G^T)Z$ 正定</p><h3 id="Language-法"><a href="#Language-法" class="headerlink" title="Language 法"></a>Language <strong>法</strong></h3><p><strong>步骤</strong></p><p>等式约束的二次规划的 Lagrange 函数为</p><script type="math/tex; mode=display">L(x,\lambda)=\frac{1}{2}x^TGx+h^Tx+\lambda (A^Tx-b)</script><p>其中 $\lambda$ 称为 Lagrange 乘数，正负都有可能。Lagrange乘数法将原本的约束优化问题转换成等价的无约束优化问题，即</p><script type="math/tex; mode=display">\underset{x,\lambda}{min} \ L(x,\lambda)</script><p>计算 $L$ 对 $x$ 和 $\lambda$ 的偏导，并且设为零，可得最优解的必要条件</p><script type="math/tex; mode=display">\left\{\begin{aligned}\frac{\partial L}{\partial x}&=Gx+h+\lambda =0 && 定常方程式\\\frac{\partial L}{\partial \lambda}&=A^Tx-b=0&&约束条件\end{aligned}\right.</script><p>表示为方程组</p><script type="math/tex; mode=display">\begin{bmatrix}G&&A\\A^T&&0\end{bmatrix}\begin{bmatrix}x\\\lambda\end{bmatrix}=\begin{bmatrix}-h\\b\end{bmatrix}</script><p>求解之后得到最优解</p><h3 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h3><p>变量消去法其实是转化成了一个 n - m 维的问题，也就是说求解 n − m 个方程组就能解决这个问题。而 Lagrange法是将其转化成一个 n + m 维的问题，即 n 个变量， m 个乘子。所以可见，如果模型维度太大，建议使用变量消去法，很直观，使用非基数来表示基变量，但是由于需要计算 $A_B^{-1}$ ，当 $A_B$ 接近奇异时会导致误差很大</p><h1 id="QP——不等式约束"><a href="#QP——不等式约束" class="headerlink" title="QP——不等式约束"></a>QP——不等式约束</h1><p>一个标准的等式不等式联合约束 QP 原模型</p><script type="math/tex; mode=display">\min \frac{1}{2}x^THx+g^Tx\\a_i^Tx=b_i,i\in E\\h_j^Tx\leq t_j,j\in I</script><p>$i\in E$ 表示的是 m 个等式约束集合， $i\in I$ 表示的是 n 个不等式约束集合。对于不等式约束下的 QP 问题有多种求解方法</p><p>并且由</p><script type="math/tex; mode=display">f(x)=\frac{1}{2}x^THx+g^Tx\\g_i(x)=ax_i-b_i\\h_i(x)=h_i^Tu-t_i</script><h2 id="求解方法-1"><a href="#求解方法-1" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="Lagrange乘数法与KKT条件"><a href="#Lagrange乘数法与KKT条件" class="headerlink" title="Lagrange乘数法与KKT条件"></a><strong>Lagrange乘数法与KKT条件</strong></h3><p><strong>一般形式</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}min\ \dot{f(x)}\\g(x)\leq 0\end{aligned}\right.</script><p>其中约束不等式 $g(x)\leq 0$ 称为<strong>原始可行性</strong>，可以定义可行域</p><script type="math/tex; mode=display">K=\{x\in R^n|g(x)\leq0\}</script><p>假设 $x^\star $ 为满足约束条件的最佳解，分两种情况讨论</p><ul><li><p>$g(x^\star )&lt;0$ 最佳解位于 K 的内部，称为内部解(interior solution)，这时<strong>约束条件是无效</strong>的 (inactive)</p><p>  <strong>必要条件</strong></p><p>  约束条件无效的情况下， $g(x)$ 不起作用，约束优化问题退化为无约束优化问题， 因此驻点 $x^\star $ 满足 $\nabla f=0且\lambda=0$</p></li><li><p>$g(x^\star )=0$ 最佳解位于 K 的边界，称为边界解(boundarysolution)，这时约束条件是有效的 (active)</p><p>  <strong>必要条件</strong></p><p>  在约束条件有效的情形下，约束不等式变成等式 $g(x)=0$，这与前述 Lagrange 乘数法的情况相同，可以证明驻点 $x^\star $ 发生于 $\nabla f\in span \nabla g$，其中 span 是生成子空间。即 $\exist \lambda\rightarrow \nabla f=-\lambda \nabla g$，并且这里的正负号有意义。因此我们希望最小化 $f$，梯度 $\nabla f$ （函数 $f$ 在点 x  的最陡上升方向），应该指向可行域 K 的内部，因为最优解是在边界取到的，但同时 $\nabla g$ 指向 K 的外部（ $g(x)&gt;0$ ）的区域，因为约束是 $g(x)\leq 0$，因此 $\lambda \geq 0$ ，称为<strong>对偶可行性</strong></p></li></ul><p>因此，不论是内部解或者边界解， $\lambda g(x)=0$ 恒成立，称为<strong>互补松弛性</strong>。综合上述两种情况，最佳解的必要条件包括 Lagrange 函数 $L(x,\lambda)$ 的<strong>定常方程式，原始可行性，对偶可行性，互补松弛性</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&\nabla_x L=\nabla f+\lambda \nabla g=0\\&g(x)\leq 0\\&\lambda\geq 0\\&\lambda g(x) =0\end{aligned}\right.</script><p>这些条件合称为Karush-Kuhn-Tucker (<strong>KKT</strong>)条件。如果我们要最大化 $f(x)$ 且受限于 $g(x)\leq0$，那么对偶可行性要改成 $\lambda \leq 0$</p><p><strong>标准约束优化</strong></p><p>考虑标准优化问题，即非线性规则</p><script type="math/tex; mode=display">\left\{\begin{aligned}&min\ f(x)\\&g_j(x)=0&&j=1…m\\&h_k(x)\leq 0&&k=1…p\end{aligned}\right.</script><p>定义 Lagrange 函数</p><script type="math/tex; mode=display">L(x,\{\lambda_j\},\{u_k\})=f(x)+\sum_{j=1}^m{\lambda_j g_j(x)}+\sum_{k=1}^pu_kh_k(x)</script><p>其中 $\lambda_j$ 是对应 $g_j(x)=0$ 的 Lagrange 乘数， $u_k$ 是对应 $h_k(x)\leq 0$ 的 Lagrange 乘数，或称为 KKT乘数。KKT条件包括<strong>定常方程式，原始可行性，对偶可行性，互补松弛性</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&\nabla_x L=0\\&g(x)= 0&&j=1...m\\&h_k(x)\leq0\\&u_k\geq 0\\&u_kh_k(x)=0&&k=1...p\end{aligned}\right.</script><p><strong>栗子</strong></p><ol><li><p>对于这个问题</p><script type="math/tex; mode=display"> \left\{\begin{aligned}min\ x_1^2+x_2^2\\x_1+x_2=1\\x_2\leq \alpha\end{aligned}\right.</script><p> 其中 $(x_1,x_2)\in R^2$ ， $\alpha$ 为实数，写出 Lagrange 函数</p><p> $L(x_1,x_2,\lambda,\mu)=x_1^2+x_2^2+\lambda (1-x_1-x_2)+\mu (x_2-\alpha)$</p><p> KKT 方程组</p><script type="math/tex; mode=display"> \left\{\begin{aligned}&\frac{\partial  L}{\partial x_i}=0&&i=1,2\\&x_1+x_2=1\\&x_2-\alpha\leq0\\&u\geq 0\\&u(x_2-\alpha)=0\end{aligned}\right.</script><p> 求偏导为</p><script type="math/tex; mode=display"> \left\{\begin{aligned}\frac{\partial L}{\partial x_1}&=2x_1-\lambda = 0\\\frac{\partial L}{\partial x_2}&=2x_2-\lambda + \mu=0\end{aligned}\right.</script><p> 解得</p><script type="math/tex; mode=display"> \left\{\begin{aligned}x_1&=\frac{\lambda}{2}\\x_2&=\frac{\lambda-\mu}{2}\end{aligned}\right.</script><p> 带入约束等式，得</p><script type="math/tex; mode=display"> x_1+x_2=\lambda-\frac{\mu}{2}=1</script><p> 合并结果为</p><script type="math/tex; mode=display"> \left\{\begin{aligned}x_1&=\frac{\mu}{4}+\frac{1}{2}\\x_2&=-\frac{\mu}{4}+\frac{1}{2}\end{aligned}\right.</script><p> 加入约束不等式</p><script type="math/tex; mode=display"> -\frac{\mu}{4}+\frac{1}{2}\leq \alpha \Rightarrow \mu\geq 2-4\alpha</script><p> 分3种情况讨论</p><ul><li>$\alpha &gt; \frac{1}{2}$ 则对于 $u=0&gt;2-4\alpha$ 满足所有的KKT条件，约束不等式无效， $x_1^\star =x_2^\star =\frac{1}{2}$ 是内部解，目标函数的极小值为  $\frac{1}{2}$</li><li>$\alpha = \frac{1}{2}$ 则 $u=0=2-4\alpha$ 满足所有的KKT条件， $x_1^\star =x_2^\star =\frac{1}{2}$ 是内部解，因为 $x_2^\star =\alpha$，即满足 $x_2^\star -\alpha=0$</li><li>$\alpha&lt;\frac{1}{2}$ 这时约束不等式是有效的，$u=2-4\alpha&gt;0$，则 $x_1^\star =1-\alpha$ 且 $x_2^\star =alpha$，目标函数的极小值为 $(1-\alpha)^2+\alpha^2$</li></ul></li><li><p>标准约束优化</p><script type="math/tex; mode=display"> \left\{\begin{aligned}&min\ f(x)=-2x_1^2-x_1^2\\&x_1^2+x_2^2-x=0\\&-x_1+x_2\geq 0\\&x_1\geq 0,x_2\geq 0\end{aligned}\right.</script><p> 试验证 $x^\star =(1,1)^T$ 为KKT点，并求出问题的 KKT 对</p><script type="math/tex; mode=display"> \left\{\begin{aligned}f(x)&=-2x_1^2-x_1^2\\g(x)&=x_1^2+x_2^2-2\\h_1(x)&=x_1-x_2\\h_2(x)&=-x_1\\h_3(x)&=-x_2\end{aligned}\right.</script><p> 求梯度，得到</p><script type="math/tex; mode=display"> \nabla f(x)=\begin{bmatrix}-4x_1\\-2x_2\end{bmatrix},\nabla g(x)=\begin{bmatrix}2x_1\\2x_2\end{bmatrix}\\\nabla h_1(x)=\begin{bmatrix}1\\-1\end{bmatrix},\nabla h_2(x)=\begin{bmatrix}-1\\0\end{bmatrix},\nabla h_3(x)=\begin{bmatrix}0\\-1\end{bmatrix}</script><p> 把 $x^\star =(1,1)^T$ 带入以上的式子，由KKT条件得</p><script type="math/tex; mode=display"> \left\{\begin{aligned}-4+2\lambda +\mu_1-\mu_2=0\\-2+2\lambda -\mu_1+\mu_3=0\end{aligned}\right.</script><p> 由于</p><script type="math/tex; mode=display"> \left\{\begin{aligned}\mu_2h_2(x)=0\\\mu_3h_3(x)=0\end{aligned}\right.\rightarrow \left\{\begin{aligned}\mu_2^\star =0\\\mu_3^\star =0\end{aligned}\right. \Rightarrow \left\{\begin{aligned}-4+2\lambda +\mu_1=0\\-2+2\lambda -\mu_1=0\end{aligned}\right. \Rightarrow \left\{\begin{aligned}&\lambda^\star =1.5\\&\mu_1^\star =1\end{aligned}\right.</script><p> 这表明 $x^\star $ 是KKT点， $(x^\star ,(\lambda^\star ,\mu^\star ))$是KKT对，其中</p><script type="math/tex; mode=display"> \left\{\begin{aligned}&\lambda^=1.5\\&\mu^\star =\begin{bmatrix}1&0 &0\end{bmatrix}^T\end{aligned}\right.</script></li></ol><h3 id="内点法"><a href="#内点法" class="headerlink" title="内点法"></a><strong>内点法</strong></h3><p><strong>基本思想</strong></p><p>将优化问题的可行域视为一个凸集，并通过一个内点序列来逐步接近最优解，而不是像单纯形法那样在顶点上进行搜索。在内点法中，每个内点表示一个可行解，而算法将不断迭代，使内点逐渐接近最优解。通过在内点附近构造一个特定的路径，内点法可以在有限的步数内找到最优解</p><p><strong>步骤</strong></p><script type="math/tex; mode=display">\left\{\begin{aligned}&min\ f(x)\\&g_j(x)=0&&j=1…m\\&h_(x)\leq 0&&k=1…p\end{aligned}\right.</script><p>写出对应的 Lagrange 函数</p><script type="math/tex; mode=display">L(x,\{\lambda_j\},\{u_k\})=f(x)+\sum_{j=1}^m{\lambda_j g_j(x)}+\sum_{k=1}^pu_kh_k(x)</script><p>对应的 KKT 条件为</p><script type="math/tex; mode=display">\left\{\begin{aligned}&Gx+c-A^T_{\varepsilon}\lambda-A^T_{I}\mu=0\\&a_i^Tx\leq b_i&i\in I\\&a_i^Tx=b_i&i\in \varepsilon\\&\mu_i\geq0&i\in I\\&\mu_i(a_i^Tx-b_i)=0&i\in I\end{aligned}\right.</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{aligned}A_{\varepsilon}=\{a_i^T\}_{i\in \varepsilon} \in R^{m_1\times n}\\A_I=\{a_i^T\}_{i \in I}\in R^{m_2\times n}\end{aligned}\right.</script><p>相当于把两组不同的约束做了拆分。</p><p>可以添加一组松弛变量</p><script type="math/tex; mode=display">\left\{\begin{aligned}&Gx+c-A^T_{\varepsilon}\lambda-A^T_{I}\mu=0\\&A_{\varepsilon}-b_{\varepsilon}=0\\&A_Ix-b_I-y=0\\&(\mu,y)\geq0&i\in I\\&\mu_iy_i=0&i\in I\end{aligned}\right.</script><p>这里的 $b_{\varepsilon},b_I$ 和之前的意思类似，就是根据不同的指标集把b区分成不同的两个列向量</p><p>写成函数的形式</p><script type="math/tex; mode=display">F(x,y,\lambda,\mu)=\begin{bmatrix}&Gx+c-A^T_{\varepsilon}\lambda-A^T_{I}\mu\\&A_{\varepsilon}-b_{\varepsilon}\\&A_Ix-b_I-y\\&U Y1\end{bmatrix}</script><p>其中 $U, Y\in R^{n_2\times n_2}$，最终的目的就是 $F(x,y,\lambda,\mu)=0$，再加上 $(\mu, y)\geq 0$ 就是完整的KKT条件了</p><p>可以适当添加一个松弛条件，即解方程</p><script type="math/tex; mode=display">F(x,y,\lambda,\mu)=\begin{bmatrix}0\\0\\0\\\tau 1\end{bmatrix}</script><p>由于要求 $(\mu,y)&gt;0$ ，所以不断缩小 $\tau \rightarrow 0$，就是最终的解</p><p>求解这个方程的解就需要求解 jacobi 矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}G&0&-A_{\varepsilon}^T&-A_I^T\\A_{\varepsilon}&0&0&0\\A_I&-I&0&0\\0&U&0&Y\end{bmatrix}\begin{bmatrix}\Delta x\\\Delta y\\\Delta \lambda\\\Delta\mu\end{bmatrix}=\begin{bmatrix}-r^d\\-r^p\\-r^y\\-UY1+\sigma \beta 1\end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\beta=\frac{y^T\lambda}{m_2}\\&\sigma \in(0,1)作为一个系数\\&r^d=Gx+c-A^T_{\varepsilon}\lambda-A^T_{I}\mu\\&r^p=A_{\varepsilon}-b_{\varepsilon}\\&r^y=A_Ix-b_I-y\end{aligned}\right.</script><h3 id="积极集法"><a href="#积极集法" class="headerlink" title="积极集法"></a><strong>积极集法</strong></h3><p>积极集法就是一堆active的约束条件的集合。active的定义是：给定任意一个在可行域内的点x，即可行解，在x下，不等式约束条件取到等号。即在 $x=x^\star $ 这个可行解下 $g(x)\geq0⇒g(x^\star )=0$</p><p>active set 里面包括了所有的等式约束以及一些可以取到等号的不等式约束</p><p>方法核心思想：如果我们知道最优点处的active的约束，就可以把那些inactive的约束条件都剔除掉，将带不等式约束的二次规划问题转变为等式约束的二次规划问题，降低搜索解的复杂度。但其有一个前提，给定的迭代的起始点要是一个可行解。</p><p><img src="/Blog_ButterFly/2024/03/19/QP%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/v2-c1427e8a1b7aa97c1285db48ff207842_720w.jpg" alt="v2-c1427e8a1b7aa97c1285db48ff207842_720w.jpg"></p><p><strong>算法流程</strong></p><p><img src="/Blog_ButterFly/2024/03/19/QP%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/v2-1b214a8477d49125d77f520d8fb972b2_720w.webp" alt="v2-1b214a8477d49125d77f520d8fb972b2_720w.webp"></p><p>图中的p是一个当前迭代点的改进方向，每次迭代，我们把从约束条件集合中拿出来的约束条件假设为active约束条件进行尝试，加入的集合称为工作集，这个集合是随着迭代不断变化的。如果第k次的迭代点 $x_k$ 不是当前工作集下的最优点，就通过求解当前工作集下的active约束的QP问题来得到一个最优解x，工作集也有可能为空，即求解原QP问题在无约束条件下的最优解，方向 $p=x^\star -x_k$， $x_k$ 朝着p移动可以使得QP目标函数值下降，求出方向p后，如果 $x_{k+1}=x_k+p$ 满足原QP里的所有约束，就将这个点作为下一个迭代点 ，如果不满足所有约束（朝p走的这一步可能会走的太大了，走出了可行域），则将步子迈的小一点，来使得所有约束条件满足，即给p加一个系数α，系数小于1。即</p><script type="math/tex; mode=display">x_{k+1}=x_k+\alpha p \ \left\{\begin{aligned}&\alpha=1&&满足所有约束\\&0<\alpha<1&&有约束不满足\end{aligned}\right.</script><p><strong>公式</strong></p><p>假设求解的 QP 问题为</p><script type="math/tex; mode=display">\min_xf(x)=\frac{1}{2}x^TGx+x^Tc\\A_ix\geq b,i\in I</script><p>则在工作集 W 的积极集约束满足的条件下的第 k 次迭代下的最优点为</p><script type="math/tex; mode=display">f(x^\star )=f(x_k+p)\\=\frac{1}{2}(x_k+p)^TG(x_k+p)+(x_k+p)^Tc\\=\frac{1}{2}p^TGp+(Gx_k+c)^Tp+\frac{1}{2}x_k^TGx_k+x_kc\\subject~to~~A_i(x_k+p)=b_i,i\in W</script><p>上式中与 p 无关的变量可以看作是常数，不需要管？也就是优化下列式子</p><script type="math/tex; mode=display">\min \frac{1}{2}p^TGp+(Gx+c)^Tp\\A_ip=0,i\in W</script><p>解出 p 后，下一个迭代点</p><script type="math/tex; mode=display">x_{k+1}=x_k+\alpha p</script><p>然后就是考虑工作集之外的约束条件的满足情况，因为工作集内的约束已经考虑过，所有条件满足。首先判断 $A_ip$ 符号，若 $A_ip\geq 0$ 则可以知道它满足所有约束，因为</p><script type="math/tex; mode=display">A_ix_{k+1}=A_i(x_k+\alpha p)\geq b,\alpha >0</script><p>如果 $A_ip\leq 0$ 则为了满足 $A_i(x_k+\alpha p)\geq b$ 条件，可以得到</p><script type="math/tex; mode=display">\alpha \leq \frac{b-A_ix_k}{A_ip}</script><p>所以可得</p><script type="math/tex; mode=display">\alpha =\min(1,\min\frac{b-A_ix_k}{A_ip})</script><p>就是沿着工作集下的active的可行域边界走，如果某次迭代没有约束条件（工作集为空），就朝着无约束下最优点在可行域内走，走到新的边界，然后将新的边界约束加入到工作集中，再沿着新的边界走，不断迭代，直到找到最优解。找到最优解的条件是 <strong>$x_k$满足KKT条件</strong>，即所有的 $\lambda$ 都大于0，则说明当前迭代点为最优解，退出迭代</p><p>其中求 $\lambda$ 的公式为</p><script type="math/tex; mode=display">\partial f(x)=Gx+c\\A_ix\geq b,i\in I</script><p>看作等式约束时，可以使用 lagrange 乘子法</p><script type="math/tex; mode=display">\partial L=Gx+c-\lambda A_i=0,i\in W</script><p>则可以得到</p><script type="math/tex; mode=display">A_i\lambda =Gx+c</script><p><a href="https://zhuanlan.zhihu.com/p/50906541">Active set method介绍 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/38163970">Karush-Kuhn-Tucker (KKT)条件 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/375762164">优化理论——二次规划 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/556832103">KKT条件，原来如此简单 | 理论+算例实践 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯滤波</title>
      <link href="/Blog_ButterFly/2024/03/19/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2/"/>
      <url>/Blog_ButterFly/2024/03/19/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p>在时移系统中通过对带有噪声的观测来估计隐状态的处理方法，滤波专门是指利用前面 k 个观测 $y_1,y_2,…,y_k$ 来估计第 k 个隐状态 $x_k$ 的方法，记作 $x_k|y_{1:k}$</p><p>如果利用前 d 个观测 (d&lt;k) 来估计第 k 个状态，称为预报</p><p>如果利用前 d 个观测 (d&gt;k) 来估计第 k 个状态。则称为平滑或内插</p><p>所以实际的滤波是 $d=k$ 的情形，本质上就是观测 $y_k$ 已知并且带有噪声，用它来估计未知隐状态 $x_k$</p><p><img src="/Blog_ButterFly/2024/03/19/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2/20200221165922555.jpg" alt="20200221165922555.jpg"></p><h3 id="状态空间模型"><a href="#状态空间模型" class="headerlink" title="状态空间模型"></a>状态空间模型</h3><p>对于一个可观测的系统，可以得到</p><script type="math/tex; mode=display">x_k=Ax_{k-1}+Bu_k+Gw_k\\y_k=Cx_k+v_k</script><p>其中 $w_k,v_k$ 分别是过程噪声和观测噪声，并且上式为状态空间方程的状态方程，下式为测量方程</p><h3 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h3><p>由于跟踪设备获得的量测信息和我们根据控制信息得到的预测信息都不是完全准确的（否则也就没有进行估计的必要了），但其一定在真值附近的一定范围内，因此我们可以假设这两个信息服从一定的概率分布来表征二者在真值附近的不确定性。考虑的是随机动态系统，自然要用概率来刻画，所以需要一个概率状态空间模型，设定如下</p><ul><li>$x_k$： k 时刻的状态</li><li>$y_k$： k 时刻的观测</li><li>$p(x_k|x_{k-1})$：动态模型/状态转移概率</li><li>$p(x_k|x_{k})$： 观测模型</li></ul><p>对于这个系统，假设如下</p><ul><li>一阶马尔可夫性： $p(x_k|x_{1:k-1},y_{1:k-1})=p(x_k|x_{k-1})$</li><li>一阶马尔可夫性： $p(x_{k-1}|x_{k:T},y_{k:T})=p(x_{k-1}|x_{k})$</li><li>条件独立性： $p(y_k|x_{1:k},y_{1:k})=p(y_k|x_k)$</li></ul><p>在 k 时刻的预测信息和量测信息的本质是一个条件概率模型</p><script type="math/tex; mode=display">x_k\sim p(x_k|x_{0:k-1},y_{1:k-1})\\y_k\sim p(y_k|x_{0:k},y_{1:k-1})</script><p>上式为更为一般的估计模型，还要进行一定的简化。最优状态的估计的过程，实际上是根据一系列已知的观测量来估计出未知的系统状态的过程，就是概率反演过程，这种状态量隐含且按照时序排列的模型为<strong>隐马尔可夫模型（HMM）</strong></p><p><img src="/Blog_ButterFly/2024/03/19/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2/20200221153252139.png" alt="20200221153252139.png"></p><p>上述的模型有两个重要性质：</p><ul><li><p>马尔科夫性</p><p>  在上述模型中，状态 $x_k$ 在给定前一时刻状态 $x_{k-1}$ 的条件下和 k-1 之前任意观测数据和状态均无关，同时和之后的状态以及测量也无关</p></li><li><p>观测量具有条件独立性</p><p>  在给定当前状态 $x_k$ 的条件下，当前观测量 $y_k$ 和所有历史状态及观测量无关</p></li></ul><p>利用这两个性质，上式可以化简为</p><script type="math/tex; mode=display">x_k\sim p(x_k|x_{k-1})\\y_k\sim p(y_k|x_k)</script><p>得到了和之前空间状态模型基本一致，但是使用条件概率表示的模型，该模型称为<strong>概率状态空间模型</strong></p><h3 id="贝叶斯估计方法"><a href="#贝叶斯估计方法" class="headerlink" title="贝叶斯估计方法"></a>贝叶斯估计方法</h3><p>在建立了概率状态空间模型之后，可以得到全状态 $X=\{x_0,…,x_k\}$ 的联合先验分布 $p(x_{0:k})$ 和所有观测量的似然 $p(y_{0:k}|x_{0:k})$ 为</p><script type="math/tex; mode=display">x_k\sim p(x_k|x_{k-1})\\y_k\sim p(y_k|x_k)</script><p>因此对于 $0\sim k$ 时刻的所有状态量和观测量，根据贝叶斯法可以获得全状态的后验分布</p><script type="math/tex; mode=display">p(x_{0:k}|y_{1:k})=\frac{p(y_{1:k}|x_{0:k})p(x_{0:k})}{p(y_{1:k})}\propto p(y_{1:k}|x_{0:k})p(x_{0:k})</script><p>对于全状态 $x_{0:k}$ 来说，使得上述后验分布最大的值即为其最优估计</p><h3 id="贝叶斯方程与推导"><a href="#贝叶斯方程与推导" class="headerlink" title="贝叶斯方程与推导"></a>贝叶斯方程与推导</h3><p><strong>公式</strong></p><script type="math/tex; mode=display">initial:p(x_0)\\prediction:p(x_k|y_{1:k-1})=\int{p(x_k|x_{k-1})p(x_{k-1}|y_{1:k-1})dx_{k-1}}\\update:p(x_k|y_{1:k})=\frac{1}{z_k}{p(x_k|x_{k})p(x_{k}|y_{1:k-1})}\\z_k=\int{p(y_k|x_k)p(x_k|y_{1:k-1})dx_k}</script><p><strong>推导</strong></p><ul><li><p><strong>prediction</strong></p><p>  要求边缘分布，要先求联合分布，写出联合密度，根据条件概率展开即可，根据一阶马尔可夫性</p><script type="math/tex; mode=display">  p(x_k,x_{k-1}|y_{1:k-1})=\frac{p(x_k,x_{k-1},y_{1:k-1})}{p(y_{1:k-1})}\\=\frac{p(x_k|x_{k-1},y_{1:k-1})p(x_{k-1},y_{1:k-1})}{p(y_{1:k-1})}\\=\frac{p(x_k|x_{k-1},y_{1:k-1})p(x_{k-1}|y_{1:k-1})p(y_{1:k-1})}{p(y_{1:k-1})}\\=p(x_k|x_{k-1},y_{1:k-1})p(x_{k-1}|y_{1:k-1})\\=p(x_k|x_{k-1})p(x_{k-1}|y_{1:k-1})</script><p>  再对 $x_{k-1}$ 积分，可得边缘条件概率，先验概率密度</p><script type="math/tex; mode=display">  p(x_k|y_{1:k-1})=\int{p(x_k|x_{k-1})p(x_{k-1}|y_{1:k-1})dx_{k-1}}</script><p>  该式子表征了贝叶斯滤波中的一步预测过程，而其离散形式是 Markov 链中经典的 <strong>CK方程</strong></p></li><li><p><strong>update</strong></p><p>  完成对于状态的一步预测之后，此时获取了 k 时刻的观测信息，那就很容易利用贝叶斯法则从已知分布 $p(x_k|y_{1:k-1})$ 和 $p(y_k|x_k)$ 求解条件分布 $p(x_k|y_{1:k})$</p><script type="math/tex; mode=display">  p(x_k|y_{1:k})=\frac{p(x_k,y_{1:k})}{p(y_{1:k})}</script><p>  分子所表示的联合概率分布，根据概率链式法则</p><script type="math/tex; mode=display">  p(x_k,y_{1:k})=p(y_k|x_k,y_{1:k-1})p(x_k,y_{1:k-1})\\=p(y_k|x_k,y_{1:k-1})p(x_k|y_{1:k-1})p(y_{1:k-1})\\=p(y_k|x_k)p(x_k|y_{1:k-1})p(y_{1:k-1})</script><p>  其中化简中利用了量测独立性 $p(y_k|x_k,y_{1:k-1})=p(y_k|x_k)$。而对于分母来说，没有任何直接信息，但是可以通过对上式所表示的联合分布积分的方式来获取对应的边缘分布</p><script type="math/tex; mode=display">  p(y_{1:k})=\int{p(x_k,y_{1:k})dx_k}=p(y_{1:k-1})\int{p(y_k|x_k)p(x_k|y_{1:k-1})dx_k}</script><p>  将分子分母带入最开始的公式中得到后验概率密度</p><script type="math/tex; mode=display">  p(x_k|y_{1:k})=\frac{p(x_k,y_{1:k})}{p(y_{1:k})}=\frac{p(y_k|x_k)p(x_k|y_{1:k-1})p(y_{1:k-1})}{p(y_{1:k-1})\int{p(y_k|x_k)p(x_k|y_{1:k-1})dx_k}}=\frac{p(y_k|x_k)p(x_k|y_{1:k-1}))}{\int{p(y_k|x_k)p(x_k|y_{1:k-1})dx_k}}</script></li></ul><p><strong>总结</strong></p><ul><li>目标：实现第 k-1 步滤波到第 k 步滤波，也就是 $p(x_{k-1}|y_{1:k-1})→p(x_k|y_{1:k})$</li><li>初始化： $p(x_0)$</li><li><p>预测步： $p(x_{k-1}|y_{1:k-1})→p(x_k|y_{1:k-1})$</p><script type="math/tex; mode=display">  p(x_k|y_{1:k-1})=\int{p(x_k|x_{k-1})p(x_{k-1}|y_{1:k-1})dx_{k-1}}</script></li><li><p>更新步： $p(x_k|y_{1:k-1})→p(x_k|y_{1:k})$，根据观测到得数据 $y_k$ 来更新数据</p><script type="math/tex; mode=display">  p(x_k|y_{1:k})=\frac{1}{z_k}{p(x_k|x_{k})p(x_{k}|y_{1:k-1})dx_{k-1}}\\z_k=\int{p(y_k|x_k)p(x_k|y_{1:k-1})dx_k}</script></li></ul><p>这就是 <strong>贝叶斯滤波</strong>，贝叶斯每次估计都需要<strong>状态预测和观测更新</strong>两步，不断循环。这个框架下可以导出 KF 和三种非线性滤波</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
            <tag> Bayesian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PR比例谐振控制器</title>
      <link href="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><p><a href="https://wenku.baidu.com/view/bd6ad8d85022aaea998f0fdb.html?_wkts_=1718038799743">比例谐振控制算法分析 - 百度文库 (baidu.com)</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在传统的矢量控制系统中，广泛的采用了坐标变换技术，将三相静止坐标系下的电流电压等正弦量转化为同步旋转坐标系下的直流量，这个实现了简化系统，并且能够很好的使电机实现解耦控制。这么做的原因就是 PI 控制器无法对正弦量实现无静差控制，坐标变换简化了系统外环控制的设计，却造成内环结构复杂，设计困难。而且在电机运行中，电机的电感，电阻等电机参数会随着磁路的饱和，温度的升高而发生改变，从而使交叉耦合项不准确，进而使系统的控制精度下降。</p><p>PR 控制器可以实现对交流的无静差控制，将 PR 控制器用于网侧变换器的控制系统中，可以在两个相对静止的坐标系下对电流进行调节，可以简化控制过程中的坐标变换，消除电流 d，q 轴分量之间的耦合关系，并且可以忽略电网电压对系统的扰动作用。并且使用 PR 控制器更容易实现低次滤波补偿，这些都有利于简化系统的结构</p><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><script type="math/tex; mode=display">F(\omega)=\int_{-\infty}^{\infty}f(t)e^{-j\omega t}dt\\f(t)=\frac{1}{2\pi}\int_{-\infty}^{\infty}F(\omega)e^{j\omega t}d\omega</script><h3 id="laplace-变换"><a href="#laplace-变换" class="headerlink" title="laplace 变换"></a>laplace 变换</h3><script type="math/tex; mode=display">F(s)=\int_{-\infty}^{\infty}f(t)e^{-st}dt\\f(t)=\frac{1}{2\pi j}\int_{\sigma-j\infty}^{\sigma+j\infty}F(s)e^{st}ds</script><h3 id="z-变换"><a href="#z-变换" class="headerlink" title="z 变换"></a>z 变换</h3><script type="math/tex; mode=display">F(z)=\sum f[n]z^{-n}\\f[n]=\frac{1}{2\pi j}\textcircled{\int} F(z)z^{n-1}dz</script><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述三种变换可以利用如下映射关系实现传递函数之间的等价转换</p><script type="math/tex; mode=display">s=j\omega=\frac{1}{T}\ln z\\z=e^{sT}=e^{j\omega T}</script><h3 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h3><p>· 连续型传递函数稳定的充要条件为，所有极点均位于 s 域左半平面；离散型传递函数稳定的充要条件为，所有极点均位于 z 域原点为圆心的单位圆内。对于连续传函离散化问题，s 域左半平面所有极点，经 $z=e^{sT}$ 映射后，均位于 z 域原点为圆心的单位圆内。因此，严格离散化前后，连续系统稳定，则离散系统稳定</p><h2 id="PR-控制器"><a href="#PR-控制器" class="headerlink" title="PR 控制器"></a>PR 控制器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>PR 控制器即比例谐振控制器，由比例环节和谐振环节组成，可对正弦量实现无静差控制。理想 PR 控制器的传递函数如下</p><script type="math/tex; mode=display">G(s)=K_P+\frac{K_Rs}{s^2+w_0^2}</script><p>其中</p><ul><li>$K_P$ 比例项系数</li><li>$K_R$ 谐振项系数</li><li>$w_0$ 谐振频率</li></ul><p>PR 控制器中的积分环节又称为广义积分器，可以对谐振频率的正弦量进行幅值积分</p><h3 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h3><p>对于同频的输入信号 $M\sin(\omega t+\varphi)$，对输入的信号进行拉普拉斯变换为</p><script type="math/tex; mode=display">L(M\sin(\omega t+\varphi))=M\cos(\varphi)\frac{\omega}{s^2+\omega^2}+M\sin(\varphi)\frac{s}{s^2+\omega^2}</script><p>经过谐振项之后，表示变为（其中 $\omega_0=\omega$ ）</p><script type="math/tex; mode=display">\frac{K_Rs}{s^2+w_0^2}(M\cos(\varphi)\frac{\omega}{s^2+\omega^2}+M\sin(\varphi)\frac{s}{s^2+\omega^2})\\=K_RM(\cos(\varphi)\frac{\omega s}{(s^2+\omega^2)^2}+\sin(\varphi)\frac{s^2}{(s^2+\omega^2)^2})\\=K_RM(\cos(\varphi)\frac{\omega s}{(s^2+\omega^2)^2}+\frac{\sin(\varphi)}{2}(\frac{1}{s^2+\omega^2}+\frac{s^2-w^2}{(s^2+\omega^2)^2}))</script><p>分别推导 $t\cos(\omega t)$ 和 $t\sin(\omega t)$ 的拉普拉斯变换为</p><script type="math/tex; mode=display">L(t\cos(\omega t))=\frac{s^2-\omega^2}{(s^2+\omega^2)}\\L(t\sin(\omega t))=\frac{2\omega s}{(s^2+\omega^2)^2}</script><p>所以上式的拉普拉斯反变换为</p><script type="math/tex; mode=display">K_RM(\frac{\cos(\varphi)}{2}t\sin(\omega t)+\frac{\sin(\varphi)}{2}(t\cos(\omega t)+\frac{1}{\omega}\sin(\omega t)))</script><p>整理之后得到</p><script type="math/tex; mode=display">\frac{K_RM}{2}((t\cos(\varphi)+\frac{\sin(\varphi)}{\omega})\sin(\omega t)+t\sin(\varphi)\cos(\omega t))</script><p>由上述可知，当 $\varphi=0$ 时，输出信号为</p><script type="math/tex; mode=display">\frac{K_RM}{2}t\sin(\omega t)</script><p>如图，与输入信号相位相同，幅值呈时间线性上升</p><p><img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718072679746.png" alt="1718072679746.png"></p><p>当 $\varphi=90$ 时，输出信号为</p><script type="math/tex; mode=display">\frac{K_RM}{2}(\frac{\sin(\omega t)}{\omega}+t\cos(\omega t))</script><p>当时间稍大时，该值贴近于 $t\cos(\omega t)$ ，从整体上看，谐振器是对误差信号按时间递增的</p><p><img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718072827101.png" alt="1718072827101.png"></p><p>如下图所示，当 PR 控制器中的积分部分 $\frac{K_Rs}{s^2+w_0^2}$ 在谐振频率点处达到无穷大的增益，在这个频率点之外几乎没有衰减，因此，为了选择地补偿谐波，它可以作为一个直角滤波器，如图所示</p><p><img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718078434417.png" alt="1718078434417.png"></p><h3 id="参数对控制器的影响"><a href="#参数对控制器的影响" class="headerlink" title="参数对控制器的影响"></a>参数对控制器的影响</h3><ul><li><p>$K_P$ 的影响</p><p>  选取 $K_R=1, \omega_0=100$</p><p>  <img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718080395579.png" alt="1718080395579.png"></p><p>  $K_P$ 越大，系统的幅值图就会约尖锐，幅值也越大，而相应的相位图就会在 $\omega_c$ 处就会变化更加急</p></li><li><p>$K_R$ 的影响</p><p>  选取 $K_P=1, \omega_0=100$</p><p>  <img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/Untitled.png" alt="Untitled"></p><p>  可见 $K_R$ 会对幅值图的幅值有影响，且 $K_R$ 越大，幅值越大，而 $K_R$ 越大，使得相位图在 $\omega_0$ 处相位变化减缓</p></li><li><p>$\omega_0$ 的影响</p><p>  选取 $K_P=1,K_R=1$</p><p>  <img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718081260701.png" alt="1718081260701.png"></p><p>  可见， $\omega_0$ 对幅值和相位也是有一定一影响的，并且 $\omega_0$ 越大，幅值越小，并且相位变化越剧烈</p></li></ul><h2 id="准-PR-控制器"><a href="#准-PR-控制器" class="headerlink" title="准 PR 控制器"></a>准 PR 控制器</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>与 PI 控制器相比，PR 控制器可以达到零稳态误差，提高有选择地抗电网电压干扰的能力，但是在实际的使用中，PR 控制器的实现存在两个问题</p><ul><li>由于模拟系统元器件参数精度和数字系统精度的限制，PR 控制器不容易实现</li><li>PR 控制器在非基频处的增益非常小，当电网频率产生偏移时，就无法有效抑制电网产生的谐波</li></ul><p>因此，在 PR 的基础上，提出了一种容易实现的准 PR 控制器，既可以保持 PR 控制器的高增益，同时还可以有效减小电网频率偏移对逆变器输出电感电流的影响</p><p>准 PR 控制器传递函数为</p><script type="math/tex; mode=display">G(s)=K_P+\frac{2K_R\omega_cs}{s^2+2\omega_cs+\omega_0^2}</script><p>控制器的伯德图如下所示，选择参数</p><script type="math/tex; mode=display">K_P=10\\K_R=100\\\omega_0=100\\\omega_c=1</script><p><img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718079135424.png" alt="1718079135424.png"></p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p>除了比例系数之外，准 PR 控制器还有 $K_R,\omega_c$ 两个参数，分析每个参数对控制器的影响，可先假设其它参数不变，然后观察各个参数对性能的影响</p><ul><li><p>$\omega_c=0$ ，调节 $K_R$</p><p>  <img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718089885780.png" alt="1718089885780.png"></p><p>  从图中可以看出，当 $K_R$ 参数增大时，控制器的峰值的增益也增大，而控制器的带宽没有变化</p><p>  <img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718083724228.png" alt="1718083724228.png"></p><p>  但是当有比例项的时候，带宽也不是一定的，会与 $K_P$ 项有关系</p></li><li><p>$K_R=1$ ，调节 $\omega_c$</p><p>  <img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718089798564.png" alt="1718089798564.png"></p><p>  如图可知， $\omega_c$ 不仅影响控制器的增益，同时还影响控制器截止频率的带宽，随着 $\omega_c$ 的增加，控制器的增益和带宽都会增加（基频增益为 $K_R$ 不变），将 $s=j\omega$ 带入到传递函数</p><script type="math/tex; mode=display">  G(j\omega)=\frac{2K_R\omega_cj\omega}{-\omega^2+2\omega_cj\omega+\omega_0^2}</script><p>  根据对带宽的定义， $|G(j\omega)|=\frac{K_R}{\sqrt(2)}$ 时，此时计算得到两个频率之差即为带宽，令 $|\frac{\omega^2-\omega_0^2}{2w_cw}|=1$ ，经过计算之后得到的准谐振控制器的带宽为 $\frac{\omega_c}{\pi}Hz$</p><p>  假设电网电压频率波动的允许的范围为 $\plusmn 0.8Hz$ ，则有 $\frac{\omega_c}{\pi}=1.6Hz$ ，也就是 $\omega_c=5Hz$</p></li></ul><h2 id="准-PR-控制器的离散化"><a href="#准-PR-控制器的离散化" class="headerlink" title="准 PR 控制器的离散化"></a>准 PR 控制器的离散化</h2><p>模拟控制器的离散化有两种方式，分别为脉冲响应不变法和双线性变换法</p><h3 id="脉冲响应不变法"><a href="#脉冲响应不变法" class="headerlink" title="脉冲响应不变法"></a>脉冲响应不变法</h3><p>PR 控制器的数字实现方法主要有两种，分别是采用 Z 算符和采用 $\delta$ 算符对其进行离散化</p><script type="math/tex; mode=display">G(s)=\frac{2K_R\omega_cs}{s^2+2\omega_cs+\omega_0^2}\\=\frac{2K_R\omega_cs}{(s-\frac{-2\omega_c+\sqrt{4\omega_c^2-4\omega_0^2}}{2})(s-\frac{-2\omega_c-\sqrt{4\omega_c^2-4\omega_0^2}}{2})}\\=\frac{2K_R\omega_cs}{(s+\omega_c-\sqrt{\omega_c^2-\omega_0^2})(s+\omega_c+\sqrt{\omega_c^2-\omega_0^2})}\\=\frac{A}{s+\omega_c-\sqrt{\omega_c^2-\omega_0^2}}+\frac{B}{s+\omega_c+\sqrt{\omega_c^2-\omega_0^2}}</script><p>其中</p><script type="math/tex; mode=display">A=K_R\omega_c(1-\frac{\omega_c}{\sqrt{\omega_c^2-\omega_0^2}})\\B=K_R\omega_c(1+\frac{\omega_c}{\sqrt{\omega_c^2-\omega_0^2}})</script><p>上式通过脉冲响应不变法转为 Z 变换，Z 变换实际上就是连续系统离散化的结果，在 matlab 中使用函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F = (<span class="number">2</span> * KR * WC * s) / (s ^ <span class="number">2</span> + <span class="number">2</span> * WC * s + W0 ^ <span class="number">2</span>);</span><br><span class="line">c2d(F, t, <span class="string">&#x27;z&#x27;</span>);</span><br></pre></td></tr></table></figure><p>得到</p><script type="math/tex; mode=display">G(z)=\frac{Az}{z-e^{-(\omega_c-\sqrt{\omega_c^2-\omega_0^2})T}}+\frac{Bz}{z-e^{-(\omega_c+\sqrt{\omega_c^2-\omega_0^2})T}}\\=\frac{A}{1-z^{-1}e^{-(\omega_c-\sqrt{\omega_c^2-\omega_0^2})T}}+\frac{B}{1-z^{-1}e^{-(\omega_c+\sqrt{\omega_c^2-\omega_0^2})T}}</script><p>设</p><script type="math/tex; mode=display">C=e^{-(\omega_c-\sqrt{\omega_c^2-\omega_0^2})T}\\D=e^{-(\omega_c+\sqrt{\omega_c^2-\omega_0^2})T}</script><p>则有</p><script type="math/tex; mode=display">G(z)=\frac{Az}{1-z^{-1}C}+\frac{Bz}{1-z^{-1}D}\\=\frac{(A+B)-(AD-BC)z^{-1}}{1-(C+D)z^{-1}+CDz^{-2}}</script><p>设 $Y=GX$ ，转为差分函数之后，该式子可以表示为</p><script type="math/tex; mode=display">y(n)=(C+D)y(n-1)-CDy(n-2)+(A+B)x(n)-(AD-BC)x(n-1)</script><p>其中</p><script type="math/tex; mode=display">A=K_R\omega_c(1-\frac{\omega_c}{\sqrt{\omega_c^2-\omega_0^2}})\\B=K_R\omega_c(1+\frac{\omega_c}{\sqrt{\omega_c^2-\omega_0^2}})\\C=e^{-(\omega_c-\sqrt{\omega_c^2-\omega_0^2})T}\\D=e^{-(\omega_c+\sqrt{\omega_c^2-\omega_0^2})T}</script><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>对于一个一阶系统</p><script type="math/tex; mode=display">G(s)=\frac{1}{s+1}</script><p>跟踪一个正弦信号量 $\sin(100\pi t)$ ，设计 PR 控制器和 PI 控制器进行对比，选取参数</p><script type="math/tex; mode=display">K_p=1000\\K_R=5000\\\omega_c=10\pi\\w_0=100\pi\\K_i=500</script><p>最终得到的结果为</p><p><img src="/Blog_ButterFly/2024/03/19/PR%E6%AF%94%E4%BE%8B%E8%B0%90%E6%8C%AF%E6%8E%A7%E5%88%B6%E5%99%A8/1718252168267.png" alt="1718252168267.png"></p><p>可见 PR 控制器对于高频信号的跟踪要比 PI 控制器好，这是因为 PI 控制器中的 i 项需要累计误差才能有效果，而对于高频信号变化太快，导致累计误差很小而影响小</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="/Blog_ButterFly/2024/03/19/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>/Blog_ButterFly/2024/03/19/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><h2 id="卡尔曼滤波-KF"><a href="#卡尔曼滤波-KF" class="headerlink" title="卡尔曼滤波 KF"></a>卡尔曼滤波 KF</h2><p><img src="/Blog_ButterFly/2024/03/19/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/v2-87047c7f01f9c404db864dede8052c16_720w.png" alt="v2-87047c7f01f9c404db864dede8052c16_720w.png"></p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><script type="math/tex; mode=display">\hat{x}_{k|k-1}=F_k\hat{x}_{k-1|k-1}\\P_{k|k-1}=F_kP_{k-1|k-1}F_k^T+Q_k\\K_k=P_{k|k-1}H_k^T(H_kP_{k|k-1}H_k^T+R_k)^{-1}\\\hat{x}_{k|k}=\hat{x}_{k|k-1}+K_k(z_k-H_k\hat{x}_{k|k-1})\\P_{k|k}=(I-K_kH_k)P_{k|k-1}</script><h3 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h3><p>卡尔曼滤波模型假设k时刻的真实状态是从（k − 1）时刻的状态演化而来</p><p><strong>状态估计方程</strong></p><script type="math/tex; mode=display">x_k=F_kx_{k-1}+B_ku_k+w_k</script><p>其中</p><ul><li>$F_k$ 是状态变换模型（矩阵/向量），运动学一般是矩阵（状态转移矩阵）</li><li>$B_k$ 是作用在控制器向量 $u_k$ 上的输入-控制模型，一般运动学中没有这一项，因对于检测的目标的是无法测量其内部的控制量的，所以简化为0</li><li>$w_k-N(0,Q_k)$ 是过程噪声。均值为 0， $x_k$ 对应的就是高斯分布的均值，因此这项可以简化为 0</li></ul><p><strong>状态估计转移方程</strong></p><script type="math/tex; mode=display">z_k=H_kx_k+v_k</script><p>表示 k 时刻真实 $x_k$ 的一个测量</p><p>其中</p><ul><li>$H_k$ 为观测模型（观测矩阵），它把真实空间状态映射成观测空间状态</li><li>$v_k-N(0,R_k)$ 是观测噪声</li></ul><p>初始状态以及每一时刻的噪声 $x_0,w_1,…,w_k,v_1,…v_k$ 都被认为是相互独立的</p><p><strong>小结</strong></p><p>从以上出发，可以计算相应的协方差矩阵，这个也是公式推导的主要部分。</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><script type="math/tex; mode=display">\hat{x}_{k|k-1}=F_k\hat{x}_{k-1|k-1}</script><p><strong>估计状态方程</strong>，表示预测下一步状态。</p><p>其中</p><ul><li>$\hat{x}_{k|k-1}$ 表示 k-1 时刻对 k 时刻的状态预测</li><li>$\hat{x}_{k-1|k-1}$ 表示在 k-1 时刻对 k-1 时刻的状态估计</li><li>$F_k$ 为状态估计矩阵</li></ul><script type="math/tex; mode=display">P_{k|k-1}=F_kP_{k-1|k-1}F_k^T+Q_k</script><p><strong>预测二估计协方差方程</strong>，预测误差方差，计算先验概率</p><p>其中</p><ul><li>$P_{k-1|k-1}$ 表示 k-1 时刻的后验估计误差协方差矩阵，度量估计值的精确程度</li><li>$P_{k|k-1}$ 表示 k-1 时刻到 k 时刻的估计误差协方差矩阵</li><li>$Q_k$ 表示过程噪声协方差矩阵，越大说明约不相信预测。实际工程中可以自行调参（$Q_k=cov(Z, Z)$），也可以自适应AKF</li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a><strong>更新</strong></h3><script type="math/tex; mode=display">K_k=P_{k|k-1}H_k^T(H_kP_{k|k-1}H_k^T+R_k)^{-1}</script><p><strong>卡尔曼增益方程</strong></p><p>其中</p><ul><li>$K_k$ 为最优卡尔曼增益</li><li>$R_k$ 为测量噪声协方差矩阵，越大说明越不相信观测。实际测量噪声由厂家提供，或者自己调参，也可自适应AKF</li></ul><script type="math/tex; mode=display">\hat{x}_{k|k}=\hat{x}_{k|k-1}+K_k(z_k-H_k\hat{x}_{k|k-1})</script><p><strong>更新状态估计方程——最终滤波的效果</strong></p><p>可以使用测量残差来简化表达公式，即</p><script type="math/tex; mode=display">\hat{y}=z_k-H_k\hat{x}_{k|k-1}\\S_k=cov(\hat{y})=H_kP_{k|k-1}H_k^T+R_k</script><p>即卡尔曼增益可以简化为</p><script type="math/tex; mode=display">K_k=P_{k|k-1}H_k^TS_k^{-1}</script><p>状态估计更新可以简化为</p><script type="math/tex; mode=display">\hat{x}_{k|k}=\hat{x}_{k|k-1}+K_k\hat{y}</script><p>其中 $cov(x)$ 求解矩阵的协方差矩阵，若 X 大小为 $M \times N$<em>，则</em> $cov(X)$ <em>大小 为</em> $N\times N$ **的矩阵。 $cov(X)$ 的第 $(i,j)$ 个元素等于 X 的第 i 列向量与第 j 列向量的方差，即 $C(Xi,Xj)$。</p><script type="math/tex; mode=display">P_{k|k}=(I-K_kH_k)P_{k|k-1}</script><p><strong>更新估计协方差——得到后验概率</strong></p><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>首先 $Q_k$ 和 $R_k$ 一般为固定值，高级卡尔曼滤波可以自适应</p><script type="math/tex; mode=display">Q_k=cov(w_k)=E(w_kw_k^T)\\R_k=cov(v_k)=E(v_kv^T_k)\\P_{k|k-1}=cov(x_k-\hat{x}_{k|k-1})=E((x_k-\hat{x}_{k|k-1})(x_k-\hat{x}_{k|k-1})^T)\\P_{k|k}=cov(x_k-\hat{x}_{k|k})=E((x_k-\hat{x}_{k|k})(x_k-\hat{x}_{k|k})^T)\\S_k=cov(\hat{y})=cov(z_k-H_k\hat{x}_{k|k-1})</script><p>从状态估计方程推导 $P_{k|k-1}$</p><script type="math/tex; mode=display">P_{k|k}=cov(x_k-\hat{x}_{k|k})\\=cov(x_k-\hat{x}_{k|k-1}-K_k(z_k-H_k\hat{x}_{k|k-1}))\\=cov(x_k-\hat{x}_{k|k-1}-K_k(H_kx_k+v_k-H_k\hat{x}_{k|k-1}))\\=cov((I-K_kH_k)(x_k-\hat{x}_{k|k-1})-K_kv_k)\\=cov((I-K_kH_k)(x_k-\hat{x}_{k|k-1})+cov(K_kv_k)\\=(I-K_kH_k)cov(x_k-\hat{x}_{k|k-1})(I-K_kH_k)^T+K_kcov(v_k)K_k^T\\=(I-K_kH_k)P_{k|k-1}(I-K_kH_k)^T+K_kR_kK_k^T</script><p>这一公式对任何卡尔曼增益 $K_k$ 都成立，如果 $K_k$ 是最优卡尔曼增益，则可以进一步简化</p><p><strong>推导最优卡尔曼增益</strong> $K_k$</p><p>可以根据上式推导最优卡尔曼增益</p><p>卡尔曼滤波器是最小均方误差估计器，后验状态误差估计是指 $P_{k|k}=cov(x_k-\hat{x}_{k|k})$，当 $P_{k|k}$ 矩阵的均方误差为最小时，即可求出最优卡尔曼增益</p><p>矩阵的均方误差为矩阵的迹。求矩阵的最小均方误差，即是求矩阵的迹的最小值，对矩阵的迹求导，导数为0时，迹最小。其中协方差 $P_{k|k}$ 是对称矩阵</p><script type="math/tex; mode=display">P_{k|k}=(I-K_kH_k)P_{k|k-1}(I-K_kH_k)^T+K_kR_kK_k^T\\=P_{k|k-1}-K_kH_kP_{k|k-1}-P_{k|k-1}(K_kH_k)^T+K_k(H_kP_{k|k-1}H_k^T+R_k)K_k^T</script><p>求解该矩阵的迹</p><script type="math/tex; mode=display">tr(P_{k|k})=tr(P_{k|k-1}-K_kH_kP_{k|k-1}-P_{k|k-1}(K_kH_k)^T+K_k(H_kP_{k|k-1}H_k^T+R_k)K_k^T)\\=tr(P_{k|k-1})-2tr(K_kH_kP_{k|k-1})+tr(K_k(H_kP_{k|k-1}H_k^T+R_k)K_k^T)</script><p>上式对 $K_k$ 求导</p><script type="math/tex; mode=display">\frac{d~tr(P_{k|k})}{d~K_k}=\frac{d[tr(P_{k|k-1})-2tr(K_kH_kP_{k|k-1})+tr(K_k(H_kP_{k|k-1}H_k^T+R_k)K_k^T)]}{d~K_k}\\=-2(H_kP_{k|k-1})^T+2K_k(H_kP_{k|k-1}H_k^T+R_k)</script><p>当导数为 0 时取极值，即</p><script type="math/tex; mode=display">-2(H_kP_{k|k-1})^T+2K_k(H_kP_{k|k-1}H_k^T+R_k)=0</script><p>得</p><script type="math/tex; mode=display">K_k=(H_kP_{k|k-1})^T(H_kP_{k|k-1}H_k^T+R_k)^{-1}</script><p>令</p><script type="math/tex; mode=display">S_kH_kP_{k|k-1}H_k^T+R_k</script><p>得</p><script type="math/tex; mode=display">K_k=P_{k|k-1}H_k^TS_k^{-1}</script><p>对该矩阵的迹求二阶导</p><script type="math/tex; mode=display">\frac{d~tr^2(P_{k|k})}{d~K_k^2}=2(H_kP_{k|k-1}H_k^{-1}+R_k)^T</script><p>由于 $R_k$ 表示 $v_k$ 的协方差矩阵，所以其一定是正定阵，因此该矩阵是正定阵，因此此时求出其迹的最小值</p><p><strong>最优卡尔曼增益化简</strong> $P_{k|k}$</p><p>从上式化简得到</p><script type="math/tex; mode=display">K_kS_k=(H_kP_{k|k-1})^T\\K_kS_kK_k^T=(H_kP_{k|k-1})^TK_k^T=P_{k|k-1}(K_kH_k)^T</script><p>带入其中得</p><script type="math/tex; mode=display">P_{k|k}=P_{k|k-1}-K_kH_kP_{k|k-1}-P_{k|k-1}(K_kH_k)^T+K_k(H_kP_{k|k-1}H_k^T+R_k)K_k^T\\=P_{k|k-1}-K_kH_kP_{k|k-1}-P_{k|k-1}(K_kH_k)^T+K_kS_kK_k^T\\=(I-K_kH_k)P_{k|k-1}</script><p>该简化式 $P_{k|k}=(I-K_kH_k)P_{k|k-1}$ 只能在最优卡尔曼增益时才成立。如果算术精度总是很低而导致数值稳定性出现问题，或者特意使用非最优卡尔曼增益，则必须使用上面未简化的后验误差协方差公式 $P_{k|k}=(I-K_kH_k)P_{k|k-1}(I-K_kH_k)^T+K_kR_kK_k^T$</p><h2 id="自适应卡尔曼滤波-AKF"><a href="#自适应卡尔曼滤波-AKF" class="headerlink" title="自适应卡尔曼滤波 AKF"></a>自适应卡尔曼滤波 AKF</h2><p>首先列出系统方程</p><script type="math/tex; mode=display">X_k=AX_{k-1}+Cu_k+Bw_k\\Y_k=CX_k+v_k</script><p>其中</p><script type="math/tex; mode=display">X_k 表示状态量\\Y_k表示输出量\\u_k表示输入量\\w_k，v_k 为噪声</script><script type="math/tex; mode=display">E[w_k]=q_k\\E[w_kw_k^T]=Q_k\delta_{tp}\\E[v_k]=r_k\\E[v_kv_k^T]=R_k\delta_{tp}</script><p>其中 $Q(t),R(t),q(t),r(t)$ 将在后续进行更新</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ol><li><strong>预测方程</strong></li></ol><script type="math/tex; mode=display">\hat{X}_{k|k-1}=A\hat{X}_{k-1|k-1}+Cu_{k-1}+B\overline{q}_{k-1}</script><p>其中 $\overline{q}_{k-1}$ 表示预测误差矩阵</p><ol><li><strong>预测均方差误差方程</strong></li></ol><script type="math/tex; mode=display">P_{k|k-1}=AP_{k-1|k-1}A^T+B\overline{Q}_{k-1}B^T</script><p>其中 $\overline{Q}_{k-1}$ 表示过程噪声协方差矩阵，Q越大表示预测的协方差就越大，对预测的不信任</p><ol><li><strong>更新滤波增益方程</strong></li></ol><script type="math/tex; mode=display">K_k=P_{k|k-1}C^T(CP_{k|k-1}C^T+\overline{R}_{k-1})^{-1}</script><p>其中 $\overline{R}_{k-1}$ 是测量噪声协方差矩阵，R越大表示观测的协方差就越大，对观测不信任</p><ol><li><strong>计算残差</strong></li></ol><script type="math/tex; mode=display">\varepsilon_k=Y_k-C\hat{X}_{k|k-1}-\overline{r}_{k-1}</script><p>其中 $\overline{r}_{k-1}$ 是观测误差矩阵</p><ol><li><strong>状态估计</strong></li></ol><script type="math/tex; mode=display">\hat{X}_{k|k}=\hat{X}_{k|k-1}+K_k\varepsilon_k</script><p>和卡尔曼滤波器的对应公式是一样的</p><ol><li><strong>均方差误差方程</strong></li></ol><script type="math/tex; mode=display">P_{k|k}=(I-K_kC)P_{k|k-1}</script><p>和卡尔曼滤波器的对应公式是一样的</p><p><strong>更新</strong> $q_k, Q_k, r_k, R_k$</p><ol><li><strong>计算加权系数</strong></li></ol><script type="math/tex; mode=display">d(t)=\frac{1-b}{1-b^{t+1}}~~~0<b<1</script><p>随着时间的推移， $d(t)→1-b$</p><script type="math/tex; mode=display">d(t)=\frac{1}{t}</script><p>随着时间推移， $d(t)→0$，当 $d(t)=0$ 时，还原为普通的卡尔曼滤波器</p><ol><li><strong>更新</strong> $\overline{q}_k, \overline{Q}_k,\overline{r}_k,\overline{R}_k$ </li></ol><script type="math/tex; mode=display">\overline{q}_k=(1-d(k-1))\overline{q}_{k-1}+d(k-1)(\hat{X}_{k|k}-A\hat{X}_{k-1|k-1})\\\overline{Q}_k=(1-d(k-1))\overline{Q}_{k-1}+d(k-1)(K_k\varepsilon_k\varepsilon_k^TK_k^T+P_{k|k}-AP_{k-1|k-1}A^T)\\\overline{r}_k=(1-d(k-1))\overline{r}_{k-1}+d(k-1)(Y_k-C\hat{X}_{k|k-1})\\\overline{R}_{k}=(1-d(k-1))\overline{R}_{k-1}-d(k-1)(\varepsilon_k\varepsilon_k^T-CP_{k|k-1}C^T)</script><h2 id="扩展卡尔曼滤波-EKF"><a href="#扩展卡尔曼滤波-EKF" class="headerlink" title="扩展卡尔曼滤波 EKF"></a>扩展卡尔曼滤波 EKF</h2><p><img src="/Blog_ButterFly/2024/03/19/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/v2-5d08b454b3149ba0500e647d2bea421f_720w.png" alt="v2-5d08b454b3149ba0500e647d2bea421f_720w.png"></p><p>用来解决非线性问题，如极坐标系的雷达，观测到的式径向距离和角度，这是观测矩阵 H 就是非线性的函数。</p><p>EKF 与 KF 最主要的区别就是转换模型和观测模型可以是非线性的，可以使用泰勒展开式替换为线性函数，两个协方差矩阵 P 和 H 要使用雅各比矩阵计算每个状态量的一阶偏导</p><p>因为主要是状态估计方程和状态估计转移方程的两个地方有些区别，所以 EKF 协方差矩阵的公式推导还是跟 KF 一样的</p><h3 id="预测-1"><a href="#预测-1" class="headerlink" title="预测"></a>预测</h3><script type="math/tex; mode=display">\hat{x}_{k|k-1}=f(\hat{x}_{k-1|k-1},u_k,0)\\P_{k|k-1}=J_FP_{k-1|k-1}J_F^T+Q_k</script><h3 id="使用-Jacobians-矩阵更新模型"><a href="#使用-Jacobians-矩阵更新模型" class="headerlink" title="使用 Jacobians 矩阵更新模型"></a>使用 Jacobians 矩阵更新模型</h3><p>过程模型(矩阵)和测量模型(矩阵)与 KF 有所区别，需要进行雅各比矩阵求导运算</p><script type="math/tex; mode=display">J_F=\frac{\partial f}{\partial x}|_{\hat{x}_{k-1|k-1}, u_k}\\J_H=\frac{\partial h}{\partial x}|_{\hat{x}_{k|k-1}}</script><p>其中</p><script type="math/tex; mode=display">h(x)=H_kx\\f(x,u,v)=F_kx+B_ku+v</script><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><script type="math/tex; mode=display">\hat{y}_k=z_k-h(\hat{x}_{k|k-1}, 0)\\S_k=J_HP_{k|k-1}H_k^T+R_k\\K_k=P_{k|k-1}J_H^TS_k^{-1}\\\hat{x}_{k|k}=\hat{x}_{k|k-1}+K_k\hat{y}\\P_{k|k}=(I-K_kJ_H)P_{k|k-1}</script><h3 id="恒定转弯率和速度模型（Constant-Turn-Rate-and-Velocity——CTRV）"><a href="#恒定转弯率和速度模型（Constant-Turn-Rate-and-Velocity——CTRV）" class="headerlink" title="恒定转弯率和速度模型（Constant Turn Rate and Velocity——CTRV）"></a>恒定转弯率和速度模型（<strong>Constant Turn Rate and Velocity——</strong>CTRV）</h3><p>状态量为</p><script type="math/tex; mode=display">X=\begin{bmatrix}x\\y\\v\\\theta\\\omega\end{bmatrix}</script><p>状态方程为</p><script type="math/tex; mode=display">X_{k+1}=X_k+\begin{bmatrix}\int_{t_k}^{t_{k+1}}{v(t)cos(\theta(t))}dt\\\int_{t_k}^{t_{k+1}}{v(t)sin(\theta(t))}dt\\0\\\omega \Delta t\\0\end{bmatrix}</script><p>其中在某一时刻将速度近似于常量，同时角速度也近似于常量。</p><p>对上式进行简化</p><script type="math/tex; mode=display">\int_{t_k}^{t_{k+1}}{v(t)cos(\theta(t))}dt=v_k\int_{t_k}^{t_{k+1}}{cos(\theta_k+\omega (t-t_k))}dt=\frac{v_k}{\omega}[sin(\omega \Delta + \theta)- sin(\theta)]\\\int_{t_k}^{t_{k+1}}{v(t)sin(\theta(t))}dt=v_k\int_{t_k}^{t_{k+1}}{sin(\theta_k+\omega (t-t_k))}dt=\frac{v_k}{\omega}[-cos(\omega \Delta + \theta)+ cos(\theta)]</script><p>则，上式的最终状态方程为</p><script type="math/tex; mode=display">X_{k+1}=X_k+\begin{bmatrix}\frac{v_k}{\omega}[sin(\omega \Delta + \theta)- sin(\theta)]\\\frac{v_k}{\omega}[-cos(\omega \Delta + \theta)+ cos(\theta)]\\0\\\omega \Delta t\\0\end{bmatrix}=\begin{bmatrix}x_k+\frac{v_k}{\omega}[sin(\omega \Delta + \theta)- sin(\theta)]\\y_k+\frac{v_k}{\omega}[-cos(\omega \Delta + \theta)+ cos(\theta)]\\v_k\\\omega \Delta t+\theta\\\omega\end{bmatrix}</script><p>对其中每个状态量求偏导得到雅各比矩阵 $J_F$</p><script type="math/tex; mode=display">J_F=\begin{bmatrix}1&0&\frac{1}{\omega}[sin(\omega \Delta t+\theta)-sin(\theta)&\frac{v_k}{\omega}[cos(\omega \Delta t+\theta)-cos(\theta)&\frac{v_k\Delta t}{\omega}cos(\omega \Delta t+\theta)-\frac{v_k}{\omega^2}[sin(\omega \Delta t+\theta)-sin(\theta)]\\0&1&\frac{1}{\omega}[-cos(\omega \Delta t+\theta)+cos(\theta)&\frac{v_k}{\omega}[sin(\omega \Delta t+\theta)-sin(\theta)&\frac{v_k\Delta t}{\omega}sin(\omega \Delta t+\theta)-\frac{v_k}{\omega^2}[-cos(\omega \Delta t+\theta)+cos(\theta)]\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1\end{bmatrix}</script><p>对于观测矩阵，如果是线性的，不用做计算。如果是非线性的，同样可以使用求偏导数的方式计算出雅各比矩阵 $J_H$</p><p>假设传感器是毫米波雷达观，且观测量是</p><script type="math/tex; mode=display">z_k=\begin{bmatrix}\rho_k\\\theta_k\\\dot{\rho}_k\end{bmatrix}=\begin{bmatrix}\sqrt{x_k^2+y_k^2}\\arctan(\frac{y_k}{x_k})\\\frac{v_xx_k+v_yy_k}{\sqrt{x_k^2+y_k^2}}\end{bmatrix}=\begin{bmatrix}\sqrt{x_k^2+y_k^2}\\arctan(\frac{y_k}{x_k})\\\frac{v_xx_kcos(\theta)+v_yy_ksin(\theta)}{\sqrt{x_k^2+y_k^2}}\end{bmatrix}</script><p>上式对状态方程每个状态量求偏导，得到雅各比矩阵，即观测矩阵 $J_H$ 为</p><script type="math/tex; mode=display">J_H=\begin{bmatrix}\frac{x}{\sqrt{x^2+y^2}}&\frac{y}{\sqrt{x^2+y^2}}&0&0&0\\-\frac{y}{x^2+y^2}&\frac{x}{x^2+y^2}&0&0&0\\\frac{y(vcos(\theta)y-vsin(\theta)x)}{(x^2+y^2)^{\frac{3}{2}}}&\frac{x(vsin(\theta)x-vcos(\theta)y)}{(x^2+y^2)^{\frac{3}{2}}}&\frac{xcos(\theta)+ysin(\theta)}{\sqrt{x^2+y^2}}&\frac{vcos(\theta)y-vsin(\theta)x}{\sqrt{x^2+y^2}}&0\end{bmatrix}</script><p><strong>Q矩阵计算</strong></p><p>对于 CTRV，假设直线加速度 $a_a$ 和偏航角加速度 $a_{\omega}$ 为常数，但是实际过程中会有噪声，因此 CTRV 的模型过程噪声主要来自于 $a_a$ 和 $a_\omega$。假设该模型噪声都符合高斯分布，即</p><script type="math/tex; mode=display">a_a\sim N(0,\sigma_a^2)\\a_\omega\sim N(0,\sigma_\omega^2)</script><p>则这两个加速度对状态量的预测噪声为</p><script type="math/tex; mode=display">w=\begin{bmatrix}\frac{\Delta t^2cos(\theta)a_a}{2}\\\frac{\Delta t^2sin(\theta)a_a}{2}\\\Delta t a_a\\\frac{\Delta t^2a_\omega}{2}\\\Delta t a_\omega\end{bmatrix}=\begin{bmatrix}\frac{\Delta t^2cos(\theta)}{2}&0\\\frac{\Delta t^2sin(\theta)}{2}&0\\\Delta t&0\\0&\frac{\Delta t^2}{2}\\0&\Delta t \end{bmatrix}\begin{bmatrix}a_a\\a_\omega \end{bmatrix}=Gu</script><p>则</p><script type="math/tex; mode=display">Q=cov(w)=E(ww^T)=GE(uu^T)G^T=G\begin{bmatrix}\sigma_a^2&0\\0&\sigma_\omega^2 \end{bmatrix}G^T</script><p>带入之后得</p><script type="math/tex; mode=display">Q=\begin{bmatrix}\frac{T^4\sigma_a^2cos^2(\theta)}{4}&\frac{T^4\sigma_a^2cos(\theta)sin(\theta)}{4}&\frac{T^3\sigma_a^2cos(\theta)}{2}&0&0\\\frac{T^4\sigma_a^2sin(\theta)cos(\theta)}{4}&\frac{T^4\sigma_a^2sin^2(\theta)}{4}&\frac{T^3\sigma_a^2sin(\theta)}{2}&0&0\\\frac{T^3\sigma_a^2cos(\theta)}{2}&\frac{T^3\sigma_a^2sin(\theta)}{2}&T^2\sigma_a^2&0&0\\0&0&0&\frac{T^4\sigma_a^2}{4}&\frac{T^3\sigma_\omega^2}{2}\\0&0&0&\frac{T^3\sigma_\omega^2}{2}&T^2\sigma_\omega^2\end{bmatrix}</script><p>常用的<strong>CV模型</strong>的状态量为</p><script type="math/tex; mode=display">X=\begin{bmatrix}x\\y\\v_x\\v_y\end{bmatrix}</script><p>其状态方程为</p><script type="math/tex; mode=display">X_{k+1}=X_k+\begin{bmatrix}v_x\Delta t\\v_y\Delta t\\0\\0\end{bmatrix}=\begin{bmatrix}x_k+v_x\Delta t\\y_k+v_y\Delta t\\v_x\\v_y\end{bmatrix}</script><p>该式子对状态量中的每个参数求偏导，得到 $J_F$</p><script type="math/tex; mode=display">J_F=\begin{bmatrix}1&0&\Delta t&0\\0&1&0&\Delta t\\0&0&1&0\\0&0&0&1\end{bmatrix}</script><p>如果假设观测量为</p><script type="math/tex; mode=display">z_k=\begin{bmatrix}\rho_k\\\theta_k\\\dot{\rho}_k\end{bmatrix}=\begin{bmatrix}\sqrt{x_k^2+y_k^2}\\arctan(\frac{y_k}{x_k})\\\frac{v_xx_k+v_yy_k}{\sqrt{x_k^2+y_k^2}}\end{bmatrix}</script><p>该式子对系统状态量中每个参数求偏导，得到 $J_H$</p><script type="math/tex; mode=display">J_H=\begin{bmatrix}\frac{x_k}{\sqrt{x_k^2+y_k^2}}&\frac{y_k}{\sqrt{x_k^2+y_k^2}}&0&0\\-\frac{y_k}{x_k^2+y_K^2}&\frac{x_k}{x_k^2+y_k^2}&0&0\\\frac{y_k(v_xy_k-v_yx_k)}{(x_k^2+y_k^2)^{\frac{3}{2}}}&\frac{x_k(v_yx_k-v_xy_k)}{(x_k^2+y_k^2)^{\frac{3}{2}}}&\frac{x_k}{\sqrt{x_k^2+y_k^2}}&\frac{y_k}{\sqrt{x_k^2+y_k^2}}\end{bmatrix}</script><p><strong>Q矩阵计算</strong></p><p>对于 CV，假设直线加速度 $a_x$ 和偏航角加速度 $a_{y}$ 为常数，但是实际过程中会有噪声，因此 CV 的模型过程噪声主要来自于 $a_x$ 和 $a_y$。假设该模型噪声都符合高斯分布，即</p><script type="math/tex; mode=display">a_x\sim N(0,\sigma_a^2)\\a_y\sim N(0,\sigma_\omega^2)</script><script type="math/tex; mode=display">w=\begin{bmatrix}\frac{\Delta t^2a_x}{2}\\\frac{\Delta t^2a_y}{2}\\\Delta t a_x\\\Delta t a_y\end{bmatrix}=\begin{bmatrix}\frac{\Delta t^2}{2}&0\\0&\frac{\Delta t^2}{2}\\\Delta t&0\\0&\Delta t \end{bmatrix}\begin{bmatrix}a_x\\a_y\end{bmatrix}=Gu</script><p>则</p><script type="math/tex; mode=display">Q=cov(w)=E(ww^T)=GE(uu^T)G^T=G\begin{bmatrix}\sigma_x^2&0\\0&\sigma_y^2 \end{bmatrix}G^T</script><script type="math/tex; mode=display">Q=\begin{bmatrix}\frac{T^4\sigma_x^2}{4}&0&\frac{T^3\sigma_x^2}{2}&0\\0&\frac{T^4\sigma_y^2}{4}&0&\frac{T^3\sigma_y^2}{2}\\\frac{T^3\sigma_x^2}{2}&0&T^2\sigma_x^2&0\\0&\frac{T^3\sigma_y^2}{2}&0&T^2\sigma_y^2\end{bmatrix}</script><h3 id="恒定转弯率和加速度模型（Constant-Turn-Rate-and-Velocity——CTRA）——过于复杂"><a href="#恒定转弯率和加速度模型（Constant-Turn-Rate-and-Velocity——CTRA）——过于复杂" class="headerlink" title="恒定转弯率和加速度模型（Constant Turn Rate and Velocity——CTRA）——过于复杂"></a>恒定转弯率和加速度模型（<strong>Constant Turn Rate and Velocity——</strong>CTRA）——过于复杂</h3><p>其中的系统状态量为</p><script type="math/tex; mode=display">X=\begin{bmatrix}x\\y\\\theta\\v\\\omega\\a\end{bmatrix}</script><p>系统状态方程为</p><script type="math/tex; mode=display">X_{k+1}=X_k+\begin{bmatrix}\int_{t_k}^{t_{k+1}}{v(t)cos(\theta(t))}dt\\\int_{t_k}^{t_{k+1}}{v(t)sin(\theta(t))}dt\\\omega \Delta t\\a\Delta t\\0\\0\end{bmatrix}</script><p>其中 $a$ 和 $\omega$ 为常量，与时间无关，其中 $\Delta t=t_{k+1}-t_k$，其中积分化简为</p><script type="math/tex; mode=display">\int_{t_k}^{t_{k+1}}{v(t)cos(\theta(t))}dt=\int_{t_k}^{t_{k+1}}{(v_k+a(t-t_k))cos(\theta_k+\omega(t-t_k))}dt=\frac{1}{\omega^2}[(v_k\omega+a\omega\Delta t)sin(\theta_k+\omega \Delta t)+acos(\theta_k+\omega\Delta t)-v_k\omega sin(\theta_k)-acos(\theta_k)]\\\int_{t_k}^{t_{k+1}}{v(t)sin(\theta(t))}dt=\int_{t_k}^{t_{k+1}}{(v_k+a(t-t_k))sin(\theta_k+\omega(t-t_k))}dt=\frac{1}{\omega^2}[-(v_k\omega+a\omega\Delta t)cos(\theta_k+\omega \Delta t)-asin(\theta_k+\omega\Delta t)+v_k\omega cos(\theta_k)+asin(\theta_k)]</script><p>所以上式最终可以表示为</p><script type="math/tex; mode=display">X_{k+1}=\begin{bmatrix}x_k+\frac{1}{\omega^2}[(v_k\omega+a\omega\Delta t)sin(\theta_k+\omega \Delta t)+acos(\theta_k+\omega\Delta t)-v_k\omega sin(\theta_k)-acos(\theta_k)]\\y+\frac{1}{\omega^2}[-(v_k\omega+a\omega\Delta t)cos(\theta_k+\omega \Delta t)-asin(\theta_k+\omega\Delta t)+v_k\omega cos(\theta_k)+asin(\theta_k)]\\\theta_k+\omega \Delta t\\v_k+a\Delta t\\\omega\\a\end{bmatrix}</script><p>对状态方程的每个状态量求偏导，得到雅各比矩阵 $J_F$</p><script type="math/tex; mode=display">J_F=\begin{bmatrix}1&0&\frac{1}{\omega^2}[(v\omega+a\omega T)cos(\theta+\omega T)-asin(\theta+\omega T)-v\omega cos(\theta)+asin(\theta)]&\frac{1}{\omega^2}[\omega sin(\theta+\omega T)-\omega sin(\theta)]&\frac{-Tasin(T\omega+\theta)+T(T\omega a+\omega v)cos(T\omega +\theta)-vsin(\theta)+(Ta+v)sin(T\omega+\theta)}{\omega^2}-\frac{2(-\omega vsin(\theta)-acos(\theta)+acos(T\omega+a)+(T\omega a+\omega v)sin(T\omega +\theta)}{\omega^3}&\frac{T\omega sin(T\omega +\theta)-cos(\theta)+cos(T\omega +\theta)}{\omega^2}\\0&1&\frac{1}{\omega^2}[(v\omega+a\omega T)sin(\theta+\omega T)+acos(\theta+\omega T)+v\omega sin(\theta)-acos(\theta)]&\frac{1}{\omega^2}[-\omega cos(\theta+\omega T)+\omega cos(\theta)]&\frac{Tacos(T\omega+\theta)+T(T\omega a+\omega v)sin(T\omega +\theta)+vcos(\theta)-(Ta+v)cos(T\omega+\theta)}{\omega^2}-\frac{2(\omega vcos(\theta)-asin(\theta)+asin(T\omega+a)-(T\omega a+\omega v)cos(T\omega +\theta)}{\omega^3}&\frac{-T\omega cos(T\omega +\theta)-sin(\theta)+sin(T\omega +\theta)}{\omega^2}\\0&0&1&0&T&0\\0&0&0&1&0&T\\0&0&0&0&1&0\\0&0&0&0&0&1\end{bmatrix}</script><h2 id="无迹卡尔曼滤波-UKF"><a href="#无迹卡尔曼滤波-UKF" class="headerlink" title="无迹卡尔曼滤波 UKF"></a>无迹卡尔曼滤波 UKF</h2><p>卡尔曼滤波（Kalman filtering）是一种利用线性系统状态方程，通过系统输入输出观测数据，对系统状态进行最优估计的算法。由于观测数据中包括系统中的噪声和干扰的影响，所以最优估计也可看作是滤波过程。</p><p>无迹卡尔曼滤波（Unscented Kalman Filter，UKF），是无损变换（Unscented Transform，UT变换）与标准卡尔曼滤波体系的结合，通过无损变换变换使非线性系统方程适用于线性假设下的标准卡尔曼体系，相当于是 KF 基础上加入了 UT 变换</p><p>对于非线性问题的处理，过程模型F和测量模型H是非线性的，EKF是求一阶全导数得到线性模型，来近似非线性模型；而UKF是直接寻找一个与真实分布近似的高斯分布，没有用线性表征。</p><h3 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h3><ul><li>对于某个系统，你拥有准确的数学模型（状态方程和观测方程），也就是说，给出这个系统的输入，你必然能算出这个系统的输出；但是，在现实生活中往往拿到的第一手测试数据并不是你想要的最直观的数据（而且数据还有噪声），这时候使用UKF可以依靠相对准确的数值模型和结合测试数据来得到你想要的信息</li><li>数值模型的参数相对不准确，但实测数据可信度更好，这时候使用UKF可以依靠相对准确的实测数据和结合数值模型来还原较真实的参数</li></ul><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p><img src="/Blog_ButterFly/2024/03/19/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/v2-008fc966f40ba5c834c555c2dd91bac1_720w.webp" alt="v2-008fc966f40ba5c834c555c2dd91bac1_720w.webp"></p><p><strong>该算法的核心思想是：采用UT变换，利用一组Sigma采样点来描述随机变量的高斯分布，然后通过非线性函数的传递，再利用加权统计线性回归技术来近似非x线性函数的后验均值和方差。相比于EKF，UKF的估计精度能够达到泰勒级数展开的二阶精度</strong></p><h3 id="UKF的原理与实现流程"><a href="#UKF的原理与实现流程" class="headerlink" title="UKF的原理与实现流程"></a><strong>UKF的原理与实现流程</strong></h3><ol><li><p><strong>UT变换</strong></p><p> 例如函数 $y=f(x)$ 是一个非线性函数，x 为 n 维随机变量，它的均值为 $\overline{x}$，方差为 $P_x$。UT变换根据一定的采样策略，获得一组 Sigma 采样点 $\{x_i\},i=0,1,…,L$，并且设定均值权值 $\omega_m^{(i)}$ 和方差权值 $\omega_c^{(i)}$，来近似非线性函数的后验均值和方差，利用选取的 Sigma 采样点集 $\{x_i\},i=0,1,…,L$，进行非线性函数传递可得 $y_i=f(x_i)$，其中 $y_i$ 为 Sigma 采样经过非线性函数传递后对应的点。根据加权统计线性回归技术可以近似得到 y 的统计特性：</p><script type="math/tex; mode=display"> \overline{y}=\sum_{i=0}^{L}{\omega_m^{(i)}y_i}\\P_{yy}=\sum_{i=0}^{L}{\omega_c^{(i)}(y_i-\overline{y})(y_i-\overline{y})^T}\\P_{xy}=\sum_{i=0}^{L}{\omega_c^{(i)}(x_i-\overline{x})(y_i-\overline{y})^T}</script></li><li><p><strong>采样策略</strong></p><p> 根据 Sigma 点采样策略不同，相应的 Sigma 点以及均值权值和方差权值也不尽相同，因此 UT 变换的估计精度也会有差异，但总体来说，其估计精度能够达到泰勒级数展开的二阶精度。为保证随机变量x经过采样之后得到的 Sigma 采样点仍具有原变量的必要特性，所以采样点的选取应满足下列条件：</p><script type="math/tex; mode=display"> g(\{x_i,\omega_m^{(i)},\omega_c^{(i)}\},L,P_x(x))=0</script><p> 其中</p><ul><li>$\{x_i,\omega_m^{(i)},\omega_c^{(i)}\}$ 为 Sigma 采样点，均值权重和方差权重组合的集合</li><li>L 为采样点个数</li><li>$P_x(x)$ 为随机变量 x 的密度函数</li><li><p>$g()$ 确定 x 的相关信息。如果密度函数 $P_x(x)$ 只有一二阶矩时可以写成</p><script type="math/tex; mode=display">g(\{x_i,\omega_m^{(i)},\omega_c^{(i)}\},L,P_x(x))=\begin{bmatrix}\sum_{i=0}^{L}\omega_m^{(i)}-1\\\sum_{i=0}^{L}\omega_c^{(i)}-1\\\sum_{i=0}^{L}w_m^{(i)}x_i-\overline{x}\\\sum_{i=0}^{L}{\omega_c^{(i)}(x_i-\overline{x})(x_i-\overline{x})^T}-P_{xx}\end{bmatrix}=0</script><p><strong>采样策略：比例采样</strong></p><p><strong>n 维随机变量 x</strong> 的均值和方差分别为 $\overline{x}$ 和 $P_x$，假设 L=2n，则 Sigma 采样点共有 2n+1 个，对应的采样点和均值权值和方差权值</p><script type="math/tex; mode=display">X^{(i)}=\left\{\begin{aligned}&\overline{X}&&i=0\\&\overline{X}+(\sqrt{(n+\kappa )P})_i&&i=1\sim n\\&\overline{X}-(\sqrt{(n+\kappa) P})_i&&i=n+1\sim 2n\end{aligned}\right.\\\omega_m^{(i)}=\omega_c^{(i)}=\left\{\begin{aligned}&\frac{\kappa }{n+\kappa }&&i=0\\&\frac{\kappa }{2(n+\kappa )}&&i=1\sim 2n\end{aligned}\right.</script><p>其中</p></li><li><p>$\kappa$ 定义为随机变量 x 的均值 $\overline{x}$ 和 Sigma 采样点间距离的比例因子，其取值的大小直接反应二阶以上的高阶矩引起的偏差</p></li><li><p>$(\sqrt{(n+\kappa) P})_i$ 定义为矩阵 $(n+\kappa) P$ 经过 $Cholesky$ 分解求得的平方根矩阵的第 i 行或列</p><p><strong>采样策略：比例修正对称采样</strong></p><p>为保证协方差的半正定性以及解决采样的非局部效应问题，采用比例修正采样策略来近似非线性函数的后验分布</p></li><li><p>比例修正算法</p><script type="math/tex; mode=display">  x_i'=x_0+\alpha(x_i-x_0)\\(\omega_m^{(i)})'=\left\{\begin{aligned}&\frac{\omega_m^{(i)}}{\alpha^2}+1-\frac{1}{\alpha^2}&&i=0\\&\frac{\omega_m^{(i)}}{\alpha^2}&&i\not=0\end{aligned}\right.\\(\omega_c^{(i)})'=\left\{\begin{aligned}&(\omega_m^{(i)})'+(1+\beta-\alpha^2)&&i=0\\&(\omega_m^{(i)})'&&i\not=0\end{aligned}\right.</script><p>  其中 $\alpha$ 为比例缩放因子， $0\leq\alpha\leq 1$，控制 $\alpha$ 的值可以控制 Sigma 点集的范围，通常设置为一个很小的正数。 $\beta$ 反映状态历史信息的高阶特性，对于高斯分布来说 $\beta=2$ 为最优</p></li><li><p>将上述比例修正算法带入对称采样中，得到比例修正对称采样策略</p><script type="math/tex; mode=display">  (X^{(i)})'=\left\{\begin{aligned}&\overline{X}&&i=0\\&\overline{X}+(\sqrt{(n+\lambda )P})_i&&i=1\sim n\\&\overline{X}-(\sqrt{(n+\lambda)P})_i&&i=n+1\sim 2n\end{aligned}\right.\\(\omega_m^{(i)})'=\left\{\begin{aligned}&\frac{\lambda}{n+\lambda}&&i=0\\&\frac{\lambda}{2(n+\lambda)}&&i=1\sim 2n\end{aligned}\right.\\(\omega_c^{(i)})'=\left\{\begin{aligned}&\frac{\lambda}{n + \lambda}+(1-\alpha^2+\beta)&&i=0\\&\frac{\lambda}{2(n+\lambda)}&&i=1\sim 2n\end{aligned}\right.</script><p>  其中 $\lambda=\alpha^2(n+\kappa)-n$， $\kappa$ 为比例因子，当 x 为单变量时， $\kappa=0$，当 x 为多变量时 $\kappa = 3 - n$。通常需要保证矩阵 $(n+\lambda)P$ 为半正定矩阵</p></li></ul></li><li><p><strong>状态方程与观测方程</strong></p><script type="math/tex; mode=display"> X_{k+1}=f(X_k)+w_k\\Z_k=h(X_k)+v_k</script><p> 其中，</p><ul><li>$f$ 是系统非线性状态方程函数，即系统在第 k+1 步与第 k 步的数学关系</li><li>$h$ 是非线性观测方程函数，即当前系统状态与实际观测数据之间的关系</li><li>$w,v$ 是状态方程与观测方程的当前噪声</li></ul></li><li><p><strong>获得 2n+1 个采样组合（即Sigma点集）及其权值（n为需要估计的参数数量）</strong></p><script type="math/tex; mode=display"> X^{(i)}=\left\{\begin{aligned}&\overline{X}&&i=0\\&\overline{X}+(\sqrt{(n+\lambda )P})_i&&i=1\sim n\\&\overline{X}-(\sqrt{(n+\lambda)P})_i&&i=n+1\sim 2n\end{aligned}\right.</script><p> 其中 $(\sqrt{P})^T(\sqrt{P})=P$， $(\sqrt{P})_i$ 表示矩阵方根的第 i 列，其中 P 指的是当前状态的协方差矩阵（每步实时更新）</p><p>  对上式进行整理</p><script type="math/tex; mode=display"> X^{(i)}_{k|k}=\begin{bmatrix}\hat{X}_{k|k}\\\hat{X}_{k|k}+(\sqrt{(n+\lambda)P_{k|k}})_i\\\hat{X}_{k|k}-(\sqrt{(n+\lambda)P_{k|k}})_i\end{bmatrix}</script></li><li><p><strong>把这2n+1个点代进状态方程，获得了这些点的k+1步预测</strong></p><script type="math/tex; mode=display"> X^{(i)}_{k+1|k}=f(k, X^{(i)}_{k|k})</script></li><li><p><strong>根据上式得到的 2n+1 个预测结果，计算系统状态的 k+1 步预测均值和协方差矩阵</strong></p><p> 设计计算权重值</p><script type="math/tex; mode=display"> \omega_m^{(i)}=\left\{\begin{aligned}&\frac{\lambda}{n+\lambda}&&i=0\\&\frac{\lambda}{2(n+\lambda)}&&i=1\sim 2n\end{aligned}\right.\\\omega_c^{(i)}=\left\{\begin{aligned}&\frac{\lambda}{n + \lambda}+(1-\alpha^2+\beta)&&i=0\\&\frac{\lambda}{2(n+\lambda)}&&i=1\sim 2n\end{aligned}\right.</script><p> 其中 m 表示均值，c 表示协方差，上标为几个采样点，其中</p><ul><li>$\lambda = \alpha^2(n+\kappa)-n$ 是一个缩放比例参数，用来降低总的预测误差</li><li>$\alpha$ 的选取控制了 Sigma点集的范围，比例缩放因子， $0\leq\alpha\leq1$，通常设置一个很小的正数</li><li>$\kappa$ 为一个待选参数，当 x 为单变量时， $\kappa=0$，当 x 为多变量时 $\kappa = 3 - n$。通常需要保证矩阵 $(n+\lambda)P$ 为半正定矩阵</li><li><p>$\beta$ 是一个非负的权系数，反映状态历史信息的高阶特性，对于高斯分布 $\beta =2$ 最优。可以合并方程中高阶项的动差，这样就可以把高阶项影响包括在内。</p><p><strong>下式的系统状态量的 k+1 步预测均值和协方差矩阵</strong></p><script type="math/tex; mode=display">\hat{X}_{k+1|k}=\sum_{i=0}^{2n}\omega_m^{(i)}X^{(i)}_{k+1|k}\\P_{k+1|k}=\sum_{i=0}^{2n}\omega_c^{(i)}[X^{(i)}_{k+1|k}-\hat{X}_{k+1|k}][X^{(i)}_{k+1|k}-\hat{X}_{k+1|k}]^T+Q</script></li></ul></li><li><p><strong>根据上式的预测均值 $\hat{X}_{k+1|k}$ 和协方差矩阵 $P_{k+1|k}$，再次使用 UT 变换，产生新的 2n+1 个 Sigma点集</strong></p><script type="math/tex; mode=display"> X^{(i)}_{k+1|k}=\begin{bmatrix}\hat{X}_{k+1|k}\\(\hat{X}_{k+1|k}+\sqrt{(n+\lambda)P_{k+1|k}})_i\\\hat{X}_{k+1|k}-(\sqrt{(n+\lambda)P_{k+1|k}})_i\end{bmatrix}</script></li><li><p><strong>将上式的点集带入观测方程，得到 k+1 步预测观测量</strong></p><script type="math/tex; mode=display"> Z_{k+1|k}^{(i)}=h(X_{k+1|k}^{(i)})</script></li><li><p><strong>上式能得到 2n+1 个预测结果，计算系统观测量的 k+1 步预测均值和协方差巨家镇，其中权值还是上面之前的权值</strong></p><script type="math/tex; mode=display"> \overline{Z}_{k+1|k}=\sum_{i=0}^{2n}\omega_m^{(i)}Z_{k+1|k}^{(i)}\\P_{z_kz_k}=\sum_{i=0}^{2n}\omega_c^{(i)}[Z_{k+1|k}^{(i)}-\overline{Z}_{k+1|k}][Z_{k+1|k}^{(i)}-\overline{Z}_{k+1|k}]^T+R\\P_{x_kz_k}=\sum_{i=0}^{2n}\omega_c^{(i)}[X_{k+1|k}^{(i)}-\hat{X}_{k+1|k}][Z_{k+1|k}^{(i)}-\overline{Z}_{k+1|k}]^T</script></li><li><p><strong>计算Kalman增益矩阵</strong></p><script type="math/tex; mode=display">K_{k+1}=P_{x_kz_k}P_{z_kz_k}^{-1}</script></li><li><p><strong>更新系统状态与协方差 P</strong></p><script type="math/tex; mode=display">\hat{X}_{k+1|k+1}=\hat{X}_{k+1|k}+K_{k+1}[Z_{k+1}-\overline{Z}_{k+1|k}]\\P_{k+1|k+1}=P_{k+1|k}-K_{k+1}P_{z_kz_k}K^T_{k+1}</script><p>其中 $Z_{k+1}$ 是第 k + 1 步实测数据</p></li><li><p><strong>最终小结</strong></p><p>UKF 用UT变换近似逼近了系统非线性变换后的分布，得到的 Kalman 增益可以类比成状态变量X的在当前步的线性修正率，有了这个线性修正率再去×修正量（实测-预测均值，即 $Z_{k+1}-\overline{Z}_{k+1|k}$ )，从而更新了 k+1 步的状态量，实现了追踪。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
            <tag> Kalman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优控制</title>
      <link href="/Blog_ButterFly/2024/03/19/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6/"/>
      <url>/Blog_ButterFly/2024/03/19/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>一个最优的控制策略是无论最初状态和最初的决策是什么，剩余的控制策略一定符合最优控制策略</p><h2 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a><strong>性能指标</strong></h3><p>假设一个系统中的状态量分别为 $x_1,…,x_n$，并且期望值 $x_{1d},…,x_{nd}$ ，可以得到性能指标，这里的状态量指的是一个状态在不同的时间下的具体表现</p><script type="math/tex; mode=display">J=(x_1-x_{1d})^2+...+(x_n-x_{nd})^2</script><p>体现的是每个状态变量的代价，也就是代价函数，当 $J→0$ 也就是说明状态与期望状态越接近，上式还可以写作另一种形式，令 $e_n=x_{nd}-x_n$</p><script type="math/tex; mode=display">J=\begin{bmatrix}e_1&...&e_n\end{bmatrix}\begin{bmatrix}e_1\\...\\e_n\end{bmatrix}</script><p>由于对于不同的变量都有不同的权重系数，所以引入权重系数 $s$</p><script type="math/tex; mode=display">J=\begin{bmatrix}e_1&...&e_n\end{bmatrix}\begin{bmatrix}s_1\\&...\\&&s_n\end{bmatrix}\begin{bmatrix}e_1\\...\\e_n\end{bmatrix}=E^TSE</script><p>由于不同的变量的单位不同，所以要将不同的单位进行规范化，需要在设计权重时考虑到</p><h3 id="物理硬约束"><a href="#物理硬约束" class="headerlink" title="物理硬约束"></a>物理硬约束</h3><p>对于一个系统的来说，速度，位置都是一种约束，这是控制中需要考虑的</p><h3 id="能耗"><a href="#能耗" class="headerlink" title="能耗"></a>能耗</h3><p>引入能耗之后，权重矩阵就变为</p><script type="math/tex; mode=display">J=E^TSE+U^TRU</script><p>其中 </p><script type="math/tex; mode=display">U=\begin{bmatrix}u_1\\...\\u_{n-1}\end{bmatrix}</script><p>这就需要考虑能耗与性能之间的权重了，如果 $S&gt;&gt;R$ 导致系统不考虑能耗，而 $R&gt;&gt;S$ 则会导致系统为了节能会有很差的表现，甚至是不动</p><p>这里的能耗约束实际上属于是一种软约束</p><p>系统的能耗也一定在某一个范围内 $u\in u^*$</p><h3 id="系统状态跟踪"><a href="#系统状态跟踪" class="headerlink" title="系统状态跟踪"></a>系统状态跟踪</h3><p>在速度追踪时，由于系统的状态的目标值不再是一个单纯的点，而是一个函数关系</p><script type="math/tex; mode=display">\begin{bmatrix}x_{1d}\\...\\x_{nd}\end{bmatrix}\rightarrow\begin{bmatrix}p_{1}(t)\\...\\p_n(t)\end{bmatrix}</script><p>实现系统向着目标点跟踪，并且在代价函数中也会体现</p><script type="math/tex; mode=display">J=||x_n-x_{nd}||^2S_n+\sum_{k=0}^{n-1}(||x_k-x_{kd}||^2Q_k+||u_k||^2R)</script><p>其中第一项为<strong>末端代价</strong>，第二项为<strong>过程代价</strong></p><h3 id="避障"><a href="#避障" class="headerlink" title="避障"></a>避障</h3><p>这是与系统状态跟踪是相关联的，系统可以运行的区域为<strong>容许轨迹</strong> $p^*$</p><p>在定义轨迹函数 p 时，需要保证 $p\in p^*$</p><h3 id="最优化控制"><a href="#最优化控制" class="headerlink" title="最优化控制"></a>最优化控制</h3><p>代价函数也可以写作</p><script type="math/tex; mode=display">J=\sum_{k=m+1}^{n}h_d(x_n,k)+\sum_{k=0}^{m}g_d(x_k,u_k,k)</script><p>其中第一项表示最终目标量的权重，而第二项表示过程的权重，最后的目标就是找到一个合适的 $u_k$ 来使得系统状态向着目标值转换，并且使代价函数 $J$ 最小</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>实际上最优控制策略体现出一种动态规划</p><p><strong>例子</strong></p><p>一个无人机，从地面以最短时间上升到 10 m</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6/1708572807088.png" alt="1708572807088.png"></p><script type="math/tex; mode=display">h(0)=0\\\dot{h}(0)=0\\\Downarrow\\h(t_f)=10\\\dot{h}(t_f)=0</script><p>由于需要时间最短，可以设计代价函数</p><script type="math/tex; mode=display">J=t_f</script><p>约束（只能向上/静止）</p><script type="math/tex; mode=display">-3\leq a\leq 2\\0\leq v\leq 3</script><p>列出系统状态方程</p><script type="math/tex; mode=display">m\ddot{h}(t)=f(t)-mg\\f(t)=Fv_m</script><p>可以将系统离散化为多个状态</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6/1708583538116.png" alt="1708583538116.png"></p><p>从终点开始，逐个计算每个状态所需的最小 cost to go，也就是将要的花费，从而得到最佳的速度路径规划</p><p><img src="/Blog_ButterFly/2024/03/19/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6/1708583966568.png" alt="1708583966568.png"></p><p>可以使用暴力算法直接解算出所有状态的代价函数，但是所需要的计算资源是不可估量的，所以要使用一个更简单的方法——动态规划</p><p><strong>一个简单的例子</strong></p><p>对于一个一维系统</p><script type="math/tex; mode=display">x_{k+1}=x_k+u_k\\x_0=1\\x_d=0</script><p>设置代价函数</p><script type="math/tex; mode=display">J=0.5||x_n-x_{nd}||^2+0.5\sum_{k=0}^{n-1}(||x_k-x_{kd}||^2Q_k+||u_k||^2R)\\\Downarrow\\J=0.5x_2^2+0.5(x_1^2+u_1^2+x_0^2+u_0^2)</script><p>可以提出两种策略</p><script type="math/tex; mode=display">u_0=-1~~x_1=x_0+u_0=0\\u_1=0~~x_2=x_1+u_1=0\\\Downarrow\\J=1</script><script type="math/tex; mode=display">u_0=-0.5~~x_1=x_0+u_0=0.5\\u_1=-0.5~~x_2=x_1+u_1=0\\\Downarrow\\J=0.875</script><p>在这里就通过计算 $u^<em>[0],u^</em>[1]$ 使代价函数最小，使用逆向分级的思想</p><script type="math/tex; mode=display">J_{1\rightarrow 2}=0.5x_2^2+0.5x_1^2+u_1^2=0.5(x_1+u_1)^2+0.5x_1^2+0.5u_1^2\\\frac{\partial J}{\partial u_1}=x_1+u_1+u_1=0\\\Downarrow\\u^*_1=-\frac{1}{2}x_1\\\Downarrow\\J^*_{1\rightarrow 2}=\frac{3}{4}x_1^2\\\Downarrow\\J_{0\rightarrow 2}=0.5x_2^2+0.5(x_1^2+u_1^2+x_0^2+u_0^2)=J_{1\rightarrow 2}+0.5(x_0^2+u_0^2)</script><p>根据贝尔曼最优理论：当 $J_{0\rightarrow 2}$ 最小，其中包含的 $J_{1\rightarrow 2}$ 一定是最小的</p><script type="math/tex; mode=display">J_{0\rightarrow 2}=J_{1\rightarrow 2}+0.5(x_0^2+u_0^2)=\frac{3}{4}x_1^2+\frac{1}{2}(x_0^2+u_0^2)=\frac{3}{4}(x_0+u_0)^2+\frac{1}{2}(x_0^2+u_0^2)\\\frac{\partial J}{\partial u_0}=\frac{3}{2}(x_0+u_0)+u_0=0\\\Downarrow\\u_0^*=-\frac{3}{5}x_0</script><p>贝尔曼动态规划最优控制方程</p><script type="math/tex; mode=display">J^*_{N-k\rightarrow N}(x_{N-k})=\underset{u_{N-k}}{min}(J^*_{N-(k-1)\rightarrow N}(f(x_{N-k},u_{N-k}))+g(x_{N-k},u_{N-k}))</script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADRC自抗扰控制器</title>
      <link href="/Blog_ButterFly/2024/03/19/ADRC%E8%87%AA%E6%8A%97%E6%89%B0%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/19/ADRC%E8%87%AA%E6%8A%97%E6%89%B0%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><p><img src="/Blog_ButterFly/2024/03/19/ADRC%E8%87%AA%E6%8A%97%E6%89%B0%E6%8E%A7%E5%88%B6%E5%99%A8/Untitled.png" alt="Untitled"></p><p>为了解决快速性和超调的矛盾，在控制器设计过程中引入了过渡过程，通俗的讲就是输入信号从初始值到目标值并不是阶跃的，而是平滑过渡的，并且这个过渡过程的时间长短是可以调节的。将过渡过程和微分器在一个模块中实现，称为<strong>跟踪-微分器(TD)，</strong>单独的过渡过程和速度规划并没有本质区别。但是TD和速度规划不是一回事，TD将输入过渡和微分器统一为一个模块，它一边尽可能快地跟踪输入信号，同时给出输入信号近似的微分。</p><p>自抗扰控制对扰动和不确定性的处理是自抗扰控制最突出的特征，它把作用于被控对象的所有不确定因素都归结为“未知扰动”，而用被控对象的输入输出数据对它进行估计，并给予补偿。“自抗扰”的名称也来源于此，即主动抵抗干扰，不需要直接测量外扰的作用，也不需要实现知道扰动的规律（能知道更好）。构建观测器，利用被控对象的输入、输出和所施加的控制输入来估计作用于系统的总扰动（包括内扰和外扰，可以粗浅地理解为所有的影响因素），实现这一功能的模块被称为<strong>扩展状态观测器</strong>（Extended State Observer，ESO）。这个名字也与观测器的形式十分匹配，因为在设计ESO时，首先构造一个扩张的系统，此系统的阶数比被控对象的阶数高一阶，ESO就是估计扩张系统的状态。观测出系统的总扰动，在设计控制器时首先抵消掉这个扰动，将得到一个标准的串联积分型系统，基于此标准型系统设计控制器时，控制器的形式与PID的形式类型，一般利用误差和误差的微分来构造控制器，这里的误差及其微分是由TD的输出和ESO的输出构造的。韩老师在其专著中给出了常用的几种<strong>非线性状态误差反馈控制律</strong>（Nonlinear State Error Feedback，NLSEF）。</p><p>以下的所有形式都是连续型的形式，对于使用离散化的控制，就需要将其离散化</p><p>也比较简单：根据导数来计算 </p><p>也比较简单：根据导数来计算 $x_{k+1}= T * \frac{dx_k}{dt} + x_k$</p><h3 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a><strong>主要模块</strong></h3><ul><li>跟踪-微分器 TD</li><li>扩张状态观测器 ESO</li><li>状态误差反馈规律 SEF</li></ul><h2 id="LADRC-线性ADRC"><a href="#LADRC-线性ADRC" class="headerlink" title="LADRC 线性ADRC"></a>LADRC 线性ADRC</h2><p>被控对象可以有时延，可以有右半平面的零点或极点，但不能在右半平面同时有零点和极点。同时有右半平面的零点和极点，意味着有根轨迹从右半平面出发有回到右半平面，可能一直在右半平面，这样控制器设计是十分困难的。</p><p>被控对象的型次要求：对象不含微分器，且型次要求允许控制器含一个积分器。LADRC本身含一个积分器，如果被控对象含微分器，会出现原点的零极点对消。允许控制器含一个积分器是因为LADRC中是一定含有一个积分器的。</p><h3 id="一阶LADRC"><a href="#一阶LADRC" class="headerlink" title="一阶LADRC"></a>一阶LADRC</h3><ul><li><p><strong>LTD</strong></p><p>  是由一阶低通滤波器 $\frac{r}{s + r}$ 推导出来的，只需要更改 $r$ 值， $r$ 值越大到达设定值 $v$ 的时间就越短</p><p>  令</p><script type="math/tex; mode=display">  X=\begin{bmatrix}x_1\end{bmatrix}\\x_1=y</script><p>  从上式的低通滤波的传递函数可以推导出系统的状态方程</p><script type="math/tex; mode=display">  \dot{X}=AX+Bu=\begin{bmatrix}-r\end{bmatrix}X+[r]u\\Y=[1]X+[0]u</script><p>  输出，这里的 u 表示输入的期望值，LTD 是对期望值进行处理的</p><script type="math/tex; mode=display">  x_1(k+1)=h\dot{x_1}(k)+x_1(k) =h(-rx_1(k) + ru)+x_1(k)</script></li><li><p><strong>LESO</strong></p><p>  从上述LTD中可知，这一步实际上是把扰动合并，将输入输出噪声与模型上的误差合并，从而得到下列式子。其中 $f$ 是总扰动</p><script type="math/tex; mode=display">  y'=f(x_1)+bu= f(x_1) + b_0u - b_0u + bu=f+b_0u</script><p>  在一阶的 ADRC 中，LESO 是二阶的，具体形式为</p><p>  令</p><script type="math/tex; mode=display">  Z=\begin{bmatrix}z_1\\z_2\end{bmatrix}</script><p>  并且</p><script type="math/tex; mode=display">  z_1\rightarrow x_1=y\\z_2\rightarrow f~扰动</script><p>  得</p><script type="math/tex; mode=display">  \dot{Z}=AZ+Bu+L(x_1-z_1)\\\hat{y}=CZ</script><p>  其中</p><script type="math/tex; mode=display">  L=\begin{bmatrix}\beta_1\\\beta_2\\\beta_3\end{bmatrix}</script><p>  带入</p><script type="math/tex; mode=display">  \left\{\begin{aligned}\left.\begin{bmatrix}\dot{z_1}\\\dot{z_2}\end{bmatrix}\right.&=&\left.\begin{bmatrix}-\beta_1&1\\-\beta_2&0\end{bmatrix}\right.\left.\begin{bmatrix}z_1\\z_2\end{bmatrix}\right.+\left.\begin{bmatrix}b_0&\beta_1\\0&\beta_2\end{bmatrix}\right.\left.\begin{bmatrix}u\\y\end{bmatrix}\right.\\\hat{y}&=&\left.\begin{bmatrix}1&0\\0&1\end{bmatrix}\right.\left.\begin{bmatrix}z_1\\z_2\end{bmatrix}\right.\end{aligned}\right.</script><p>  其中 $\beta$ 存在于特征方程中，如下</p><script type="math/tex; mode=display">  L_{ESO}(s)=s^{n+1}+\beta_1 s^n + \beta_2 s^{n-1}+…+\beta_{n-1}</script><p>  将极点都配置到左半轴同一位置，可以将调节参数缩减为</p><script type="math/tex; mode=display">  L_{ESO}(s)=(s+w_o)^{n+1}=0</script><p>  其中 $w_o$ 表示扩张观测器的带宽，而 $\beta$ 对应着相应的系数</p><p>  输入为 $u, y$</p><p>  输出为</p><script type="math/tex; mode=display">  z_1(k+1)=z_1(k)+h\dot{z_1}(k)=z_1(k)+h(-\beta_1z_1(k)+z_2(k)+b_0u+\beta_1y)\\z_2(k+1)=z_2(k)+h\dot{z_2}(k)=z_2(k)+h(-\beta_2z_1(k)+\beta_2y)</script></li><li><p><strong>LSEF</strong></p><p>  令</p><script type="math/tex; mode=display">  e_1 = x_1 - z_1\\u_0 = a_1 \times e_1\\u=\frac{u_0-z_2}{b_0}</script><p>  其中 $a_1$ 存在于 SEF 特征方程中</p><script type="math/tex; mode=display">  L_{SEF}(s)=s^n+a_ns^{n-1}+…+a_2s+a_1</script><p>  将特征值统一配置在左半实轴同一位置，得到</p><script type="math/tex; mode=display">  L_{SEF}(s)=(s+w_c)^{n}</script><p>  其中 $w_c$ 是 LSEF 的带宽</p></li></ul><h3 id="二阶LADRC"><a href="#二阶LADRC" class="headerlink" title="二阶LADRC"></a><strong>二阶LADRC</strong></h3><ul><li><p><strong>LTD</strong></p><p>  二阶LTD是由二阶低通滤波器传递函数 $\frac{r^2}{s^2+2rs+r^2}$ 得来的，只需要更改 $r$ 值， $r$ 值越大到达设定值 $v$ 的时间就越短</p><p>  令</p><script type="math/tex; mode=display">  X=\begin{bmatrix}x_1\\x_2\end{bmatrix}\\  \left\{\begin{aligned}x_1 = y\\x_2=\dot{x_1}\end{aligned}\right.</script><p>  从上式的低通滤波的传递函数可以推导出系统的状态方程</p><script type="math/tex; mode=display">  \dot{X}=AX+Bu=\begin{bmatrix}0&1\\-r^2&-2r\end{bmatrix}X+\begin{bmatrix}0\\r^2\end{bmatrix}u\\Y=\begin{bmatrix}1\\0\end{bmatrix}X+[0]u</script><p>  输出，这里的 u 表示输入的期望值，LTD 是对期望值进行处理的</p><script type="math/tex; mode=display">  x_1(k+1)=hx_2(k)+x_1(k)\\x_2(k+1) =h(-r^2 x_1(k) - 2rx_2(k)+r^2 u)+x_2(k)</script></li><li><p><strong>LESO</strong></p><p>  从上述LTD中可知，这一步实际上是把扰动合并，将输入输出噪声与模型上的误差合并，从而得到下列式子。其中 $f$ 是总扰动</p><script type="math/tex; mode=display">  y''=f(x_1)+bu= f(x_1) + b_0u - b_0u + bu=f+b_0u</script><p>  在一阶的 ADRC 中，LESO 是二阶的，具体形式为</p><p>  令</p><script type="math/tex; mode=display">  Z=\begin{bmatrix}z_1\\z_2\\z_3\end{bmatrix}</script><p>  并且</p><script type="math/tex; mode=display">  z_1\rightarrow x_1=y\\z_2\rightarrow x_2=\dot{y}\\z_3\rightarrow f~扰动</script><p>  得</p><script type="math/tex; mode=display">  \dot{Z}=AZ+Bu+L(x_1-z_1)\\\hat{y}=CZ</script><p>  其中</p><script type="math/tex; mode=display">  L=\begin{bmatrix}\beta_1\\\beta_2\\\beta_3\end{bmatrix}</script><p>  带入得</p><script type="math/tex; mode=display">  \left\{\begin{aligned}\left.\begin{bmatrix}\dot{z_1}\\\dot{z_2}\\\dot{z_3}\end{bmatrix}\right.&=&\left.\begin{bmatrix}-\beta_1&1&0\\-\beta_2&0&1\\-\beta_3&0&0\end{bmatrix}\right.\left.\begin{bmatrix}z_1\\z_2\\z_3\end{bmatrix}\right.+\left.\begin{bmatrix}0&\beta_1\\b_0&\beta_2\\0&\beta_3\end{bmatrix}\right.\left.\begin{bmatrix}u\\y\end{bmatrix}\right.\\\hat{y}&=&\left.\begin{bmatrix}1&0&0\\0&1&0\\0&0&1\end{bmatrix}\right.\left.\begin{bmatrix}z_1\\z_2\\z_3\end{bmatrix}\right.\end{aligned}\right.</script><p>  其中 $\beta$ 存在于特征方程中，如下</p><script type="math/tex; mode=display">  L_{ESO}(s)=s^{n+1}+\beta_1 s^n + \beta_2 s^{n-1}+…+\beta_{n-1}</script><p>  将极点都配置到左半轴同一位置，可以将调节参数缩减为</p><script type="math/tex; mode=display">  L_{ESO}(s)=(s+w_o)^{n+1}=0</script><p>  其中 $w_o$ 表示扩张观测器的带宽，而 $\beta$ 对应着相应的系数</p><p>  输入为 $u, y$</p><p>  输出为</p><script type="math/tex; mode=display">  z_1(k+1)=z_1(k)+h\dot{z_1}(k)=z_1(k)+h(-\beta_1z_1(k)+z_2(k)+\beta_1y)\\z_2(k+1)=z_2(k)+h\dot{z_2}(k)=z_2(k)+h(-\beta_2z_1(k)+z_3(k)+b_0u+\beta_2y)\\z_3(k+1)=z_3(k)+h\dot{z_3}(k)=z_3(k)+h(-\beta_3z_1(k)+\beta_3y)</script></li><li><p><strong>LSEF</strong></p><p>  令</p><script type="math/tex; mode=display">  e_1 = x_1 - z_1\\e_2=x_2-z_2\\u_0 = a_1 e_1+a_2e_2\\u=\frac{u_0-z_3}{b_0}</script><p>  其中 $a_1$ 存在于 SEF 特征方程中</p><script type="math/tex; mode=display">  L_{SEF}(s)=s^n+a_ns^{n-1}+…+a_2s+a_1</script><p>  将特征值统一配置在左半实轴同一位置，得到</p><script type="math/tex; mode=display">  L_{SEF}(s)=(s+w_c)^{n}</script><p>  其中 $w_c$ 是 LSEF 的带宽</p></li></ul><h3 id="三阶LADRC"><a href="#三阶LADRC" class="headerlink" title="三阶LADRC"></a><strong>三阶LADRC</strong></h3><ul><li><p><strong>LTD</strong></p><p>  三阶 LTD 是由三阶低通滤波传递函数 $\frac{r^3}{s^3+3rs^2+3r^2s+r^3}$得来的</p><p>  令</p><script type="math/tex; mode=display">  X=\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}\\\left\{\begin{aligned}x_1 = y\\x_2=\dot{x_1}\\x_3=\dot{x_2} \end{aligned}\right.</script><p>  得</p><script type="math/tex; mode=display">  \dot{X}=\begin{bmatrix}0&1&0\\0&0&1\\-r^3&-3r^2&-3r\end{bmatrix}X+\begin{bmatrix}0\\0\\r^3\end{bmatrix}u\\y=\begin{bmatrix}1\\0\\0\end{bmatrix}X+\begin{bmatrix}0\end{bmatrix}u</script><p>  输出，这里的 u 表示输入的期望值，LTD 是对期望值进行处理的</p><script type="math/tex; mode=display">  x_1(k+1)=hx_2(k)+x_1(k)\\x_2(k+1) =hx_3(k)+x_2(k)\\x_3(k+1) =h(-r^3 x_1(k) - 3r^2x_2(k) -3rx_3(k)+r^3 u)+x_3(k)</script></li><li><p><strong>LESO</strong></p><p>  由上式可以得出</p><script type="math/tex; mode=display">  y^{'''}=f(x_1, x_2, x_3) + bu\\=f+b_0u</script><p>  此时引入 $z$ 跟踪量</p><script type="math/tex; mode=display">  \left\{\begin{aligned}z_1\rightarrow x_1\\z_2\rightarrow x_2\\z_3\rightarrow x_3\\z_4\rightarrow f\end{aligned}\right.\\Z=\begin{bmatrix}z_1\\z_2\\z_3\\z_4\end{bmatrix}</script><p>  可得</p><script type="math/tex; mode=display">  \dot{Z}=\begin{bmatrix}0&1&0&0\\0&0&1&0\\0&0&0&1\\0&0&0&0\end{bmatrix}Z+\begin{bmatrix}0\\0\\b_0\\0\end{bmatrix}u+L(x_1-z_1)\\\hat{y}=CZ+Du</script><p>  其中</p><script type="math/tex; mode=display">  L=\begin{bmatrix}\beta_1\\\beta_2\\\beta_3\\\beta_4\end{bmatrix}</script><p>  带入得</p><script type="math/tex; mode=display">  \dot{Z}=\begin{bmatrix}-\beta_1&1&0&0\\-\beta_2&0&1&0\\-\beta_3&0&0&1\\-\beta_4&0&0&0\end{bmatrix}Z+\begin{bmatrix}0&\beta_1\\0&\beta_2\\b_0&\beta_3\\0&\beta_4\end{bmatrix}\begin{bmatrix}u\\y\end{bmatrix}\\\hat{y}=CZ+Du=\begin{bmatrix}1&0&0&0\end{bmatrix}\begin{bmatrix}z_1\\z_2\\z_3\\z_4\end{bmatrix}</script><p>  其中 $\beta$ 存在于特征方程中，如下</p><script type="math/tex; mode=display">  L_{ESO}(s)=s^{n+1}+\beta_1 s^n + \beta_2 s^{n-1}+…+\beta_{n-1}</script><p>  将极点都配置到左半轴同一位置，可以将调节参数缩减为</p><script type="math/tex; mode=display">  L_{ESO}(s)=(s+w_o)^{n+1}=0</script><p>  其中 $w_o$ 表示扩张观测器的带宽，而 $\beta$ 对应着相应的系数</p><p>  输入为 $u, y$</p><p>  输出为</p><script type="math/tex; mode=display">  z_1(k+1)=z_1(k)+h\dot{z_1}(k)=z_1(k)+h(-\beta_1z_1(k)+z_2(k)+\beta_1y)\\z_2(k+1)=z_2(k)+h\dot{z_2}(k)=z_2(k)+h(-\beta_2z_1(k)+z_3(k)+\beta_2y)\\z_3(k+1)=z_3(k)+h\dot{z_3}(k)=z_3(k)+h(-\beta_3z_1(k)+z_4(k)+b_0u+\beta_3y)\\z_4(k+1)=z_4(k)+h\dot{z_4}(k)=z_4(k)+h(-\beta_4z_1(k)+\beta_4y)</script></li><li><p><strong>LSEF</strong></p><p>  令</p><script type="math/tex; mode=display">  e_1 = x_1 - z_1\\e_2=x_2-z_2\\e_3=x_3-z_3\\u_0 = a_1 e_1+a_2e_2+a_3e_3\\u=\frac{u_0-z_4}{b_0}</script><p>  其中 $a_1$ 存在于 SEF 特征方程中</p><script type="math/tex; mode=display">  L_{SEF}(s)=s^n+a_ns^{n-1}+…+a_2s+a_1</script><p>  将特征值统一配置在左半实轴同一位置，得到</p><script type="math/tex; mode=display">  L_{SEF}(s)=(s+w_c)^{n}</script><p>  其中 $w_c$ 是 LSEF 的带宽</p></li></ul><h3 id="四阶LADRC"><a href="#四阶LADRC" class="headerlink" title="四阶LADRC"></a><strong>四阶LADRC</strong></h3><ul><li><p><strong>LTD</strong></p><p>  四阶 LTD 是由三阶低通滤波传递函数 $\frac{r^4}{s^4+4rs^3+6r^2s^2+4r^3s+r^4}$得来的</p><p>  令</p><script type="math/tex; mode=display">  X=\begin{bmatrix}x_1\\x_2\\x_3\\x_4\end{bmatrix}\\\left\{\begin{aligned}x_1 = y\\x_2=\dot{x_1}\\x_3=\dot{x_2}\\x_4 = \dot{x_3}\end{aligned}\right.</script><p>  得</p><script type="math/tex; mode=display">  \dot{X}=\begin{bmatrix}0&1&0&0\\0&0&1&0\\0&0&0&1\\-r^4&-4r^3&-6r^2&-4r\end{bmatrix}X+\begin{bmatrix}0\\0\\0\\r^4\end{bmatrix}u\\y=\begin{bmatrix}1\\0\\0\\0\end{bmatrix}X+\begin{bmatrix}0\end{bmatrix}u</script><p>  输出，这里的 u 表示输入的期望值，LTD 是对期望值进行处理的</p><script type="math/tex; mode=display">  x_1(k+1)=hx_2(k)+x_1(k)\\x_2(k+1) =hx_3(k)+x_2(k)\\x_3(k+1) =hx_4(k)+x_3(k)\\x_4(k+1) =h(-r^4 x_1(k) - 4r^3x_2(k) -6r^2x_3(k)-4rx_4(k)+r^4 u)+x_4(k)</script></li><li><p><strong>LESO</strong></p><p>  由上式可以得出</p><script type="math/tex; mode=display">  y^{''''}=f(x_1, x_2, x_3, x_4) + bu\\=f+b_0u</script><p>  此时引入 $z$ 跟踪量，相当于是一个预测量</p><script type="math/tex; mode=display">  \left\{\begin{aligned}z_1\rightarrow x_1\\z_2\rightarrow x_2\\z_3\rightarrow x_3\\z_4\rightarrow x_4\\z_5\rightarrow f\end{aligned}\right.\\Z=\begin{bmatrix}z_1\\z_2\\z_3\\z_4\\z_5\end{bmatrix}</script><p>  可得</p><script type="math/tex; mode=display">  \dot{Z}=\begin{bmatrix}0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1\\0&0&0&0&0\end{bmatrix}Z+\begin{bmatrix}0\\0\\0\\b_0\\0\end{bmatrix}u+L(x_1-z_1)\\\hat{y}=CZ+Du</script><p>  其中</p><script type="math/tex; mode=display">  L=\begin{bmatrix}\beta_1\\\beta_2\\\beta_3\\\beta_4\\\beta_5\end{bmatrix}</script><p>  带入得</p><script type="math/tex; mode=display">  \dot{Z}=\begin{bmatrix}-\beta_1&1&0&0&0\\-\beta_2&0&1&0&0\\-\beta_3&0&0&1&0\\-\beta_4&0&0&0&1\\-\beta_5&0&0&0&0 \end{bmatrix}Z+\begin{bmatrix}0&\beta_1\\0&\beta_2\\0&\beta_3\\b_0&\beta_4\\0&\beta_5\end{bmatrix}\begin{bmatrix}u\\y\end{bmatrix}\\\hat{y}=CZ+Du=\begin{bmatrix}1&0&0&0&0\end{bmatrix}\begin{bmatrix}z_1\\z_2\\z_3\\z_4\\z_5\end{bmatrix}</script><p>  其中 $\beta$ 存在于特征方程中，如下</p><script type="math/tex; mode=display">  L_{ESO}(s)=s^{n+1}+\beta_1 s^n + \beta_2 s^{n-1}+…+\beta_{n-1}</script><p>  将极点都配置到左半轴同一位置，可以将调节参数缩减为</p><script type="math/tex; mode=display">  L_{ESO}(s)=(s+w_o)^{n+1}=0</script><p>  其中 $w_o$ 表示扩张观测器的带宽，而 $\beta$ 对应着相应的系数</p><p>  输入为 $u, y$</p><p>  输出为</p><script type="math/tex; mode=display">  z_1(k+1)=z_1(k)+h\dot{z_1}(k)=z_1(k)+h(-\beta_1z_1(k)+z_2(k)+\beta_1y)\\z_2(k+1)=z_2(k)+h\dot{z_2}(k)=z_2(k)+h(-\beta_2z_1(k)+z_3(k)+\beta_2y)\\z_3(k+1)=z_3(k)+h\dot{z_3}(k)=z_3(k)+h(-\beta_3z_1(k)+z_4(k)+\beta_3y)\\z_4(k+1)=z_4(k)+h\dot{z_4}(k)=z_4(k)+h(-\beta_4z_1(k)+z_5(k)+b_0u+\beta_4y)\\z_5(k+1)=z_5(k)+h\dot{z_5}(k)=z_5(k)+h(-\beta_5z_1(k)+\beta_5y)</script></li><li><p><strong>LSEF</strong></p><p>  令</p><script type="math/tex; mode=display">  e_1 = x_1 - z_1\\e_2=x_2-z_2\\e_3=x_3-z_3\\e_4=x_4-z_4\\u_0 = a_1 e_1+a_2e_2+a_3e_3+a_4e_4\\u=\frac{u_0-z_5}{b_0}</script><p>  其中 $a_1$ 存在于 SEF 特征方程中</p><script type="math/tex; mode=display">  L_{SEF}(s)=s^n+a_ns^{n-1}+…+a_2s+a_1</script><p>  将特征值统一配置在左半实轴同一位置，得到</p><script type="math/tex; mode=display">  L_{SEF}(s)=(s+w_c)^{n}</script><p>  其中 $w_c$ 是 LSEF 的带宽</p></li></ul><h3 id="其中参数的调整和选择"><a href="#其中参数的调整和选择" class="headerlink" title="其中参数的调整和选择"></a>其中参数的调整和选择</h3><ul><li>首先是 LTD 中的低通滤波器带宽，r 越大相应的也就会越快趋于目标值</li><li>$b_0$：假设 $K_G=\frac{b_0}{b}$，当 $K_G$ 偏离 1 越远，系统相角裕度越小。当 $K_G=4$ 时，系统不稳定，因此为了改善控制性能， $b_0$ 的选择应当尽可能接近真实参数 $b$</li><li>$w_o$ 表示扩张观测器的带宽，一般选择 $w_o=3\sim5 w_c$（这适用于状态反馈控制系统，其中 $w_0$ 是根据暂态响应要求，特别是稳定时间规范确定的。控制器设计可以使用平滑的瞬态轮廓，而不是阶跃命令，作为期望的轨迹，允许输出更紧密地跟随）。带宽 $w_o$ 增大有益于 LADRC 的稳定性和鲁棒性，但是 $w_o$ 过大导致控制器的输出过大，不利于工程应用，实际调参需要折中一下。带宽 $w_o$ 虽然不会影响超调量的大小，但是会影响 LESO 的跟踪速度， $w_o$ 越大，系统响应越快，但是在实际的系统中， $w_o$ 的提高受观测噪声的限制，增大 $w_o$ 同时高频带增益也随之增加，噪声放大作用明显。</li><li>$w_c$ 表示状态误差反馈控制律的带宽</li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul><li>约定当且仅当系统的状态 $x_i$ 和LESO跟踪误差 $~x$ 都稳定时，称LADRC系统稳定</li><li>增大带宽会导致系统噪声过大，因此可在 LESO 前端设置滤波器来抑制其影响</li><li>LESO 的微分方程的求解，一般依赖初始值（RungeKutta），初值对系统输出的超调量有一定影响</li><li>$w_o$ 和 $w_c$ 的单位都是 rad/s.</li><li>实际调试参数时，首先确定系统阶数，其次确定 $w_c$ 和 $w_o$ 不变，再按照数量级以此调试 $b_0$，直到系统输出满足期望状态</li></ul><h2 id="NADRC-非线性ADRC"><a href="#NADRC-非线性ADRC" class="headerlink" title="NADRC 非线性ADRC"></a><strong>NADRC 非线性ADRC</strong></h2><h3 id="一阶NADRC"><a href="#一阶NADRC" class="headerlink" title="一阶NADRC"></a><strong>一阶NADRC</strong></h3><ul><li><p><strong>LTD</strong></p><p>  形式为：</p><script type="math/tex; mode=display">  \left\{\begin{aligned}e_1&=x_1-v\\\frac{dx_1}{dt}&=-r*fal(e_1,\alpha_1,\delta_1)\end{aligned}\right.</script><p>  离散化处理之后为</p><script type="math/tex; mode=display">  \left\{\begin{aligned}e_1(k)&=x_1(k)-v(k)\\x_1(k+1)&=-rTfal(e_1(k),\alpha_1,\delta_1)+x_1(k)\end{aligned}\right.</script><p>  其中</p><script type="math/tex; mode=display">  fal(e, \alpha,\delta)=\left\{\begin{aligned}&{|e|}^{\alpha}sign(e) && |e| > \delta\\&\frac{e}{\delta^{1-\alpha}} && |e| \leq \delta\end{aligned}\right.</script><p>  其中， $fal$函数中的 $\alpha$ 反映了增益的变化率，当 $\alpha&gt;1$，误差又比较大时，该函数增益可能过大，从而导致系统不稳定，通常 $0&lt;\alpha&lt;1$， $\alpha$ 越大，到达设定值的时间就越短。 $\delta$ 是为了避免函数在原点震荡引入的一个很小的正数，可决定函数增益线性变化的区间大小， $\delta$ 越大，则整个函数在作用区间大部分区间内都是线性的，如果 $\delta$ 越小就会使非线性函数更类似于一个开关函数，在原点附近有高频震荡现象</p></li><li><p><strong>LESO</strong></p><p>  形式为：</p><script type="math/tex; mode=display">  \left\{\begin{aligned}e_2&=z_{21}-y\\\frac{dz_{21}}{dt}&=z_{22}-\beta_{21}fal(e_2, \alpha_2,\delta_2)+bu\\\frac{dz_{22}}{dt} &= -\beta_{22}fal(e_2, \alpha_2,\delta_2)\end{aligned}\right.</script><p>  其中</p><script type="math/tex; mode=display">  \left\{\begin{aligned}\beta_{21}&=2*\omega_0\\\beta_{22}&=\omega_0^2\end{aligned}\right.</script><p>  离散化处理之后</p><script type="math/tex; mode=display">  \left\{\begin{aligned}e_2(k)&=z_{21}(k)-y(k)\\z_{21}(k+1)&=T(z_{22}(k)-\beta_{21}fal(e_2,\alpha_2,\delta_2)+bu)+z_{21}(k)\\z_{22}(k+1)&=-T\beta_{22}fal(e_2,\alpha_2,\delta_2)+z_{22}(k)\end{aligned}\right.</script><script type="math/tex; mode=display">  \left\{\begin{aligned}z_{21}→y\\z_{22}→f\end{aligned}\right.</script><p>  输出为</p><script type="math/tex; mode=display">   \left\{\begin{aligned}z_{21}(k+1)\\z_{22}(k+1)\end{aligned}\right.</script></li><li><p><strong>LSEF</strong></p><p>  形式为：</p><script type="math/tex; mode=display">  \left\{\begin{aligned}e_3&=x_1-z_{21}\\u_0&=kp*fal(e_3,\alpha_3,\delta_3)\\u&=\frac{u_0-z_{22}}{b}\\u&=u_0-\frac{z_{22}}{b}\end{aligned}\right.</script><p>  输出 $u$</p><p>  离散化处理：这里应当是依据于最新状态来计算的</p><script type="math/tex; mode=display">  \left\{\begin{aligned}e_3(k)&=x_1(k)-z_{21}(k)\\u_0(k)&=kp*fal(e_3(k),\alpha_3,\delta_3)\\u(k)&=\frac{u_0(k)-z_{22}(k)}{b}\\u(k)&=u_0(k)-\frac{z_{22}(k)}{b}\end{aligned}\right.</script></li></ul><h3 id="二阶NADRC"><a href="#二阶NADRC" class="headerlink" title="二阶NADRC"></a><strong>二阶NADRC</strong></h3><ul><li><p><strong>LTD</strong></p><script type="math/tex; mode=display">  \left\{\begin{aligned}\frac{dx_1}{dt}&=x_2\\\frac{dx_2}{dt}&=-r*sign(x_1-v+\frac{x_2|x_2|}{2r})\end{aligned}\right.</script><p>  为了避免在原点附近的颤振，将符号函数  $sign$ 改为线性饱和函数 $sat$ 就得到有效的二阶跟踪一微分器:</p><script type="math/tex; mode=display">  \left\{\begin{aligned}\frac{dx_1}{dt}&=x_2\\\frac{dx_2}{dt}&=-r*sat(x_1-v+\frac{x_2|x_2|}{2r}, \delta)\end{aligned}\right.</script><p>  其中</p><script type="math/tex; mode=display">  sat(x, \delta)=\left\{\begin{aligned}&sign(x)&&|x|\geq\delta\\&\frac{x}{\delta}&&|x|<\delta\end{aligned}\right.</script><p>  对应的离散化函数为</p><script type="math/tex; mode=display">  \left\{\begin{aligned}x_1(k+1)&=x_1(k)+h*x_2(k)\\x_2(k+1)&=x_2(k)+h*fst(x_1(k)-v(k),x_2(k),r,h1)\end{aligned}\right.</script><p>  其中 $r$ 决定跟踪速度，称为速度因子， $h_1$ 对噪声有滤波作用，称为滤波因子</p><script type="math/tex; mode=display">  \left\{\begin{aligned}d&=r*h_1\\d_0&=h_1*d\\y&=x_1(k)+h_1*x_2(k)-v(k)\\a_0&=\sqrt{d^2+8r|y|}\\a&=\left\{\begin{aligned}x_2(k)+\frac{a_0-d}{2}sign(y)&&|y|>d_0\\x_2(k)+\frac{y}{h_1}&&|y|\leq d_0\end{aligned}\right.\\fst(x_1(k)-v(k),x_2,r,h_1)&=\left\{\begin{aligned}-r*sign(a)&&|a|>d\\-r\frac{a}{d}&&|a|\leq d\end{aligned}\right.\end{aligned}\right.</script><p>  其中 $r$ 是决定跟踪快慢的参数， $h_1$ 是决定噪声滤波效应的参数</p><p>  当 $h_1&gt;h$ 时，对于含有噪声的信号，TD滤波器有较好的滤波功能，在确定滤波器参数时，r和ℎ1需要协调调制。r 越大，跟踪信号越快，噪声放大也越厉害，ℎ1越大，滤波效果越好，跟踪信号的相位也损失越大。离散TD能快速、无超调、无颤振的跟踪信号。实际上上面这种 TD 的形式会导致在到达稳态之后输入产生高频震荡，只能说十分的恶心</p><p>  通过查阅资料（自抗扰控制技术）离散化函数也可以写成这样：</p><script type="math/tex; mode=display">  \left\{\begin{aligned}x_1(k+1)&=x_1(k)+hx_2(k)\\x_2(k+1)&=x_2(k)+h*fhan(x_1(k)-v(k),x_2(k),r,h1)\end{aligned}\right.</script><p>  这里的 $h_1$ 就是噪声滤波效应的参数，应当比 $h$ 大一点</p><script type="math/tex; mode=display">  fst(x_1(k)-v(k),x_2,r,h_1)=\left\{\begin{aligned}d&=r*h_1^2\\a_0&=h_1*x_2\\y&=x_1(k)-v(k)+a_0\\a_1&=\sqrt{d(d+8|y|)}\\a_2&=a_0+\frac{a_1-d}{2}sign(y)\\a&=(a_0+y)fsg(y,d)+a_2(1-fsg(y,d))\\fhan&=-r\frac{a}{d}fsg(a,d)-r*sign(a)(1-fsg(a,d))\\fsg(x,d)&=\frac{sign(x+d)-sign(x-d)}{2}\end{aligned}\right.</script></li><li><p><strong>LESO</strong></p><script type="math/tex; mode=display">  \left\{\begin{aligned}e_2&=z_{21}-y\\\frac{dz_{21}}{dt}&=z_{22}-\beta_{21}*e_2\\\frac{dz_{22}}{dt}&=z_{23}-\beta_{22}*fal(e_2,\alpha_2,\delta_2)+b*u\\\frac{dz_{23}}{dt}&=-\beta_{23}*fal(e_2,\alpha_3,\delta_3)\end{aligned}\right.</script><p>  式中的 $\beta$ 取指方式与二阶的 LESO 相同。同时 $\alpha_3&lt;\alpha_2$， $\delta_2$ 可以取相同值，离散化的时候取 $5T\leq \delta_2\leq 10T$，T 为采样周期</p><script type="math/tex; mode=display">  \left\{\begin{aligned}\beta_{21}&=3*\omega_o\\\beta_{22}&=3*\omega_o^2\\\beta_{23}&=\omega_o^3\end{aligned}\right.</script><p>  离散化处理</p><script type="math/tex; mode=display">  \left\{\begin{aligned}z_{21}(k+1)&=h(z_{22}(k)-\beta_{21}*e_2(k)) + z_{21}(k)\\z_{22}(k+1)&=h(z_{23}(k)-\beta_{22}fal(e_2(k),\alpha_2,\delta_2)+bu(k)) + z_{22}(k)\\z_{23}(k+1)&=h(-\beta_{23}*fal(e_2(k),\alpha_3,\delta_3)) + z_{23}(k)\end{aligned}\right.</script><p>  其中</p><script type="math/tex; mode=display">   fal(e, \alpha,\delta)=\left\{\begin{aligned}&{|e|}^{\alpha}sign(e) && |e| > \delta\\&\frac{e}{\delta^{1-\alpha}} && |e| \leq \delta\end{aligned}\right.</script></li><li><p><strong>LSEF</strong></p><p>  总共有三种非线性的反馈控制规律</p><script type="math/tex; mode=display">  u_0=\left\{\begin{aligned}&\beta_1e_1+\beta_2e_2\\&\sum_{i=1}^n\beta_ifal(x_i-z_i,\alpha_i,d)\\&-fhan(e_1,e_2,r,h)\\&-fhan(e_1,ce_2,r,h)\end{aligned}\right.</script><p>  其中</p><script type="math/tex; mode=display">  e_0=\int^{t}_{0}{e_1(t)dt}</script><p>  这里的 $u_0$ 有四种形式</p><p>  其中</p><script type="math/tex; mode=display">  fhan(e_1,e_2,r,h)=\left\{\begin{aligned}d&=r*h^2\\a_0&=h_1*e_2\\y&=e_1+a_0\\a_1&=\sqrt{d*(d+8|y|)}\\a_2&=a_0+\frac{a_1-d}{2}sign(y)\\a&=(a_0+y)fsg(y,d)+a_2(1-fsg(y,d))\\fhan&=-r\frac{a}{d}fsg(a,d)-r*sign(a)(1-fsg(a,d))\\fsg(x,d)&=\frac{sign(x+d)-sign(x-d)}{2}\end{aligned}\right.</script><p>  $u$ 也有两种形式</p><script type="math/tex; mode=display">  u=\left\{\begin{aligned}&\frac{u_0-z_{23}}{b}\\&u_0-\frac{z_{23}}{b}\end{aligned}\right.</script><p>  离散化处理之后</p><script type="math/tex; mode=display">  \left\{\begin{aligned}u_0&=\left\{\begin{aligned}&\beta_1e_1+\beta_2e_2\\&\sum_{i=1}^n\beta_ifal(x_i-z_i,\alpha_i,d)\\&-fhan(e_1,e_2,r,h)\\&-fhan(e_1,ce_2,r,h)\end{aligned}\right.\\u(k)&=\left\{\begin{aligned}&\frac{u_0(k)-z_{23}(k)}{b}\\&u_0(k)-\frac{z_{23}(k)}{b}\end{aligned}\right.\end{aligned}\right.</script></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[<a href="https://zhuanlan.zhihu.com/p/585324684">自抗扰控制-低阶LADRC与PID</a>]</p><p>[<a href="https://zhuanlan.zhihu.com/p/664345718">自抗扰控制-ADRC</a>]</p><p>[<a href="https://zhuanlan.zhihu.com/p/115283894">自抗扰控制理论</a>]</p><p>[<a href="https://ieeexplore.ieee.org/document/4796887">From PID to Active Disturbance Rejection Control</a>]</p><p>自抗扰控制技术——韩京清</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LQG线性二次高斯</title>
      <link href="/Blog_ButterFly/2024/03/18/LQG%E7%BA%BF%E6%80%A7%E4%BA%8C%E6%AC%A1%E9%AB%98%E6%96%AF/"/>
      <url>/Blog_ButterFly/2024/03/18/LQG%E7%BA%BF%E6%80%A7%E4%BA%8C%E6%AC%A1%E9%AB%98%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><p><strong>Linear Quadratic Gaussian</strong></p><p>在实际系统中，噪声是不可避免的，在噪声的影响下，系统状态方程可以写作</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\dot{X}=AX+Bu+Gw\\&y=CX+Du+Hw+v\end{aligned}\right.</script><p>其中 $w,v$ 均被当作为白噪声</p><p>如果我们假设噪声是均值为0高斯分布（事实上很多时候确实近似服从高斯分布，想想为什么呢？）由于系统噪声和输出噪声的存在，状态不能完美的衰减为0。我们就希望优化损失函数的期望，即</p><script type="math/tex; mode=display">J=E\{\underset{T\rightarrow\infty}{\lim}\frac{1}{T}\int_0^T[X^TQX+U^TRU]dt\}</script><p>LQG 控制器实际上就是一个最优二次型线性调节器+一个最优状态估计器（卡尔曼滤波器）而得到的一个控制器，即 LQR+KF</p><p>而 LQG 控制器相当于是将两个系统分离，LQR 与 KF 分离，而 LQR 是依旧是依据原系统所建立的一个控制系统，不过是对应的应该使用 KF 的输出值</p><h3 id="KF"><a href="#KF" class="headerlink" title="KF"></a>KF</h3><p>在 LQG 框观测器架中的卡尔曼滤波器，指的是一个最优状态观测器，这里的观测器是现代控制理论—状态空间方程中的最常见的观测器——龙伯格观测器，但是后者极点是自由配置的，并且没有考虑噪声的影响，并不是最优</p><p>对于一个系统</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu+Gw\\y=Cx+Du+Hw+v</script><p>其中 $w$ 是过程噪声， $v$ 是观测噪声，它们被假设是符合高斯（Gauss）分布的。 $G,H$ 是常系数矩阵，用于描述 $x$ 中各部分受到噪声强度不一致的情况，很多地方 $H$ 被认为是一个 0 矩阵，区别不大 </p><p><strong>假设</strong></p><ul><li>系统可观测</li><li>噪声符合高斯分布，且协方差矩阵为 $E(ww^T)=Q_k,E(vv^T)=R_k,E(wv^T)=N_k$</li></ul><p>对于给定观测器动态和代价函数</p><script type="math/tex; mode=display">\dot{\hat x}=A\hat{x}+Bu+L(y-C\hat{x}-Du)\\\\\hat{y}=\hat{x}\\\\J'=\underset{t\rightarrow \infty}{\lim}E\{(x-\hat{x})(x-\hat x)^T\}</script><p>需要寻找一个常系数矩阵使得 $J’$ 最小，最后得到</p><script type="math/tex; mode=display">L=(PC^T+\overline{N})\overline{R}^{-1}</script><p>其中</p><script type="math/tex; mode=display">\overline{R}=R_k+HN_k+N_k^TH^T+HQ_kH^T\\\overline{N}=G(Q_kH^T+N_k)</script><p>同时 $P$ 是以下 Riccati 方程的解，并且 $P$ 是一个对称正定矩阵</p><script type="math/tex; mode=display">A^TP+PA-(PB+N_k)R_k^{-1}(B^TP+N_k^T)+Q_k=0</script><p>使用得到的这个 $L$ 的最优观测器，就是 LQG 框架使用的卡尔曼滤波器</p><h3 id="LQG"><a href="#LQG" class="headerlink" title="LQG"></a>LQG</h3><p><img src="/Blog_ButterFly/2024/03/18/LQG%E7%BA%BF%E6%80%A7%E4%BA%8C%E6%AC%A1%E9%AB%98%E6%96%AF/v2-08a6922f338cace58c7b03b433517171_720w.webp" alt="v2-08a6922f338cace58c7b03b433517171_720w.webp"></p><p>其中的 -K 就是 LQR 控制器，而 w 是过程噪声， v 是观测噪声</p><h3 id="分离性原理"><a href="#分离性原理" class="headerlink" title="分离性原理"></a>分离性原理</h3><p>假设系统可控可观测</p><p>LQR 是一种最优的线性状态反馈， KF 是一种最优的状态估计，直接将两级串联闭环系统可以写作</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x}\\\dot{\hat x}\end{bmatrix}=A_{lqg}\begin{bmatrix}x\\\hat x\end{bmatrix}+G_{lqg}\begin{bmatrix}w\\v\end{bmatrix}\\\\y=C_{lqg}\begin{bmatrix}x\\\hat x\end{bmatrix}+H_{lqg}\begin{bmatrix}w\\v\end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">A_{lqg}=\begin{bmatrix}A&-BF\\LC&A-BF-LC\end{bmatrix}\\\\G_{lqg}=\begin{bmatrix}G&0\\LH&L\end{bmatrix}\\\\B_{lqg}=\begin{bmatrix}B\\B-LD\end{bmatrix}\\\\C_{lqg}=\begin{bmatrix}C&-DF\\0&0\end{bmatrix}\\\\H_{lqg}=\begin{bmatrix}H&0\\0&I\end{bmatrix}</script><p>此时引入观测器误差 $\delta=x-\hat{x}$，可以得到</p><script type="math/tex; mode=display">\begin{bmatrix}x\\\delta\end{bmatrix}=\begin{bmatrix}I&0\\I&-I\end{bmatrix}\begin{bmatrix}x\\\hat x\end{bmatrix}\\\\\Downarrow\\\\\begin{bmatrix}I&0\\I&-I\end{bmatrix}\begin{bmatrix}x\\\delta\end{bmatrix}=\begin{bmatrix}x\\\hat x\end{bmatrix}\\\\C_{transform}=\begin{bmatrix}I&0\\I&-I\end{bmatrix}</script><p>所以带入上式可以得到</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x}\\\dot{\delta}\end{bmatrix}=C_{transform}A_{lqg}C_{transform}\begin{bmatrix}x\\\delta\end{bmatrix}+C_{transform}G_{lqg}\begin{bmatrix}w\\v\end{bmatrix}\\\\y=C_{lqg}C_{transform}\begin{bmatrix}x\\\delta\end{bmatrix}+H_{lqg}\begin{bmatrix}w\\v\end{bmatrix}\\\\\Downarrow\\\\\begin{bmatrix}\dot{x}\\\dot{\delta}\end{bmatrix}=\begin{bmatrix}A-BF&BF\\0&A-LC\end{bmatrix}\begin{bmatrix}x\\\delta\end{bmatrix}+C_{transform}B_{lqg}\begin{bmatrix}w\\v\end{bmatrix}\\\\\Downarrow\\\\\dot{x_a}=A_ax_a+G_aW\\\\y=C_ax_a+H_aW</script><p>由于 $A-BF$ 和 $A-LC$ 都是稳定的，即它们的特征值都严格小于 0，根据分块矩阵的特征值得计算规则，这个大的矩阵也是稳定的。这就意味着可以使 LQR 和 KF 级联，得到一个稳定的系统，这就是分离性原理。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/Blog_ButterFly/2024/03/18/LQG%E7%BA%BF%E6%80%A7%E4%BA%8C%E6%AC%A1%E9%AB%98%E6%96%AF/Untitled.png" alt="Untitled"></p><p>由此图列出系统状态方程</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x_1}\\\dot{x_2}\end{bmatrix}=\begin{bmatrix}0&1\\\frac{k}{m}&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\\\frac{1}{m}\end{bmatrix}u+\begin{bmatrix}1\\1\end{bmatrix}w\\\\y=\begin{bmatrix}1&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\end{bmatrix}w+v</script><p>首先是建立 LQR 控制器，先不考虑噪声</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x_1}\\\dot{x_2}\end{bmatrix}=\begin{bmatrix}0&1\\\frac{k}{m}&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\\\frac{1}{m}\end{bmatrix}u\\\\y=\begin{bmatrix}1&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}</script><p>根据系统代价函数</p><script type="math/tex; mode=display">J=\int^\infty_0[x^TQx+u^TRu]dt</script><p>设定相应的权重系数矩阵 Q 和 R，并且在matlab中可以直接调用函数 lqr 来获得对应的线性反馈控制器</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K = lqr(A, B, Q, R);</span><br></pre></td></tr></table></figure><p>推导过程可以查看 LQR线性二次调节器——系统输入线性化</p><p>建立 KF 滤波器</p><script type="math/tex; mode=display">\hat{x}_{k|k-1}=F_k\hat{x}_{k-1|k-1}\\\\P_{k|k-1}=F_kP_{k-1|k-1}F_k^T+Q_k\\\\K_k=P_{k|k-1}H_k^T(H_kP_{k|k-1}H_k^T+R_k)^{-1}\\\\\hat{x}_{k|k}=\hat{x}_{k|k-1}+K_k(z_k-H_k\hat{x}_{k|k-1})\\\\P_{k|k}=(I-K_kH_k)P_{k|k-1}</script><p>根据公式，可以得到 $\hat{x}$，然后与 lqr 的线性反馈控制器作用，得到对系统的控制</p><p>关于 KF 可以看 卡尔曼滤波 KF</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://ww2.mathworks.cn/help/control/ref/ss.lqi.html">线性二次积分控制 - MATLAB lqi - MathWorks 中国</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LQG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WBC全身控制器</title>
      <link href="/Blog_ButterFly/2024/03/18/WBC%E5%85%A8%E8%BA%AB%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/18/WBC%E5%85%A8%E8%BA%AB%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在 WBC 的各种功能中，任务层次结构很重要，因为它提供了一个保证，即较高的优先级任务不会由于与较低优先级任务的冲突而失败。 该方法类似于资源分配问题，其中一些资源（即机器人附件或部件）比其他部件更重要，同时试图实现多个目标。</p><h3 id="伪逆矩阵"><a href="#伪逆矩阵" class="headerlink" title="伪逆矩阵"></a>伪逆矩阵</h3><p>伪逆矩阵又叫做广义逆矩阵，是线性代数中针对矩阵的一种运算，指的是拥有部分逆矩阵的特性，但是不一定具有逆矩阵的所有特性的另一种矩阵。</p><p>假设</p><script type="math/tex; mode=display">A\in R^{n\times m}\\A^g\in R^{m\times n}</script><p>并且满足</p><script type="math/tex; mode=display">AA^gA=A</script><p>则 $A^g$ 就是 $A$ 的广义逆矩阵。</p><p>建构广义逆阵的目的是针对可逆矩阵以外的矩阵（例如非方阵的矩阵）可以找到一矩阵有一些类似逆矩阵的特性。任意的矩阵都存在广义逆阵，若一矩阵存在逆矩阵，逆矩阵即为其唯一的广义逆阵。</p><p>伪逆矩阵的性质</p><script type="math/tex; mode=display">AA^gA=A\\A^gAA^g=A^g\\AA^g=(AA^g)^T\\A^gA=(A^gA)^T</script><h3 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h3><p>在数学中，一个算子 $A$ 的零空间是方程 $A\vec{v}=\vec{0}$ 的所有解的集合，也叫做 $A$ 的<a href="https://zh.wikipedia.org/wiki/%E6%A0%B8_(%E4%BB%A3%E6%95%B0">核</a>)。用集合构建符号表示为</p><script type="math/tex; mode=display">Null(A)=\{\vec{v}\in V:A\vec{v}=0\}</script><p>如果算子是在向量空间上的线性算子，零空间就是线性子空间，因此零空间是向量空间</p><p>零空间的维度称之为零度，上式中零空间维数为 $n-Rank(A)$ ，其中 $n$ 是 $\vec v$ 的行数</p><h3 id="左逆矩阵"><a href="#左逆矩阵" class="headerlink" title="左逆矩阵"></a>左逆矩阵</h3><p>对于列满秩的矩阵 $A\in R^{M\times N}$ ，列向量线性无关，则矩阵零空间 $Null(A)$ 只有零向量，方程 $Ax=b$ 无解或者只有唯一解。当矩阵 $A$ 列满秩时，矩阵 $A^TA$ 为可逆矩阵，这是讨论最小二乘问题的核心。所以矩阵 $A^TA$ 为可逆矩阵，也就是存在</p><script type="math/tex; mode=display">(A^TA)^{-1}A^TA=I</script><p>所以可以得到</p><script type="math/tex; mode=display">A_l^{-1}A=I\\A_l^{-1}=(A^TA)^{-1}A^T</script><p>也就是 $A_l^{-1}$ 为 $A$ 的左逆矩阵，并且有</p><script type="math/tex; mode=display">A_l^{-1}\in R^{N\times M}\\A_l^{-1}A=I\in R^{N \times N}</script><p>但是需要注意，右乘左逆矩阵一般不能得到单位阵，除非 $M=N$</p><h3 id="右逆矩阵"><a href="#右逆矩阵" class="headerlink" title="右逆矩阵"></a>右逆矩阵</h3><p>对于行满秩的矩阵 $A\in R^{M\times N}$ ，行向量线性无关，则矩阵零空间 $Null(A^T)$ 只有零向量。 $A$ 的零空间的维数为 $N-M$ ，也就是拥有 $N-M$ 个自由变量，当 $N$ 大于 $M$ 时，方程 $Ax=b$ 有无穷多个解</p><p>此时矩阵 $AA^T$ 为可逆矩阵，所以存在</p><script type="math/tex; mode=display">AA^T(AA^T)^{-1}=I</script><p>相应的得到</p><script type="math/tex; mode=display">AA_r^{-1}=I\\A_r^{-1}=A^T(AA^T)^{-1}</script><p>也就是 $A_r^{-1}$ 为 $A$ 的左逆矩阵，并且有</p><script type="math/tex; mode=display">A_r^{-1}\in R^{M\times N}\\AA_r^{-1}=I\in R^{M \times M}</script><p>但是需要注意，左乘右逆矩阵一般不能得到单位阵，除非 $M=N$</p><h2 id="基于零空间投影的WBC"><a href="#基于零空间投影的WBC" class="headerlink" title="基于零空间投影的WBC"></a>基于零空间投影的WBC</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>基于零空间投影的WBC零空间方法出现的时间相对较早，其基本思想就是将低优先级的任务映射到高优先级任务的零空间中，从而使得低优先级任务不会影响高优先级任务的执行。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>无法解决不等式的约束问题，对于不可行约束也无法有效处理，另外，在求解过程中会涉及到广义逆的求解，从而增加求解时间和难度。</p><h3 id="雅各比矩阵"><a href="#雅各比矩阵" class="headerlink" title="雅各比矩阵"></a>雅各比矩阵</h3><p>零空间投影方法通过将较低优先级的任务投影到较高优先级任务的零空间来完成严格的任务层次结构。</p><p>首先定义</p><ul><li>$\vec{q}\in R^N$ 关节空间向量，表示机器人关节位置的集合</li><li>$\vec{w}\in R^M$ 任务空间向量，维度取决于不同的任务</li></ul><p>其中，任务空间向量与关节空间向量满足运动学约束</p><script type="math/tex; mode=display">w=kinematics(q)</script><p>对上述式子求导，就可以得到雅各比将矩阵，可以完成由关节角速度 $\dot{q}$ 映射到末端速度 $\dot w$</p><script type="math/tex; mode=display">\dot{w}=J\dot{q}</script><p>这里选择矩阵求导的<strong>分子布局</strong>形式，则得到</p><script type="math/tex; mode=display">J\in R^{M\times N}</script><p>当关节空间维度 $N$ 大于任务空间维度 $M$ 时，该任务被称为存在冗余自由度。对于上述存在冗余自由度的任务来说，其任务雅可比矩阵存在<strong>右伪逆矩阵</strong> $J^+$，即满足 $JJ^+=I$ ，当雅可比矩阵列满秩，即 $Rank(J)=M$ 时，存在</p><script type="math/tex; mode=display">J^+=J^T(JJ^T)^{-1}</script><p>所以可以得到</p><script type="math/tex; mode=display">\dot{q}=J^+\dot{w}</script><h3 id="零空间-1"><a href="#零空间-1" class="headerlink" title="零空间"></a>零空间</h3><p>当任务存在冗余自由度时，就会存在零空间。如果雅可比矩阵行满秩，零空间的维度就是其列数减去行数。零空间在数学上的定义为满足方程 $Ax=0$ 的所有 $x$ 的集合。在机器人中，就是满足任务空间速度为零的所有关节空间速度的集合，即</p><script type="math/tex; mode=display">NULL(J)={\dot{q}\in \dot{Q}:J\dot{q}=0}</script><p>此时加入零空间矩阵 $N$ ，零空间投影矩阵 $N$ 是可以将任意的关节速度投影到对应的零空间的投影矩阵。其中满足</p><script type="math/tex; mode=display">\forall{\dot{q}},\ JN\dot{q}=0\\N=I-J^+J\not=0</script><p>并且零空间矩阵 $N$ 具有以下性质</p><script type="math/tex; mode=display">\left\{\begin{aligned}N^+=N\\NN=N\end{aligned}\right.</script><h3 id="多任务的优先级"><a href="#多任务的优先级" class="headerlink" title="多任务的优先级"></a>多任务的优先级</h3><p>使用零空间的定义和性质可以实现多任务的严格的优先级控制。</p><p>对于两个任务，对应任务的雅各比矩阵</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\dot{w}_1=J_1\dot{q}&&\textcircled{1}\\&\dot{w}_2=J_2\dot{q}&&\textcircled{2}\end{aligned}\right.</script><p>对于上述公式 $\textcircled{1}$ 中，可以得到</p><script type="math/tex; mode=display">\dot{q}=J_1^+\dot{w}_1+(I-J_1^+J_1)\dot{q}_0\quad\textcircled{3}</script><p>其中 $\dot{q}_0$ 表示任意关节的空间速度向量。从零空间中的定义，可以设定 $N_1=I-J_1^+J_1$ 和 $N_2=I-J_2^+J_2$ 。并且根据零空间投影的性质可知 $J_1N_1\dot{q}_0=0$ 和 $J_2N_2\dot{q}_0=0$ ，所以 $\dot{q}_0$ 无论何值都不会对最终的关节位置造成影响，最终都会满足该任务的，也就是</p><script type="math/tex; mode=display">\forall \dot{q}_0,J_1\dot{q} = J_1J^+_1\dot{w}_1+J_1N_1\dot{q}_0=\dot{w}_1\\\forall \dot{q}_0,J_2\dot{q} = J_2J^+_2\dot{w}_1+J_2N_2\dot{q}_0=\dot{w}_2</script><p>将 $\textcircled{3}$ 式带入 $\textcircled{2}$ 中</p><script type="math/tex; mode=display">\dot{w}_2=J_2(J_1^+\dot{w}_1+N_1\dot{q}_0)</script><p>此时对于 $\dot{q}_0$ 的结果可能有无数个，也可能只有一个，需要找到最优解，可以建立优化代价函数来求解</p><p>可以得到</p><script type="math/tex; mode=display">\dot{q}_0=(J_2N_1)^+(\dot{w}_2-J_2J_1^+\dot{w}_1)\quad\textcircled{4}</script><p>将 $\textcircled{4}$ 带入到 $\textcircled{3}$ 中，此时最终关节空间速度可以表示为</p><script type="math/tex; mode=display">\dot{q} = J_1^+\dot{w}_1+N_1(J_2N_1)^+(\dot{w}_2-J_2J_1^+\dot{w}_1)\quad\textcircled{5}</script><p>将 $\textcircled{5}$ 带入 $\textcircled{2}$ 中，此时证明</p><script type="math/tex; mode=display">\dot{w}_2=J_2\dot{q}=J_2(J_1^+w_1+N_1(J_2N_1)^+(\dot{w}_2-J_2J_1^+\dot{w}_1))\\=J_2J_1^+w_1+(J_2N_1)(J_2N_1)^{-1}(\dot{w}_2-J_2J_1^+\dot{w}_1)=\dot{w}_2</script><p>可见最终任务 2 也能完成</p><p>对于有 $n$ 个任务时，上述的 $\textcircled{4}$ 可以写作，此处用 $a$ 代替 $q$ 防止重复</p><script type="math/tex; mode=display">\dot{a}_0=(J_2N_1)^+(\dot{w}_2-J_2J_1^+\dot{w}_1)+(I-(J_2N_1)^+(J_2N_1))\dot{a}_1\quad\textcircled{6}</script><p>此时得到 $\textcircled{5}$ 的形式为</p><script type="math/tex; mode=display">\dot{q} = J_1^+\dot{w}_1+N_1(J_2N_1)^+(\dot{w}_2-J_2J_1^+\dot{w}_1)+N_1(I-(J_2N_1)^+(J_2N_1))\quad\textcircled{7}</script><p>然后将其带入到第三个任务的公式中，也就是</p><script type="math/tex; mode=display">\dot{w}_3=J_3\dot{q}=J_3J_1^+\dot{w}_1+J_3N_1(J_2N_1)^+(\dot{w}_2-J_2J_1^+\dot{w}_1)+J_3N_1(I-(J_2N_1)^+(J_2N_1))\dot{a}_1\\\Downarrow\\(I-(J_2N_1)^+(J_2N_1))\dot{a}_1=(J_3N_1)^+(\dot{w}_3-J_3J_1^+\dot{w}_1)-(J_3N_1)^+J_3N_1(J_2N_1)^+(\dot{w}_2-J_2J_1^+\dot{w}_1)+(I-(J_3N_1)^+(J_3N_1))\dot{a}_2</script><p>此时可以看出已经出现了一致性，所以这里直接写出最终形式，如下</p><script type="math/tex; mode=display">\dot{q}=\sum_{i=1}^{n}{\overline{N_i}\dot{q}_i}\\\dot{q}_i=(J_i\overline{N_i})^+(\dot{w}_i-J_i\sum_{k=1}^{i-1}{\overline{N}_k\dot{q}_k})</script><p>其中 $\overline{N_i}$ 表示组合雅可比矩阵 $\overline{J_i}$ 的零空间投影矩阵，组合雅可比矩阵 $\overline{J_i}$ 是<strong>所有任务优先级高于任务 $i$ 的任务</strong>的雅可比矩阵的组合，如下</p><script type="math/tex; mode=display">\overline{J_i}=\begin{bmatrix}J_1\\…\\J_{i-1}\end{bmatrix}\\\overline{N_i}=(I-\overline{J}_i^+\overline{J}_i)</script><p>上述公式对应的迭代形式为</p><script type="math/tex; mode=display">\dot{q}_i = \dot{q}_{i-1}+N_{i-1}(J_iN_{i-1})^+(\dot{w}_i- J_i\dot{q}_{i-1})</script><p>当存在 $n$ 个有相同的优先级，通常采用如下方法求取广义速度矩阵</p><script type="math/tex; mode=display">\dot{q}=\begin{bmatrix}J_1\\...\\J_{n}\end{bmatrix}^+\begin{bmatrix}w_1\\...\\w_n\end{bmatrix}</script><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>对于一个三自由度的平面机械臂，如图所示</p><p><img src="/Blog_ButterFly/2024/03/18/WBC%E5%85%A8%E8%BA%AB%E6%8E%A7%E5%88%B6%E5%99%A8/1718007700320.png" alt="1718007700320.png"></p><p>对其末端位置进行控制，末端位置可以根据运动学方程得到，如下</p><script type="math/tex; mode=display">x=L_1\sin(\theta_1)+L_2\sin(\theta_1+\theta_2)+L_3\sin(\theta_1+\theta_2+\theta_3)\\y=L_1\cos(\theta_1)+L_2\cos(\theta_1+\theta_2)+L_3\cos(\theta_1+\theta_2+\theta_3)</script><p>对两边进行求导，可以得到末端速度与关节速度的关系</p><script type="math/tex; mode=display">\dot{x}=L_1\cos(\theta_1)\dot{\theta}_1+L_2\cos(\theta_1+\theta_2)(\dot{\theta}_1+\dot{\theta}_2)+L_3\cos(\theta_1+\theta_2+\theta_3)(\dot{\theta}_1+\dot{\theta}_2+\dot\theta_3)\\\dot y=-L_1\sin(\theta_1)\dot{\theta}_1-L_2\sin(\theta_1+\theta_2)(\dot{\theta}_1+\dot{\theta}_2)-L_3\sin(\theta_1+\theta_2+\theta_3)(\dot{\theta}_1+\dot{\theta}_2+\dot\theta_3)</script><p>此时设任务 1 为控制 $x$ 方向的速度，任务 2 控制 $y$ 方向的速度，得到</p><script type="math/tex; mode=display">\dot{x}=\begin{bmatrix}L_1\cos(\theta_1)+L_2\cos(\theta_1+\theta_2)+L_3\cos(\theta_1+\theta_2+\theta_3)\\L_2\cos(\theta_1+\theta_2)+L_3\cos(\theta_1+\theta_2+\theta_3)\\L_3\cos(\theta_1+\theta_2+\theta_3)\end{bmatrix}\dot\theta=J_x\dot\theta\\\dot{y}=\begin{bmatrix}-L_1\sin(\theta_1)-L_2\sin(\theta_1+\theta_2)-L_3\sin(\theta_1+\theta_2+\theta_3)\\-L_2\sin(\theta_1+\theta_2)-L_3\sin(\theta_1+\theta_2+\theta_3)\\-L_3\sin(\theta_1+\theta_2+\theta_3)\end{bmatrix}\dot\theta=J_y\dot\theta\\\dot\theta=\begin{bmatrix}\dot\theta_1\\\dot\theta_2\\\dot\theta_3\end{bmatrix}</script><p>然后根据上述公式可以得到，关节的速度如下</p><script type="math/tex; mode=display">\dot{q} = J_1^+\dot{x}+N_1(J_2N_1)^+(\dot{y}-J_2J_1^+\dot{x})</script><p>这就是末端的设定速度</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基于零空间投影的方法通过将低优先级任务投影到高优先级任务零空间的方法实现任务层级。零空间投影的一个缺点是<strong>无法结合不等式约束</strong>。在动作高度动态时，机器人会打破约束，使这个问题突显，基于零空间的方法假设接触约束均为等式，这在物理层面是错误的</p><h2 id="基于二次规划的WBC"><a href="#基于二次规划的WBC" class="headerlink" title="基于二次规划的WBC"></a>基于二次规划的WBC</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>通过将任务写成带有约束的最优化形式，同时，在引入松弛变量后，可以解决约束不可行的问题。而分层二次规划作为二次规划的级联形式，可以用来求解具有优先级的多任务问题，并且已经被证明这种求解方式可以很大程度上加快求解时间</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于一个任务</p><script type="math/tex; mode=display">\dot{w}_1=J_1\dot{q}</script><p>可以将其写作如下的最优化形式</p><script type="math/tex; mode=display">\underset{\dot{q}}{\min}\parallel J_1\dot{q}-\dot{w}_1\parallel_2</script><p>只考虑任务 1 时引入松弛变量 $s_1$ ，可以将任务 1 写作二次规划形式，如下</p><script type="math/tex; mode=display">\underset{\dot{q},s_1}{min}\parallel s_1\parallel_2\\s_1+J_1\dot{q}=\dot{w}_1</script><p>其中 $s_1$ 表示任务 1 的松弛变量，就是用来放松该任务中的不可行约束的，求解目标函数，即使该任务没有解</p><p>任务 $T_1$ 可以定义为解向量 $x\in R^n$ 上的一组线性等式或者不等式约束</p><script type="math/tex; mode=display">T=\left\{\begin{aligned}Ax-b&&s=\omega\\Dx-f&&s\leq v\end{aligned}\right.</script><p>其中 $w$ 和 $v$ 是要最小化的松弛变量，当同时解决一组任务 $T_1,…,T_n$ 时，可以选择互相加权，也可以按照严格的优先顺序解决</p><p><strong>严格的优先顺序求解</strong></p><p>假设求解p个任务得到了最优解 $x^\star$。为了保证严格的优先级划分，下一个解 $x_{p+1}$ 是在所有高优先级相等约束的零空间 $Z_p=\Nu(\underline{A}_p)$ 中寻找，其中 $\underline{A}_p=\begin{bmatrix}A_1^T…A_{p}^T\end{bmatrix}^T$。最终得到 $x_{p+1}=x^<em>+Z_pz_{p+1}$，其中 $z_{p+1}$ 是一个位于 $Z_p$ 行空间中的向量。求解一个新的任务 $T_{p+1}$ 意味着从下面的二次规划问题中计算 $Z_{p+1}^</em>$ 和 $V_{p+1}^*$</p><script type="math/tex; mode=display">\underset{z_{p+1},v_{p+1}}{min} \frac{1}{2} ||A_{p+1}(X^*+Z_pz_{p+1})-b_{p+1}||^2+\frac{1}{2}||v_{p+1}||^2</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{aligned} D_{p+1}(X^*+Z_pz_{p+1})-f_{p+1}&\leq v_{p+1}^*\\D_p(X^*+Z_pz_{p+1})-f_p&\leq v_{p}^*\\...\\D_1(X^*+Z_pz_{p+1})-f_1&\leq v_1^*\\v_{p+1}&\geq\end{aligned}\right.</script><p>设</p><script type="math/tex; mode=display">\xi_p^T=\begin{bmatrix}z_p^T&&v_p^T\end{bmatrix}</script><p>上述问题可以写作</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\underset{\xi_{p+1}}{min}\frac{1}{2}\xi_{p+1}^TH_{p+1}\xi_{p+1}+c_{p+1}^{T}\xi_{p+1}\\&\widetilde{D}{p+1}\xi{p+1}\leq\widetilde{f}_{p+1}\end{aligned}\right.</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{aligned}H_{p+1}&=\begin{bmatrix}Z_p^TA_{p+1}^TA_{p+1}Z_p&&0\\0&&I\end{bmatrix}\\c_{p+1}&=\begin{bmatrix}Z_p^TA_{p+1}^T(A_{p+1}X^*-b_{p+1})\\0\end{bmatrix}\\\widetilde{D}_{p+1}&=\begin{bmatrix}D_{p+1}Z_p&&-I\\D_pZ_p&&0\\.\\.\\D_1Z_p&&0\\0&&-I\end{bmatrix}\\\widetilde{f}_{p+1}&=\begin{bmatrix}f_{p+1}-D_{p+1}X^*\\f_p-D_pX^*+v_p^*\\.\\.\\f_1-D_1X^*+v_1^*\\0\end{bmatrix}\end{aligned}\right.</script><p>上式就是基于零空间的分层二次规划表达形式。通过对上述分层二次规划问题进行求解，就可以得到期望的状态变量 $x^*$，其中包含机器人的速度、加速度和接触力等信息，再结合机器人动力学模型计算得到所需关节力矩，给到控制器，就可以对具有优先级的多任务问题进行控制，实现关节空间的轨迹跟踪，进而完成任务空间中规划的任务。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际上，上述所写的控制器并不是很完善，很多内容在网上几乎找不到资料。当前比较常用的 WBC 应该是 MIT 开源的 minicheetah 中的算法了吧。</p><p>以后看到相关资料之后再更新叭</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲁棒控制理论</title>
      <link href="/Blog_ButterFly/2024/03/18/%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"/>
      <url>/Blog_ButterFly/2024/03/18/%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>一种典型的不确定系统模型的基本形式是</p><script type="math/tex; mode=display">y=(P+\Delta)u+n</script><p>其中，y 是系统输出，u 是系统输入，P 是标称对象的传递函数，模型的不确定性以两种形式展现：n 是未知噪声或者干扰， $\Delta$ 是位置的对象摄动（未建模动态）</p><p>一般地说，鲁棒性概念是指反馈控制系统的某项性能对于某集合中的每一个对象都是成立的。具体地说，我们有如下鲁棒性定义。</p><ul><li><strong>鲁棒稳定性：</strong>设计一个控制器，使对每一个摄动后的对象，都能保证闭环系统的稳定性。</li><li><strong>鲁棒性能：</strong>设计一个控制器，使对每一个摄动后的对象，闭环系统都满足稳定性和某种特定的系统性能。</li></ul><p>上述鲁棒性的概念是指定给定一个控制器，如果某集合中的每一个对象都能保持某种特性成立，则称控制器对此特性是鲁棒的。因此鲁棒性必须包含一个控制器，有一个对象的集合和某些系统的特性</p><h1 id="H-infty-控制器"><a href="#H-infty-控制器" class="headerlink" title="$H_\infty$ 控制器"></a>$H_\infty$ 控制器</h1><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><p>首先说明一些定义</p><p>$sup$：一个集合最小的上界，不小于它最大值的值，都是它的上界</p><p>$inf$：一个集合最大的下界，不大于它最小值的值，都是它的下界</p><p>$max$：最大值</p><p>$min$：最小值</p><p>$Im~f$：相当于 f 的值域</p><p>$Ker~f$：相当于 f 的零空间，也就是 $f(x)=0$ 中所有点对应的原像，这个原像不唯一，所构成的集合就是 $Ker~f$</p><h3 id="系统的一些性能指标"><a href="#系统的一些性能指标" class="headerlink" title="系统的一些性能指标"></a>系统的一些性能指标</h3><ul><li><p><strong>IE 增益</strong></p><script type="math/tex; mode=display">  \Gamma_{ie}=\underset{w(t)=w_0\delta(t),||w_0||\leq1}{sup}||z||_2</script><p>  对于原线性时不变连续时间系统，如果该系统是严格真的（D=0）和渐进稳定（矩阵A特征值均具有负实部）的，那么系统的 <strong>IE 增益</strong>是有限的，并且 $\Gamma_{ie}=\sqrt{||B^TYB||}$，其中矩阵的范数取为谱范数，即矩阵的最大奇异值，例如 A 的谱范数为 $\sqrt{\max(eig(A^TA))}$，其中 $eig$ 表示为取特征值的函数，矩阵 $Y$ 就是以下李雅普诺夫方程的解</p><script type="math/tex; mode=display">  YA+A^TY+C^TC=0</script><p>  该定理可以转化为以下的优化问题</p><script type="math/tex; mode=display">  min~\gamma</script><p>  其中满足</p><script type="math/tex; mode=display">  \exists P:PD\\\\  PA+A^TP+C^TC<0\\\\  B^TPB\leq\gamma I\\\\  P>0</script><p>  该优化问题有一个最优值 $\gamma^\star$，则 $\Gamma_{ie}=\sqrt{\gamma^\star}$。该优化问题是一个具有线性不等式约束和线性目标函数的凸优化问题，以应用 <strong>LMI 工具箱中的求解器 mincx</strong> 来求解</p></li><li><p><strong>EP 增益</strong></p><script type="math/tex; mode=display">  \Gamma_{ep}=\underset{||w||_2\leq1}{sup}||z||_\infty</script><p>  对于原线性时不变连续时间系统，如果该系统是严格真的（D=0）和渐进稳定（矩阵A特征值均具有负实部）的，那么系统的 <strong>EP 增益</strong>是有限的，并且 $\Gamma_{ep}=\sqrt{||CXC^T||}$，其中矩阵的范数取为谱范数，即矩阵的最大奇异值，例如 A 的谱范数为 $\sqrt{\max(eig(A^TA))}$，其中 $eig$ 表示为取特征值的函数，矩阵 $X$ 就是以下李雅普诺夫方程的解</p><script type="math/tex; mode=display">  AX+XA^T+B^TB=0</script><p>  该定理可以转化为以下的优化问题</p><script type="math/tex; mode=display">  min~\gamma</script><p>  其中满足</p><script type="math/tex; mode=display">  \exists Q:PD\\\\  AQ+QA^T+BB^T<0\\\\  CQC^T\leq\gamma I\\\\  Q>0</script><p>  该优化问题有一个最优值 $\gamma^\star$，则 $\Gamma_{ep}=\sqrt{\gamma^\star}$。该优化问题是一个具有线性不等式约束和线性目标函数的凸优化问题，以应用 <strong>LMI 工具箱中的求解器 mincx</strong> 来求解</p></li><li><p><strong>EE 增益</strong></p><script type="math/tex; mode=display">  \Gamma_{ee}=\underset{||w||_2\leq1}{sup}||z||_2</script><p>  定理：对于原线性时不变连续时间系统，设 $\gamma$ 是一个给定的常数，则下列条件是等价的：</p><ol><li>系统渐进稳定，且 $\Gamma_{ee}&lt;\gamma$</li><li><p>存在一个对阵阵 $P&gt;0$，使得</p><script type="math/tex; mode=display"> \begin{bmatrix}A^TP+PA&PB&C^T\\B^TP&-\gamma I&D^T\\C&D&-\gamma I\end{bmatrix}<0</script></li></ol></li></ul><pre><code>由于条件 2 是一个线性矩阵不等式，因此可以应用 **LMI 工具箱中的求解器 feasp** 来判断系统增益 $\Gamma_&#123;ee&#125;$ 是否满足给定的约束条件。</code></pre><ul><li><p><strong>PP 增益</strong></p><script type="math/tex; mode=display">  \Gamma_{pp}=\underset{||w||_\infty\leq1}{sup}||z||_\infty</script><p>  定理：对于原线性时不变连续时间系统，设 $\gamma$ 是一个给定的标量，如果存在对称矩阵 $R&gt;0$，标量 $\gamma&gt;0$ 和 $\mu&gt;0$，使得：</p><script type="math/tex; mode=display">  \begin{bmatrix}A^TR+RA+\gamma R&RB\\B^TR&-\mu I\end{bmatrix}<0\\\begin{bmatrix}\gamma R&0&C^T\\0&(\gamma-\mu)I&D^T\\C&D&\gamma^I\end{bmatrix}>0</script><p>  那么满足 $\Gamma_{pp}&lt;\gamma$，上述线性矩阵不等式，因此可以应用 <strong>LMI 工具箱中的求解器 feasp</strong> 来判断系统增益 $\Gamma_{ee}$ 是否满足给定的约束条件。</p></li></ul><h2 id="LMI矩阵不等式"><a href="#LMI矩阵不等式" class="headerlink" title="LMI矩阵不等式"></a>LMI矩阵不等式</h2><h3 id="不确定系统描述"><a href="#不确定系统描述" class="headerlink" title="不确定系统描述"></a>不确定系统描述</h3><p><img src="/Blog_ButterFly/2024/03/18/%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210306152914283.png" alt="20210306152914283.png"></p><p>其中有</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\dot{x} = Ax+B_1w+B_2u\\&z = C_1x +D_{11}w+D_{12}u\\&y=C_2x+D_{21}w+D_{22}u\end{aligned}\right.</script><p>其中 $C_1, D_{11}, D_{12}, D_{21}, D_{22}$ 是适当维数的矩阵，没有选择标准，要根据实际情况，大量实验选取。 </p><p>$P$ 为增广控制对象。</p><p>$K$ 是控制器</p><p>$u$ 控制输入</p><p>$y$ 系统被测量的输出</p><p>$w$ 是外部输入或参考的输入，噪声扰动之类的</p><p>$z$ 是被控制量的输出，是系统的现时状态</p><p>则传递函数为：</p><script type="math/tex; mode=display">U=KY\\\\Y=G_{21}W+G_{22}U=G_{21}W+G_{22}KY\\\\Y=(1-G_{22}K)^{-1}G_{21}W\\\\T_{WZ} = \frac{Z}{W}=G_{11}+G_{12}K(1-G_{22}K)^{-1}G_{21}=F_l(G, K)</script><p>则有</p><ol><li><p>$H_{\infty}$ 最优控制问题</p><p> 对于标准鲁棒控制器理论控制框图，寻找一个真实有理的控制器 K，使闭环控制系统稳定，而且最小化闭环传递函数矩阵 $T_{ZW}$ 的 $H_{\infty}$ 范数，即</p><script type="math/tex; mode=display"> \underset {K镇定G}{min}||T_{WZ}(G, K)||_{\infty}</script></li><li><p>$H_{\infty}$ 次最优控制问题</p><p> 对于标准鲁棒控制器理论控制框图，寻找一个真实有理的控制器 K，使闭环控制系统稳定，而且使闭环传递函数矩阵 $T_{ZW}$ 的 $H_{\infty}$ 范数小于一个给定的常数 $\gamma$ ，即</p><script type="math/tex; mode=display"> ||T_{WZ}(G, K)||_{\infty} < \gamma</script></li></ol><h3 id="Schur-补性质"><a href="#Schur-补性质" class="headerlink" title="Schur 补性质"></a>Schur 补性质</h3><p>给定的对称矩阵</p><script type="math/tex; mode=display">S=\begin{bmatrix}S_{11}&S_{12}\\S_{21}&S_{22}\end{bmatrix}</script><p>其中 $S_{11}$ 是 $r\times r$ 维矩阵，所以以下三个条件是等价的</p><ul><li>S &lt; 0，负定</li><li>$S_{11} &lt;0,S_{22}-S_{12}^TS_{11}^{-1}S_{12}&lt;0$</li><li>$S_{22} &lt;0,S_{11}-S_{12}S_{11}^{-1}S_{12}^T&lt;0$</li></ul><h3 id="系统范数"><a href="#系统范数" class="headerlink" title="系统范数"></a>系统范数</h3><ul><li><p>1-范数，信号的时间累计量有界</p><script type="math/tex; mode=display">  \|u\|_1=\int_{-\infty}^{+\infty}|u|dt</script></li><li><p>2-范数，信号的能量有界，平放是对信号能量的一种度量</p><script type="math/tex; mode=display">  \|u\|_2=\sqrt{\int_{-\infty}^{+\infty}|u|^2dt}</script></li><li><p>$\infty$-范数，信号的最大幅值有界，真确上界，即连续函数的上界， $\infty$-范数是对信号幅值的度量</p><script type="math/tex; mode=display">  \|u\|_{\infty}=\underset{t\in(-\infty,+\infty)}{ess~sup}|u|<\infty</script><p>  sup 表示上确界，ess sup 表示真上确界</p></li><li><p>系统的 $H_\infty$ 范数对应 Bode 图中幅值曲线的峰值 $|G(jw)|$，Bode图增益最大值，离原点最大的距离</p></li><li>系统的 $H_2$ 范数对应 Bode 图中幅值曲线下方的面积。</li><li>Bode 图横坐标： $w=10^t, L(w)=20lg|G(jw)|$</li></ul><h3 id="状态反馈-H-infty-控制"><a href="#状态反馈-H-infty-控制" class="headerlink" title="状态反馈 $H_\infty$ 控制"></a>状态反馈 $H_\infty$ 控制</h3><p><strong>控制问题的基本框图</strong></p><p><img src="/Blog_ButterFly/2024/03/18/%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/Untitled.png" alt="Untitled"></p><ol><li><p><strong>闭环传递函数确定</strong></p><p> 考虑线性不变的连续时间系统，存在扰动 $w$</p><script type="math/tex; mode=display"> state:\dot{x}=Ax+B_1w+B_2u\\\\ z=C_1x+D_{11}w+D_{12}u\\\\ y=C_2x+D_{21}w+D_{22}u</script><p> 寻找一个控制器 $u=Kx$，使系统保持稳定，将其带入系统中得到</p><script type="math/tex; mode=display"> \dot{x}=Ax+B_1w+B_2u=(A+B_2K)x+B_1w\\\\ z=C_1x+D_{11}w+D_{12}u=(C_1+D_{12}K)x+D_{11}w</script><p> 对于系统 $w→z$ 来说，从上式中的到闭环系统传递函数为</p><script type="math/tex; mode=display"> G(s)=C(sI-A)^{-1}B+D\\\\ T_{WZ}(s)=(C_1+D_{12}K)[sI-(A+B_2K)]^{-1}]B_1+D_{11}</script></li><li><p><strong>状态反馈</strong> $H_\infty$ <strong>控制器</strong></p><p> 由于 EE 增益定理，可以得到，给定常数 $\gamma=1$，当且仅当存在一个对称正定矩阵 P，使得</p><script type="math/tex; mode=display"> \begin{bmatrix}(A+B_2K)^TP+P(A+B_2K)&PB_1&(C_1+D_{12}K)^T\\B_1^TP&-I&D_{11}^T\\C_1+D_{12}K&D_{11}&-I\end{bmatrix}<0</script><p> 为了求得未知矩阵 $K$ 和 $P$，使用变量替换法，将其转化为一个等价的关于新变量的线性矩阵不等式</p><p> 首先，分别对其左乘和右乘一个对角阵 $diag\{P^{-1},I,I\}$，则得到</p><script type="math/tex; mode=display"> \begin{bmatrix}P^-1\\&I\\&&I\end{bmatrix}\begin{bmatrix}(A+B_2K)^TP+P(A+B_2K)&PB_1&(C_1+D_{12}K)^T\\B_1^TP&-I&D_{11}^T\\C_1+D_{12}K&D_{11}&-I\end{bmatrix}\begin{bmatrix}P^-1\\&I\\&&I\end{bmatrix}<0\\\\\Downarrow\\\\\begin{bmatrix}(AP^{-1}+B_2KP^{-1})^T+(AP^{-1}+B_2KP^{-1})&B_1&(C_1P^{-1}+D_{12}KP^{-1})^T\\B_1^T&-I&D_{11}^T\\C_1P^{-1}+D_{12}KP^{-1}&D_{11}&-I\end{bmatrix}<0</script><p> 定义 $X=P^{-1}$ 和 $W=KX$，得到</p><script type="math/tex; mode=display"> \begin{bmatrix}(AX+B_2W)^T+(AX+B_2W)&B_1&(C_1X+D_{12}W)^T\\B_1^T&-I&D_{11}^T\\C_1X+D_{12}W&D_{11}&-I\end{bmatrix}<0</script><p> 对于原线性定常系统，存在一个状态反馈 $H_\infty$ 控制器，当且仅当存在一个对称正定矩阵 X 和矩阵 W ( W 不对称正定)，使得上式和 $X&gt;0$ 成立，并且可行解 $X^\star$和 $W^\star$ 组成的 $u=W^\star(X^\star)^{-1}x$ 是系统的的一个状态反馈 $H_\infty$ 控制器。该矩阵的不等式是 $X$ 和 $W$ 的一个线性矩阵不等式，可以利用 <strong>LMI 工具箱的求解器 feasp</strong> 来求解</p></li><li><p><strong>状态反馈 $\gamma-$次优 $H_\infty$ 控制器</strong></p><p> 对于一个给定的标量 $\gamma &gt;0$，为了求系统的状态反馈 $\gamma-$次优 $H_\infty$ 控制器，由于</p><script type="math/tex; mode=display"> ||T_wz(s)||_\infty<\gamma</script><p> 可以得到</p><script type="math/tex; mode=display"> ||\gamma^{-1}T_{wz}(s)||_\infty<1</script><p> 也就是</p><script type="math/tex; mode=display"> ||\gamma^{-1}(C_1+D_{12}K)[sI-(A+B_2K)]^{-1}]B_1+D_{11}||_\infty<1</script><p> 所以可以通过使用 $\gamma^{-1}C_1,\gamma^{-1}D_{12},\gamma^{-1}D_{11}$来替换先前的 $C_1,D_{12},D_{11}$，解算方法与上述一致。可以得到</p><script type="math/tex; mode=display"> \begin{bmatrix}(AX+B_2W)^T+(AX+B_2W)&B_1&\gamma^{-1}(C_1X+D_{12}W)^T\\B_1^T&-I&\gamma^{-1}D_{11}^T\\\gamma^{-1}(C_1X+D_{12}W)&\gamma^{-1}D_{11}&-I\end{bmatrix}<0</script><p> 将上式分别左乘和右乘一个对角矩阵 $diag\{I,I,\gamma I\}$，得到</p><script type="math/tex; mode=display"> \begin{bmatrix}(AX+B_2W)^T+(AX+B_2W)&B_1&(C_1X+D_{12}W)^T\\B_1^T&-I&D_{11}^T\\(C_1X+D_{12}W)&D_{11}&-\gamma^{2}I\end{bmatrix}<0</script><p> 存在一个状态反馈 $\gamma-$次优 $H_\infty$ 控制器，当且仅当存在一个对称正定矩阵 X 和矩阵 W ( W 不对称正定)，使得上式和 $X&gt;0$ 成立，并且可行解 $X^\star$和 $W^\star$ 组成的 $u=W^\star(X^\star)^{-1}x$ 是系统的的一个状态反馈 $H_\infty$ 控制器。该矩阵的不等式是 $X$ 和 $W$ 的一个线性矩阵不等式，可以利用 <strong>LMI 工具箱的求解器 feasp</strong> 来求解</p></li><li><p>状态反馈最优 $H_\infty$ 控制器</p><p> 基于状态反馈 $\gamma-$次优 $H_\infty$ 控制器的存在条件，建立一个优化问题</p><script type="math/tex; mode=display"> \min\rho\\\begin{bmatrix}(AX+B_2W)^T+(AX+B_2W)&B_1&(C_1X+D_{12}W)^T\\B_1^T&-I&D_{11}^T\\(C_1X+D_{12}W)&D_{11}&-\rho I\end{bmatrix}<0\\X>0</script><p> 该问题是一个具有线性矩阵不等式约束和线性目标函数的凸优化问题，可以应用LMI工具箱的求解mincx来求解。如果该问题有解，就可以得到系统的状态反馈最优 $H_\infty$ 控制器。</p></li></ol><h3 id="输出反馈-H-infty-控制"><a href="#输出反馈-H-infty-控制" class="headerlink" title="输出反馈 $H_\infty$ 控制"></a>输出反馈 $H_\infty$ 控制</h3><ol><li><p><strong>设计思路</strong></p><p> 当<strong>系统状态难以测量</strong>时，可以选择输出反馈的控制方式，所以就是设计出一个输出反馈控制器 $u=Ky$ 使得原线性定常系统渐进稳定且闭环传递函数 $||T_{WZ}(s)||_\infty&lt;1$。</p><p> 首先需要假定 $(A,B_2,C_2)$ 是能稳能检测的， $D_{22}=0$，将 $u=Ky$ 写成状态空间方程的形式</p><script type="math/tex; mode=display"> \dot{\hat x}=A_K\hat{x}+B_Ky\\\\ u=C_K\hat{x}+D_Ky</script><p> 其中 $\hat{x}$ 是控制器的状态，而 $A_K,B_K,C_K,D_K$ 是<strong>待确定的控制器参数矩阵</strong>，将其带入原系统得到新的广义闭环系统</p><script type="math/tex; mode=display"> \begin{bmatrix}\dot{x}\\\dot{\hat x}\end{bmatrix}=\begin{bmatrix}A+B_2D_KC_2&B_2C_K\\B_KC_2&A_K\end{bmatrix}\begin{bmatrix}x\\\hat{x}\end{bmatrix}+\begin{bmatrix}B_1+B_2D_KD_{21}\\B_KD_{21}\end{bmatrix}w\\\\ z=\begin{bmatrix}C_1+D_{12}D_KC_2&D_{12}C_K\end{bmatrix}\begin{bmatrix}x\\\hat{x}\end{bmatrix}+(D_{11}+D_{12}D_KD_{21})w</script><p> 简化为</p><script type="math/tex; mode=display"> \dot{x}_a=A_cx_a+B_cw\\\\ z=C_cx_a+D_cw</script><p> 由于 EE 增益定理，可以得到，给定常数 $\gamma=1$，当且仅当存在一个对称正定矩阵 $X_c$，使得</p><script type="math/tex; mode=display"> \begin{bmatrix}A_c^TX_c+X_cA_c&X_cB_c&C_c\\B_c^TX_c&-I&D_c^T\\C_c&D_c&-I\end{bmatrix}<0</script><p> 但是可以看到，由于 $A_c,B_c,C_c,D_c$ 等的存在，使得上述 LMI 为非线性，MATLAB计算非常困难，所以需要转化成线性矩阵，主要有两种方法：<strong>消去法</strong>和<strong>变量替代法</strong>。</p></li><li><p><strong>消元法设计输出反馈</strong> $H_\infty$ <strong>控制器</strong></p><p> 定义一个矩阵，这个矩阵将控制器中的待定的参数矩阵集中在一起，这也是输出反馈 $H_\infty$ 控制器设计问题中最终要确定的矩阵</p><p> 设计所需要的输出反馈 $H_\infty$ 控制器</p><ul><li>求解满足下面定理的矩阵 X 和 Y</li><li>求解满足 $X-Y^{-1}=X_2X_2^T$ 的矩阵 $X_2\in R^{n\times n_K}$，其中 $n_K$ 可以是矩阵 $X-Y^{-1}$ 的秩</li><li>用 $X$ 和 $X_2$ 构造 $X_{c}=\begin{bmatrix}X&amp;X_2^T\\X_2&amp;I\end{bmatrix}$</li><li><p>将矩阵 $X_c$ 带入到矩阵不等式 $H_{X_c}+P_{X_c}^TKQ+Q^TK^TP_{X_c}&lt;0$ 中，求解将矩阵变量 K</p><p>其中</p><script type="math/tex; mode=display">A_0=\begin{bmatrix}A&0\\0&0\end{bmatrix},B_0=\begin{bmatrix}B_1\\0\end{bmatrix},C_0=\begin{bmatrix}C_1&0\end{bmatrix}\\\overline{B}=\begin{bmatrix}0&B_2\\I&0\end{bmatrix},\overline{C}=\begin{bmatrix}0&I\\C_2&0\end{bmatrix},\overline{D}_{12}=\begin{bmatrix}0&D_{12}\end{bmatrix},\overline{D}_{21}=\begin{bmatrix}0\\D_{21}\end{bmatrix}\\H_{X_c}=\begin{bmatrix}A_0^TX_{c}+X_cA_0&X_cB_0&C_0^T\\B_0^TX_c&-I&D_{11}^T\\C_0&D_{11}&-I\end{bmatrix}\\P_{X_c}=\begin{bmatrix}\overline{B}^TX_c&0&\overline{D}_{12}^T\end{bmatrix}\\Q=\begin{bmatrix}\overline{C}&\overline{D}_{21}^T&0\end{bmatrix}</script><p><strong>定理</strong>：原线性定常系统存在一个输出反馈 $H_\infty$控制器，当且仅当存在两个对称正定矩阵 X，Y ，使得</p><script type="math/tex; mode=display">1.~\begin{bmatrix}N_0&0\\0&I\end{bmatrix}^T\begin{bmatrix}A^TX+XA&XB_1&C_1^T\\B_1^TX&-I&D_{11}^T\\C_1&D_{11}&-I\end{bmatrix}\begin{bmatrix}N_0&0\\0&I\end{bmatrix}<0</script><script type="math/tex; mode=display">2.~\begin{bmatrix}N_c&0\\0&I\end{bmatrix}^T\begin{bmatrix}AY+YA^T&YC_1^T&B_1\\C_1Y&- I&D_{11}\\B_1^TC_1&D_{11}^T&- I\end{bmatrix}\begin{bmatrix}N_c&0\\0&I\end{bmatrix}<0</script><script type="math/tex; mode=display">3.~\begin{bmatrix}X&I\\I&Y\end{bmatrix}\geq 0</script><p>其中， $N_0,N_c$ 分别是以子空间 $ker([C_2~ D_{21}])$ 和 $ker([B_2^T~ D_{12}^T])$ 中任意一组基向量作为列所构成的矩阵，即满足 $ImN_o=ker([C_2~ D_{21}])$和 $ImN_c=ker([B_2^T~ D_{12}^T])$ 的矩阵 $N_o,N_c$。如果核空间 $ker([C_2~ D_{21}])$ 和 $ker([B_2^T~ D_{12}^T])$ 中有任意一个等于零空间，则在定理条件中可以删去相应的线性矩阵不等式。<strong>若系统不存在控制输入和测量输出</strong>，则可以在系统模型中取 $B_2=0,C_2=0,D_{12}=0,D_{21}=0$，因此相应的 $N_o=I,N_c=I$。这种情况下，上述的不等式变作</p><script type="math/tex; mode=display">1.~\begin{bmatrix}A^TX+XA&XB_1&C_1^T\\B_1^TX&-I&D_{11}^T\\C_1&D_{11}&-I\end{bmatrix}<0</script><script type="math/tex; mode=display">2.~\begin{bmatrix}AY+YA^T&YC_1^T&B_1\\C_1Y&- I&D_{11}\\B_1^TC_1&D_{11}^T&- I\end{bmatrix}<0</script><script type="math/tex; mode=display">3.~\begin{bmatrix}X&I\\I&Y\end{bmatrix}\geq 0</script><p>相应的上述的设计步骤也会发生改变</p><p>其中第四步变为</p><script type="math/tex; mode=display">A_0=\begin{bmatrix}A&0\\0&0\end{bmatrix}\\\\\overline{B}=\begin{bmatrix}0&B_2\\I&0\end{bmatrix}\\\\\overline{C}=\begin{bmatrix}0&I\\C_2&0\end{bmatrix}\\\\H_{X_c}=\begin{bmatrix}A_0^TX_{c}+X_cA_0&0&0\\0&-I&0\\0&0&-I\end{bmatrix}\\\\P_{X_c}=\begin{bmatrix}\overline{B}^TX_c&0&0\end{bmatrix}\\\\Q=\begin{bmatrix}\overline{C}&0&0\end{bmatrix}\\\\\Downarrow\\\\H_{X_c}+P_{X_c}^TKQ+Q^TK^TP_{X_c}<0</script><p>控制器 K 便可以获得可以使用 <strong>LMI 工具箱的求解器 feasp 来求解</strong></p></li></ul></li><li><p><strong>变量替代法设计输出反馈</strong> $H_\infty$ <strong>控制器</strong></p><p> 将矩阵 $X_c$ 和它的逆矩阵进行以下分块</p><script type="math/tex; mode=display"> X_c=\begin{bmatrix}Y&N\\N^T&W\end{bmatrix}~X_c^{-1}=\begin{bmatrix}X&M\\M^T&Z\end{bmatrix}</script><p> 其中， $X,Y\in R^{n\times n}$ 是对称矩阵。从等式 $X_cX_c^{-1}=I$ 可以得到</p><script type="math/tex; mode=display"> X_c\begin{bmatrix}X\\M^T\end{bmatrix}=\begin{bmatrix}I\\0\end{bmatrix}</script><p> 进一步得到</p><script type="math/tex; mode=display"> X_c\begin{bmatrix}X&I\\M^T&0\end{bmatrix}=\begin{bmatrix}I&Y\\0&N^T\end{bmatrix}</script><p> 定义</p><script type="math/tex; mode=display"> F_1=\begin{bmatrix}X&I\\M^T&0\end{bmatrix},F_1=\begin{bmatrix}I&Y\\0&N^T\end{bmatrix}</script><p> 也就是 $X_cF_1=F_2$，进一步利用矩阵的运算，可以得到</p><script type="math/tex; mode=display"> F_1^TX_cA_cF_1=F_2^TA_cF_1\\=\begin{bmatrix}AX+B_2(D_KC_2X+C_KM^T)&A+B_2D_KC_2\\Y(A+B_2D_KC_2)X+NB_KC_2X+YB_2C_KM^T+NA_KM^T&YA+(YB_2D_K+NB_K)C_2\end{bmatrix}\\\\ F_1^TX_cB_c=\begin{bmatrix}B_1+B_2D_KD_{21}\\YB_1+(YB_2D_K+NB_K)D_{21}\end{bmatrix}\\\\ C_cF_1=\begin{bmatrix}C_1X+D_{12}(D_KC_2X+C_KM^{-1})&C_1+D_{12}D_KC_2\end{bmatrix}\\\\ F_1^TX_cF_1=F_2^TF_1=\begin{bmatrix}X&I\\I&Y\end{bmatrix}</script><p> 为了找到一个适当的变量替换，能够将矩阵不等式非线性的LMI转化为一个等价的线性矩阵不等式。结合以上得到的关系式，定义以下的变量替换公式</p><script type="math/tex; mode=display"> \hat{A}=Y(A+B_2D_KC_2)X+NB_KC_2X+YB_2C_KM^T+NA_KM^T\\\\ \hat{B}=YB_2D_K+NB_K\\\\ \hat{C}=D_KC_2X+C_KM^T\\\\ \hat{D}=D_K</script><p> 可以看到，只要在确定矩阵 $M,N$ 的前提下，从定义的变量替换公式可以确定控制器参数。所以非线性 LMI 可以转化为</p><script type="math/tex; mode=display"> \begin{bmatrix}AX+XA^T+B_2\hat{C}+(B_2\hat{C})^T&\hat{A}^T+(A+B_2\hat{D}C_2)&B_1+B_2\hat{D}D_{21}&(C_1X+D_{12}\hat{C})^T\\0&A^TY+YA+\hat{B}C_2+(\hat{B}C_2)^T&YB_1+\hat{B}D_{21}&(C_1+D_{12}\hat{D}C_2)^T\\0&0&-I&(D_{11}+D_{12}\hat{D}D_{21})^T\\0&0&0&-I\end{bmatrix}<0</script><p> 现在求出矩阵 $M,N$ 就能确定控制器参数。</p><p> 根据恒等式 $X_c^TX_c=I$，可得</p><script type="math/tex; mode=display"> MN^T=I-XY</script><p> 可以通过矩阵 $I-XY$ 的奇异值分解来得到满秩矩阵 $M,N$， $X_c&gt;0$ 保证了</p><script type="math/tex; mode=display"> \begin{bmatrix}X&I\\I&Y\end{bmatrix}>0</script><p> 由此可以得到 $I-XY&gt;0$，所以 $M,N$ 总是可以通过奇异值分解得到。控制器参数</p><script type="math/tex; mode=display"> D_K=\hat{D}\\\\ C_K=(\hat{C}-D_KC_2X)(M^T)^{-1}\\\\ B_K=N^{-1}(\hat{B}-YB_2D_K)\\\\ A_K=N^{-1}[\hat{A}-Y(A+B_2D_KC_2)X](M^T)^{-1}-B_KC_2X(M^T)^{-1}-N^{-1}YB_2C_K</script><p> 所以通过变量替代法将上述非线性 LMI 输出反馈问题转化为如下线性 LMI 问题</p><script type="math/tex; mode=display"> \begin{bmatrix}AX+XA^T+B_2\hat{C}+(B_2\hat{C})^T&\hat{A}^T+(A+B_2\hat{D}C_2)&B_1+B_2\hat{D}D_{21}&(C_1X+D_{12}\hat{C})^T\\0&A^TY+YA+\hat{B}C_2+(\hat{B}C_2)^T&YB_1+\hat{B}D_{21}&(C_1+D_{12}\hat{D}C_2)^T\\0&0&-I&(D_{11}+D_{12}\hat{D}D_{21})^T\\0&0&0&-I\end{bmatrix}<0\\\begin{bmatrix}X&I\\I&Y\end{bmatrix}>0\\MN^T=I-XY</script><p> 可得控制器</p><script type="math/tex; mode=display"> D_K=\hat{D}\\\\ C_K=(\hat{C}-D_KC_2X)(M^T)^{-1}\\\\ B_K=N^{-1}(\hat{B}-YB_2D_K)\\\\ A_K=N^{-1}[\hat{A}-Y(A+B_2D_KC_2)X](M^T)^{-1}-B_KC_2X(M^T)^{-1}-N^{-1}YB_2C_K</script><p> 如上的控制器是状态空间的实行，实际上可以通过 <code>K = pck(Ak,Bk,Ck,Dk)</code>指令得到一个增益的形式，</p></li><li><p><strong>输出反馈 $\gamma-$次优 $H_\infty$ 控制器</strong></p><p> 对于一个给定的标量 $\gamma&gt;0$，为了求解系统的状态反馈 $\gamma-$次优 $H_\infty$ 控制器，当且仅当存在两个对称正定矩阵 $X,Y$，使得崩坏星穷铁道</p><script type="math/tex; mode=display"> 1.~\begin{bmatrix}N_0&0\\0&I\end{bmatrix}^T\begin{bmatrix}A^TX+XA&XB_1&C_1^T\\B_1^TX&-\gamma I&D_{11}^T\\C_1&D_{11}&-\gamma I\end{bmatrix}\begin{bmatrix}N_0&0\\0&I\end{bmatrix}<0</script><script type="math/tex; mode=display"> 2.~\begin{bmatrix}N_c&0\\0&I\end{bmatrix}^T\begin{bmatrix}AY+YA^T&YC_1^T&B_1\\C_1Y&-\gamma I&D_{11}\\B_1^TC_1&D_{11}^T&-\gamma I\end{bmatrix}\begin{bmatrix}N_c&0\\0&I\end{bmatrix}<0</script><script type="math/tex; mode=display"> 3.~\begin{bmatrix}X&I\\I&Y\end{bmatrix}\geq 0</script><p> 其中， $N_0,N_c$ 分别是以子空间 $ker([C_2~D_{21}])$ 和 $ker([B_2^T~D_{12}^T])$ 中任意一组基向量作为列所构成的矩阵。可以使用 <strong>LMI 工具箱的求解器 feasp 来求解</strong></p></li><li><p><strong>输出反馈最优</strong> $H_\infty$ <strong>控制器</strong></p><p> 基于输出反馈 $\gamma-$次优 $H_\infty$ 控制器存在的条件，建立一个优化问题</p><script type="math/tex; mode=display"> \min\rho\\\begin{bmatrix}N_0&0\\0&I\end{bmatrix}^T\begin{bmatrix}A^TX+XA&XB_1&C_1^T\\B_1^TX&-\rho I&D_{11}^T\\C_1&D_{11}&-\rho I\end{bmatrix}\begin{bmatrix}N_0&0\\0&I\end{bmatrix}<0\\\begin{bmatrix}N_c&0\\0&I\end{bmatrix}^T\begin{bmatrix}AY+YA^T&YC_1^T&B_1\\C_1Y&-\rho I&D_{11}\\B_1^TC_1&D_{11}^T&-\rho I\end{bmatrix}\begin{bmatrix}N_c&0\\0&I\end{bmatrix}<0\\\begin{bmatrix}X&I\\I&Y\end{bmatrix}\geq 0</script><p> 该问题是一个具有线性矩阵不等式约束和线性目标函数的凸优化问题，可以应用LMI工具箱的求解mincx来求解。如果该问题有解，就可以得到系统的状态反馈最优 $H_\infty$ 控制器。</p></li><li><p><strong>连续时间系统</strong> $H_\infty$ <strong>控制器综合问题求解器 <code>hinflmi</code></strong></p><p> 在 <code>matlab</code> 中可以使用 <code>ltisys</code> 和 <code>hinflmi</code> 函数来求解</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B=[B1 B2];C=[C1;C2];D=[D11,D12;D21,D22];</span><br><span class="line"><span class="built_in">gamma</span>;</span><br><span class="line">G=ltisys(A,B,C,D);</span><br><span class="line">[gopt,K]=hinflmi(G,[<span class="number">1</span> <span class="number">1</span>],<span class="built_in">gamma</span>);</span><br><span class="line">[Ak,Bk,Ck,Dk]=ltiss(K)</span><br></pre></td></tr></table></figure><p> 得到满足 $H_\infty$性能 $\gamma&lt;gamma$ 的一个输出反馈次优 $H_\infty$，如果不填 gamma 参数，获得的是一个最优控制</p><p> <code>hinflmi</code> 函数的基本用法是 <code>[gopt,K]=hinflmi(system,[p m])</code>，通过 <code>mincx</code> 来优化系统的 $H_\infty$ 性能指标，其中 <code>p</code> 是系统测量输出的个数， <code>m</code> 是系统控制输入的个数， <code>K</code> 是最优 $H_\infty$ 控制器系统矩阵，可通过 <code>ltiss</code> 函数得到其状态空间实现。</p></li></ol><h2 id="控制器设计"><a href="#控制器设计" class="headerlink" title="控制器设计"></a>控制器设计</h2><p>图中的 y 是系统观测量，而 u 是对系统的输入值，K 就是对反馈处理的反馈控制器。要使用两个测量量，即系统加速度和系统的行程，u 是控制系统的加速度来控制系统的，也即这个系统是个二阶系统。当然也可以是一阶系统。对于 w 就是来自于系统外部的输入，例如干扰，噪声和参考信号之类的。对于 z 是一些系统输出的错误信号，可以是真实的也可以是虚拟的，在模型中临时使用来设计控制器， $z=\begin{bmatrix}x\\\ddot{x}\\f\end{bmatrix}$，这里使用的是系统的输出和加速度，还有系统驱动力。当干扰输入到系统中之后，在系统 P 种会将干扰放大，而执行器的目标是使干扰的放大最小化，并且在执行过程中使执行力最小，这就是  $H_{\infty}$ 做的，是一种优化，用于计算控制器以最小化 w 和 z 之间得到增益的过程。当然对于系统的控制不一定每一个状态量都重要，所以给 w 和 z 添加加权因子来设置模型的重要性</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="状态反馈控制"><a href="#状态反馈控制" class="headerlink" title="状态反馈控制"></a>状态反馈控制</h3><p>对于一个滑块弹簧系统</p><p><img src="/Blog_ButterFly/2024/03/18/%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/1708827448070.png" alt="1708827448070.png"></p><p>可以得到系统状态方程，假设力的最终作用在滑块上存在噪声 w，满足条件，定义噪声 $-0.05\leq w\leq 0.05,random$</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x_1}\\\dot{x_2}\end{bmatrix}=\begin{bmatrix}0&1\\\frac{k}{m}&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\\\frac{1}{m}\end{bmatrix}u+\begin{bmatrix}1\\1\end{bmatrix}w</script><script type="math/tex; mode=display">z=\begin{bmatrix}1&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}\\y=\begin{bmatrix}1&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\end{bmatrix}w</script><script type="math/tex; mode=display">\dot{x}=Ax+B_1w+B_2u</script><script type="math/tex; mode=display">z=C_1x</script><script type="math/tex; mode=display">y=C_2x+D_{21}w</script><p>将 $u=Kx$ 带入其中，得到</p><script type="math/tex; mode=display">\dot{x}=(A+B_2K)x+B_1w</script><script type="math/tex; mode=display">z=C_1x</script><script type="math/tex; mode=display">y=C_2+D_{21}w</script><p>得到传递函数 </p><script type="math/tex; mode=display">T_{WZ}(s)=C_1[sI-(A+B_2K)]^{-1}B_1</script><p>根据之前的过程可以得到</p><script type="math/tex; mode=display">\begin{bmatrix}(AX+B_2W)^T+(AX+B_2W)&B_1&(C_1X)^T\\B_1^T&-I&0\\C_1X&0&-I\end{bmatrix}<0</script><p>当且仅当存在一个对称正定矩阵X和矩阵W(W不对称正定)，使得上述不等式和 $X&gt;0$ 成立，并且得到控制器 $u=W^\star(X^\star)^{-1}x$ 是系统的一个状态反馈控制器</p><script type="math/tex; mode=display">\begin{bmatrix}(AX+B_2W)^T+(AX+B_2W)&B_1&(C_1X+D_{12}W)^T\\B_1^T&-I&D_{11}^T\\(C_1X+D_{12}W)&D_{11}&-\gamma^{2}I\end{bmatrix}<0</script><p>系统次优 $H_\infty$ 控制器</p><script type="math/tex; mode=display">\min\rho\\\begin{bmatrix}(AX+B_2W)^T+(AX+B_2W)&B_1&(C_1X+D_{12}W)^T\\B_1^T&-I&D_{11}^T\\(C_1X+D_{12}W)&D_{11}&-\rho I\end{bmatrix}<0\\X>0</script><p>系统最优 $H_\infty$ 控制器</p><p>设定 $k=1,m=1$，并将其放入matlab中求解</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>鲁棒控制-线性矩阵不等式处理方法——俞立</p><p><a href="https://zhuanlan.zhihu.com/p/385669774">H∞(H无穷)滤波器（H-infinity filter）</a></p><p><a href="https://blog.csdn.net/weixin_45454343/article/details/114443288">H无穷控制学习笔记——H无穷控制-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_50892810/article/details/126827871">H∞输出反馈控制器推导(最后含例子及程序)_h无穷控制器-CSDN博客</a></p><!-- # $H_2$ 控制器最优控制中的线性二次型[$H_2$ 控制器](https://www.notion.so/H_2-7478fcac2c0d4dfeaf3ddf869bc5727c?pvs=21)--><p>持续更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鲁棒控制 </tag>
            
            <tag> H无穷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID控制理论</title>
      <link href="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"/>
      <url>/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><p>完整计算公式</p><script type="math/tex; mode=display">output=k_perr_{now}+k_i\sum_{j=0}^{k}e_j+k_d(err_{now} - err_{last})</script><p>含义：</p><ul><li><p>P: $kperr_{now}$</p><p>  就是 <code>kp</code> 乘以<strong>此次误差</strong>，理论值与当前值的差值，作用是主动减小误差，使测量值主动贴近理论值。但是如果只有P的话，响应可能会非常剧烈，不好把控，P太大会导致超调</p></li><li><p>I: $ki\sum_{j = 0}^{k} e_j$</p><p>  只要存在误差（稳态误差），不论误差有多小，i的输出也会越来越大</p><p>  作用是消除稳态误差，当系统误差已经接近0时，p 的输出会很小，起不到继续减小误差的作用了，导致误差没有办法减小到0，这个时候就需要用到 I 算法，让误差值不断累积，并且累加到输出中</p></li><li><p>D: $kd(err_{now} - err_{last})$</p><p>  就是 <code>kd</code> 乘以<strong>此次误差减上次误差</strong>，如果只有 <code>P+D</code>，那相当于是一个弹簧系统，阻尼。当变化越剧烈D的效果就会比较大。可以用来抑制系统过冲，更好的控制在理论值范围内，但是kd过大会导致系统产生一些不必要的震荡，所以可以在系统输出保持平稳的条件下，尽可能地增大kd</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">compute</span><span class="params">(PID* pid, <span class="type">float</span> real)</span> &#123;</span><br><span class="line">pid-&gt;err = pid-&gt;target - real;</span><br><span class="line">pid-&gt;errsum += pid-&gt;err;</span><br><span class="line">limitInRange(&amp;pid-&gt;errsum, <span class="number">2000</span>);</span><br><span class="line">pid-&gt;err_dif = pid-&gt;err - pid-&gt;err_last;</span><br><span class="line">pid-&gt;err_last = pid-&gt;err;</span><br><span class="line">pid-&gt;output = pid-&gt;kp*pid-&gt;err + pid-&gt;ki*pid-&gt;err_sum + pid-&gt;kd*pid-&gt;err_dif;</span><br><span class="line">limitInRange(&amp;pid-&gt;output, pid-&gt;limit);</span><br><span class="line"><span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速度控制环一般使用PI控制</p><h3 id="位置式PID"><a href="#位置式PID" class="headerlink" title="位置式PID"></a>位置式PID</h3><p>输出的结果可以直接作为一个控制量，但是有时候需要加一个前馈。因为有误差积分 $\sum{e_i}$，一直累加，也就是当前的输出u(k)与过去的所有状态都有关系，用到了误差的累加值；（误差 $e_i$ 会有误差累加），输出的u(k)对应的是执行机构的实际位置，一旦控制输出出错(控制对象的当前的状态值出现问题 )，u(k)的大幅变化会引起系统的大幅变化。</p><p>并且位置式PID在积分项达到饱和时,误差仍然会在积分作用下继续累积，一旦误差开始反向变化，系统需要一定时间从饱和区退出，所以在u(k)达到最大和最小时，要停止积分作用，并且要有积分限幅和输出限幅，所以在使用位置式PID时，一般直接使用PD控制</p><script type="math/tex; mode=display">output = k_perr_{now}+k_i\sum_{j=0}^{k}e_j+k_d(err_{now} - err_{last})</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">compute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;accErr += pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;accErr, pid-&gt;accErrLimit);</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*pid-&gt;err[<span class="number">0</span>] + pid-&gt;ki*pid-&gt;accErr + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增量式PID"><a href="#增量式PID" class="headerlink" title="增量式PID"></a>增量式PID</h3><p>输出的结果是控制量的增量，控制量是多次计算不断累积出来的结果，增量式pid实际上要根据每次的改变量与上次的改变量的差值来做为 kp 项，只有运行起来的时候 kp 相才有作用。控制量 $output$ 仅与最近3次的采样值有关，容易通过加权处理获得比较好的控制效果，并且在系统发生问题时，增量式不会严重影响系统的工作。</p><script type="math/tex; mode=display">output_i = k_p(err_{now}-err_{last})+k_i*err_{now}+k_d(err_{now}-2err_{last} + err_{lastlast}) + output_{i - 1}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">compute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + pid-&gt;ki*pid-&gt;err[<span class="number">0</span>] + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - <span class="number">2</span>*pid-&gt;err[<span class="number">1</span>] + pid-&gt;err[<span class="number">2</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;limit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T形积分PID"><a href="#T形积分PID" class="headerlink" title="T形积分PID"></a>T形积分PID</h3><p>跟普通的pid相似，是为了减小积分项所带来的误差和控制的幅度</p><p>位置式</p><p>$output = k_perr_{now} + \frac{k_i  \sum_{j=0}^{k} e_j}{2} + k_d  (err_{now} - err_{last})$</p><p>增量式</p><script type="math/tex; mode=display">output_i = k_p(err_{now} - err_{last}) + \frac{k_ierr_{now}}{2} + k_d(err_{now} - 2err_{last} + err_{lastlast}) + output_{i - 1}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">TincCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  <span class="type">float</span> ierr = (pid-&gt;err[<span class="number">0</span>] + pid-&gt;err[<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + pid-&gt;ki*ierr + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - <span class="number">2</span>*pid-&gt;err[<span class="number">1</span>] + pid-&gt;err[<span class="number">2</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">TposCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;accErr += (pid-&gt;err[<span class="number">0</span>] + pid-&gt;err[<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  limitInRange(&amp;pid-&gt;accErr, pid-&gt;accErrLimit);</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*pid-&gt;err[<span class="number">0</span>] + pid-&gt;ki*pid-&gt;accErr + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不完全微分PID"><a href="#不完全微分PID" class="headerlink" title="不完全微分PID"></a>不完全微分PID</h3><p>微分项有引入高频干扰的风险，但若在控制算法中加入低通滤波器，则可使系统性能得到改善。方法之一就是在PID算法中加入一个一阶低通滤波器。这就是所谓的不完全微分，有两种形式，其结构图如下：</p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20180602221746804.png" alt="20180602221746804.png"></p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20180602221755189.png" alt="20180602221755189.png"></p><p>其中微分环节的计算公式为：</p><ul><li><p>位置式公式</p><p>  $U_d(k) = k_d(1-\alpha)(err(k)-err(k-1))+\alpha U_d(k-1)$</p></li><li><p>增量式公式：</p><p>  $\Delta U_d(k) = k_d(1-\alpha)(err(k)-err(k-1))-(1-\alpha)U_d(k-1)$</p><p>  或者表示为</p><p>  $\Delta U_d(k) = k_d(1-\alpha)(err(k)-2err(k-1)+err(k-2))+\alpha \Delta U_d(k-1)$</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> real;</span><br><span class="line">  <span class="type">float</span> target;</span><br><span class="line">  <span class="type">float</span> err[<span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> accErr;</span><br><span class="line">  <span class="type">float</span> accErrLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ud;</span><br><span class="line">  <span class="type">float</span> deltaud;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> output;</span><br><span class="line">  <span class="type">float</span> outputLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> alpha; <span class="comment">// 滤波因子</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> kp;</span><br><span class="line">  <span class="type">float</span> ki;</span><br><span class="line">  <span class="type">float</span> kd;</span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">posCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;accErr += pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;accErr, pid-&gt;accErrLimit);</span><br><span class="line"></span><br><span class="line">  pid-&gt;ud = pid-&gt;kd*(<span class="number">1</span> - pid-&gt;alpha)*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + pid-&gt;alpha*pid-&gt;ud;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*pid-&gt;err[<span class="number">0</span>] + pid-&gt;ki*pid-&gt;accErr + pid-&gt;ud;</span><br><span class="line"></span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line"><span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">incCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> deltaud = pid-&gt;kd*(<span class="number">1</span> - pid-&gt;alpha)*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) - (<span class="number">1</span> - pid-&gt;alpha)*pid-&gt;ud;</span><br><span class="line">  pid-&gt;ud += deltaud;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + pid-&gt;ki*pid-&gt;err[<span class="number">0</span>] + pid-&gt;ud;</span><br><span class="line"></span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line"><span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">incCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  </span><br><span class="line">  pid-&gt;ud = pid-&gt;kd*(<span class="number">1</span> - pid-&gt;alpha)*(pid-&gt;err[<span class="number">0</span>] - <span class="number">2</span>*pid-&gt;err[<span class="number">1</span>] + pid-&gt;err[<span class="number">2</span>]) + pid-&gt;alpha*pid-&gt;deltaud;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + pid-&gt;ki*pid-&gt;err[<span class="number">0</span>] + pid-&gt;ud;</span><br><span class="line"></span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line"><span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="微分先行PID"><a href="#微分先行PID" class="headerlink" title="微分先行PID"></a>微分先行PID</h3><p>微分先行PID控制是只对输出量进行微分，而对给定指令不起微分作用，因此它适合于给定指令频繁升降的场合，可以避免指令的改变导致超调过大。微分先行的基本结构图：</p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20180609152629114.png" alt="20180609152629114.png"></p><p>根据上面的结构图，我们可以推出PID控制器的输出公式，比例和积分是不变的只是微分部分变为只对输出对象积分。将输出对象记为 $y$ ，对微分部分引入一阶惯性滤波 $\frac{1}{\gamma T_d+1}$，则可记微分部分传递函数为 $\frac{U_d(s)}{Y(s)}=\frac{T_ds+1}{\gamma T_ds+1}$，于是微分部分公式为 $u_d(k)=\frac{\gamma T_d}{\gamma T_d+T}u_d(k-1) + \frac{T_d+T}{\gamma T_d+T}y(k)+\frac{T_d}{\gamma T_d +T}y(k-1)$</p><p>由于 $kd = kp \frac{T_d}{T}$，带入其中可得</p><p>位置式公式</p><script type="math/tex; mode=display">u_d(k)=\frac{\gamma k_d}{\gamma k_d+k_p}u_d(k-1) + \frac{k_d+k_p}{\gamma k_d+k_p}y(k)+\frac{k_d}{\gamma k_d +k_p}y(k-1)</script><p>增量式公式</p><script type="math/tex; mode=display">\Delta u_d(k)=\frac{\gamma k_d}{\gamma k_d+k_p}\Delta u_d(k-1) + \frac{k_d+k_p}{\gamma k_d+k_p}\Delta y(k)+\frac{k_d}{\gamma k_d +k_p}\Delta y(k-1)</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> target;</span><br><span class="line">  <span class="type">float</span> err[<span class="number">3</span>];</span><br><span class="line">  <span class="type">float</span> input[<span class="number">2</span>];</span><br><span class="line">  <span class="type">float</span> deltaInput[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> accErr;</span><br><span class="line">  <span class="type">float</span> accErrLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ud;</span><br><span class="line">  <span class="type">float</span> deltaud;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> output;</span><br><span class="line">  <span class="type">float</span> outputLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> gama; <span class="comment">// 微分先行滤波系数</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> kp;</span><br><span class="line">  <span class="type">float</span> ki;</span><br><span class="line">  <span class="type">float</span> kd;</span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">posCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;input[<span class="number">0</span>] = input;</span><br><span class="line">  pid-&gt;ud = (pid-&gt;gama*pid-&gt;kd*pid-&gt;ud + (pid-&gt;kd + pid-&gt;kp)*pid-&gt;input[<span class="number">0</span>] + pid-&gt;kd*pid-&gt;input[<span class="number">1</span>]) / (pid-&gt;gama*pid-&gt;kd + pid-&gt;kp);</span><br><span class="line">  pid-&gt;input[<span class="number">1</span>] = pid-&gt;input[<span class="number">0</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;accErr += pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;accErr, pid-&gt;accErrLimit);</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*pid-&gt;err[<span class="number">0</span>] + pid-&gt;ki*pid-&gt;accErr + pid-&gt;ud;</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">incCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;input[<span class="number">0</span>] = input;</span><br><span class="line">  pid-&gt;deltaInput[<span class="number">0</span>] = input - pid-&gt;input[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;deltaud = (pid-&gt;gama*pid-&gt;kd*pid-&gt;deltaud + (pid-&gt;kd + pid-&gt;kp)*pid-&gt;deltaInput[<span class="number">0</span>] + pid-&gt;kd*pid-&gt;deltaInput[<span class="number">1</span>]) / (pid-&gt;gama*pid-&gt;kd + pid-&gt;kp);</span><br><span class="line">  pid-&gt;input[<span class="number">1</span>] = pid-&gt;input[<span class="number">0</span>];</span><br><span class="line">  pid-&gt;deltaInput[<span class="number">1</span>] = pid-&gt;deltaInput[<span class="number">0</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + pid-&gt;ki*pid-&gt;err[<span class="number">0</span>] + pid-&gt;deltaud;</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="积分分离PID"><a href="#积分分离PID" class="headerlink" title="积分分离PID"></a>积分分离PID</h3><p>在过程的启动、结束或大幅度增减设定值时，短时间内系统输出有很大偏差，会造成PID运算的积分累积，引起超调或者振荡。为了解决这一干扰，人们引入了积分分离的思想。其思路是偏差值较大时，取消积分作用，以免于超调量增大；而偏差值较小时，引入积分作用，用来消除静差，提高控制精度。</p><p>根据实际情况，设定一个阈值；当偏差大于阈值时，消除积分项仅用PD控制；当偏差小于等于阈值时，引入积分采用PID控制。</p><p>位置式</p><script type="math/tex; mode=display">u(k) = \left\{\begin{aligned}&k_p err(k)+k_i\sum^{k}_{j=0}err(j)+k_d(err(k)-err(k-1))&&|err(k)|\leq\varepsilon\\&k_p err(k)+k_d(err(k)-err(k-1))&&|err(k)|>\varepsilon\end{aligned}\right.</script><p>增量式</p><script type="math/tex; mode=display">\Delta u(k)=\left\{\begin{aligned}&k_p(err(k)-err(k-1))+k_ierr(k)+k_d(err(k)-2err(k-1)+err(k-2))&&|err(k)|\leq \varepsilon\\&k_p(err(k)-err(k-1))+k_d(err(k)-2err(k-1)+err(k-2))&&|err(k)|> \varepsilon\end{aligned}\right.</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> target;</span><br><span class="line">  <span class="type">float</span> err[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> accErr;</span><br><span class="line">  <span class="type">float</span> accErrLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> output;</span><br><span class="line">  <span class="type">float</span> outputLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> inputThreshold;</span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> kp;</span><br><span class="line">  <span class="type">float</span> ki;</span><br><span class="line">  <span class="type">float</span> kd;</span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">posCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;accErr += pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;accErr, pid-&gt;accErrLimit);</span><br><span class="line">  <span class="type">int</span> kicontrol = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">abs</span>(pid-&gt;err[<span class="number">0</span>]) &gt; pid-&gt;inputThreshold) kicontrol = <span class="number">0</span>;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*pid-&gt;err[<span class="number">0</span>] + kicontrol*pid-&gt;ki*pid-&gt;accErr + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">incCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  <span class="type">int</span> kicontrol = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">abs</span>(pid-&gt;err[<span class="number">0</span>]) &gt; pid-&gt;inputThreshold) kicontrol = <span class="number">0</span>;</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + kicontrol*pid-&gt;ki*pid-&gt;err[<span class="number">0</span>] + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - <span class="number">2</span>*pid-&gt;err[<span class="number">1</span>] + pid-&gt;err[<span class="number">2</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变速积分PID"><a href="#变速积分PID" class="headerlink" title="变速积分PID"></a>变速积分PID</h3><p>在普通的PID控制算法中，由于积分系数ki；是常数，所以在整个控制过程中，积分增量不变。而系统对积分项的要求是，系统偏差大时积分作用应减弱甚至全无，而在偏差小时则应加强。积分系数取大了会产生超调，甚至积分饱和，取小了又迟迟不能消除静差。变速积分PID的基本思想是设法改变积分项的累加速度，使其与偏差大小相对应：偏差越大，积分越慢，反之则越快。主要是为了防止在偏差过大时积分项产生超调，在越接近的时候就产生积分项来消除静态误差，从而更精确的控制系统</p><p>位置式：</p><p>$u_i(k)=k_i(\sum_{i=0}^{k-1}e(i)+f(e(k))*e(k))$</p><p>$u(k)=k_perr(k)+u_i(k)+k_d*(err(k)-err(k-1))$</p><p>增量式：</p><p>$\Delta u_i(k)=k_if(e(k))e(k))$</p><p>$\Delta u(k)=k_p(err(k)-err(k-1))+u_i(k)+k_d(err(k)-2err(k-1)+err(k-2))$</p><p>其中 $f$ 函数可设为</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}&1&&|x|\leq B\\&\frac{A-|x|+B}{A}&&B<|x|\leq A+B\\&0&&|x|>A+B\end{aligned}\right.</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> target;</span><br><span class="line">  <span class="type">float</span> err[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> accErr;</span><br><span class="line">  <span class="type">float</span> accErrLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> output;</span><br><span class="line">  <span class="type">float</span> outputLimit;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ui;</span><br><span class="line">  <span class="type">float</span> deltaui;</span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> kp;</span><br><span class="line">  <span class="type">float</span> ki;</span><br><span class="line">  <span class="type">float</span> kd;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> (*func) (<span class="type">float</span> ex);</span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">posCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;accErr += pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;accErr, pid-&gt;accErrLimit);</span><br><span class="line">  pid-&gt;ui = pid-&gt;ki*(pid-&gt;accErr + pid-&gt;func(pid-&gt;err[<span class="number">0</span>])*pid-&gt;err[<span class="number">0</span>]);</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*pid-&gt;err[<span class="number">0</span>] + pid-&gt;ui + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">incCompute</span><span class="params">(PID* pid, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">pid-&gt;err[<span class="number">0</span>] = pid-&gt;target - input;</span><br><span class="line">  pid-&gt;deltaui = pid-&gt;kp*pid-&gt;func(pid-&gt;err[<span class="number">0</span>]);</span><br><span class="line">  pid-&gt;output = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]) + pid-&gt;deltaui + pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - <span class="number">2</span>*pid-&gt;err[<span class="number">1</span>] + pid-&gt;err[<span class="number">2</span>]);</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  limitInRange(&amp;pid-&gt;output, pid-&gt;outputLimit);</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模糊PID"><a href="#模糊PID" class="headerlink" title="模糊PID"></a>模糊PID</h3><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210215205920301.png" alt="20210215205920301.png"></p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210215210540132.png" alt="20210215210540132.png"></p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/1700735988292.png" alt="1700735988292.png"></p><p>随着自动控制系统被控对象的复杂化，表现为控制系统具有多输入，多输出的强耦合性参数时变性和非线性特性，更突出的问题是从系统获得的信息量相对减少，相反对控制性能得到要求却日益高度化。很多时侯被控对象的精确的数学模型很难或者无法建立。所以可以添加一系列控制规则，再利用模糊理论，模糊语言变量和模糊逻辑推理，将模糊的控制规则上升为数值运算，让计算机实现这些规则，就可以利用计算机模拟人进行自动控制被控对象。</p><p>模糊控制系统由模糊数据和规则库，模糊器，模糊推理机和解模糊器组成。并且一般选择 $kp, ki, kd$ 三个系数的增量来作为模糊PID控制的输出值</p><ol><li><p>模糊化——模糊器</p><p> 模糊化相当于是划定一个范围，对于控制对象的偏转值的范围做一个划分。但是偏差值最终目标是0。误差总会在一定范围内波动，一般来说把这个范围划分为6等分。如果误差不在这个范围内，而在 $[a, b]$ 范围内，就可以使用线性差值将这个误差规定在这个范围内</p><p> $err_{now} = \frac{2err_{max}}{b-a}(err_{now} - \frac{a+b}{2})$</p><p> | NB           | NM                      | NS                      | ZO  | PS                     | PM                     | PB          |<br> | —————— | ———————————- | ———————————- | —- | ——————————— | ——————————— | —————- |<br> | $-err_{max}$ | $-\frac{2}{3}err_{max}$ | $-\frac{1}{3}err_{max}$ | 0   | $\frac{1}{3}err_{max}$ | $\frac{2}{3}err_{max}$ | $err_{max}$ |</p><ul><li>N 代表 negative</li><li>P 代表 positive</li><li>B big大</li><li>M middle</li><li>S small</li><li><p>$err_{max}$ 偏差的最大范围</p><p><strong>隶属度</strong></p><p>假设此时的误差为 $-\frac{1}{4}err_{max}$ 那么它相对于 NM 的距离为 $\frac{1}{12}err_{max}$，相对于 NS 的距离为 $\frac{1}{4}err_{max}$，那么对于  PB 的隶属度为 $\frac{1}{12} / \frac{1}{3}= \frac{1}{4}$，相对于 Z0 的隶属度就是 $\frac{1}{4} / \frac{1}{3} = \frac{1}{12}$</p><p>于是隶属度曲线关系为</p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210209041517247.png" alt="20210209041517247.png"></p><p>其中利用的是高斯曲线最为隶属度函数的</p><p>$f(x,\sigma ,c)= e^{-\frac{(x-c)^2}{2\sigma^2}}$</p><p>还可以使用三角形，梯形，S型和Z型作为隶属度曲线。实际上这个影响并不大，而每个模糊子集对整个区域的覆盖范围的大小对性能影响较大，一般来说每个模糊子集的宽度如果选择适当，控制效果就会比较好，如果选择宽度较小，则部分区域没有规则相适应，那么收敛性就不好。</p><p>对于误差变化率也可以进行模糊化，规则有两种 <strong>Mamdini</strong> 和 <strong>T-S型模糊控制器</strong></p></li><li><p>Mamdini 型模糊控制器</p><p>  <img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210209140638767.png" alt="20210209140638767.png"></p><p>  这里的误差变化率为 ec，误差为 e。</p><p>  在PID中的一般经验是</p><ul><li>偏差较大时，选用较大的 kp 和较小的 kd 来加快响应，以 kd 为0时来避免积分饱和</li><li>当偏差很小时，为了消除稳态误差，克服超调，ki 要稍微加大，而 kd 需要取正值，来做一些抑制</li></ul></li><li>T-S型模糊控制器</li></ul></li><li>模糊推理——模糊推理机</li><li><p>去模糊化——解模糊器</p><p> 对于实际的PID控制需要精确值来做控制，所以需要去模糊化</p><p> 在实际控制中，每个输入值都会介于两个论阈之间，所以会在规则表中选中一个四格子的矩阵</p><p> 例子：</p><p> |     | NM  | NS  |<br> | —- | —- | —- |<br> | PS  | ZO  | ZO  |<br> | PM  | NS  | PS  |</p><p> 假设输入值位于 NM 和 NS 之间，并且输入值的变化量位于 PS 和 PM 之间，则</p><ul><li>E 对于 NM 隶属度为 a，对于 NS 的隶属度为 1-a</li><li><p>EC 对于 PS 的隶属度为 b，对于 PM 的隶属度为 1-b</p><p>所以有多种解模糊化的算法</p></li><li><p>最大隶属度解模糊法</p><p>$output = ZOab + ZOa(1-b)+NS(1-a)b+PS(1-a)(1-b)$</p><p>除此以外还有面积平分法，面积中心法，加权平均法等方法可以使用。</p><p>在模糊PID中一般选择 $kp, ki, kd$ 三个值的增量来作为模糊控制的输出值</p><p>下面是经验的三个参数的模糊规则</p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210209144420550.png" alt="20210209144420550.png"></p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210209144456308.png" alt="20210209144456308.png"></p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/20210209144529183.png" alt="20210209144529183.png"></p><p>说实话这个傻鸟模糊pid是真难搞，状态量太多了，真是恶心</p></li></ul></li></ol><h3 id="专家PID"><a href="#专家PID" class="headerlink" title="专家PID"></a>专家PID</h3><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-4276975872139efc588601b150e5adcd_720w.webp" alt="v2-4276975872139efc588601b150e5adcd_720w.webp"></p><p><img src="/Blog_ButterFly/2024/03/18/PID%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-b51c092656c83675b4cdcafef59f61be_720w.webp" alt="v2-b51c092656c83675b4cdcafef59f61be_720w.webp"></p><p>优点：</p><ol><li>模型的容量大大扩充，通过不断增删修改规则，可以满足任意动态的控制要求，尤其适用于强干扰，时变的，非线性系统的控制，鲁棒性，自适应性很好。</li><li>可以充分利用先验知识。</li><li>可以接受定性的描述（可能会需要结合模糊数学的知识）。</li><li>可以通过故障检测获得更丰富的知识，进行自我的改善和提升。</li><li>长期连续的可靠性。</li></ol><p>控制规则</p><ol><li><p>设定误差上限，如果误差值的绝对值已经大于误差上限了，此时直接让控制器满负荷运行</p><p> $u(k) = sign(err)*u_{max}$</p></li><li><p>设定误差下限，如果误差存在并且误差正在持续不变或者正在变大，可以控制输出值加上一个增量pid的结果值即 $u(k) = u(k - 1) + k_1(k_p(err(k) - err(k-1)) + k_i*err(k)+ k_d(err(k) - 2err(k-1)+err(k-2))$，实际上是把pid的输出值增大</p><p> 如果误差值大于误差下限，说明误差值仍然较大，可以将 $k_1$ 增大，反之可以减小</p></li><li><p>当误差存在并且误差值正在减小，可以将输出维持原值 $u(k) = u(k-1)$</p></li><li>当误差存在并且 $\Delta err(k)*\Delta err(k -1) &lt; 0$ 说明此时误差值到了极值，此时输出为 $u(k) = u(k-1)+k_2k_ie(k)$，当误差值大于误差下限，说明误差仍然较大，可以适当的将 $k_2$ 增大，反之减小</li><li>设定控制精度，如果误差值在控制精度范围内，就使用 PI 控制，减少稳态误差，此时输出为 $u(k) = u(k-1)+k_ierr(k)+k_p(err(k)-err(k-1))$</li></ol><h3 id="PID的一些缺陷"><a href="#PID的一些缺陷" class="headerlink" title="PID的一些缺陷"></a>PID的一些缺陷</h3><ol><li>闭环系统动态品质对PID增益的变化很敏感，如果环境变换，PID控制器的参数需要进行调整；</li><li>基于误差消除误差是PID的精髓，但直接取目标与实际之间的差值并不合理，初始误差大会导致初始控制力大，会使系统出现超调（快速性与超调是相互矛盾的），有时也有控制量饱和的问题；</li><li>含噪声的信号进行微分难以得到期望的微分信号，PID控制器由于缺少合适的微分器，限制了PID控制的能力；</li><li>PID中的误差积分，有时会让系统的性能变差。</li></ol><p>一个比较好用的PID的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PID</span> &#123;</span></span><br><span class="line">  u8    mode;</span><br><span class="line">  <span class="type">float</span> target;</span><br><span class="line">  <span class="type">float</span> input;</span><br><span class="line">  <span class="type">float</span> err[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> accErr;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> pOut;</span><br><span class="line">  <span class="type">float</span> iOut;</span><br><span class="line">  <span class="type">float</span> dOut;</span><br><span class="line">  <span class="type">float</span> output;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 误差阈值，过小不计</span></span><br><span class="line">  <span class="type">float</span> errThreshold;</span><br><span class="line">  <span class="comment">// 积分分离的阈值</span></span><br><span class="line">  <span class="type">float</span> integralThreshold;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> kp;</span><br><span class="line">  <span class="type">float</span> ki;</span><br><span class="line">  <span class="type">float</span> kiScale;</span><br><span class="line">  <span class="type">float</span> kd;</span><br><span class="line">&#125; PID;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">PIDCompute</span><span class="params">(PID* pid, <span class="type">float</span> target, <span class="type">float</span> input)</span> &#123;</span><br><span class="line">  pid-&gt;err[<span class="number">0</span>] = target - input;</span><br><span class="line">  <span class="keyword">if</span> (fabsf(pid-&gt;err[<span class="number">0</span>]) &lt;= pid-&gt;errThreshold)</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (fabsf(pid-&gt;err[<span class="number">0</span>]) &lt;= pid-&gt;integralThreshold)</span><br><span class="line">    pid-&gt;kiScale = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pid-&gt;kiScale = <span class="number">0</span>;</span><br><span class="line">  pid-&gt;accErr += pid-&gt;kiScale*(pid-&gt;err[<span class="number">0</span>] + pid-&gt;err[<span class="number">1</span>])*<span class="number">0.5f</span>;</span><br><span class="line">  <span class="keyword">switch</span> (pid-&gt;mode) &#123;</span><br><span class="line">    <span class="keyword">case</span> PIDPOS:</span><br><span class="line">      pid-&gt;pOut   = pid-&gt;kp*pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">      pid-&gt;iOut   = pid-&gt;ki*pid-&gt;accErr*pid-&gt;kiScale;</span><br><span class="line">      pid-&gt;dOut   = pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]);</span><br><span class="line">      pid-&gt;output = pid-&gt;pOut + pid-&gt;iOut + pid-&gt;dOut;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIDINC:</span><br><span class="line">      pid-&gt;pOut    = pid-&gt;kp*(pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>]);</span><br><span class="line">      pid-&gt;iOut    = pid-&gt;ki*pid-&gt;kiScale*(pid-&gt;err[<span class="number">0</span>] + pid-&gt;err[<span class="number">1</span>])*<span class="number">0.5</span>;</span><br><span class="line">      pid-&gt;dOut    = pid-&gt;kd*(pid-&gt;err[<span class="number">0</span>] - <span class="number">2</span>*pid-&gt;err[<span class="number">1</span>] + pid-&gt;err[<span class="number">2</span>]);</span><br><span class="line">      pid-&gt;output += pid-&gt;pOut + pid-&gt;iOut + pid-&gt;dOut;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pid-&gt;err[<span class="number">2</span>] = pid-&gt;err[<span class="number">1</span>];</span><br><span class="line">  pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> pid-&gt;output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字信号和模拟信号</title>
      <link href="/Blog_ButterFly/2024/03/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/"/>
      <url>/Blog_ButterFly/2024/03/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p><strong>模拟信号（Analog signal）简称 A</strong></p><p>模拟信号是连续的信号，如下图中红色的曲线</p><p><strong>优点</strong></p><ol><li>更容易处理</li><li>最适合音频和视频传输</li><li>具有更高的密度，可以传输更精细的信息</li><li>需要的带宽比数字信号少</li><li>可以准确的表达物理现象的变化</li><li>电气容差敏感度较低</li></ol><p><strong>缺点</strong></p><ol><li>长距离传输可能会产生意外干扰信号</li><li>容易产生耗损</li><li>数字信号抗扰性更高，模拟信号更容易受到噪声和失真的影响</li><li>信号质量较低</li></ol><p><strong>数字信号（Digital signal）简称 D</strong></p><p>数字信号是离散的信号，如下图中黑色的阶梯型曲线</p><p><strong>优点</strong></p><ol><li>能以更小的噪声，失真和干扰传递信息</li><li>数字电路能以较低的成本更容易大量复制</li><li>数字信号处理更加灵活，因为通过数字可编程系统可以改动DSP的操作</li><li>数字信号处理更加安全，数字信号可以被轻易加密和压缩</li><li>数字系统更加精确，而且通过错误检测和矫正代码可以降低错误发生的几率</li><li>数字信号可以通过半导体芯片存储在任何磁性介质或者光学介质上</li><li>数字信号可以远距离传输</li></ol><p><strong>缺点</strong></p><ol><li>与传输相同信息的模拟信号相比，数字通信需要更高的带宽</li><li>DSP以更高的速率处理信号，而且包含更多上层内部硬件资源，这将导致更高的功耗，而模拟信号处理因为包含消耗更少能量的无源组件，所以功耗相对较低</li><li>数数字系统和处理通常更为复杂</li></ol><p><img src="https://pic1.zhimg.com/80/v2-4a9af5e31e5443d40cbc5007245d6a18_720w.webp" alt="https://pic1.zhimg.com/80/v2-4a9af5e31e5443d40cbc5007245d6a18_720w.webp"></p><p><strong>为什么要进行数模转换呢</strong></p><ol><li><p>模拟信号转数字信号：ADC</p><p> 因为需要使用计算机对数据进行各种计算来处理成矩阵图像，而模拟信号是无法被计算机处理的。计算机只能处理离散的具体数据，而模拟数据是连续的，是不具体的，故而无法对模拟信号进行处理。计算机的时间不是连续的，是有最小的时钟信号的</p><p> <strong>过程</strong></p><p> <img src="/Blog_ButterFly/2024/03/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/Untitled.png" alt="Untitled"></p><p> 如图，输入为模拟信号，通过采样保持电路（S/H）对其进行处理，创建该信号的近似数字表示，信号幅度不再是无限，而是根据ADC分辨率量化成的离散值，具有较高分辨率的ADC将具有更精细的步长，并且能更准确的表达输入模拟信号，ADC的最后一级将数字化信号编码为代表模拟信号幅度的二进制比特流</p></li><li><p>数字信号转模拟信号：DAC</p><p> 对于一些设备的控制，不可能只用数字信号就能控制的了的，所以需要一些手段来进行连续的控制，例如电机的控制，电机是通过控制电流或者电压来控制的，但是电流和电压是连续的模拟信号，所以就需要数字信号转化为模拟信号，常使用保持器来保证控制的连续性</p><p> <strong>过程</strong></p><p> <img src="/Blog_ButterFly/2024/03/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/Untitled%201.png" alt="Untitled"></p><p> DAC提供反向操作，DAC的输入是来自数字系统的二进制数据流，它输出的离散值可近似为模拟信号，DAC分辨率越高，输出信号也会更加接近真实的，平滑连续的模拟信号，在模拟信号链中经常还有一个后置滤波器，用于进一步平滑波形</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOC磁场定向控制</title>
      <link href="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/"/>
      <url>/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>电机场向量调制是一种用于控制感应电机的方法。它使用三相电流控制来调制电机的转矩和转速。在FOC控制中，电机的转子位置和速度被监测和估计，以提供准确的电流控制。这使得电机能够以高效率和低噪音运行。</p><p>FOC控制是现代驱动器系统的标准，用于控制感应电机、同步电机和永磁电机。它提供了高度可预测的电机控制，并且可以在不同负载条件下实现高效率。</p><h2 id="电机类型"><a href="#电机类型" class="headerlink" title="电机类型"></a>电机类型</h2><ol><li><p>步进电机</p><p> 步进电机是一种将电脉冲转化为角位移的执行机构。通俗一点讲当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（及步进角）。您可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的；同时您可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到准确定位的目的；同时您可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。</p><ol><li>永磁式 一般为2相，转矩和体积比较小，步进角为7.5或者15度</li><li>反应式 一般为3相，可实现大扭矩，步进角1.5度，噪声振动较大</li><li>混合式  结合以上两者优点，分为2相和5相，步进角为1.8度和0.72度</li></ol></li><li>直流电机 通入直流旋转，反向电流就反向转</li><li>交流电机 输入或者输出为交流电的旋转电机</li><li><p>伺服电机 </p><p> 伺服电动机又称执行电动机，在自动控制系统中，用作执行元件，把所收到的电信号转换成电动机轴上的角位移或角速度输出。分为直流和交流伺服电动机两大类，其主要特点是，当信号电压为零时无自转现象，转速随着转矩的增加而下降。</p></li></ol><ul><li>有刷电机有电刷，转向器，在适当的时候转换电流方向，使电机继续转动</li><li>无刷电机无电刷，通过mos管来改变电流方向使电机继续转动</li></ul><p>电机内部的转子一般是一组线圈，线圈的个数就是磁级数</p><h2 id="电机的旋转方式"><a href="#电机的旋转方式" class="headerlink" title="电机的旋转方式"></a>电机的旋转方式</h2><ol><li><p>电磁铁的构成</p><p> 单个线圈通电</p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425094308893.png" alt="20210425094308893.png"></p><p> 3个线圈通每个线圈方向间隔120度，为了减少硬件电路驱动(H桥)的数量，因此一般是将三个线圈的一端进行相连接，组成了三相星型结构</p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/202104250944353.png" alt="202104250944353.png"></p></li><li><p>H桥驱动电路驱动线圈</p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425094627135.png" alt="20210425094627135.png"></p><p> H桥由4个mos管组成，当A和B’打开时，电流从左上方流入线圈(红色箭头方向)，打开B和A’，电流就是蓝色的方向，也就是反向的电流</p><p> 控制线圈产生的磁场大小，通过控制电压占空比来实现</p><p> 这里可以使用方波来控制MOS管的导通，如时间周期T，在T/2时间打开A和B’，剩下的T/2关闭A和B’，这样的话就相当于0.5VDC的电压加载到线圈上了(若是T时间均打开 那么线圈上的电压就是VDC)，线圈上的电压可能是0~0.5VDC之间不断的跳动，但是线圈的电流是接近连续的，因为这是电感，如下图，若是电压变动很快并且电感足够大，理论上是可以做到电流连续的</p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425141727433.png" alt="20210425141727433.png"></p><p> 三个线圈连接在一起是为了减少mos管的使用</p><p> <strong>注意</strong>：上面的H桥驱动电路上桥和下桥在同一时间只有一个能打开，两个同时打开会短路，所以在PWM输出时会设置一个保护时段，这个时段上下管都不会有输出</p><p> <strong>H桥驱三相星链线圈</strong></p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425141922616.png" alt="20210425141922616.png"></p><p> 上桥开通下桥关断定义为状态1</p><p> 上桥关断下桥开通定义为状态0</p><p> 一共有八种组合方式：<strong>000</strong>、<strong>001</strong>、<strong>010</strong>、<strong>011</strong>、<strong>100</strong>、<strong>101</strong>、<strong>110</strong>、<strong>111</strong></p></li><li><p>三相线圈产生的磁场</p><p> 0电流状态：在000和111状态上可以看出在这两个状态上时三相线圈是没有电流的，其余6种都会产生电流</p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425141951716.png" alt="20210425141951716.png"></p><p> 橘色箭头的方向和电磁铁形成磁场方向一致，但是这里我们把橘黄色箭头称呼为<strong>电压矢量的方向</strong>，因为这里我们加载的是电压方向（1图中A指向B和C）由于是稳态的，所以电流方向也是这个方向，所以磁场方向和橘色箭头一致了&lt;右手螺旋法则&gt;。所以最终产生的磁场方向汇总如下</p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425142039650.png" alt="20210425142039650.png"></p></li><li><p>电磁场牵引转子最优的状态</p><p> 当电磁铁的方向和转子(永久磁铁)的方向呈90度的时候，力矩最大。转子会向着电磁铁的方向旋转,此时若转子受到牵引转动了θ角，与此同时电磁铁也按照同方向转动了θ角，那么电磁铁的方向始终和转子的方向垂直，这样转子就会不断的进行旋转了并且力矩始终是最大的</p><p> 三相线圈只能生成6个方向的电压矢量，通过SVPWM可以根据这六个电压矢量合成任意角度的电压矢量</p></li></ol><h2 id="SVPWM空间矢量脉宽调制"><a href="#SVPWM空间矢量脉宽调制" class="headerlink" title="SVPWM空间矢量脉宽调制"></a>SVPWM空间矢量脉宽调制</h2><p>基本思想就是根据上面的六个磁场方向合成任意角度的磁场方向</p><p>与FOC的关系：FOC的输出是SVPWM的输入，SVPWM输出是三相电压的占空比，也就是最终设置到计时器中的比较寄存器的值</p><p>FOC的输出结果</p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/2021042514465922.png" alt="2021042514465922.png"></p><p>得到FOC的输出结果之后，可以根据该值来判断合成的矢量所在的扇区，然后利用对应扇区的公式计算 Tx, Ty, Tz 的数值然后进行变换之后设置到PWM控制器的比较值中，就可以产生对应的波形，从而产生对应的磁场方向</p><h2 id="FOC控制原理"><a href="#FOC控制原理" class="headerlink" title="FOC控制原理"></a>FOC控制原理</h2><p>一个三相无刷电机时，当手转动电机然后用示波器观察电机的三根信号线，能够看到输出的是三个相位相差120度的正弦波形，因为电动机反过来就是发电机。因为控制常用的就是闭环控制，而检测正弦波比较困难，那么FOC主要做的工作就是解耦，就是将复杂的信号拆解成比较容易分析的量。</p><ol><li><p>FOC控制的结构</p><p> <img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/2021042514480029.png" alt="2021042514480029.png"></p><p> 这幅图是以电流闭环控制的</p><p> 控制器的输入是最左边的<strong>Iq_ref</strong>和 <strong>Id_ref</strong>，两个变量经过PID控制器进行反馈调节，其中还涉及到几个变换模块， <strong>Park变换和Clark变换</strong>；最后通过前面提到的SVPWM模块作用到三相逆变器上进而控制电机；而PID控制器的反馈量，是对电机输出电流的采样值。</p></li></ol><p><strong>控制流程</strong></p><ol><li>采样得到三相的电流</li><li>将三相电流经过Clark变换之后得到 $I_\alpha,I_\beta$</li><li>$I_\alpha,I_\beta$ 经过Park变换之后得到 $I_q,I_d$</li><li>计算 $I_q,I_d$ 和设定值 Iq_ref, Id_ref 之间的误差</li><li>上述误差使用到PID控制器上，得到输出的控制电压 $U_q, U_d$</li><li>将其进行反向 Park变换得到 $U_\alpha, U_\beta$</li><li>再用 $U_\alpha, U_\beta$ 合成电压空间矢量，输入 SVPWM模块 进行调制，输出该时刻三个半桥的状态编码值</li><li>根据状态码控制三相逆变器的MOS管开关，驱动电机</li></ol><p><strong>Clark变换</strong></p><p>通过电流的采样，我们得到了三个相位相差120度的正弦波，采集电机前的电流的作用主要是用作PID反馈，以此来调整输入的误差。从上图可以看出，我们只需要采样两个信号线，另一根可以使用基尔霍夫定律得出 $I_a + I_b +I_c = 0$</p><p>采集的得到的电流是三个正弦波，直接做PID十分复杂，所以进行转换</p><p>Clark变换公式：</p><p>$\left\{\begin{matrix} I_\alpha=I_a-cos(\frac{\pi}{3})I_b-cos(\frac{2\pi}{3})I_c \\ I_\beta=sin(\frac{\pi}{3})I_b-sin(\frac{\pi}{3})I_c\end{matrix}\right.$</p><p>之后就把三个电流值转化为两个电流值了</p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425150420123.png" alt="20210425150420123.png"></p><p><strong>Park变换</strong></p><p>上面的Clark变换的输出中得到了 $\alpha-\beta$ 坐标系，将该坐标系旋转 $\theta$ 角度之后得到 Q-D 坐标系</p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425150507579.png" alt="20210425150507579.png"></p><p>坐标转换公式为</p><p>$\left\{\begin{matrix} I_d=I_\alpha cos(\theta)+I_\beta sin(\theta)  \\ I_q=-I_\alpha sin(\theta)+I_\beta cos(\theta) \end{matrix}\right.$</p><p>Q和D可能很熟悉，那就是分别对应电机的Q轴(交轴)和D轴(直轴)，θ就是转子转动的角度，也就是d-q坐标系是始终随着转子进行转动的</p><p>这个操作是可行的，因为我们会通过编码器输入转子的实时旋转角度，所以这个角度始终是一个已知数。经过这一步的变换，我们会发现，一个匀速旋转向量在这个坐标系下变成了一个定值！<strong>（因为参考系相对于该向量静止了，Id和Iq相对于D-Q坐标系）</strong>，这个坐标系下两个控制变量都被线性化了！</p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425150639711.png" alt="20210425150639711.png"></p><p><strong>PID控制</strong></p><p>FOC控制中主要使用三个PID环，电流环，速度环，位置环</p><p>其实就是，通过电流反馈控制电流，通过控制扭矩控制转速，再通过控制转速控制电机位置</p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/202104251508193.png" alt="202104251508193.png"></p><p>clack变换和pack变换最后输出的Iq和Id的值，也就是主要对采样的正弦电流进行解耦，分解成径向和切向这两个方向的变量。 $I_q$ 是期望的力矩输出， $I_d$ 是我们不需要的，应该是径向力矩输出。 <strong>由上图可以知道经过FOC的控制目标就是将Id的电流尽量减小到0，因为其对电机的转向是没有任何帮助的所以我们尽量让其控制到0</strong></p><p>电流环：</p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425150753110.png" alt="20210425150753110.png"></p><p>速度环：w是电机的转速反馈，可以通过电机编码器或者霍尔传感器等计算得到，依然是使用<strong>PI控制</strong></p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425150918628.png" alt="20210425150918628.png"></p><p>位置环：</p><p><img src="/Blog_ButterFly/2024/03/18/FOC%E7%A3%81%E5%9C%BA%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6/20210425150943629.png" alt="20210425150943629.png"></p><p>这个位置环去掉了速度环，所以使用的是完整的 PID 控制 ，把微分项加上了，微分项就是速度信息，这样可以减小位置控制的震荡加快收敛，积分项消除静态误差</p><h2 id="动能回收"><a href="#动能回收" class="headerlink" title="动能回收"></a>动能回收</h2><h2 id="双反应理论"><a href="#双反应理论" class="headerlink" title="双反应理论"></a>双反应理论</h2>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻抗和导纳控制</title>
      <link href="/Blog_ButterFly/2024/03/18/%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E6%8E%A7%E5%88%B6/"/>
      <url>/Blog_ButterFly/2024/03/18/%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="机器人交互控制"><a href="#机器人交互控制" class="headerlink" title="机器人交互控制"></a>机器人交互控制</h2><ol><li><p>直接力控 直接对完成任务所需要的力做一个设定，利用力或者转矩的传感器实时对力进行反馈，从而达到控制</p><p> 存在的一些问题：使用的一些力的传感器一般会比较贵，也会出现精度和噪声的情况，其次就是不容易对力进行设定</p></li><li><p>间接力控</p><ol><li>柔顺控制<ol><li>被动柔顺  使用一些机械的设备，例如弹簧之类的设备使机器人在与外界交互中出现一些柔顺性</li><li>主动柔顺  通过软件使机器人对外界的环境做出一些柔顺性</li></ol></li><li>阻抗/导纳控制  让机器人在与外界交互的过程中，包含有质量，弹簧，阻尼这样一个二阶阻抗系统的性质<ol><li>关节空间</li><li>笛卡尔空间 也就是三维空间坐标系</li></ol></li></ol></li><li><p>力位混合控制</p><p> 机器人在某个方向上做力的控制，在正交的方向上做位移的控制</p></li></ol><h2 id="阻抗控制"><a href="#阻抗控制" class="headerlink" title="阻抗控制"></a>阻抗控制</h2><h3 id="关节空间内的阻抗控制"><a href="#关节空间内的阻抗控制" class="headerlink" title="关节空间内的阻抗控制"></a>关节空间内的阻抗控制</h3><p>目标：让机器人的每一个关节能体现出由弹簧-阻尼-质量组成的二阶系统的动态特性，其中 $q_d$ 是对关节角度的设定值， $q$ 是实际测量值，那么 $\overline{q}$ 就是一个控制误差，左边就是对这个控制的动态误差的描述，M, D, K 就是三个矩阵，表示质量，阻尼和弹性系数，这个q矩阵的大小是和关节数自由度量有关的，一般会设计为对角阵，也就是每个关节独立，三个矩阵必须正定才能保证整个二阶系统的稳定性，右侧就是关节受到的外力产生的力矩</p><p>$M_d\overset{..}{\overline{q}}+D_d\overset{.}{\overline{q}}+K_d\overline{q} = \tau_{ext}$       $\overline{q} = q_d-q$</p><p><strong>实现机器人的动态特性</strong></p><p>机器人动力学方程：</p><p>$M(q)\overset{..}{q}+C(\overset{.}{q}, q)\overset{.}{q} + g(q) = \tau-\tau_{ext}$</p><p>其中 $q,\overset{.}{q},\overset{..}{q}$ 分别代表机器人的关节角度，角速度，角加速度，M，C，g分贝代表了惯性矩阵，<a href="[科里奥利效应 (baidu.com">科里奥利效应</a>](<a href="https://baike.baidu.com/item/%E7%A7%91%E9%87%8C%E5%A5%A5%E5%88%A9%E6%95%88%E5%BA%94/599761?fr=ge_ala))，重力效应，这里的M矩阵是与机器人的机械结构和运动有关的，是一个转动惯量矩阵，是一个不能随意定义的矩阵，这三个矩阵都是和机器人的运动状态有关的，运动状态改变，三个矩阵的数值也会发生改变，需要实时的计算这三个矩阵。">https://baike.baidu.com/item/%E7%A7%91%E9%87%8C%E5%A5%A5%E5%88%A9%E6%95%88%E5%BA%94/599761?fr=ge_ala))，重力效应，这里的M矩阵是与机器人的机械结构和运动有关的，是一个转动惯量矩阵，是一个不能随意定义的矩阵，这三个矩阵都是和机器人的运动状态有关的，运动状态改变，三个矩阵的数值也会发生改变，需要实时的计算这三个矩阵。</a></p><p>$\tau$ 是输入力矩，是驱动电机产生的力矩， $\tau_{test}$ 是外界产生的力矩也就是阻力矩。两个力矩之和控制了机器人的运动状态</p><ul><li><p>一个小栗子：</p><p>  假设机器人的控制任务是跟随一条轨迹运动，即 $q_d,\overset{.}{q_d},\overset{..}{q_d}$ 就可以定义如下关节转矩控制的输入，也就是电机的转矩大小</p><script type="math/tex; mode=display">  \tau = M(q)\overset{..}{q_d} + C(\overset{.}{q},q) + g(q) + M(q)M_d^{-1}(D_d\overset{.}{\overline{q}} + K_d\overline{q}) + (I-M(q)M_d^{-q})\tau_{ext}</script><p>  第一个式子是和机器人动力学方程是一样的，唯一区别是其中的角加速度为设定值，第二个式子与之前定义的二阶系统的参数有关，同时还包含着控制误差的反馈，括号外面的是一个转动惯量矩阵，最后一个式子，是机器人受到外力力矩的反馈再乘以一个系数。</p><p>  <img src="/Blog_ButterFly/2024/03/18/%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E6%8E%A7%E5%88%B6/uTools_1693271711198.png" alt="uTools_1693271711198.png"></p><p>  把阻抗控制分为3部分</p><ol><li>回授线性化，为了让机器人对外体现出一种线性化的特征，并且如此我们可以使用一个线性控制器来控制它</li><li>线性控制器，此时控制设定值为线性角度，线性角速度，线性角加速度，同时这些值也可以乘以不同的增益，这些增益就是之前的二阶系统的质量，阻尼系数和弹性系数，对关节角加速度实行的是前馈控制，关节角加速度和角度实行负反馈控制，三部分之和就是线性控制系统的输出</li><li><p>转矩反馈，根据反馈的转矩来乘以一个系数，合并到输入中，作为力矩的输入</p><p>总结</p></li><li><p>阻抗控制是通过控制机器人运动实现间接力控的方法</p></li><li>最终目的不是直接控制机器人的运动，也不直接控制机器人与外界的接触力，而是控制两者之间的动态关系。</li><li>要想实现理想的阻抗控制的条件<ol><li>机器人动态模型和相关参数已知</li><li>机器人关节角，角速度实时反馈</li><li>机器人关节力矩实时反馈</li><li>机器人的转矩控制</li></ol></li></ol></li></ul><p>一些变化：</p><ol><li><p>不能提供关节力矩的实时反馈：</p><ul><li><p>删除与关节力矩相关的部分</p><script type="math/tex; mode=display">\tau = M(q)\overset{..}{q_d} + C(\overset{.}{q},q) + g(q) + M(q)M_d^{-1}(D_d\overset{.}{\overline{q}} + K_d\overline{q})</script><p>带入机器人动力学方程中</p><script type="math/tex; mode=display">M_d\overset{..}{\overline{q}}+D_d\overset{.}{\overline{q}}+K_d\overline{q} = M_dM^{-1}(q)\tau_{ext}</script><p>这种情况下各个关节会存在耦合的情况，M, D, K 是对角矩阵，但是右侧存在M(q)矩阵，所以不可能是对角阵，所以各个关节之间会存在耦合</p></li><li><p>还可以设计 $M_d = M(q)$</p><script type="math/tex; mode=display">\tau = M(q)\overset{..}{q_d} + C(\overset{.}{q},q) + g(q) + M(q)M_d^{-1}(D_d\overset{.}{\overline{q}} + K_d\overline{q}) + (I-M(q)M_d^{-q})\tau_{ext}</script><p>这种情况下，关于 $\tau_{ext}$ 的一项就会为0，</p><p>代入运动学方程中为</p><script type="math/tex; mode=display">M(q)\overset{..}{\overline{q}}+D_d\overset{.}{\overline{q}}+K_d\overline{q} = \tau_{ext}</script><p>结果是，机器人仍然能体现出阻抗性，但是与质量相关的项存在耦合关系</p><p>优点：由于关节加速度很小，所以对系统影响很小，耦合作用相对较弱。</p></li></ul></li><li><p>简化</p><p> 令 $\overset{..}{q_d},\overset{.}{q_d}$ 为0，同时忽略 $M_d,M(q)$ </p><p> 此时 $\tau = C(\overset{.}{q},q)\overset{.}{q}+g(q)-D_d\overset{.}{q}+K_d\overline{q}$ 这种控制被称为KD+控制， $K_d$为p控制器， $D_d$为d控制器，同时加上了非线性补偿 $C(\overset{.}{q},q)\overset{.}{q}$ 。</p><p> 带入动力学方程：</p><p> $-M(q)\overset{..}{q}-D_d\overset{.}{q}+K_d\overline{q} = \tau_{ext}$</p><p> 其中 $M(q)\overset{..}{q}$ 几乎为0，机器人仍然体现出一些阻抗特性，但是这种阻抗特性是由 D和K提供的，但是会与之前设定的标准值相差较大。当关节加速度较小时，几乎可以看作为一阶系统，有时候被定义为关节柔顺控制。</p></li></ol><h3 id="笛卡尔空间内的阻抗控制"><a href="#笛卡尔空间内的阻抗控制" class="headerlink" title="笛卡尔空间内的阻抗控制"></a>笛卡尔空间内的阻抗控制</h3><p>目标：让机器末端执行器在笛卡尔空间内的每个方向上都体现出由弹簧-阻尼-质量组成的二阶系统的动态特性，但是要注意，目标方向数量应该小于等于自由度的数量，最多可以定义六个方向上的运动</p><p>$M_d\overset{..}{\overline{x}}+D_d\overset{.}{\overline{x}}+K_d\overline{x} = F_{ext}$       $\overline{x} = x_d-x$</p><p>假定控制任务是跟随一条轨迹</p><script type="math/tex; mode=display">\tau = M(q)J^{-1}(q)M_d^{-1}(M_d\overset{..}{x_d}+K\overset{.}{\overline{x}} + D\overline{x}-M_dJ^{'}(\overset{.}{q},{q})\overset{.}{q})+(J^T(q)-M(q)J^{-1}(q)M_d^{-1})F_{ext}+g(q)+C(q,\overset{.}{q})\overset{.}{q}</script><p>公式分为3个部分：</p><ul><li><p>第一个部分与之前的几乎一样，但是加上了雅各比矩阵来进行笛卡尔空间到关节空间之间的转换，后面出现雅各比矩阵的导数是由于速度和加速度的求解，物理层面上就是为了抵消一部分由加速度产生的惯性力的作用 $M_dJ^{‘}(\overset{.}{q},{q})\overset{.}{q}$</p><p>  $\overset{.}{x} = J(q)\overset{.}{q}$     ⇒      $\overset{..}{x} = J(q)\overset{..}{q}+J^{‘}(\overset{.}{q},{q})\overset{.}{q}$</p></li><li><p>第二部分就是把外界的力通过笛卡尔空间转化为关节空间的力</p></li><li>第三部分是机器人自身运动过程中来源于自身的一些非线性的力</li></ul><p>将关节控制输入表达式带入到机器人动力学方程中可以得到所期望的二阶系统动态方程，理想状态下，可以体现出完全解耦的阻抗特性</p><p>实际操作中需要：</p><ul><li>求解雅各比矩阵的逆矩阵和导数矩阵</li><li>精确测量机器人执行器末端的受到的外力</li><li>精确的机器人运动学以及动力学模型</li><li>机器人关节位置和转速的测量</li><li>机器人关节转矩控制</li><li>不要过度接近机器人的奇异点，会导致雅各比矩阵的求解误差教大，机器人运动受限</li></ul><p>笛卡尔空间的控制结构</p><p><img src="/Blog_ButterFly/2024/03/18/%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E6%8E%A7%E5%88%B6/uTools_1693279517478.png" alt="uTools_1693279517478.png"></p><p>阻抗控制器： $K_p,K_d,M_d$ 是控制器的增益，尽量减小设定值与机器人在空间运动的实际值的误差，之后产生一个虚拟的控制输入y</p><p>通过运动学逆解得到在实际空间中所需要产生的力矩</p><p>一些变化</p><ul><li><p>不能提供末端外力的实时反馈</p><ul><li><p>直接删去与外力相关的部分</p><script type="math/tex; mode=display">  \tau = M(q)J^{-1}(q)M_d^{-1}(M_d\overset{..}{x_d}+K\overset{.}{\overline{x}} + D\overline{x}-M_dJ^{'}(\overset{.}{q},{q})\overset{.}{q})+g(q)+C(q,\overset{.}{q})\overset{.}{q}</script></li><li><p>带入机器人动力学方程中</p><script type="math/tex; mode=display">  M_d\overset{..}{\overline{x}}+D_d\overset{.}{\overline{x}}+K_d\overline{x} =M_dJ(q)M^{-1}(q)J^T(q) F_{ext}</script></li><li><p>结果是机器人仍然体现阻抗特性，但是各个方向之间存在耦合关系</p></li></ul></li><li><p>PD+控制</p><script type="math/tex; mode=display">\tau = J^T(q)(K\overline{x}+D\overset{.}{\overline{x}})+g(q)+C(q,\overset{.}{q})\overset{.}{q}</script><p>  就是一个简单的PD控制器乘以一个雅各比矩阵的转置，然后再加上机器人运动中产生的非线性的力</p><script type="math/tex; mode=display">-J^{-T}M(q)\overset{..}{q}+D_d\overset{.}{\overline{x}}+K_d\overline{x} = F_{ext}</script><p>  结果：机器人依旧能体现一定的阻抗特性，但是与设定值的误差较大</p><p>  还需要考虑如何设计阻尼系数 $D_d$ 从而减小部分耦合作用</p><p>  阅读(<a href="https://link.springer.com/book/10.1007/978-3-540-69255-3">Cartesian Impedance Control of Redundant and Flexible-Joint Robots | SpringerLink</a>)</p></li></ul><h2 id="导纳控制"><a href="#导纳控制" class="headerlink" title="导纳控制"></a>导纳控制</h2><p>目的与阻抗控制一样，都是让机器人对外体现出弹簧-阻尼-质量组成的二阶系统的动态特性</p><p>区别：</p><ol><li>物理意义</li><li><p>控制方法</p><p> <img src="/Blog_ButterFly/2024/03/18/%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E6%8E%A7%E5%88%B6/uTools_1693292365375.png" alt="uTools_1693292365375.png"></p><p> 阻抗控制，可以把控制器认为是一种阻抗，会有机器人的位置信息，根据位置信息和事先定义好的阻抗行为计算一个力的设定值，机器人运行这个力的设定值的时候会产生一定的运动，对于控制器来说，输入位置，输出是力，而对于机器人就是输入是力输出是位置</p><p> 导纳控制，控制器接收到的是外界的力，控制器根据定义好的阻抗特性计算机器人该产生什么样的位移，机器人执行这个位置的过程中会对外界产生一定的力</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阻抗控制 </tag>
            
            <tag> 导纳控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMC虚拟模型控制</title>
      <link href="/Blog_ButterFly/2024/03/18/VMC%E8%99%9A%E6%8B%9F%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/Blog_ButterFly/2024/03/18/VMC%E8%99%9A%E6%8B%9F%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>一点点小补充</strong></p><ul><li>M3508 转矩常数0.3，也就是每增加1A电流力矩增加0.3牛米</li><li>AK80-6 转矩常数 0.09 这个好像不用管</li></ul><p>对于四足，电机相对，力矩Tp由TB和TF共同提供，会比以上计算更简单</p><h1 id="五连杆正运动学解算"><a href="#五连杆正运动学解算" class="headerlink" title="五连杆正运动学解算"></a>五连杆正运动学解算</h1><p><img src="/Blog_ButterFly/2024/03/18/VMC%E8%99%9A%E6%8B%9F%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6/1710491620264.png" alt="1710491620264.png"></p><p>以杆 $L_5$ 的中心为原点，可以得到</p><script type="math/tex; mode=display">A=(-\frac{L_5}{2}, 0)\\B=(-\frac{L_5}{2}+L_1\cos\varphi_1,L_1\sin\varphi_1)\\D=(\frac{L_5}{2}+L_4\cos\varphi_4,L_4\sin\varphi_4)\\E=(\frac{L_5}{2},0)</script><p>通过五连杆左右两部分列写 C 点坐标，可以得到下列等式</p><script type="math/tex; mode=display">\left\{\begin{aligned}&x_B+L_2\cos\varphi_2=x_D+L_3\cos\varphi_3\\&y_B+L_2\sin\varphi_2=y_D+L_3\sin\varphi_3\end{aligned}\right.</script><p>求解得到</p><script type="math/tex; mode=display">\varphi_2=2\arctan(\frac{B+\sqrt{A^2+B^2-C^2}}{A+C})\\\varphi_3=\pi-2\arctan(\frac{-B+\sqrt{A^2+B^2-D^2}}{A+D})</script><p>其中</p><script type="math/tex; mode=display">A=2L_2(x_D-x_B)\\B=2L_2(y_D-y_B)\\C=L_2^2+L_{BD}^2-L_3^2\\D=L_3^2+L_{BD}^2-L_2^2\\L_{BD}=\sqrt{(x_D-x_B)^2+(y_D-y_B)^2}</script><p>可以得到 C 点坐标</p><script type="math/tex; mode=display">x_C=-\frac{L_5}{2}+L_1\cos(\varphi_1)+L_2\cos(\varphi_2)\\y_C=L_1\sin(\varphi_1)+L_2\sin(\varphi_2)</script><p>则</p><script type="math/tex; mode=display">L_0=\sqrt{x_c^2+y_c^2}\\\varphi_0=\arctan{\frac{y_c}{x_c}}</script><h1 id="VMC"><a href="#VMC" class="headerlink" title="VMC"></a>VMC</h1><p>关键是在每个需要控制的自由度上构造合适的虚拟构件来产生合适的虚拟力。虚拟力不是实际执行机构的作用力或力矩，而是通过执行机构的作用经过机构转换而成。对于一些控制问题，我们可能需要将工作空间 (Task Space) 的力或力矩映射成关节空间 (Joint Space) 的关节力矩。</p><p>在五连杆中，需要获得机构末端沿腿的推力 $F$ 与沿中心轴的力矩 $T_b$，对应极坐标 $L_0,\varphi_0$ 与 $A,E$ 两个关节转动副力矩 $T_A,T_E$ 的关系。所以定义</p><script type="math/tex; mode=display">x=\begin{bmatrix}L_0\\\varphi_0\end{bmatrix}\\q=\begin{bmatrix}\varphi_1\\\varphi_4\end{bmatrix}</script><p>对正运动学模型 $x=f(q)$ 做微分得</p><script type="math/tex; mode=display">f'=\begin{bmatrix}\frac{\partial L_0}{\partial \varphi_1}&\frac{\partial L_0}{\partial \varphi_4}\\\frac{\partial \varphi_0}{\partial \varphi_1}&\frac{\partial \varphi_0}{\partial \varphi_4}\end{bmatrix}</script><p>这就是 x 对 q 的雅各比矩阵，记作 $J$。得到对应的全微分方程为</p><script type="math/tex; mode=display">\Delta x=J\Delta q</script><p>通过雅各比矩阵 $J$ 将关节速度 $\dot{q}$ 映射为五连杆姿态变化率 $\dot{x}$。根据虚功原理，可以得到</p><script type="math/tex; mode=display">T^T\Delta q+(-F)^T\Delta x=0\\T=\begin{bmatrix}T_A\\T_E\end{bmatrix}\\F_{pole}=\begin{bmatrix}F\\T_b\end{bmatrix}</script><p>将全微分方程带入之后可得</p><script type="math/tex; mode=display">T=J^TF_{pole}</script><p>但是上述推导中的正运动学模型直接求雅各比矩阵比较困难，因为模型中有大量的平方与三角函数的运算，结果比较复杂。所以进行下列改进</p><p>由于雅各比矩阵实际上描述的是两坐标微分的线性映射关系，所以可以计算速度映射来得到雅各比矩阵。由于 $L_0,\varphi_0$ 实际上就是 $C$ 点的极坐标，所以首先求出 $C$ 点直角坐标速度</p><script type="math/tex; mode=display">\dot{x}_C=-L_1\dot{\varphi}_1\sin\varphi_1-L_2\dot{\varphi}_2\sin\varphi_2\\\dot{y}_C=L_1\dot{\varphi}_1\cos\varphi_1+L_2\dot{\varphi}_2\cos\varphi_2</script><p>通过五连杆左右两部分列写 C 点坐标求导可以得到 $\dot\varphi_2$</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\dot x_B-L_2\dot\varphi_2\sin\varphi_2=\dot x_D-L_3\dot\varphi_3\sin\varphi_3\\&y_B+L_2\sin\varphi_2=y_D+L_3\sin\varphi_3\end{aligned}\right.</script><p>消去 $\dot\varphi_3$ 得到 $\dot\varphi_2$</p><script type="math/tex; mode=display">\dot\varphi_2=\frac{(\dot x_D-\dot x_B)\cos\varphi_3+(\dot y_D-\dot y_B)\sin\varphi_3}{L_2\sin(\varphi_3-\varphi_2)}</script><p>其中</p><script type="math/tex; mode=display">\dot x_B=-L_2\dot\varphi_1\sin\varphi_1\\\dot y_B=L_2\dot\varphi_1\cos\varphi_1\\\dot x_D=-L_4\dot\varphi_4\sin\varphi_4\\\dot y_D=L_4\dot\varphi_4\sin\varphi_4</script><p>并且其中的 $\dot\varphi_1,\dot\varphi_4$ 都是直接测出来的，带入之后得到</p><script type="math/tex; mode=display">\dot{x}_C=-L_1\dot{\varphi}_1\sin\varphi_1-L_2\frac{(\dot x_D-\dot x_B)\cos\varphi_3+(\dot y_D-\dot y_B)\sin\varphi_3}{L_2\sin(\varphi_3-\varphi_2)}\sin\varphi_2\\\dot{y}_C=L_1\dot{\varphi}_1\cos\varphi_1+L_2\frac{(\dot x_D-\dot x_B)\cos\varphi_3+(\dot y_D-\dot y_B)\sin\varphi_3}{L_2\sin(\varphi_3-\varphi_2)}\cos\varphi_2</script><p>化简之后得到</p><script type="math/tex; mode=display">\begin{bmatrix}\dot x_C\\\dot y_C\end{bmatrix}=\begin{bmatrix}\frac{L_1\sin(\varphi_1-\varphi_2)\sin\varphi_3}{\sin(\varphi_2-\varphi_3)}&\frac{L_4\sin(\varphi_3-\varphi_4)\sin\varphi_2}{\sin(\varphi_2-\varphi_3)}\\-\frac{L_1\sin(\varphi_1-\varphi_2)\cos\varphi_3}{\sin(\varphi_2-\varphi_3)}&-\frac{L_4\sin(\varphi_3-\varphi_4)\cos\varphi_2}{\sin(\varphi_2-\varphi_3)}\end{bmatrix}\begin{bmatrix}\dot \varphi_1\\\dot \varphi_4\end{bmatrix}</script><p>记作</p><script type="math/tex; mode=display">\begin{bmatrix}\dot x_C\\\dot y_C\end{bmatrix}=J\begin{bmatrix}\dot \varphi_1\\\dot \varphi_4\end{bmatrix}</script><p>根据上式可以得到关节力矩 $T$ 与虚拟力 $F_{rect}$ 的关系</p><script type="math/tex; mode=display">T=J^TF_{rect}\\F_{rect}=\begin{bmatrix}F_x\\F_y\end{bmatrix}</script><p>利用旋转矩阵将 $F_{rect}$ 旋转到杆的方向，旋转矩阵记作 $R$</p><script type="math/tex; mode=display">\begin{bmatrix}F_x\\F_y\end{bmatrix}=\begin{bmatrix}\cos\theta&\sin\theta\\-\sin\theta&\cos\theta\end{bmatrix}\begin{bmatrix}F_c\\F_t\end{bmatrix}</script><p>将杆的方向里转到极坐标方向的力 $F_{pole}$，旋转矩阵记作 $M$</p><script type="math/tex; mode=display">\begin{bmatrix}F_c\\F_t\end{bmatrix}=\begin{bmatrix}0&\frac{1}{L_0}\\1&0\end{bmatrix}\begin{bmatrix}F\\T_b\end{bmatrix}</script><p>依次带入得到最终的关节力矩与虚拟力之间的映射关系</p><script type="math/tex; mode=display">T=J^TRMF_{pole}</script><p>令</p><script type="math/tex; mode=display">A=\frac{L_1\sin(\varphi_1-\varphi_2)}{\sin(\varphi_2-\varphi_3)}\\B=\frac{L_4\sin(\varphi_3-\varphi_4)}{\sin(\varphi_2-\varphi_3)}</script><p>最终带入得到</p><script type="math/tex; mode=display">T=\begin{bmatrix}-A\cos(\theta+\varphi_3)&\frac{A\sin(\theta+\varphi_3)}{L_0}\\-B\cos(\theta+\varphi_2)&\frac{B\sin(\theta+\varphi_2)}{L_0}\end{bmatrix}F_{pole}</script><p>但是在这里解算中的 $\varphi_0,\varphi_1,\varphi_2,\varphi_3, \varphi_4$ 都是逆时针为正的，所以最终得到的 $T$ 也是逆时针的，要施加到电机上需要取负值，因此最终结果为</p><script type="math/tex; mode=display">T=\begin{bmatrix}A\cos(\theta+\varphi_3)&-\frac{A\sin(\theta+\varphi_3)}{L_0}\\B\cos(\theta+\varphi_2)&-\frac{B\sin(\theta+\varphi_2)}{L_0}\end{bmatrix}F_{pole}</script><p>注意，这里的·解算中，对于每个关节电机转矩的方向是顺时针为正，其他都是按照图上的方向的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">2</span>, <span class="number">2</span>&gt; trans;</span><br><span class="line"><span class="type">float</span>                      A = l1 * <span class="built_in">sin</span>(angle1 - angle2) / <span class="built_in">sin</span>(angle2 - angle3);</span><br><span class="line"><span class="type">float</span>                      B = l4 * <span class="built_in">sin</span>(angle3 - angle4) / <span class="built_in">sin</span>(angle2 - angle3);</span><br><span class="line">trans &lt;&lt; -A * <span class="title function_">cos</span><span class="params">(theta.now + angle3)</span>, </span><br><span class="line"> A * <span class="title function_">sin</span><span class="params">(theta.now + angle3)</span> / L0.now, </span><br><span class="line">         -B * <span class="title function_">cos</span><span class="params">(theta.now + angle2)</span>, </span><br><span class="line">         B * <span class="title function_">sin</span><span class="params">(theta.now + angle2)</span> / L0.now;</span><br><span class="line"></span><br><span class="line">this-&gt;jointF-&gt;setTorque(-trans(<span class="number">0</span>, <span class="number">0</span>) * this-&gt;Fset - trans(<span class="number">0</span>, <span class="number">1</span>) * this-&gt;Tbset);</span><br><span class="line">this-&gt;jointB-&gt;setTorque(-trans(<span class="number">1</span>, <span class="number">0</span>) * this-&gt;Fset - trans(<span class="number">1</span>, <span class="number">1</span>) * this-&gt;Tbset);</span><br><span class="line">this-&gt;wheel-&gt;setTorque(this-&gt;Twset);</span><br></pre></td></tr></table></figure><h3 id="虚功原理"><a href="#虚功原理" class="headerlink" title="虚功原理"></a>虚功原理</h3><p><a href="https://zhuanlan.zhihu.com/p/417114829">理论力学次叙——虚功原理</a></p><p>是分析静力学中关键且重要的原理</p><ol><li>一个原为静止的质点系，如果约束是理想双面定常约束，则系统继续保持静止的条件是所有作用于该系统的主动力对作用点的虚位移所作的功的和为零</li><li>在结构力学刚体体系中表述为：设满足理想约束的刚体体系上作用的任意平衡力系，又假设体系发生满足约束条件的无限小的刚体位移，则主动力在位移上所做的虚功总和恒为零</li><li>在结构力学变形体体系中表述为：体系在任意平衡力系作用下，给体系以几何可能的位移和变形，体系上所有外力所作的虚功总和恒等于体系各截面所有内力在微段变形上所作的虚功总和。</li></ol><p>总之就是</p><ol><li>当系统平衡且处于理想约束时，所有主动力的虚功之和为0</li><li>当系统平衡且处于理想约束时，外力的虚功等于内力的虚功</li></ol><p>虚功 $\delta W$ 就是力在虚位移上做的功</p><p>则虚功原理表达式为</p><p>$\delta W_{in}(内力做的虚功) = \delta W_{ex}(外力做的虚功)$  </p><p>或： $\sum_{i=1}^n F_i * \delta q_i=0\ (F 是主动力，矢量)$</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HighGain and HighFrequency</title>
      <link href="/Blog_ButterFly/2024/03/18/HighGain-and-HighFrequency/"/>
      <url>/Blog_ButterFly/2024/03/18/HighGain-and-HighFrequency/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><p>对于一个系统</p><script type="math/tex; mode=display">\dot{x}=f(x)+u\\\\x\rightarrow x_d</script><p>其中不清楚 $f(x)$ 的具体表达形式，但是 $f(x)$ 是有界的，并且 $|f(x)|&lt;\rho(x)$</p><p>引入误差 $e=x_d-x$ ⇒ $\dot{e}=\dot{x}_d-f(x)-u$，定义李雅普诺夫函数 $V(e)=\frac{1}{2}e^2$</p><p>不妨令</p><script type="math/tex; mode=display">u=ke+\dot{x}_d+u_{aux}</script><p>其中 $u_{aux}$ 是一个辅助的控制器</p><p><strong>滑膜控制器：</strong> $u_{aux}=\rho(x) \frac{|e|}{e}$，而这个会导致系统不断抖动</p><p><strong>High Gain：</strong> $u_{aux}=\frac{1}{\varepsilon}\rho^2e$ 用足够大的输入抵消不确定性</p><p>带入 $\dot{V}$，得</p><script type="math/tex; mode=display">\dot{V}=e\dot{e}=e(\dot{x}_d-f(x)-ke-\dot{x}_d-\frac{1}{\varepsilon}\rho^2e)=-ef(x)-ke^2-\frac{1}{\varepsilon}\rho^2e^2\\\\\Downarrow\\\\\dot{V}\leq -ke^2+\rho|e|(1-\frac{1}{\varepsilon}\rho |e|)</script><p>此时出现两种情况</p><p>case 1:</p><script type="math/tex; mode=display">\rho |e| > \varepsilon \\\\\Downarrow\\\\1-\frac{1}{\varepsilon}\rho |e|<0 \\\\\Downarrow \\\\\rho|e|(1-\frac{1}{\varepsilon}\rho |e|)<0 \\\\\Downarrow \\\\\dot{V} \leq -ke^2</script><p>case 2:</p><script type="math/tex; mode=display">\rho |e| \leq \varepsilon \\\\\Downarrow \\\\0\leq 1-\frac{1}{\varepsilon}\rho |e|\leq 1\\\\\Downarrow \\\\\rho|e|(1-\frac{1}{\varepsilon}\rho |e|)\leq \rho|e|\leq \varepsilon \\\\\Downarrow\\\\\dot{V}\leq -ke^2+\varepsilon=-2kV+\varepsilon \\\\Introduce ~~s(t)>0\\\\\Downarrow\\\\\dot{V}+2kV=\varepsilon -s(t)\\\\解微分方程\\\\\Downarrow\\\\V=\frac{1}{2}e^2=\frac{1}{2}e^2_{(0)}exp(-2kt)-exp(-2kt)\int_0^texp(2k\tau)s(\tau)d\tau + \frac{\varepsilon}{2k} (1-exp(-2kt))\\\\由于第二项总是大于0的\\\\\Downarrow\\\\\frac{1}{2}e^2\leq\frac{1}{2}e^2_{(0)}exp(-2kt)+ \frac{\varepsilon}{2k} (1-exp(-2kt))\\\\两边同时乘2开平方\\\\\Downarrow\\\\|e_{(t)}|\leq\sqrt{|e_0|exp(-2kt)+\frac{\varepsilon}{k}-\frac{\varepsilon}{k}exp(-2kt)}\\\\t\rightarrow \infty\\\\\Downarrow\\\\|e_{(t)}|\leq\sqrt{\frac{\varepsilon}{k}}</script><p>这就是系统最终会保持一个误差，但是当 $\varepsilon$ 足够小，误差就很小，但是这也导致输入 $u_{aux}=\frac{1}{\varepsilon}\rho^2e$ 会非常大，需要做一个权衡</p><p><strong>High Frequency：</strong> $u_{aux}=\frac{\rho^2e}{\rho |e|+\varepsilon}$ 相当于把滑模控制的抖动幅度减小了</p><p>带入 $\dot{V}$ 得</p><script type="math/tex; mode=display">\dot{V}=-ef(x)-ke^2-e\frac{\rho^2e}{\rho |e|+\varepsilon}\leq |e||f(x)|-ke^2-\frac{\rho^2e^2}{\rho |e|+\varepsilon}\\\\\Downarrow\\\\\dot{V}\leq-ke^2+|e|\rho(1-\frac{\rho |e|}{\rho |e|+\varepsilon})=-ke^2+\varepsilon\frac{\rho |e|}{\rho |e|+\varepsilon}\\0\leq\frac{\rho |e|}{\rho |e|+\varepsilon}\leq 1\\\\\Downarrow\\\\\dot{V}\leq -ke^2+\varepsilon=-2kV+\varepsilon \\\\Introduce ~~s(t)>0\\\\\Downarrow\\\\\dot{V}+2kV=\varepsilon -s(t)\\\\解微分方程\\\\\Downarrow\\\\V=\frac{1}{2}e^2=\frac{1}{2}e^2_{(0)}exp(-2kt)-exp(-2kt)\int_0^texp(2k\tau)s(\tau)d\tau + \frac{\varepsilon}{2k} (1-exp(-2kt))\\\\由于第二项总是大于0的\\\\\Downarrow\\\\\frac{1}{2}e^2\leq\frac{1}{2}e^2_{(0)}exp(-2kt)+ \frac{\varepsilon}{2k} (1-exp(-2kt))\\\\两边同时乘2开平方\\\\\Downarrow\\\\|e_{(t)}|\leq\sqrt{|e_0|exp(-2kt)+\frac{\varepsilon}{k}-\frac{\varepsilon}{k}exp(-2kt)}\\\\t\rightarrow \infty\\\\\Downarrow\\\\|e_{(t)}|\leq\sqrt{\frac{\varepsilon}{k}}</script><p>但是这个 $\varepsilon$ 过小时，并不会导致系统的输入过大</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>对于一个系统</p><script type="math/tex; mode=display">\dot{x}=ax^2+u=f(x)+u\\\\x\rightarrow x_d</script><p>在先前是设定 $a$ 是一个常数，但在此控制系统中，认为 $a$ 是一个有界（ $|a|\leq |\overline{a}|$，其中 $\overline{a}$ 已知 ）的数，并非是一个常数， $a$ 是一个 $[-1,1]$ 之间的一个随机数</p><p>系统的目标依旧是 $x→x_d$，设定 $e=x_d-x$，得到 $\dot{e}=\dot{x}_d-\dot{x}=\dot{x}_d-f(x)-u$</p><p>引入一个函数 $\rho(x)$（实际上可以是函数，也可以是一个固定的上界）使得 $|f(x)|\leq\rho (x)$，设定</p><ul><li><p>high gain</p><script type="math/tex; mode=display">  u=ke+\dot{x}_d+\frac{1}{\varepsilon}\rho^2e</script></li><li><p>high frequency</p><script type="math/tex; mode=display">  u=ke+\dot{x}_d+\frac{\rho^2e}{\rho |e|+\varepsilon}</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HighGain </tag>
            
            <tag> HighFrequency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMC滑膜控制理论</title>
      <link href="/Blog_ButterFly/2024/03/18/SMC%E6%BB%91%E8%86%9C%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"/>
      <url>/Blog_ButterFly/2024/03/18/SMC%E6%BB%91%E8%86%9C%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><h2 id="李雅普诺夫Lyapunov平衡理论"><a href="#李雅普诺夫Lyapunov平衡理论" class="headerlink" title="李雅普诺夫Lyapunov平衡理论"></a>李雅普诺夫<strong>Lyapunov</strong>平衡理论</h2><p><a href="https://blog.csdn.net/sheagu/article/details/108113576">李雅普诺夫（第二方法）稳定性</a></p><p><a href="https://zhuanlan.zhihu.com/p/58738073">如何理解李雅普诺夫稳定性分析</a></p><p>主要是用来判断一个系统是否能稳定</p><h3 id="平衡点"><a href="#平衡点" class="headerlink" title="平衡点"></a>平衡点</h3><p>一个控制系统最重要的问题就是稳定性的问题。稳定性就是一个系统在收到扰动之后能否有能力在平衡状态继续工作。平衡点就是系统状态不再发生状态的点，可能不止一个，也可能很脆弱稍微有点扰动就不再平衡了。实际上系统状态稳定的点应该是导数为0的点，也就是让系统状态方程的所有状态的导数为0，即变化率为0。</p><h3 id="李雅普诺夫稳定"><a href="#李雅普诺夫稳定" class="headerlink" title="李雅普诺夫稳定"></a>李雅普诺夫稳定</h3><ul><li>如果平衡状态受到扰动之后，仍然停留在平衡状态点附近，即该平衡点在李雅普诺夫意义下是稳定的</li><li>如果平衡状态受到扰动之后，最终都会收敛到该平衡点处，即该平衡点在李雅普诺夫意义下是渐进稳定的</li><li>如果平衡状态受到任何扰动之后最终都会收敛到该平衡点处时，即该平衡点咋子李雅普诺夫意义下是大范围渐进稳定的</li><li><p>如果平衡状态受到某种扰动之后状态开始偏离平衡点，就称该点在李雅普诺夫意义下是不稳定的</p><p>  <img src="/Blog_ButterFly/2024/03/18/SMC%E6%BB%91%E8%86%9C%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-4ac6a500e089aab5a4eb6965938a62cf_720w.webp" alt="v2-4ac6a500e089aab5a4eb6965938a62cf_720w.webp"></p></li></ul><h3 id="李雅普诺夫第一法"><a href="#李雅普诺夫第一法" class="headerlink" title="李雅普诺夫第一法"></a>李雅普诺夫第一法</h3><p>需要将非线性系统在平衡态附近线性化，然后讨论线性化系统的特征值分布来研究原非线性系统的稳定性问题。称之为间接法</p><h3 id="李雅普诺夫第二法"><a href="#李雅普诺夫第二法" class="headerlink" title="李雅普诺夫第二法"></a>李雅普诺夫第二法</h3><p>稳定的系统能量总是不断被耗散的，李雅普诺夫通过定义一个标量函数 $V(x)$（通常能代表广义能量）来分析稳定性。这种方法的避免了直接求解方程，也没有进行近似线性化，所以也一般称之为直接法。</p><p>如果该标量函数满足：</p><ul><li>$V(x)=0\ if\ and\ only\ if\ x=0$</li><li>$V(x)&gt;0\ if\ and\ only\ if\ x\neq 0$</li><li>$\dot{V(x)}=\frac{d}{dt}V(x)=\sum_{i=1}^{n}\frac{\partial V}{\partial x_i}f(x_i) \leq 0\ when\  x\neq 0$</li></ul><p>则该系统在李雅普诺夫意义下是稳定的，特别的，当 $\dot{V(x)}&lt;0$ 则该系统是渐进稳定的</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在判断一个系统稳定性方面很有用。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>很多时候李亚普诺夫函数是凭着经验的猜测。对于一个陌生的控制系统很难构建一个李亚普诺夫函数去证明这个系统的稳定性</p><h2 id="滑膜控制理论"><a href="#滑膜控制理论" class="headerlink" title="滑膜控制理论"></a>滑膜控制理论</h2><p>滑模控制理论（Sliding Mode Control, SMC）是一种建立在现代控制理论基础上的控制理论，主要数学核心为李雅普诺夫函数。滑模控制的核心思想是建立一个滑模面，将被控系统拉取到滑模面上来，使系统沿着滑模面运动。滑模控制的一个优势是无视外部扰动和不确定参数，采用一种比较“暴力”的方式达到控制的目的。</p><p>其思想和反步法有些类似，但数学实现起来更加方便而不抽象。相比反步法，滑模控制没有复杂的数学计算，也不会出现“微分爆炸”的问题。但另一方面，滑模控制所采用的控制信号大多是具有正负值反复交替的信号，对于硬件要求很高，一般硬件无法达到这种信号高频来回切换的要求，因此这是滑模控制的一个缺点。<br>除此之外，信号高频切换所导致的输出信号会出现振荡，系统状态在所选取的滑模面附近来回颤动，这种颤动是无法消除的。这也是滑模控制的一个痛点，目前主流的方法大多是采用滤波、模糊控制、神经网络等方法对震颤进行缓解。</p><p>优越性：</p><ul><li>滑动模态可以进行设计，调节的参数少，响应速度快</li><li>对扰动不灵敏</li></ul><p>滑模控制本质上是非线性控制的一种，简单的说，它的非线性表现为控制的不连续性，即系统的“结构”不固定，可以在动态过程中根据系统当前的状态有目的地不断变化，迫使系统按照预定“滑动模态”的状态轨迹运动。</p><h3 id="控制设计流程"><a href="#控制设计流程" class="headerlink" title="控制设计流程"></a>控制设计流程</h3><ol><li><p>首先列出系统状态方程</p><p> 对于一个一阶系统</p><p> $\left\{\begin{aligned}\dot{x_1}&amp;=x_2\\\dot{x_2}&amp;=u\end{aligned}\right.$</p></li><li><p>设计滑模面</p><p> $s=cx_1+x_2$</p><p> 设计控制器的目的是为了使 $x_1=0,x_2=0$。当 $s=0$ 时</p><p> $\left\{\begin{aligned}cx_1+x2&amp;=0\\\dot{x_1}&amp;=x_2\end{aligned}\right.\Rightarrow cx_1+\dot{x_1}=0\Rightarrow \left\{\begin{aligned}x_1&amp;=x_1(0)e^{-ct}\\x_2&amp;=-cx_1e(0)e^{-ct}\end{aligned}\right.$</p><p> 可以看出，当 $t→\infty$ 时，状态量都会趋近于0，而且都是以指数的形式趋近的，并且通过调节 c 的大小可以调节状态趋近于0的速度。所以如果满足 $s=cx_1+x_2$，那么系统的状态将沿着滑模面趋近于0。图中就是指状态量都要趋近于0。状态一旦达到滑模面，将以指数的形式趋于稳定</p><p> <img src="/Blog_ButterFly/2024/03/18/SMC%E6%BB%91%E8%86%9C%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-21933be4499504c5671e5435e3d09922_720w.png" alt="v2-21933be4499504c5671e5435e3d09922_720w.png"></p></li><li><p>设计趋近律，寻找 $s$ 与u之间的关系</p><p> 将状态方程带入</p><p> $s=cx_1+x_2 \Rightarrow \dot{s}=c\dot{x_1}+\dot{x_2} \Rightarrow \dot{s}=cx_2+u$</p><p> 这个趋近律就是指 $\dot{s}$，一般来说会有几种设计</p><script type="math/tex; mode=display"> \left\{\begin{aligned}等速趋近律:\dot{s}&=-\varepsilon*sign(s)&&\varepsilon>0\\\\ 指数趋近律:\dot{s}&=-\varepsilon*sign(s)-k*s&&\varepsilon>0:k>0\\\\ 幂次趋近律:\dot{s}&=-k|s|^{\alpha}sign(s)&&0<\alpha<1\\\\ 一般趋近律:\dot{s}&=-\varepsilon*sign(s)-f(s)\end{aligned}\right.</script><p> 其中 </p><script type="math/tex; mode=display"> sign(x)=\left\{\begin{aligned}1&&s>0\\\\ -1&&s<0\end{aligned}\right.</script><p> 就可以求出 $u$ 的值，进而对系统进行控制</p></li></ol><h3 id="趋近律设计的原因"><a href="#趋近律设计的原因" class="headerlink" title="趋近律设计的原因"></a>趋近律设计的原因</h3><p>控制系统中会使用<strong>Lyapunov</strong>函数来判断系统的稳定性，对于系统状态方程 $\dot{s}=cx_2+u$，平衡点为 $s=0$，对于平衡点 $s$，如果存在一个连续函数 $V$ 满足</p><ol><li>$\lim_{|s|-&gt;\infty}V=\infty$</li><li>$\dot{V}&lt;0\ for s \not= 0$</li></ol><p>可以选择 $V(s,t)=\frac{1}{2}s^2$，满足第一条件，对于第二个条件 $\dot{V}=s\dot{s}=-s \varepsilon sign(s)=-\varepsilon |s| &lt; 0$ 满足条件，所以 $s→0$</p><p>但是实际上 <strong>Lyapunov</strong> 函数并没有保证趋于平衡的时间，所以对 <strong>Lyapunov</strong> 函数的第二个条件做修改</p><p>$\dot{V}\leq -\alpha V^{0.5}$</p><p>对第二条件做积分变换 </p><script type="math/tex; mode=display">\int_0^t{\frac{\dot{V}}{V^{0.5}}}dt\leq-\alpha t$ ⇒ $V^{0.5}\leq -\frac{1}{2}\alpha t + V^{0.5}(0)$ ⇒  $t_r\leq\frac{2V^{0.5}(0)}{\alpha}</script><p>最终得到到达稳定状态的时间</p><p>同时因为 <strong>Lyapunov</strong> 函数条件发生了改变，控制器也要做出改变</p><script type="math/tex; mode=display">\left\{\begin{aligned} \dot{V}&=s\dot{s}=-s \varepsilon sign(s)\\V&=0.5s^2\\\dot{V}&\leq -\alpha V^0.5 \end{aligned}\right.$⇒ $\varepsilon \geq \frac{\alpha}{\sqrt{2}}</script><p>所以只有满足最后的条件，才能实现有限时间到达滑模面</p><h3 id="扰动分析"><a href="#扰动分析" class="headerlink" title="扰动分析"></a>扰动分析</h3><p>加入扰动，即 $s=cx_1+x_2 \Rightarrow \dot{s}=c\dot{x_1}+\dot{x_2} \Rightarrow \dot{s}=cx_2+u +d$</p><p>控制率依旧保持以上的形式 $u=-cx_2-\varepsilon sign(s)$</p><p>带入之后得</p><p>$\left\{\begin{aligned} \dot{V}&amp;=s\dot{s}=s(- \varepsilon sign(s)+d)\leq-|s|(\varepsilon -L)\\\dot{V}&amp;\leq -\alpha V^0.5 \end{aligned}\right.$</p><p>其中 L 表示干扰的上界，对比的条件，只有满足 $\varepsilon \geq \frac{\alpha}{\sqrt{2}}+L$ 时，<strong>Lyapunov</strong> 函数既满足有限时间收敛又负定。所以系统依旧会先滑动到滑模面，再沿着滑模面做指数级趋近运动，干扰没有影响。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>滑膜控制策略与常规控制不同之处在于不连续性，使系统结构随时间变化的开关特性。可以使系统在一定条件下沿着规定的状态轨迹做小幅度高频率的上下运动，这就是滑动模态</p><p>仿真实现之后，发现对于一阶和二阶系统来说仿真效果还是很好的，选用指数趋近律会很快接近平衡状态，并且跟踪性很好，但是把曲线放大多倍就会看到系统会有高频震荡，这个对硬件要求很高，所以这个还是不被大量使用的一大缺点，但是可以使用一般趋近律，通过设定一个比较好的 $f(s)$ 来减小这种影响</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>对于一个系统</p><script type="math/tex; mode=display">\dot{x}=ax^2+u=f(x)+u\\x\rightarrow x_d</script><p>在先前是设定 $a$ 是一个常数，但在此控制系统中，认为 $a$ 是一个有界（ $|a|\leq |\overline{a}|$，其中 $\overline{a}$ 已知 ）的数，并非是一个常数</p><p>系统的目标依旧是 $x→x_d$，设定 $e=x_d-x$，得到 $\dot{e}=\dot{x}_d-\dot{x}=\dot{x}_d-f(x)-u$</p><p>引入一个函数 $\rho(x)$（实际上可以是函数，也可以是一个固定的上界）使得 $|f(x)|\leq\rho (x)$，设定</p><script type="math/tex; mode=display">u=\dot{x}_d+ke+\rho(x)\frac{|e|}{e}</script><p><strong>验证</strong></p><p>设置李雅普诺夫函数</p><script type="math/tex; mode=display">V(e)=\frac{1}{2}e^2:PD</script><p>则</p><script type="math/tex; mode=display">\dot{V}(e)=e\dot{e}=e(\dot{x}_d-f(x)-u)=e(\dot{x}_d-f(x)-\dot{x}_d-ke-\rho(x)\frac{|e|}{e})\\\Downarrow\\\dot{V}(e)=-ke^2-ef(x)-\rho(x)|e|\leq -ke^2+|e||f(x)|-\rho(x)|e|\leq-ke^2\\\Downarrow\\ \dot{V}(e):ND</script><p>所以系统是渐进稳定的</p><p>将 $u$ 带入到 $\dot{e}$ 的表达式中，可以看到</p><script type="math/tex; mode=display">\dot{e}=-ke-f(x)-\rho(x)\frac{|e|}{e}</script><p>先画出 $\dot{e}=-ke$ 的相平面</p><p><img src="/Blog_ButterFly/2024/03/18/SMC%E6%BB%91%E8%86%9C%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/1708515640623.png" alt="1708515640623.png"></p><p>可以看到在这个平面山都是向中间原点趋近的，也就是渐进稳定的，所以 $-f(x)-\rho(x)\frac{|e|}{e}$ 就是为了使不在这个平面上的状态进入到这个平面上，这就是<strong>滑膜控制理论</strong></p><p>可以取</p><script type="math/tex; mode=display">u=\dot{x}_d+ke+\frac{|e|}{e}(f(x)+0.1)</script><p>最终会导致</p><script type="math/tex; mode=display">t\rightarrow \infty,e\rightarrow 0</script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SMC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非线性自适应控制器</title>
      <link href="/Blog_ButterFly/2024/03/18/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/18/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>对于一个系统</p><script type="math/tex; mode=display">\dot{x}=ax^2+u\\x\rightarrow x_d</script><p>可以设定 $e=x_d-x$，并且使 $e→0$，定义李雅普诺夫函数</p><script type="math/tex; mode=display">V(e)=\frac{1}{2}e^2:PD</script><p>得到</p><script type="math/tex; mode=display">\dot{V}(e)=e\dot{e}=e(\dot{x}_d-ax^2-u)</script><p>要使得上式负定，可以令 $\dot{e}=-ke$ ，就可以设置 $u=\dot{x}_d-ax^2+ke$，化简上式为</p><script type="math/tex; mode=display">\dot{V}(e)=-ke^2:ND</script><p>但是对于上述例子，如果 $a$ 是未知的，或者是缓慢变化的数字（$\dot{a}=0$）就难以控制，所以需要自适应控制器</p><p>可以引入估计值 $\hat{a}$ 和估计误差 $\widetilde a=a-\hat{a}$，所以 $\dot{\widetilde a}=\dot{a}-\dot{\hat{a}}=-\dot{\hat{a}}$</p><p>所以设置李雅普诺夫函数</p><script type="math/tex; mode=display">V(e,\widetilde a)=\frac{1}{2}e^2+\frac{1}{2}\widetilde a^2</script><p>求导得</p><script type="math/tex; mode=display">\dot{V}(e,\widetilde a)=e\dot{e}+\widetilde a\dot{\widetilde a}=e(\dot{x}_d-{a}x^2-u)-\widetilde a\dot{\hat{a}}</script><p>所以可以令 $u=\dot{x}_d-\hat{a}x^2+ke$，带入之后得</p><script type="math/tex; mode=display">\dot{V}(e,\widetilde a)=-ke^2-\widetilde a(ex^2+\dot{\hat{a}})\\-ke^2:ND\\-\widetilde a(ex^2+\dot{\hat{a}}):未知</script><p>要保证其负定，但是不能保证第二项负定，但是可以令第二项为 0</p><script type="math/tex; mode=display">-\widetilde a(ex^2+\dot{\hat{a}})=0\\\Downarrow\\\dot{\hat{a}}=-ex^2\\\dot{V}(e,\widetilde a)=-ke^2:NSD</script><p>引入一个<strong>引理</strong></p><script type="math/tex; mode=display">①~V\geq 0\\\\②~g(t)\geq 0~~~~\dot{V}\leq -g(t)\\\\③~\dot{g}(t)\in L_{\infty}有界\rightarrow g(t)连续\\\\\Downarrow\\\\\underset{t\rightarrow \infty}{lim}  ~g(t)=0</script><p>可以用于验证上式</p><script type="math/tex; mode=display">①~V\geq 0\\\\②~V=-ke^2\leq -(ke^2)=-g(t),g(t)=ke^2\geq 0\\\\③~\dot{g}(t)=2ke\dot{e}有界\\\\\Downarrow\\\\\underset{t\rightarrow \infty}{lim}~g(t)=0\\\\\Downarrow\\\\e\rightarrow 0</script><p>由于 $\dot{\hat{a}}=-ex^2 \Rightarrow \hat{a}=-\int_0^{t}ex^2d\tau$ ，可得</p><script type="math/tex; mode=display">u=\dot{x}_d+x^2\int_0^{t}ex^2d\tau +ke</script><h3 id="一个先前的例子"><a href="#一个先前的例子" class="headerlink" title="一个先前的例子"></a>一个先前的例子</h3><p><img src="/Blog_ButterFly/2024/03/18/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6%E5%99%A8/1708437413726.png" alt="1708437413726.png"></p><p>对于一个非线性弹簧滑块的系统，假设弹簧的力的与拉伸长度的关系为 $F=\alpha x^3$，其中 $\alpha$ 是一个未知数</p><p>所以该系统的状态方程为</p><script type="math/tex; mode=display">m\ddot{x}+\alpha x^3=F</script><p>系统的输入为 $F$，滑块位移为 $x$，质量为 $m$</p><p>规定滑块的目标轨迹为 $x_{1d}$</p><p>令</p><script type="math/tex; mode=display">x_1=x\\x_2=\dot{x}</script><p>所以得到</p><script type="math/tex; mode=display">\dot{x}_1=x_2~~①\\\dot{x}_2=-\frac{\alpha}{m}x_1^3+\frac{u}{m}~~②</script><p>所以可以通过控制输入来控制 $\dot{x}_2$ 进而控制 $x_2$，从而控制 $x_1$</p><p>引入误差 $e$</p><script type="math/tex; mode=display">e=x_{1d}-x_1~~③</script><p>从而目标变为 $e→0$</p><p>求导得到</p><script type="math/tex; mode=display">\dot{e}=\dot{x}_{1d}-\dot{x}_1=\dot{x}_{1d}-x_2~~④</script><p>可以找到一个李雅普诺夫函数 $V(e)$ 使之渐进稳定，从而实现目标，设</p><script type="math/tex; mode=display">V_1(e)=\frac{1}{2}e^2~~⑤</script><p>$V_1$ 是一个正定的函数，求导得到</p><script type="math/tex; mode=display">\dot{V}_1=e(\dot{x}_{1d}-x_2)~~⑥\\\\\Downarrow\\\\\dot{x}_{1d}-x_2=-k_1e\\\\\dot{V}_1=-k_1e^2:ND</script><p>根据上述期望，可以设置$x_2$ 的期望值</p><script type="math/tex; mode=display">x_{2d}=\dot{x}_{1d}+k_1e~~⑦</script><p>所以目标变为 $x_2→x_{2d}$，令</p><script type="math/tex; mode=display">\delta=x_{2d}-x_2~~⑧</script><p>将 8 带入到 6 中，得到</p><script type="math/tex; mode=display">\dot{V}_1=e(\dot{x}_{1d}-(x_{2d}-\delta))</script><p>带入 7 式</p><script type="math/tex; mode=display">\dot{V}_1=-k_1e^2+e\delta~~⑨</script><p>由于 $\dot{\delta}=\dot{x}_{2d}-\dot{x}_2$，带入 2 式和 7 式，得</p><script type="math/tex; mode=display">\dot{\delta}=\ddot{x}_{1d}+k_1\dot{e}-(-\frac{\alpha}{m}x_1^3+\frac{u}{m})</script><p>带入 4 式</p><script type="math/tex; mode=display">\dot{\delta}=\ddot{x}_{1d}+k_1(x_{1d}-x_2)+\frac{\alpha}{m}x_1^3-\frac{u}{m}~~⑩</script><p>此时就需要 $\delta→0,e→0$，需要找到新的李雅普诺夫函数 $V(e,\delta)$ 使之满足渐进稳定的条件了</p><script type="math/tex; mode=display">V_2=V_1+\frac{1}{2}\delta^2:PD</script><p>对上式求导得到</p><script type="math/tex; mode=display">\dot{V}_2=\dot{V}_1+\delta\dot\delta=-k_1e^2+e\delta+\delta\dot\delta=-k_1e^2+\delta(e+\dot\delta)</script><p>为使之负定，可以设计使 $e+\dot\delta=-k_2\delta$，带入 10 式得</p><script type="math/tex; mode=display">e+\ddot{x}_{1d}+k_1(x_{1d}-x_2)+\frac{\alpha}{m}x_1^3-\frac{u}{m}=-k_2\delta</script><p>最终得到</p><script type="math/tex; mode=display">u=me+m\ddot{x}_{1d}+mk_1(\dot{x}_{1d}-x_2)+\alpha x_1^3+mk_2\delta~~⑪</script><p>由于上述中 $\alpha$ 未知，所以引入一个预测值 $\hat{\alpha}$ 和预测差值 $\widetilde \alpha=\alpha-\hat{\alpha}\rightarrow0$</p><p>设定一个新的李雅普诺夫方程</p><script type="math/tex; mode=display">V_3=\frac{1}{2}e^2+\frac{1}{2}\delta^2+\frac{1}{2}\widetilde \alpha^2:PD</script><p>求导得到</p><script type="math/tex; mode=display">\dot{V}_3=e\dot{e}+\delta\dot\delta+\widetilde \alpha\dot{\widetilde \alpha}</script><p>并且有</p><script type="math/tex; mode=display">u=me+m\ddot{x}_{1d}+mk_1(\dot{x}_{1d}-x_2)+\hat\alpha x_1^3+mk_2\delta~~⑪</script><p>带入其中得到</p><script type="math/tex; mode=display">\dot{V}_3=-k_1e^2-k_2\delta^2+\widetilde \alpha(\dot{\hat{\alpha}}+\frac{\delta x_1^3}{m})</script><p>已知前两项为负定，不能保证第三项为负定，所以可以使第三项为 0</p><script type="math/tex; mode=display">\dot{\hat\alpha}=-\frac{\delta x_1^3}{m}\\\\\Downarrow\\\\\hat{\alpha}=-\int_0^t\frac{\delta x_1^3}{m}dt</script><p>则求出 </p><script type="math/tex; mode=display">u=me+m\ddot{x}_{1d}+mk_1(\dot{x}_{1d}-x_2)-x_1^3\int_0^t\frac{\delta x_1^3}{m}dt+mk_2\delta~~⑪</script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非线性控制 </tag>
            
            <tag> 自适应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非线性系统控制器设计</title>
      <link href="/Blog_ButterFly/2024/03/18/%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/Blog_ButterFly/2024/03/18/%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>对于一个非线性系统</p><script type="math/tex; mode=display">\dot{x}=f(x,u)</script><p>假设 u 是 x 的函数</p><script type="math/tex; mode=display">u=\phi (x)</script><p>所以得到系统状态图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((u))--&gt;B[f]--&gt;C((x))</span><br><span class="line">C--&gt;D[Φ]--&gt;A</span><br></pre></td></tr></table></figure><h3 id="反馈线性化"><a href="#反馈线性化" class="headerlink" title="反馈线性化"></a>反馈线性化</h3><p>就是将传递函数 $f(x,u)$ 中的非线性部分通过调整 $\phi (x)$ 来抵消，最终得到的是一个线性的关系</p><p><strong>例子</strong></p><script type="math/tex; mode=display">\dot{x}=f(x,u)=ax^2+u</script><p>可以使得 $u=\phi(x)=-ax^2-x$，其中 $-ax^2$ 用于抵消系统的非线性量，而 $-x$ 用于将系统保持平稳，得到</p><script type="math/tex; mode=display">\dot{x}=-x\\\\\downarrow\\\\x=e^{-t}</script><p>当 $t→\infty$ 时， $x→0$</p><h3 id="李雅普诺夫直接办法"><a href="#李雅普诺夫直接办法" class="headerlink" title="李雅普诺夫直接办法"></a>李雅普诺夫直接办法</h3><p>需要选取李雅普诺夫函数来判断</p><p>例子</p><script type="math/tex; mode=display">\dot{x}=f(x,u)=x^2-x^3+u</script><p>选定</p><script type="math/tex; mode=display">V=\frac{1}{2}x^2</script><p>由于</p><script type="math/tex; mode=display">V(0)=0\\\\V(x)>0~~x\not=0\\\\\dot{V}=x^3-x^4+xu</script><p>所以就需要设计 u 使 $\dot{V}$ 负定</p><p>已知</p><script type="math/tex; mode=display">x^3:非负定\\\\-x^4:负定</script><p>所以就需要选定 u 来消除 $x^3$</p><p>可以选择 $u=-x^2-x$，消除非负定项</p><p>最终得到</p><script type="math/tex; mode=display">\dot{x}=-x^3-x</script><p>根据仿真的结果，可以看出，设计 $u$ 时一定要慎重考虑能耗和收敛速度的平衡关系</p><h3 id="反步法"><a href="#反步法" class="headerlink" title="反步法"></a>反步法</h3><p>对于一个假定的系统</p><script type="math/tex; mode=display">\dot{x}_1=f_1=x_1^2+x_2\\\\\dot{x_2}=f_2=x_1+u</script><p>由于控制输入并不能直接作用到目标 $x_1$ 上，所以控制时就需要控制 $u\rightarrow\dot{x}_2→x_2→\dot{x}_1→x_1$，但是在设计时需要反过来设计，使之不断地满足李雅普诺夫的渐近稳定条件</p><p><strong>步骤</strong></p><ol><li><p>设计一个 $x_2\rightarrow x_{2d}$ 使得 $x_1→x_{1d}$</p><p> 引入一个误差 $e=x_{1d}-x_1$，并且使 $e→0$</p><p> 需要设计一个李雅普诺夫函数 $V_1(e)=\frac{1}{2}e^2$，是个正定的函数，要想满足<strong>李雅普诺夫渐进稳定的条件</strong>，就保证导数负定就可以了</p><p> 要使 $\dot{V}_1(e)=e\dot e$ 负定，可以使 $\dot{V}_1(e)=-k_1e^2$，也就是</p><script type="math/tex; mode=display"> \dot{e}=\dot{x}_{1d}-\dot{x}_1=\dot{x}_{1d}-(x_1^2+x_2)=-k_1e</script><p> 根据上述假定的系统，要使上一步实现，就需要设定 $x_{2d}$，使该系统有一个这样的表现</p><script type="math/tex; mode=display"> x_{2d}=k_1e+\dot{x}_{1d}-x_1^2</script></li><li><p>设计 u 使得 $x_2→x_{2d}$</p><p> 引入一个误差 $\delta=x_{2d}-x_2$，并且使 $\delta→0$，带入到 $\dot{V}_1$ 中得到</p><script type="math/tex; mode=display"> \dot{V}_1=-k_1e^2</script><p> 此时设计一个李雅普诺夫函数 $V_2(e,\delta)=V_1(e)+\frac{1}{2}\delta^2$，可知它是一个正定的函数，要想满足<strong>李雅普诺夫渐进稳定的条件</strong>，就保证导数负定就可以了，其中 $x_2=x_{2d}-\delta$</p><script type="math/tex; mode=display"> \dot{V}_2=e\dot{e}+\delta\dot{\delta}=e(\dot{x}_{1d}-x_1^2-(k_1e+\dot{x}_{1d}-x_1^2-\delta))+\delta\dot\delta=-k_1e^2+e\delta+\delta\dot\delta\\\\ \downarrow\\\\ \dot{V}_2=-k_1e^2+\delta(e+\dot\delta)</script><p> 所以要使之负定，就需要保证 $e+\dot\delta=-k_2\delta$，带入之后得到</p><script type="math/tex; mode=display"> e+(k_1\dot{e}+\ddot{x}_{1d}-2x_1(x_1^2+x_2)-x_1-u)=-k_2(k_1e+\dot{x}_{1d}-x_1^2-x_2)</script><p> 最终得到</p><script type="math/tex; mode=display"> u=e+k_1\dot{e}+\ddot{x}_{1d}-2x_1(x_1^2+x_2)-x_1+k_2(k_1e+\dot{x}_{1d}-x_1^2-x_2)</script></li></ol><h3 id="一个反步法控制非线性系统的例子"><a href="#一个反步法控制非线性系统的例子" class="headerlink" title="一个反步法控制非线性系统的例子"></a>一个反步法控制非线性系统的例子</h3><p><img src="/Blog_ButterFly/2024/03/18/%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1708437413726.png" alt="1708437413726.png"></p><p>对于一个非线性弹簧滑块的系统，假设弹簧的力的与拉伸长度的关系为 $F=\alpha x^3$</p><p>所以该系统的状态方程为</p><script type="math/tex; mode=display">m\ddot{x}+\alpha x^3=F</script><p>系统的输入为 $F$，滑块位移为 $x$，质量为 $m$</p><p>规定滑块的目标轨迹为 $x_{1d}$</p><p>令</p><script type="math/tex; mode=display">x_1=x\\x_2=\dot{x}</script><p>所以得到</p><script type="math/tex; mode=display">\dot{x}_1=x_2~~①\\\\\dot{x}_2=-\frac{\alpha}{m}x_1^3+\frac{u}{m}~~②</script><p>所以可以通过控制输入来控制 $\dot{x}_2$ 进而控制 $x_2$，从而控制 $x_1$</p><p>引入误差 $e$</p><script type="math/tex; mode=display">e=x_{1d}-x_1~~③</script><p>从而目标变为 $e→0$</p><p>求导得到</p><script type="math/tex; mode=display">\dot{e}=\dot{x}_{1d}-\dot{x}_1=\dot{x}_{1d}-x_2~~④</script><p>可以找到一个李雅普诺夫函数 $V(e)$ 使之渐进稳定，从而实现目标，设</p><script type="math/tex; mode=display">V_1(e)=\frac{1}{2}e^2~~⑤</script><p>$V_1$ 是一个正定的函数，求导得到</p><script type="math/tex; mode=display">\dot{V}_1=e(\dot{x}_{1d}-x_2)~~⑥\\\\\Downarrow\\\\\dot{x}_{1d}-x_2=-k_1e\\\\\dot{V}_1=-k_1e^2:ND</script><p>根据上述期望，可以设置$x_2$ 的期望值</p><script type="math/tex; mode=display">x_{2d}=\dot{x}_{1d}+k_1e~~⑦</script><p>所以目标变为 $x_2→x_{2d}$，令</p><script type="math/tex; mode=display">\delta=x_{2d}-x_2~~⑧</script><p>将 8 带入到 6 中，得到</p><script type="math/tex; mode=display">\dot{V}_1=e(\dot{x}_{1d}-(x_{2d}-\delta))</script><p>带入 7 式</p><script type="math/tex; mode=display">\dot{V}_1=-k_1e^2+e\delta~~⑨</script><p>由于 $\dot{\delta}=\dot{x}_{2d}-\dot{x}_2$，带入 2 式和 7 式，得</p><script type="math/tex; mode=display">\dot{\delta}=\ddot{x}_{1d}+k_1\dot{e}-(-\frac{\alpha}{m}x_1^3+\frac{u}{m})</script><p>带入 4 式</p><script type="math/tex; mode=display">\dot{\delta}=\ddot{x}_{1d}+k_1(x_{1d}-x_2)+\frac{\alpha}{m}x_1^3-\frac{u}{m}~~⑩</script><p>此时就需要 $\delta→0,e→0$，需要找到新的李雅普诺夫函数 $V(e,\delta)$ 使之满足渐进稳定的条件了</p><script type="math/tex; mode=display">V_2=V_1+\frac{1}{2}\delta^2:PD</script><p>对上式求导得到</p><script type="math/tex; mode=display">\dot{V}_2=\dot{V}_1+\delta\dot\delta=-k_1e^2+e\delta+\delta\dot\delta=-k_1e^2+\delta(e+\dot\delta)</script><p>为使之负定，可以设计使 $e+\dot\delta=-k_2\delta$，带入 10 式得</p><script type="math/tex; mode=display">e+\ddot{x}_{1d}+k_1(x_{1d}-x_2)+\frac{\alpha}{m}x_1^3-\frac{u}{m}=-k_2\delta</script><p>最终得到</p><script type="math/tex; mode=display">u=me+m\ddot{x}_{1d}+mk_1(\dot{x}_{1d}-x_2)+\alpha x_1^3+mk_2\delta~~⑪</script><p><strong>检验</strong></p><p>将 8 式带入 4 式</p><script type="math/tex; mode=display">\dot{e}=\dot{x}_{1d}-(x_{2d}-\delta)=-k_1e+\delta</script><p>将 11 式带入 10 式</p><script type="math/tex; mode=display">\dot{\delta}=-e-k_2\delta</script><p>所以得到一个线性关系的系统</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{e}\\\dot{\delta}\end{bmatrix}=\begin{bmatrix}-k_1&1\\-1&-k_2\end{bmatrix}\begin{bmatrix}e\\\delta\end{bmatrix}</script><p>可以分析一下系数矩阵的特征值</p><script type="math/tex; mode=display">\lambda_1+\lambda_2=-k_1-k_2 < 0\\\\\lambda_1\lambda_2=k_1k_2+1 > 0\\\\\downarrow\\\\k_1,k_2<0</script><p>由于平衡点在零点，而且特征值均小于 0 ，是一个渐近稳定的系统</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非线性控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性状态观测器和线性控制器综合</title>
      <link href="/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B%E5%99%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%BC%E5%90%88/"/>
      <url>/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B%E5%99%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>对于一个不可观测的系统的控制，就需要用到设计观测器和控制器结合</p><p>对于一个系统</p><script type="math/tex; mode=display">\dot{X}=AX+Bu\\y=CX+Du</script><h3 id="观测器"><a href="#观测器" class="headerlink" title="观测器"></a>观测器</h3><p>根据之前的观测器设计，可以得到</p><script type="math/tex; mode=display">\dot{e_x}=(A-LC)e_x\\e_x={X}-{\hat{X}}\\L=\begin{bmatrix}l_1\\l_2\end{bmatrix}</script><p>需要 $A-LC$ 的特征值小于 0 ，才能使得该误差值逐渐趋近于 0</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>其中需要设计控制器为</p><script type="math/tex; mode=display">u=-K\hat{X}</script><p>带入到系统状态方程中可以得到</p><script type="math/tex; mode=display">\dot{X}=AX-BK(X-e_x)=(A-BK)X+BKe_x</script><p>与观测器中的式子合并可以得到</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{e_x}\\\dot{x}\end{bmatrix}=\begin{bmatrix}A-LC&0\\BK&A-BK\end{bmatrix}\begin{bmatrix}{e_x}\\{x}\end{bmatrix}=M\begin{bmatrix}{e_x}\\{x}\end{bmatrix}</script><p>这里就看出来了，M 矩阵的特征值得实部必须小于 0 ，实际上该矩阵的特征值就是 $A-LC$ 和 $A-BK$ 的特征值</p><p>最后就是要求观测器的 $A-LC$ 特征值与控制器的 $A-BK$ 的特征值小于 0，它们两个就分离开了</p><p>有一个要求就是观测器的收敛速度一定要大于控制器的收敛速度，以此来保证观测到的数据都是较为准确的</p><p><strong>一般来说极点位置 $s=-a$ 越小系统收敛越快</strong></p><h2 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h2><p><img src="/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B%E5%99%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%BC%E5%90%88/Untitled.png" alt="Untitled"></p><p>建立系统状态空间方程，令</p><script type="math/tex; mode=display">X=\begin{bmatrix}x_1\\x_2\end{bmatrix}\\\\x_1=\phi\\\\x_2=\dot{\phi}（不可测）\\\\u=\frac{1}{L}\ddot{x}_{block}</script><p>则从上式可以得到状态空间方程</p><script type="math/tex; mode=display">\dot{X}=\begin{bmatrix}0&1\\\frac{g}{L}&0\end{bmatrix}X+\begin{bmatrix}0\\-1\end{bmatrix}u\\\\y=\begin{bmatrix}1&0\end{bmatrix}X+[0]u</script><p>可以得到</p><script type="math/tex; mode=display">A-LC=\begin{bmatrix}0&1\\\frac{g}{L}&0\end{bmatrix}-\begin{bmatrix}l_1\\l_2\end{bmatrix}\begin{bmatrix}1&0\end{bmatrix}=\begin{bmatrix}-l_1&1\\\frac{g}{L}-l_2&0\end{bmatrix}</script><p>可以假设</p><script type="math/tex; mode=display">g=10~N/m^2\\\\L=1~m</script><p>带入后得到</p><script type="math/tex; mode=display">A-LC=\begin{bmatrix}-l_1&1\\10-l_2&0\end{bmatrix}</script><p>求其特征方程为</p><script type="math/tex; mode=display">|\lambda I-(A-LC)|=0\\\\\Downarrow\\\\\lambda^2+l_1\lambda+l_2-10=0</script><p>所以，令该特征方程的两个根都为 -1 ，可以得到</p><script type="math/tex; mode=display">l_1=2\\\\l_2=11</script><p>所以带入到估计值的方程中可以得到</p><script type="math/tex; mode=display">\dot{\hat{X}}=(A-LC)\hat{X}+(B-LD)u+Ly\\\\\Downarrow\\\\\dot{\hat{X}}=\begin{bmatrix}-2&1\\-1&0\end{bmatrix}\hat{X}+\begin{bmatrix}0\\-1\end{bmatrix}u+\begin{bmatrix}2\\11\end{bmatrix}y</script><p>对于线性控制器来说，输入 $u$ 满足</p><script type="math/tex; mode=display">u=-K\hat{X}</script><script type="math/tex; mode=display">\begin{bmatrix}\dot{e_x}\\\dot{x}\end{bmatrix}=\begin{bmatrix}A-LC&0\\BK&A-BK\end{bmatrix}\begin{bmatrix}{e_x}\\{x}\end{bmatrix}=M\begin{bmatrix}{e_x}\\{x}\end{bmatrix}</script><p>特征方程为</p><script type="math/tex; mode=display">\lambda^2-k_2\lambda-10-k_1=0</script><p>令 $A-BK$ 的特征方程的两个根都为 -1，可以得到</p><script type="math/tex; mode=display">k_1=-11\\\\k_2=-2</script><p>所以得到</p><script type="math/tex; mode=display">u=\begin{bmatrix}11&2\end{bmatrix}\hat{X}</script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性控制器设计</title>
      <link href="/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="系统控制"><a href="#系统控制" class="headerlink" title="系统控制"></a>系统控制</h2><p>对于一个开环控制器来说</p><script type="math/tex; mode=display">\dot{X}=AX</script><p>这里的 $A$ 的特征值 $\lambda$ 决定系统的表现，稳定性</p><p>当引入一个输入量时，控制器变为</p><script type="math/tex; mode=display">\dot{X}=AX+Bu</script><p>其中由于 $u$ 是 $X$ 的函数，所以系统形成了一个闭环控制</p><p>对于线性控制器来说，输入 $u$ 满足</p><script type="math/tex; mode=display">u=-KX</script><p>代入到控制器中可以得到</p><script type="math/tex; mode=display">\dot{X}=AX-BKX=(A-BK)X</script><p>可以选择 $K$ 的数值来使得 $X$ 前的系数的特征值 $\lambda_i$ 处于一个期望的位置上，一般来说，需要保证其特征值均 $≤0$ 才能使得系统稳定</p><p>选取 $\lambda_i$ 的原则</p><ul><li>如果选取 $\lambda$ 为虚数，那么一定会有共轭解存在，将一定会引入一个反复的振动</li><li>$\lambda$ 决定收敛的速度，最后的解的形式会变为 $c_1e^{\lambda_1}+c_2e^{\lambda_2}+…$</li><li>考虑输入 $u$，有些控制理论中会引入代价函数 $J=\int_0^{\infty}(X^TQX+U^TRU)dt$ ，用于调节参数平衡 u 与系统稳定的关系</li></ul><p>控制器设计之前一定要判断一下系统的可控性，一般来说 <strong>先可控，再稳定</strong></p><h3 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h3><p>对于一阶倒立摆模型，下面的小块也能移动</p><p><img src="/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1708349286931.png" alt="1708349286931.png"></p><p>当小球在运动中的运动学方程（初始位置为竖直点）</p><script type="math/tex; mode=display">x_{ball}=Lsin(\phi)+x_{block}\rightarrow x_{ball}=L\phi+x_{block}\\y_{ball}=L(1-cos(\phi))=0</script><p>小球的动力学方程</p><script type="math/tex; mode=display">F_x=m\ddot{x}_{ball}=Fsin(\phi)=F\phi=ML\ddot{\phi}+m\ddot{x}_{block}\\F_y=Fcos(\phi)=F=Mg</script><p>动力学方程化简得到</p><script type="math/tex; mode=display">Mg\phi=ML\ddot{\phi}+M\ddot{x}_{block}\\\Downarrow\\\ddot{\phi}-\frac{g}{L}\phi+\frac{1}{L}\ddot{x}_{block}=0</script><p>建立系统状态空间方程，令</p><script type="math/tex; mode=display">X=\begin{bmatrix}x_1\\x_2\end{bmatrix}\\x_1=\phi\\x_2=\dot{\phi}\\u=\frac{1}{L}\ddot{x}_{block}</script><p>则从上式可以得到状态空间方程</p><script type="math/tex; mode=display">\dot{X}=\begin{bmatrix}0&1\\\frac{g}{L}&0\end{bmatrix}X+\begin{bmatrix}0\\-1\end{bmatrix}u\\y=\begin{bmatrix}1&0\end{bmatrix}X+[0]u</script><ul><li><p>对于开环系统，也就是没有输入 u</p><script type="math/tex; mode=display">  A=\begin{bmatrix}0&1\\\frac{g}{L}&0\end{bmatrix}</script><p>  特征值中有一个大于 0 的特征值，不稳定</p></li><li><p>对于闭环系统</p><p>  系统的可控性，由系统的可控性中可知</p><script type="math/tex; mode=display">  Co=\begin{bmatrix}B&AB\end{bmatrix}=\begin{bmatrix}0&-1\\-1&0\end{bmatrix}\\Rank(Co)=2</script><p>  所以系统可控，令</p><script type="math/tex; mode=display">  u=-\begin{bmatrix}k_1&k_2\end{bmatrix}X</script><p>  带入之后得到</p><script type="math/tex; mode=display">  \dot{X}=\begin{bmatrix}0&1\\\frac{g}{L}+k_1&k_2\end{bmatrix}X=A_dX</script><p>  求系数矩阵的特征根</p><script type="math/tex; mode=display">  |\lambda I-A_d|=0\\\Downarrow\\\lambda^2-k_2\lambda-\frac{g}{L}-k_1=0</script><p>  为了使得系统稳定，所以一般使其特征根位于负半轴上，所以可以将该式子定义为</p><script type="math/tex; mode=display">  \lambda^2-k_2\lambda-\frac{g}{L}-k_1=0=\lambda^2+2\lambda+1</script><p>  得到</p><script type="math/tex; mode=display">  k_1=-1-\frac{g}{L}\\k_2=-2</script><p>  带入之后得到</p><script type="math/tex; mode=display">  u=\begin{bmatrix}1+\frac{g}{L}&2\end{bmatrix}X</script></li></ul><h2 id="线性控制器——状态跟踪"><a href="#线性控制器——状态跟踪" class="headerlink" title="线性控制器——状态跟踪"></a>线性控制器——状态跟踪</h2><p>对于上面所设计的控制器，如果想要使系统状态稳定再某一个位置时，就需要使用状态跟踪了</p><p>所以引入一个期望值，这里不对 $x_2$ 进行跟踪</p><script type="math/tex; mode=display">x_{1d}</script><p>令</p><script type="math/tex; mode=display">e_1=x_{1d}-x_1\\\\E=\begin{bmatrix}e_1\\x_2\end{bmatrix}</script><p>一般来说，系统的期望值是不变的，所以可以得到</p><script type="math/tex; mode=display">\dot{e_1}=-\dot{x}_1</script><p>所以可以得到，这里的 $a_{11}$ 是矩阵 A 中的一个元素</p><script type="math/tex; mode=display">\dot{E}=AE+Bu-\begin{bmatrix}0\\a_{11}\end{bmatrix}x_{1d}</script><p>可以设计控制器，目的是稳定系统和调整平衡点</p><script type="math/tex; mode=display">u=-KE-B_d^{-1}GX_d</script><p>带入得到</p><script type="math/tex; mode=display">\dot{E}=(A_d-B_dK)E</script><p>所以需要选择合适的 $K$ 使系统稳定</p><h3 id="还是上面那个倒立摆的例子"><a href="#还是上面那个倒立摆的例子" class="headerlink" title="还是上面那个倒立摆的例子"></a>还是上面那个倒立摆的例子</h3><p>对于上面所设计的控制器，如果想要使系统状态稳定再某一个位置时，就需要使用状态跟踪了</p><p>所以引入一个期望值，这里不对 $x_2$ 进行跟踪</p><script type="math/tex; mode=display">x_{1d}</script><p>令</p><script type="math/tex; mode=display">e_1=x_{1d}-x_1\\\\E=\begin{bmatrix}e_1\\x_2\end{bmatrix}</script><p>一般来说，系统的期望值是不变的，所以可以得到</p><script type="math/tex; mode=display">\dot{e_1}=-\dot{x}_1</script><p>对于上面的系统</p><script type="math/tex; mode=display">A=\begin{bmatrix}0&1\\\frac{g}{L}&0\end{bmatrix}\\B=\begin{bmatrix}0\\-1\end{bmatrix}</script><p>带入得到</p><script type="math/tex; mode=display">\dot{E}=\begin{bmatrix}0&-1\\-\frac{g}{L}&0\end{bmatrix}E+\begin{bmatrix}0\\-1\end{bmatrix}u+\begin{bmatrix}0\\\frac{g}{L}\end{bmatrix}x_{1d}</script><p>所以可以设计</p><script type="math/tex; mode=display">u=-KE+\frac{g}{L}x_{1d}</script><p>带入之后得到</p><script type="math/tex; mode=display">A-BK=\begin{bmatrix}0&1\\-\frac{g}{L}+k_1&k_2\end{bmatrix}</script><p>求得特征方程为</p><script type="math/tex; mode=display">\lambda^2-k_2\lambda+k_1-\frac{g}{L}=0</script><p>令</p><script type="math/tex; mode=display">\lambda^2-k_2\lambda-\frac{g}{L}+k_1=0=\lambda^2+2\lambda+1</script><p>得到</p><script type="math/tex; mode=display">k_2=-2\\k_1=1+\frac{g}{L}</script><p>也就是</p><script type="math/tex; mode=display">u=\begin{bmatrix}-1-\frac{g}{L}&2\end{bmatrix}E+\frac{g}{L}x_{1d}=-x_{1d}+(1+\frac{g}{L})x_1+2x_2</script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性状态观测器</title>
      <link href="/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>对于系统的状态，一般都是可以直接测定的，但是有些情况，系统的状态不能够直接测定，所以要根据系统的输入和输出来估计系统的状态</p><p>对于一个系统</p><script type="math/tex; mode=display">\dot{X}=AX+Bu\\y=CX+Du</script><p>设定 $\hat{X}$ 为系统状态的估计值， $\hat{y}$ 为输出的估计值</p><script type="math/tex; mode=display">\dot{\hat{X}}=A\hat{X}+Bu+L(y-\hat{y})\\\hat{y}=C\hat{X}+Du</script><p>两式合并得</p><script type="math/tex; mode=display">\dot{\hat{X}}=(A-LC)\hat{X}+(B-LD)u+Ly</script><p>这就是观测器形式</p><p>可以得到</p><script type="math/tex; mode=display">\dot{X}-\dot{\hat{X}}=AX+Bu-((A-LC)\hat{X}+(B-LD)u+Ly)\\\Downarrow\\\dot{X}-\dot{\hat{X}}=(A-LC)X-(A-LC)\hat{X}=(A-LC)(X-\hat{X})</script><p>此时，令</p><script type="math/tex; mode=display">e_x={X}-{\hat{X}}</script><p>是估计值与实际值之间的误差</p><p>由于我们的目标肯定是使得实际值与估计值是一致的，所以误差值的期望是变小的，也就是 $e_x→0$</p><p>所以根据上式可以得到一个这样的式子</p><script type="math/tex; mode=display">\dot{e_x}=(A-LC)e_x</script><p>所以就需要 $A-LC$ 的特征值小于 0 ，才能使得该误差值逐渐趋近于 0</p><p>所以需要建立一个新的反馈系统使得 $e_x→0$</p><p>所以，令</p><script type="math/tex; mode=display">L=\begin{bmatrix}l_1\\l_2\end{bmatrix}</script><p>带入之后选取适当的数值可以使得系统稳定</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>一个倒立摆模型</p><p><img src="/Blog_ButterFly/2024/03/18/%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B%E5%99%A8/Untitled.png" alt="Untitled"></p><p>建立系统状态空间方程，令</p><script type="math/tex; mode=display">X=\begin{bmatrix}x_1\\x_2\end{bmatrix}\\x_1=\phi\\x_2=\dot{\phi}（不可测）\\u=\frac{1}{L}\ddot{x}_{block}</script><p>则从上式可以得到状态空间方程</p><script type="math/tex; mode=display">\dot{X}=\begin{bmatrix}0&1\\\frac{g}{L}&0\end{bmatrix}X+\begin{bmatrix}0\\-1\end{bmatrix}u\\y=\begin{bmatrix}1&0\end{bmatrix}X+[0]u</script><p>可以得到</p><script type="math/tex; mode=display">A-LC=\begin{bmatrix}0&1\\\frac{g}{L}&0\end{bmatrix}-\begin{bmatrix}l_1\\l_2\end{bmatrix}\begin{bmatrix}1&0\end{bmatrix}=\begin{bmatrix}-l_1&1\\\frac{g}{L}-l_2&0\end{bmatrix}</script><p>可以假设</p><script type="math/tex; mode=display">g=10~N/m^2\\L=1~m</script><p>带入后得到</p><script type="math/tex; mode=display">A-LC=\begin{bmatrix}-l_1&1\\10-l_2&0\end{bmatrix}</script><p>求其特征方程为</p><script type="math/tex; mode=display">|\lambda I-(A-LC)|=0\\\downarrow\\\lambda^2+l_1\lambda+l_2-10=0</script><p>所以，令该特征方程的两个根都为 -1 ，可以得到</p><script type="math/tex; mode=display">l_1=2\\l_2=11</script><p>所以带入到估计值的方程中可以得到</p><script type="math/tex; mode=display">\dot{\hat{X}}=(A-LC)\hat{X}+(B-LD)u+Ly\\\Downarrow\\\dot{\hat{X}}=\begin{bmatrix}-2&1\\-1&0\end{bmatrix}\hat{X}+\begin{bmatrix}0\\-1\end{bmatrix}u+\begin{bmatrix}2\\11\end{bmatrix}y</script><h2 id="系统的可观测性"><a href="#系统的可观测性" class="headerlink" title="系统的可观测性"></a>系统的可观测性</h2><p>对于一个开环系统</p><script type="math/tex; mode=display">\dot{X}=AX\\y=CX</script><p>可以得到系统的状态转移方程</p><script type="math/tex; mode=display">X=e^{At}X(0)</script><p>根据状态方程的解，可以知道</p><script type="math/tex; mode=display">y=CX=Ce^{At}X(0)</script><p>根据矩阵质数定义的状态转移矩阵有</p><script type="math/tex; mode=display">e^{At}=I+At+\frac{1}{2!}A^2t^2+...</script><p>取前 n 项</p><script type="math/tex; mode=display">e^{At}=I+At+\frac{1}{2!}A^2t^2+...+\frac{1}{(n-1)!}A^{n-1}t^{n-1}</script><p>带入到上面 y 的式子中</p><script type="math/tex; mode=display">y=(CI+CAt+...+\frac{1}{(n-1)!}CA^{n-1}t^{n-1})X(0)\\=\begin{bmatrix}I&t&...&\frac{1}{(n-1)!}t^{n-1}\end{bmatrix}\begin{bmatrix}C\\CA\\\dots\\CA^{n-1}\end{bmatrix}X(0)</script><p>这是一个非齐次线性方程组，要从上面的式子中唯一的解出 n 阶初始状态 x(0) 的充要条件就是下面这个矩阵为满秩。实际的意义就是<strong>保证从任意状态来说都能推导出一个唯一的初始状态</strong></p><p>定义一个矩阵 O</p><script type="math/tex; mode=display">O=\begin{bmatrix}C\\CA\\\dots\\CA^{n-1}\end{bmatrix}</script><p><strong>当 $Rank(O)=n$ 就称该系统是可观测的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LQR线性二次型调节器</title>
      <link href="/Blog_ButterFly/2024/03/18/LQR%E7%BA%BF%E6%80%A7%E4%BA%8C%E6%AC%A1%E5%9E%8B%E8%B0%83%E8%8A%82%E5%99%A8/"/>
      <url>/Blog_ButterFly/2024/03/18/LQR%E7%BA%BF%E6%80%A7%E4%BA%8C%E6%AC%A1%E5%9E%8B%E8%B0%83%E8%8A%82%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><p>线性指的是系统是线性的，典型的线性系统的状态方程 </p><script type="math/tex; mode=display">x(k+1)=Ax(k)+Bu(k)</script><p>二次型是指代价函数 $J$ 是二次型的。</p><script type="math/tex; mode=display">J=\frac{1}{2} x(N)^TSx(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[x^T(k)Qx(k)+u^T(k)Ru(k)]}</script><p>其中前一项中 $N$ 表示末端时刻， $x_d$ 是系统的参考，也就是目标，这个 $J$ 是末端代价， $S$ 为末端状态的权重矩阵，是一个对角阵， $Q$ 是运行过程中的权重矩阵， $R$ 是控制量的权重矩阵， $S$ 和 $Q$ 是 $N\times N$ 的，但是 $R$ 是 $P\times P$的，如果对某个元素要求大时可以对应的将 $R$ 增大，关键的是 $S$ 和 $Q$ 都是半正定阵， $R$ 为正定阵，只有这样系统才会有最小值，即 $s≥0,q≥0,r&gt;0$</p><p>对于一个系统来说，当 $x_d$ 为零时，该系统就是一个调节系统，不为零就是一个跟踪系统。</p><h2 id="LQR线性二次型调节器"><a href="#LQR线性二次型调节器" class="headerlink" title="LQR线性二次型调节器"></a>LQR线性二次型调节器</h2><p>对应的调节二次型的 LQR 的代价函数就是</p><script type="math/tex; mode=display">J=\frac{1}{2} x(N)^TSx(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[x^T(k)Qx(k)+u^T(k)Ru(k)]}</script><p>采用逆向分级的方法来进行分析</p><p>系统的状态空间方程如下</p><script type="math/tex; mode=display">x(k+1)=Ax(k)+Bu(k)\\\\\\k=0:\ x(1)=Ax(0)+Bu(0)\\\\k=1:\ x(2)=Ax(1)+Bu(1)=A(Ax(0)+Bu(0))+Bu(1)\\\\\dots\\\\k=N-1:\ x(N)=A^{k+1}x(0)+\sum_{i=0}^{k}A^{k-i}Bu(i)</script><p>其中 $u(n-1)$ 可以使 $x(n-1)$ 转化为 $x(n)$</p><p>那么根据上式也可以得出对应的调节二次型的雅各比矩阵</p><script type="math/tex; mode=display">J=\frac{1}{2} x(N)^TSx(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[x^T(k)Qx(k)+u^T(k)Ru(k)]}\\k=N:J_{N\rightarrow N}^*=\frac{1}{2} x(N)^TSx(N)=\frac{1}{2} x(N)^TP(0)x(N);\ S=P(0)\\k=N-1:J_{N-1\rightarrow N}^* = \frac{1}{2} x(N)^TSx(N)+\frac{1}{2} x(N-1)^TQx(N-1)+\frac{1}{2}u(N-1)^TRu(N-1)=J^*_{N\rightarrow N}+\frac{1}{2} x(N-1)^TQx(N-1)+\frac{1}{2}u(N-1)^TRu(N-1)\\k=N-2:J_{N-2\rightarrow N}^* = \frac{1}{2} x(N)^TSx(N)+\frac{1}{2} x(N-1)^TQx(N-1)+\frac{1}{2}u(N-1)^TRu(N-1)+\frac{1}{2} x(N-2)^TQx(N-2)+\frac{1}{2}u(N-2)^TRu(N-2)\\=J_{N-1\rightarrow N}^*+\frac{1}{2} x(N-2)^TQx(N-2)+\frac{1}{2}u(N-2)^TRu(N-2)</script><p>其中标 * 的表示最优解</p><p>根据贝尔曼最优理论：</p><p>当 $J_{N-2→N}$为最优时 $J_{N-1→N}$一定为最优的</p><p>观察上个式子，对于每一步的最优解都是取决于最后的一部分，因为前一部分的最优是根据上一步的最优来的，所以对于每一步我们只需要求解最后一部分，而且由于 $x(k)$ 是系统状态量，所以是已知的，根本不需要考虑，因此就是求出最优的 $u(k)$ 就可以了。所以对于$J_{k→N}$的最优解求解就是直接求导，导数为0就可以得到最优控制策略，证明二阶导是一个正定矩阵，所以得到的 $u(k)$一定是最优的解。</p><p>下面将展示如何求解 $u(N-1)$，因为其他的求解方式与之相同，不再赘述</p><script type="math/tex; mode=display">J_{N-1\rightarrow N}^* = \frac{1}{2} x(N)^TSx(N)+\frac{1}{2} x(N-1)^TQx(N-1)+\frac{1}{2}u(N-1)^TRu(N-1)=J^*_{N\rightarrow N}+\frac{1}{2} x(N-1)^TQx(N-1)+\frac{1}{2}u(N-1)^TRu(N-1)</script><p>由上述可知</p><script type="math/tex; mode=display">x(N)=Ax(N-1)+Bu(N-1)</script><p>所以对应的雅可比矩阵可以转化为</p><script type="math/tex; mode=display">J_{N-1\rightarrow N}^* = \frac{1}{2} (Ax(N-1)+Bu(N-1))^TP(0)(Ax(N-1)+Bu(N-1))+\frac{1}{2} x(N-1)^TQx(N-1)+\frac{1}{2}u(N-1)^TRu(N-1)</script><p>对上式求导</p><script type="math/tex; mode=display">\frac{\partial J_{N-1\rightarrow N}}{\partial u(N-1)}=0\\frist\ part: \frac{\partial \frac{1}{2}x(N)^TP(0)x(N)}{\partial u(N-1)}=\frac{\partial x(N)}{\partial u(N-1)}*\frac{\partial \frac{1}{2}x(N)^TP(0)x(N)}{\partial x(N)}=B^T*P(0)x(N)=B^TP(0)(Ax(N-1)+Bu(N-1))\\second\ part:\frac{\partial \frac{1}{2} x(N-1)^TQx(N-1)}{\partial u(N-1)}=0\\third\ part:\frac{\partial \frac{1}{2}u(N-1)^TRu(N-1)}{\partial u(N-1)}=Ru(N-1)\\\frac{\partial J_{N-1\rightarrow N}}{\partial u(N-1)}=B^TP(0)(Ax(N-1)+Bu(N-1))+Ru(N-1)</script><p>解得</p><script type="math/tex; mode=display">B^TP(0)(Ax(N-1)+Bu(N-1))+Ru(N-1)=0\\\Rightarrow u^*(N-1)=-(B^TP(0)B+R)^{-1}B^TP(0)Ax(N-1)</script><p>令 $F(N-1)=(B^TP(0)B+R)^{-1}B^TP(0)A$，原式化简为</p><script type="math/tex; mode=display">u^*(N-1)=-F(N-1)x(N-1)</script><p>这就是一个全状态的一个反馈控制器。</p><p>由于一阶导为0只能证明是极值，所以求解二阶导来验证一下该结果是否为最小值</p><script type="math/tex; mode=display">\frac{\partial^2 J_{N-1\rightarrow N}}{\partial u(N-1)^2}=(B^TP(0)B)^T+R^T</script><p>由于 $R$ 是一个正定矩阵，而 $B^TP(0)B$ 是一个半正定矩阵，所以结果是正定的，因此该结果是最小值</p><p>将最优的解带入到代价函数中去，可得到最优的代价</p><script type="math/tex; mode=display">J_{N-1\rightarrow N}^* = \frac{1}{2}x(N-1)^T\{(A-BF(N-1))^TP(0)(A-BF(N-1))+F(N-1)^TRF(N-1)+Q\}x(N-1)</script><p>令</p><script type="math/tex; mode=display">P(1)=(A-BF(N-1))^TP(0)(A-BF(N-1))+F(N-1)^TRF(N-1)+Q</script><p>上式可为</p><script type="math/tex; mode=display">J_{N-1\rightarrow N}^* = \frac{1}{2}x(N-1)^TP(1)x(N-1)\\P(1)=(A-BF(N-1))^TP(0)(A-BF(N-1))+F(N-1)^TRF(N-1)+Q</script><p>所以最终可以得到</p><script type="math/tex; mode=display">\left\{\begin{aligned}&J^*_{N-k\rightarrow N}=\frac{1}{2}x(N-k)^TP(k)x(N-k)\\&P(k)=(A-BF(N-k))^TP(k-1)(A-BF(N-k))+F(N-k)^TRF(N-k)+Q\\&F(N-k)=(B^TP(k-1)B+R)^{-1}B^TP(k-1)A\end{aligned}\right.</script><p>根据递归计算就可以得到所有的状态矩阵了，其中 $F[N-k]$是反馈增益， $u[N-k]$是N-k时的最优控制量，也会得到 $p[k]$进行下一步的计算，最后需要不断递归计算得到 $u[0]$也就是需要使用的输入量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%系统定义</span></span><br><span class="line"><span class="comment">%定义系统矩阵A</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span>; <span class="number">-1</span> <span class="number">-0.5</span>];</span><br><span class="line">n = <span class="built_in">size</span>(A, <span class="number">1</span>);</span><br><span class="line"><span class="comment">%定义系统矩阵B</span></span><br><span class="line">B = [<span class="number">0</span>; <span class="number">1</span>];</span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%系统离散</span></span><br><span class="line"><span class="comment">%离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">%连续系统转为离散系统 不是必须的</span></span><br><span class="line"><span class="comment">%sys_d = c2d(ss(A, B), Ts);</span></span><br><span class="line"><span class="comment">%A = sys_d.a;</span></span><br><span class="line"><span class="comment">%B = sys_d.b;</span></span><br><span class="line"><span class="comment">%%%%%%%%%%系统初始化</span></span><br><span class="line"><span class="comment">%初始状态 可以有多个输入值，这个输入值是一个位移和速度</span></span><br><span class="line">x0 = [<span class="number">1</span>; <span class="number">0</span>];</span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">%初始输入</span></span><br><span class="line">u0 = <span class="number">2</span>;</span><br><span class="line">u = u0;</span><br><span class="line"><span class="comment">%%%%%%%%%%初始化参数</span></span><br><span class="line"><span class="comment">%定义运行步数</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">%定义存储系统状态结果的矩阵 维度为 n * k_step</span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n, k_steps);</span><br><span class="line"><span class="comment">%系统状态赋值存储</span></span><br><span class="line">x_history(:, <span class="number">1</span>) = x;<span class="comment">%对第一次进行赋值</span></span><br><span class="line"><span class="comment">%定义系统输入状态存储矩阵 p*k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p, k_steps);</span><br><span class="line"><span class="comment">%将系统输入初始赋值</span></span><br><span class="line">u_history(:, <span class="number">1</span>) = u;</span><br><span class="line"><span class="comment">%%%%%%%%%%权重矩阵设计</span></span><br><span class="line"><span class="comment">%系统状态权重矩阵</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%系统终值权重矩阵</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%系统输入权重矩阵(单输入)</span></span><br><span class="line">R = <span class="number">1</span>;</span><br><span class="line"><span class="comment">%p矩阵初始化</span></span><br><span class="line">p_k = S;</span><br><span class="line"><span class="comment">%F_N矩阵计算，可以提前计算好，之后使用，F_N的结果与系统的状态无关，与系统的输入输出也无关</span></span><br><span class="line">N = k_steps;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>: N</span><br><span class="line">    F = inv(R + B&#x27;* p_k * B)*B&#x27;* p_k * A;</span><br><span class="line">    p_k = (A - B * F)&#x27; * p_k * (A - B * F) + (F)&#x27; * R * (F) + Q;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span></span><br><span class="line">        F_N = F;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        F_N = [F; F_N];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%%%%%%%%%%开始仿真</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>: k_steps</span><br><span class="line">    <span class="comment">%计算系统输入</span></span><br><span class="line">    u = - F_N((k<span class="number">-1</span>)*p+<span class="number">1</span>:k*p, :) * x;</span><br><span class="line">    <span class="comment">%系统输入带入系统方程，计算系统响应</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">%保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:, k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">%保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:, k) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%结果显示</span></span><br><span class="line"><span class="comment">%系统状态视图</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: n</span><br><span class="line">    <span class="built_in">plot</span>(x_history(<span class="built_in">i</span>, :));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>: n)&#x27;, <span class="string">&#x27;x %d&#x27;</span>));</span><br><span class="line">xlim([<span class="number">1</span>, k_steps]);</span><br><span class="line">grid on;</span><br><span class="line"><span class="comment">%系统输入视图</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>, :));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>: p)&#x27;, <span class="string">&#x27;u %d&#x27;</span>));</span><br><span class="line">xlim([<span class="number">1</span>, k_steps]);</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><h2 id="LQR线性二次型跟踪器"><a href="#LQR线性二次型跟踪器" class="headerlink" title="LQR线性二次型跟踪器"></a>LQR线性二次型跟踪器</h2><p>跟踪二次型系统的LQR的代价函数为</p><script type="math/tex; mode=display">J=\frac{1}{2} [x(n)-x_d(n))^TS(x(n)-x_d(n)]+\frac{1}{2}\sum_{k=0}^{N-1}{[x(k)-x_d(k))^T\Phi (x(k)-x_d(k)) + u(k)^TRu(k)]}</script><p>定义系统误差</p><script type="math/tex; mode=display">e(k)=x(k)-x_d(k)</script><p>跟踪器就是对 $e(k)$ 的调节器，也就是 $e_d(k)=0$</p><p>可以定义矩阵的系统状态方程</p><script type="math/tex; mode=display">\begin{bmatrix}x(k+1)\\x_d(k+1)\end{bmatrix}=\begin{bmatrix}A&&0\\0&&A_0\end{bmatrix}\begin{bmatrix}x(k)\\x_d(k)\end{bmatrix}+\begin{bmatrix}B\\0\end{bmatrix}u(k)</script><p>一般来说跟踪的量是不会改变的，也就是 $A_0=I$</p><p>可以用一些符号代表矩阵来简化式子</p><script type="math/tex; mode=display">x_a(k+1)=A_ax_a(k)+B_au(k)</script><p>由</p><script type="math/tex; mode=display">e(k)=x(k)-x_d(k)=\begin{bmatrix}I&&-I\end{bmatrix}\begin{bmatrix}x(k)\\x_d(k)\end{bmatrix}=C_ax_a(k)</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{aligned}&A_a=\begin{bmatrix}A&&0\\0&&A_0\end{bmatrix}\\&B_a=\begin{bmatrix}B\\0\end{bmatrix}\\&C_a=\begin{bmatrix}I&&-I\end{bmatrix}\end{aligned}\right.</script><p>对应的代价函数为</p><script type="math/tex; mode=display">J=\frac{1}{2} e(N)^TSe(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[e^T(k)Qe(k)+u^T(k)Ru(k)]}</script><p>带入上式为</p><script type="math/tex; mode=display">J=\frac{1}{2} x_a(N)^TC_a^TSC_ax_a(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[x_a^T(k)C_a^TQC_ax_a(k)+u^T(k)Ru(k)]}</script><p>令 $S_a=C_a^TSC_a$， $Q_a=C_a^TQC_a$，得</p><script type="math/tex; mode=display">J=\frac{1}{2} x_a(N)^TS_ax_a(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[x_a^T(k)Q_ax_a(k)+u^T(k)Ru(k)]}</script><p>与 LQR 调节器求解过程相同，得最终结果为</p><script type="math/tex; mode=display">\left\{\begin{aligned}&J^*_{N-k\rightarrow N}=\frac{1}{2}x_a(N-k)^TP_a(k)x_a(N-k)\\&F_a(N-k)=(B_a^TP_a(k-1)B_a+R)^{-1}B_a^TP_a(k-1)A_a\\&P_a(k)=(A_a-B_aF_a(N-k))^TP_a(k-1)(A_a-B_aF_a(N-k))+F_a(N-k)^TRF_a(N-k)+Q_a\\&u(N-k)=-F_a(N-k)x_a(N-k)\end{aligned}\right.</script><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span>; <span class="number">-1</span> <span class="number">-0.5</span>];</span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">B = [<span class="number">0</span>; <span class="number">1</span>];</span><br><span class="line">p = <span class="built_in">size</span>(B, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">[A, B]=c2d(A,B,Ts);</span><br><span class="line"></span><br><span class="line">x0 = [<span class="number">0</span>; <span class="number">0</span>];</span><br><span class="line">x = x0;</span><br><span class="line">xd = [<span class="number">1</span>; <span class="number">0</span>];</span><br><span class="line">xa = [x; xd];</span><br><span class="line"></span><br><span class="line">u0 = <span class="number">2</span>;</span><br><span class="line">u = u0;</span><br><span class="line"></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n, k_steps);</span><br><span class="line">x_history(:, <span class="number">1</span>) = x;</span><br><span class="line">u_history = <span class="built_in">zeros</span>(p, k_steps);</span><br><span class="line">u_history(:, <span class="number">1</span>) = u;</span><br><span class="line"></span><br><span class="line">AD = <span class="built_in">eye</span>(n);</span><br><span class="line">Ca = [<span class="built_in">eye</span>(n) -<span class="built_in">eye</span>(n)];</span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">R = <span class="number">0.01</span>;</span><br><span class="line">Sa = Ca&#x27; * S * Ca;</span><br><span class="line">Qa = Ca&#x27; * Q * Ca;</span><br><span class="line">Aa = [A <span class="built_in">zeros</span>(n); <span class="built_in">zeros</span>(n) AD];</span><br><span class="line">Ba = [B; <span class="built_in">zeros</span>(n, <span class="number">1</span>)];</span><br><span class="line">p_k = Sa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>: k_steps</span><br><span class="line">    F = inv(R + Ba&#x27;* p_k * Ba) * Ba&#x27;* p_k * Aa;</span><br><span class="line">    p_k = (Aa-Ba*F)&#x27;*p_k*(Aa-Ba*F)+ (F)&#x27;*R*(F)+Qa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">%计算系统输入</span></span><br><span class="line">    u = -F * xa;</span><br><span class="line">    <span class="comment">%系统输入带入系统方程，计算系统响应</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    xa = [x; xd];</span><br><span class="line">    <span class="comment">%保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:, k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">%保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:, k) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: n</span><br><span class="line">    <span class="built_in">plot</span>(x_history(<span class="built_in">i</span>, :));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>: n)&#x27;, <span class="string">&#x27;x %d&#x27;</span>));</span><br><span class="line">xlim([<span class="number">1</span>, k_steps]);</span><br><span class="line">grid on;</span><br><span class="line"><span class="comment">%系统输入视图</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>, :));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>: p)&#x27;, <span class="string">&#x27;u %d&#x27;</span>));</span><br><span class="line">xlim([<span class="number">1</span>, k_steps]);</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><h2 id="LQR线性二次型跟踪器——稳态非零参考值控制"><a href="#LQR线性二次型跟踪器——稳态非零参考值控制" class="headerlink" title="LQR线性二次型跟踪器——稳态非零参考值控制"></a>LQR线性二次型跟踪器——稳态非零参考值控制</h2><p>对于一个系统（这是系统的状态方程的递推形式）</p><script type="math/tex; mode=display">x_{k+1}=Ax_k+Bu_k</script><p>由于 LQR线性二次型跟踪器 在应对 R 过大时，也就是太过于注重节能的话，系统的输入就会为 0，这将导致系统不运作，所以有了这个控制模式</p><p>对于有些系统，处于某个目标状态并且稳定时，它所需要的输入/输出是一个非 0 的值，这个输入 $u_d$ 将会使系统保持稳定在目标位置，也就是</p><script type="math/tex; mode=display">x_d=Ax_d+Bu_d</script><p>所以需要定义稳态输入误差</p><script type="math/tex; mode=display">\Delta u_k=u_k-u_d</script><p>带入到状态方程中就是</p><script type="math/tex; mode=display">x_{k+1}=Ax_k+B(\Delta u_k+u_d)=Ax_k+B\Delta u_k+(I-A)x_d</script><p>这里的话就可以得到一个增广矩阵，其中 $x_d$ 为常数，并且定义误差矩阵</p><script type="math/tex; mode=display">x_a[k+1]=\begin{bmatrix}x_{k+1}\\x_d\end{bmatrix}=\begin{bmatrix}A&I-A\\0&I\end{bmatrix}\begin{bmatrix}x_k\\x_d\end{bmatrix}+\begin{bmatrix}B\\0\end{bmatrix}\Delta u_k\\\Downarrow\\x_a[k+1]=A_ax_a[k]+B_a\Delta u_k\\e_k=x_k-x_d=\begin{bmatrix}I&-I\end{bmatrix}\begin{bmatrix}x_k\\x_d\end{bmatrix}=C_ax_a[k]</script><p>列出代价函数，前面部分的计算都是与线性二次型跟踪器是一致的，只有第二部分是不一样的，这里的代价函数为</p><script type="math/tex; mode=display">J=\frac{1}{2} e(N)^TSe(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[e^T(k)Qe(k)+\Delta u^T(k)R\Delta u(k)]}</script><p>令 $S_a=C_a^TSC_a$， $Q_a=C_a^TQC_a$，得</p><script type="math/tex; mode=display">J=\frac{1}{2} x_a(N)^TS_ax_a(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[x_a^T(k)Q_ax_a(k)+\Delta u^T(k)R\Delta u(k)]}</script><p>其中第二项就表示系统的稳态输入误差，表示输入偏离目标位置的距离</p><p>与 LQR 调节器求解过程相同，得最终结果为</p><script type="math/tex; mode=display">\left\{\begin{aligned}&J^*_{N-k\rightarrow N}=\frac{1}{2}x_a(N-k)^TP_a(k)x_a(N-k)\\&F_a(N-k)=(B_a^TP_a(k-1)B_a+R)^{-1}B_a^TP_a(k-1)A_a\\&P_a(k)=(A_a-B_aF_a(N-k))^TP_a(k-1)(A_a-B_aF_a(N-k))+F_a(N-k)^TRF_a(N-k)+Q_a\\&\Delta u(N-k)=-F_a(N-k)x_a(N-k)\\&u(N-k)=u_d+\Delta u(N-k)\end{aligned}\right.</script><h2 id="LQR线性二次型跟踪器——输入增量控制"><a href="#LQR线性二次型跟踪器——输入增量控制" class="headerlink" title="LQR线性二次型跟踪器——输入增量控制"></a>LQR线性二次型跟踪器——输入增量控制</h2><p>上述中 $x_d$ 是一个常数，所以这里讨论 $x_d$ 为非常数的变化，并且设置</p><script type="math/tex; mode=display">x_d[k+1]=A_dx_d[k]</script><p>定义一个 $u$ 的增量 </p><script type="math/tex; mode=display">\Delta u_k=u_k-u_{k-1}\\u_k=\Delta u_k+u_{k-1}</script><p>这个可以使得系统的输入更加平滑，输入的变化不那么剧烈。带入到系统状态方程中</p><script type="math/tex; mode=display">x_{k+1}=Ax_k+B\Delta u_k+u_{k-1}</script><p>此时设置增广矩阵</p><script type="math/tex; mode=display">x_a[k]=\begin{bmatrix}x_{k}\\x_d[k]\\u_{k-1}\end{bmatrix}\\\Downarrow\\e_k=x_k-x_d[k]=\begin{bmatrix}I&-I&0\end{bmatrix}\begin{bmatrix}x_{k}\\x_d[k]\\u_{k-1}\end{bmatrix}=C_ax_a[k]</script><p>并且可以得到系统的递归函数</p><script type="math/tex; mode=display">x_a[k+1]=\begin{bmatrix}x_{k+1}\\x_d[k+1]\\u_{k}\end{bmatrix}=\begin{bmatrix}A&0&B\\0&A_d&0\\0&0&I\end{bmatrix}\begin{bmatrix}x_k\\x_d[k]\\u_{k-1}\end{bmatrix}+\begin{bmatrix}B\\0\\I\end{bmatrix}\Delta u_k</script><p>系统的代价函数可以设计为</p><script type="math/tex; mode=display">J=\frac{1}{2} e(N)^TSe(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[e^T(k)Qe(k)+\Delta u^T(k)R\Delta u(k)]}</script><p>令 $S_a=C_a^TSC_a$， $Q_a=C_a^TQC_a$，得</p><script type="math/tex; mode=display">J=\frac{1}{2} x_a(N)^TS_ax_a(N)+\frac{1}{2}\sum_{k=0}^{N-1}{[x_a^T(k)Q_ax_a(k)+\Delta u^T(k)R\Delta u(k)]}</script><p>与 LQR 调节器求解过程相同，得最终结果为</p><script type="math/tex; mode=display">\left\{\begin{aligned}&J^*_{N-k\rightarrow N}=\frac{1}{2}x_a(N-k)^TP_a(k)x_a(N-k)\\&F_a(N-k)=(B_a^TP_a(k-1)B_a+R)^{-1}B_a^TP_a(k-1)A_a\\&P_a(k)=(A_a-B_aF_a(N-k))^TP_a(k-1)(A_a-B_aF_a(N-k))+F_a(N-k)^TRF_a(N-k)+Q_a\\&\Delta u(N-k)=-F_a(N-k)x_a(N-k)\\&u(N-k)=u(N-k-1)+\Delta u(N-k)\end{aligned}\right.</script><h2 id="LQR线性二次调节器——系统输入线性化"><a href="#LQR线性二次调节器——系统输入线性化" class="headerlink" title="LQR线性二次调节器——系统输入线性化"></a>LQR线性二次调节器——系统输入线性化</h2><p>这一部分实际上就是工程上比较常用的，将 LQR 控制器的输入 u 定义为 $u=-Ke$ 的形式，一种线性反馈控制器，最后成为一个近似于 PD 控制器</p><p>连续系统</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu\\e=x_d-x\\\dot{x_d}=A_dx_d</script><p>定义连续系统代价函数，由于 $t→\infty, e→0$</p><script type="math/tex; mode=display">J=\frac{1}{2} e^T(t_f)Se(t_f)+\frac{1}{2}\int_{0}^{t_f}{[e^TQe+u^TRu]}dt</script><script type="math/tex; mode=display">e(k)=x(k)-x_d(k)=\begin{bmatrix}I&&-I\end{bmatrix}\begin{bmatrix}x(k)\\x_d(k)\end{bmatrix}=C_ax_a(k)</script><p>设计最优控制</p><script type="math/tex; mode=display">u=-Ke=-KC_ax_a</script><p>可以得到</p><script type="math/tex; mode=display">\dot{x}_a=\begin{bmatrix}A&0\\0&A_d\end{bmatrix}x_a+\begin{bmatrix}B\\0\end{bmatrix}u=\begin{bmatrix}A-BKC_a&0\\0&A_d\end{bmatrix}x_a\\\dot{x}_a=A_cx_a+B_cu=A_ax_a</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{aligned}&A_a=\begin{bmatrix}A&&0\\0&&A_0\end{bmatrix}\\&B_a=\begin{bmatrix}B\\0\end{bmatrix}\\&C_a=\begin{bmatrix}I&&-I\end{bmatrix}\end{aligned}\right.</script><p>对应的代价函数为</p><script type="math/tex; mode=display">J=\frac{1}{2} e(t_f)^TSe(t_f)+\frac{1}{2}\int_{0}^{t_f}{[e^TQe+u^TRu]}dt</script><p>带入上式为</p><script type="math/tex; mode=display">J=\frac{1}{2} x_a(t_f)^TC_a^TSC_ax_a(t_f)+\frac{1}{2}\int_{0}^{t_f}{[x_a^TC_a^TQC_ax_a+u^TRu]}dt</script><p>令 $S_a=C_a^TSC_a$， $Q_a=C_a^TQC_a$，得</p><script type="math/tex; mode=display">J=\frac{1}{2} x_a^T(t_f)S_ax_a(t_f)+\frac{1}{2}\int_{0}^{t_f}{[x_a^TQ_ax_a+u^TRu]}dt</script><p>将 $u=-Ke$ 带入到代价函数中去</p><script type="math/tex; mode=display">J=\frac{1}{2} x_a^T(t_f)S_ax_a(t_f)+\frac{1}{2}\int_{0}^{t_f}{x_a^T(Q_a+K^TRK)x_a}dt</script><p><strong>第一种解法</strong></p><p>可以假设存在一个向量 P，使得</p><script type="math/tex; mode=display">\frac{d}{dt}(x_a^TPx_a)=-x_a^T(Q_a+K^TRK)x_a~~①</script><p>假设系统是稳定的（实际上需要验证），带入代价函数中得到</p><script type="math/tex; mode=display">J=\frac{1}{2}x^T_a(0)Px_a(0)</script><p>将 1 式左侧微分展开，并且把 $x_a$ 微分形式替换</p><script type="math/tex; mode=display">\dot{x}_a^TPx_a+x_a^TP\dot{x}_a+x_a^T(Q_a+K^TRK)x_a=0\\x_a^TA_a^TPx_a+x_a^TPA_ax_a+x_a^T(Q_a+K^TRK)x_a=0\\x_a^T(A_a^TP+PA_a+Q_a+K^TRK)x_a=0</script><p>要想式子成立，括号里必须始终为 0</p><script type="math/tex; mode=display">A_a^TP+PA_a+Q_a+K^TRK=0</script><p>这就是 $Riccati$ 方程</p><p><strong>第二种解法</strong></p><script type="math/tex; mode=display">J=\frac{1}{2} x_a^T(t_f)S_ax_a(t_f)+\frac{1}{2}\int_{0}^{t_f}{[x_a^TQ_ax_a+u^TRu]}dt</script><p>由于函数第一项是恒定的数值，所以只考虑第二项的最小值就好，也就是</p><script type="math/tex; mode=display">min\int_{0}^{t_f}{[x_a^TQ_ax_a+u^TRu]}dt</script><p>引入哈密顿函数</p><script type="math/tex; mode=display">H=f(x_a,u)+\lambda g(x_a,u)=x_a^TQ_ax_a+u^TRu+\lambda(A_cx_a+B_cu)</script><script type="math/tex; mode=display">\frac{\partial H}{\partial u}=(R+R^T)u+B_c^T\lambda=0\\\Downarrow\\u=-(R+R^T)^{-1}B_c^T\lambda</script><script type="math/tex; mode=display">-\frac{\partial H}{\partial x}=-(f_x+\lambda g_x)=-[(Q_a+Q_a^T)x_a+A^T\lambda]=\dot\lambda\\\frac{\partial H}{\partial \lambda}=g=A_cx_a+B_cu=A_cx-B_c(R+R^T)^{-1}B_c^T\lambda=\dot{x}_a</script><p>由于我们设定 $u=-Kx_a$，所以可以知道 $\lambda=Px_a$，并且 $-(R+R^T)^{-1}B_c^TP=K$</p><p>带入上述的方程得到</p><script type="math/tex; mode=display">\dot\lambda=-[(Q_a+Q_a^T)x_a+A_c^T\lambda]=-(Q_a+Q_a^T+A_c^TP)x_a\\\dot{x}_a=A_cx-B_c(R+R^T)^{-1}B_c^T\lambda=[A_c-B_c(R+R^T)^{-1}B_c^TP]x_a</script><p>联立得到</p><script type="math/tex; mode=display">\dot{\lambda}=\dot{P}x_a+P\dot{x}_a=[\dot{P}+P(A_c-B_c(R+R^T)^{-1}B_c^TP)]x_a=-(Q_a+Q_a^T+A_c^TP)x_a</script><p>所以得到</p><script type="math/tex; mode=display">\dot{P}+PA_c-PB_c(R+R^T)^{-1}B_c^TP+Q_a+Q_a^T+A_c^TP=0</script><p>令 $Q_1=Q_a+Q_a^T,Q_2=R+R^T$，得到</p><script type="math/tex; mode=display">\dot{P}+PA_c-PB_cQ_2^{-1}B_c^TP+Q_1+A_c^TP=0</script><p>最终得到一个 $Riccati$ 方程</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>输入系统线性化相当于是得到了一个线性的输入， $u=-Kx$ 这个 $K$ 可以通过解算 $Riccati$ 方程得到解，并且将会是一个固定的常数，所以最终的控制有点像 PD 控制器</p><p>但是 $Riccati$ 方程是一个由许多解的方程，所以不容易手算出来，所以在 matlab 中直接调用 <code>lqr</code> 函数就可以得到对应的 $K$</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LQR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab中LMI工具箱使用</title>
      <link href="/Blog_ButterFly/2024/03/18/matlab%E4%B8%ADLMI%E5%B7%A5%E5%85%B7%E7%AE%B1%E4%BD%BF%E7%94%A8/"/>
      <url>/Blog_ButterFly/2024/03/18/matlab%E4%B8%ADLMI%E5%B7%A5%E5%85%B7%E7%AE%B1%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化一个-LMI-系统"><a href="#初始化一个-LMI-系统" class="headerlink" title="初始化一个 LMI 系统"></a>初始化一个 LMI 系统</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setlmis(lmi0);</span><br><span class="line">setlmis([]); <span class="comment">% 常用</span></span><br></pre></td></tr></table></figure><h3 id="向-LMI-系统中添加矩阵变量-lmivar"><a href="#向-LMI-系统中添加矩阵变量-lmivar" class="headerlink" title="向 LMI 系统中添加矩阵变量 lmivar"></a>向 LMI 系统中添加矩阵变量 <code>lmivar</code></h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = lmivar(<span class="built_in">type</span>, struct); <span class="comment">% 常用</span></span><br><span class="line">[X, ndec, xdec] = lmivar(<span class="built_in">type</span>, struct); <span class="comment">% ndec表述与X有关的决策变量的个数，xdec表示X对这些决策变量的初始依赖关系</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>type类型对应的数值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>对角线对称矩阵格式，每个对角块都是满块</td></tr><tr><td>2</td><td>矩形块，struct=[m,n] 表示 m x n 阶矩阵</td></tr><tr><td>3</td><td>描述复杂类型的矩阵</td></tr></tbody></table></div><ol><li><p><code>type=1</code></p><p> struct 包含两个基本变量</p><ul><li>第一个描述矩阵块的阶数</li><li><p>第二个描述矩阵块的类型</p><p>  | 0   | 标量 |<br>  | —- | —— |<br>  | 1   | 满块 |<br>  | -1  | 零块 |</p></li></ul></li><li><code>type=2</code></li><li><p><code>type=3</code></p><p> 描述复杂类型的矩阵</p></li></ol><h3 id="返回-LMI-的函数的内部描述-getlmis"><a href="#返回-LMI-的函数的内部描述-getlmis" class="headerlink" title="返回 LMI 的函数的内部描述 getlmis"></a>返回 LMI 的函数的内部描述 <code>getlmis</code></h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lmisys = getlmis <span class="comment">% lmisys 称为存储在机器内部线性矩阵不等式系统的名称，一个线性矩阵不等式以 setlmis 开始，以 getlmis 结束</span></span><br></pre></td></tr></table></figure><h3 id="确定线性矩阵不等式中各项的内容-lmiterm"><a href="#确定线性矩阵不等式中各项的内容-lmiterm" class="headerlink" title="确定线性矩阵不等式中各项的内容 lmiterm"></a>确定线性矩阵不等式中各项的内容 <code>lmiterm</code></h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lmiterm(termID, A, B, flag);</span><br></pre></td></tr></table></figure><p><code>termID</code>：是一个四项的整数向量，用于指定 LMI 中相的位置和所涉及的矩阵变量</p><ul><li><code>termID(1) = +p/-p</code>，其中 +p 表示第 p 个 LMI 左侧项，-p 表示第 p 个 LMI 右侧的相，也就是 $X_1&lt;X_2$ 中不等式的左右</li><li><code>termID(2 : 3) = [0, 0]</code>，对应于外部的矩阵</li><li><code>termID(2 : 3) = [i, j]</code>，对应于左/右侧因子的第 (i, j) 块中的项</li><li><code>termID(4) = 0</code> 对应与外部的变量</li><li><code>termID(4) = x</code> 对应于变量 <code>AXB</code> ，X 是所需要反馈的矩阵变量，A，B是设定好的矩阵</li><li><code>termID(4) = -x</code> 对应于变量 <code>AX’B</code></li></ul><p>对于 <code>(AXB) + (AXB)&#39; = AXB + B&#39;XA&#39;</code> 设置 <code>flag = &#39;s&#39;</code> ，允许使用单个 lmiterm 命令指定类别</p><h3 id="约束条件下求-LMI-可行性问题-feasp"><a href="#约束条件下求-LMI-可行性问题-feasp" class="headerlink" title="约束条件下求 LMI 可行性问题 feasp"></a>约束条件下求 LMI 可行性问题 <code>feasp</code></h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tmin, xfeas] = feasp(lmisys, options, target); <span class="comment">% 如果返回 tmin &lt;= 0 说明系统可行</span></span><br></pre></td></tr></table></figure><ul><li><code>lmisys</code> 称为存储在机器内部线性矩阵不等式系统的名称</li><li><code>options</code> 是一个五维向量，用来描述迭代过程中的一些控制参数<ul><li><code>option(1)</code> 分量不可用</li><li><code>option(2)</code> 该参数设定优化迭代过程中允许的最大迭代次数，默认值是 100</li><li><code>option(3)</code> 该参数设定了可行域的半径， <code>option(3) = R &gt; 0</code> 表示限制决策变量在球体内 $\sum_{i=1}^Nx_i^2&lt;R^2$ 中，或者说向量 <code>xfeas</code> 的欧式范数不超过 R，该参数默认值为 $R=10^9$。可行域半径的设定可以避免产生具有很大数值的解 x，同时也可以加快计算过程，改进数值稳定性</li><li><code>option(4)</code> 该参数可用于加快迭代过程的结束，它提供了反映优化过程中迭代速度和解得到精度之间的一个折中指标。当该参数取值为一个正整数 n 时，表示在最后的 n 次迭代中如果每次迭代后 t 的减小幅度不超过 1%，则优化迭代过程就停止，默认是 10</li><li><code>option(5)</code> <code>option(5)=1</code> 表示不显示迭代过程中的数据， <code>option(5)=0</code> 则相反</li><li>将对应的维度设置为 0 就是使用默认值</li></ul></li><li><code>target</code> 为 <code>tmin</code> 设定了目标值，使得只要 <code>tmin &lt; target</code> 则优化过程停止，默认值为 0</li></ul><p>为了调用 <code>feasp</code> 函数，需要首先确定线性矩阵不等式系统</p><h3 id="在-LMI-约束下最小化线性目标-mincx"><a href="#在-LMI-约束下最小化线性目标-mincx" class="headerlink" title="在 LMI 约束下最小化线性目标 mincx"></a>在 LMI 约束下最小化线性目标 <code>mincx</code></h3><script type="math/tex; mode=display">\min C^Tx\\L(x)<R(x)</script><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[copt, xopt] = mincx(lmisys, c, options, xinit, target);</span><br></pre></td></tr></table></figure><p>LMI 系统由 <code>lmisys</code> 描述。 向量 c 的长度必须与 x 相同。 该长度对应于函数 <code>decnbr</code> 返回的决策变量的数量。 对于用矩阵变量表示的线性目标，可以使用 <code>defcx</code> 轻松导出足够的c向量。</p><ul><li><code>target</code> 是目标函数的一个设定目标，只要某个可行的 x 满足 $e^Tx≤target$，求解过程就停止</li><li><code>option</code> 是一个 5 维向量，用来描述优化迭代过程中的一些控制参数<ul><li><code>option(1)</code> 该参数确定了最优值 <code>copt</code> 所要求的精度，默认是 $10^{-2}$</li><li><code>option(2)</code> 该参数设定优化迭代过程中允许的最大迭代次数，默认值是 100</li><li><code>option(3)</code> 该参数设定了可行域的半径，与 <code>feasp</code> 中的定义一致</li><li><code>option(4)</code> 该参数用于加快迭代过程的结束，当该参数取值为一个正整数 n 时，表示在最后的 n 次迭代中如果每次迭代后 $C^Tx$ 的减小幅度在给定的京都内，则优化迭代过程就停止，默认是 5</li><li><code>option(5)</code> <code>option(5)=1</code> 表示不显示迭代过程中的数据， <code>option(5)=0</code> 则相反</li><li>将对应的维度设置为 0 就是使用默认值</li></ul></li></ul><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p><code>Mat2dec</code> 根据矩阵变量值构造决策变量向量</p><p><code>Dec2mat</code> 从决策变量向量中提取矩阵变量值。将求解器求出的向量，根据对称性转换为普通的矩阵</p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> LMI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不变性原理</title>
      <link href="/Blog_ButterFly/2024/03/18/%E4%B8%8D%E5%8F%98%E6%80%A7%E5%8E%9F%E7%90%86/"/>
      <url>/Blog_ButterFly/2024/03/18/%E4%B8%8D%E5%8F%98%E6%80%A7%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>例子</strong></p><p>对于一个简单的倒立摆</p><p><img src="/Blog_ButterFly/2024/03/18/%E4%B8%8D%E5%8F%98%E6%80%A7%E5%8E%9F%E7%90%86/1708427697880.png" alt="1708427697880.png"></p><p>可以知道系统状态方程是</p><script type="math/tex; mode=display">L\ddot{\phi}+gsin\phi=0</script><p>设</p><script type="math/tex; mode=display">x_1=\phi\\\\x_2=\dot{\phi}</script><p>得到</p><script type="math/tex; mode=display">\dot{x}_1=x_2\\\\\dot{x}_2=-\frac{g}{L}sinx_1</script><p>寻找李雅普诺夫函数，可以使用能量方程</p><script type="math/tex; mode=display">E=K动能+P势能\\\\=\frac{1}{2}mv^2+mgh=\frac{1}{2}m(L\dot{\phi})^2+mgL(1-cos\phi)</script><p>所以得到李雅普诺夫函数</p><script type="math/tex; mode=display">V(x)=\frac{1}{2}m(Lx_2)^2+mgL(1-cosx_1)</script><p>开始分析，看得出来</p><script type="math/tex; mode=display">V(0)=0</script><p>并且，对于任意 $x_1,x_2$，可以得到</p><script type="math/tex; mode=display">V(x)>0</script><p>是满足正定条件的</p><p>求导得到</p><script type="math/tex; mode=display">\dot{V}=\triangledown V f(x)=\begin{bmatrix}\frac{\partial V}{\partial x_1}&\frac{\partial V}{\partial x_2}\end{bmatrix}\begin{bmatrix}f_1\\f_2\end{bmatrix}=\begin{bmatrix}mgLsinx_1&mL^2x_2\end{bmatrix}\begin{bmatrix}x_2\\-\frac{g}{L}sinx_1\end{bmatrix}=0</script><p>所以满足半负定</p><script type="math/tex; mode=display">\dot{V}=0\leq 0</script><p>所以这个系统稳定，并且 $\dot{V}=0$ 表明这个系统能量不变</p><p>当引入阻力之后，可以得到</p><script type="math/tex; mode=display">mL\ddot{\phi}=-mgsin\dot{\phi}-kL\dot{\phi}\\\\V(x)=\frac{1}{2}m(Lx_2)^2+mgL(1-cosx_1)\\\\\dot{V}(x)=-kL^2x_2^2</script><p>在这里出现一个很离谱的情况，也就是 $\dot{V}(x)$ 在 $\begin{bmatrix}x_1&amp;0\end{bmatrix}$ 处总是为 0 的，这导致该函数并不是一个负定的，而是一个半负定系统。</p><p>这个系统是一个稳定系统，不是一个渐进稳定系统</p><p><strong>动机</strong></p><p>在上述的例子中</p><script type="math/tex; mode=display">mL\ddot{\phi}=-mgsin\dot{\phi}-kL\dot{\phi}\\\\V(x)=\frac{1}{2}m(Lx_2)^2+mgL(1-cosx_1)\\\\\dot{V}(x)=-kL^2x_2^2</script><p>所以可以得到</p><script type="math/tex; mode=display">V(0)=0~:~PD\\\\V(x)>0\\\\\dot{V}\leq 0~:~NSD</script><p>系统是一个稳定系统，但不是一个渐进稳定系统，根据物理学，这个系统最终会停下来，但是数学上并没有证明，所以引入<strong>不变性原理</strong>，用来<strong>扩大李雅普诺夫的判定</strong></p><p><strong>不变性原理</strong></p><ol><li>$V(x):PD$</li><li>$\dot{V}(x):NSD$</li><li>当且仅当 $X=0$ 时， $\dot{V}=0$</li></ol><p>所以就满足系统在平衡点渐进稳定</p><p><strong>例子</strong></p><p>对于上述的例子，已知 $V(x):PD,\dot{V}(x):NSD$</p><p>所以可以令 $\dot{V}=0$，此时 $x_2=0$。</p><p>当 $\dot{V}$ 恒为 0 时， $x_2$ 恒为 0，也就是 $\dot{x}_2$ 恒为 0</p><p>由于</p><script type="math/tex; mode=display">\dot{x}_2=-\frac{g}{L}sinx_1</script><p>所以 $x_1$ 恒为 0</p><p>也就证明了只有当 $X=0$ 时， $\dot{V}=0$，也就是系统是<strong>渐进稳定的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统稳定性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统的稳定性</title>
      <link href="/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
      <url>/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>稳定性：系统在离开平衡点之后的动态反应随时间不增加</p><h3 id="函数的一些知识"><a href="#函数的一些知识" class="headerlink" title="函数的一些知识"></a>函数的一些知识</h3><p><strong>PD 正定</strong></p><ul><li>$V(x)=0\ if\ and\ only\ if\ x=0$</li><li>$V(x)&gt;0\ if\ and\ only\ if\ x\neq 0$</li></ul><p><strong>PSD 半正定</strong></p><ul><li>$V(x)=0\ if\ and\ only\ if\ x=0$</li><li>$V(x)\geq0\ if\ and\ only\ if\ x\neq 0$</li></ul><p><strong>ND 负定</strong></p><ul><li>$V(x)=0\ if\ and\ only\ if\ x=0$</li><li>$V(x)&lt;0\ if\ and\ only\ if\ x\neq 0$</li></ul><p><strong>NSD 半负定</strong></p><ul><li>$V(x)=0\ if\ and\ only\ if\ x=0$</li><li>$V(x)\leq0\ if\ and\ only\ if\ x\neq 0$</li></ul><p><strong>平衡点</strong></p><p>对于一个函数满足</p><script type="math/tex; mode=display">\dot{x}=f(x)\\f(x=0)=0\\\downarrow\\\dot{x}_{x=0}=0</script><p>那就说这个 $x=0$ 点是该函数的一个<strong>平衡点</strong></p><p>如果此时的函数 V 满足</p><script type="math/tex; mode=display">V:PD\\\dot{V}:NSD\\\downarrow\\x=0是稳定点</script><script type="math/tex; mode=display">V:PD\\\dot{V}:ND\\\downarrow\\x=0是渐进稳定点</script><h3 id="李雅普诺夫函数的导数"><a href="#李雅普诺夫函数的导数" class="headerlink" title="李雅普诺夫函数的导数"></a>李雅普诺夫函数的导数</h3><p>对于一个系统来说，设定</p><script type="math/tex; mode=display">\dot{x}_1=f_1\\\dot{x}_2=f_2\\V=x_1^2+x_2^2</script><p>可以得到</p><script type="math/tex; mode=display">\dot{V}=\begin{bmatrix}\frac{\partial V}{\partial x_1}&\frac{\partial V}{\partial x_2}\end{bmatrix}\begin{bmatrix}f_1\\f_2\end{bmatrix}=\triangledown V f(x)=L_fV(x)</script><p>这个就是李雅普诺夫函数的导数</p><p><strong>例子</strong></p><p>对于一个简单的倒立摆</p><p><img src="/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/1708427697880.png" alt="1708427697880.png"></p><p>可以知道系统状态方程是</p><script type="math/tex; mode=display">L\ddot{\phi}+gsin\phi=0</script><p>设</p><script type="math/tex; mode=display">x_1=\phi\\x_2=\dot{\phi}</script><p>得到</p><script type="math/tex; mode=display">\dot{x}_1=x_2\\\dot{x}_2=-\frac{g}{L}sinx_1</script><p>寻找李雅普诺夫函数，可以使用能量方程</p><script type="math/tex; mode=display">E=K动能+P势能\\=\frac{1}{2}mv^2+mgh=\frac{1}{2}m(L\dot{\phi})^2+mgL(1-cos\phi)</script><p>所以得到李雅普诺夫函数</p><script type="math/tex; mode=display">V(x)=\frac{1}{2}m(Lx_2)^2+mgL(1-cosx_1)</script><p>开始分析，看得出来</p><script type="math/tex; mode=display">V(0)=0</script><p>并且，对于任意 $x_1,x_2$，可以得到</p><script type="math/tex; mode=display">V(x)>0</script><p>是满足正定条件的</p><p>求导得到</p><script type="math/tex; mode=display">\dot{V}=\triangledown V f(x)=\begin{bmatrix}\frac{\partial V}{\partial x_1}&\frac{\partial V}{\partial x_2}\end{bmatrix}\begin{bmatrix}f_1\\f_2\end{bmatrix}=\begin{bmatrix}mgLsinx_1&mL^2x_2\end{bmatrix}\begin{bmatrix}x_2\\-\frac{g}{L}sinx_1\end{bmatrix}=0</script><p>所以满足半负定</p><script type="math/tex; mode=display">\dot{V}=0\leq 0</script><p>所以这个系统稳定，并且 $\dot{V}=0$ 表明这个系统能量不变</p><p>当引入阻力之后，可以得到</p><script type="math/tex; mode=display">mL\ddot{\phi}=-mgsin\dot{\phi}-kL\dot{\phi}\\V(x)=\frac{1}{2}m(Lx_2)^2+mgL(1-cosx_1)\\\dot{V}(x)=-kL^2x_2^2</script><p>在这里出现一个很离谱的情况，也就是 $\dot{V}(x)$ 在 $\begin{bmatrix}x_1&amp;0\end{bmatrix}$ 处总是为 0 的，这导致该函数并不是一个负定的，而是一个半负定系统。</p><p>这个系统是一个稳定系统，不是一个渐进稳定系统</p><h2 id="李雅普诺夫稳定性"><a href="#李雅普诺夫稳定性" class="headerlink" title="李雅普诺夫稳定性"></a>李雅普诺夫稳定性</h2><p><a href="https://blog.csdn.net/sheagu/article/details/108113576">李雅普诺夫（第二方法）稳定性</a></p><p><a href="https://zhuanlan.zhihu.com/p/58738073">如何理解李雅普诺夫稳定性分析</a></p><p>主要是用来判断一个系统是否能稳定</p><h3 id="平衡点"><a href="#平衡点" class="headerlink" title="平衡点"></a>平衡点</h3><p>一个控制系统最重要的问题就是稳定性的问题。稳定性就是一个系统在收到扰动之后能否有能力在平衡状态继续工作。平衡点就是系统状态不再发生状态的点，可能不止一个，也可能很脆弱稍微有点扰动就不再平衡了。实际上系统状态稳定的点应该是导数为0的点，也就是让系统状态方程的所有状态的导数为0，即变化率为0。</p><h3 id="李雅普诺夫稳定"><a href="#李雅普诺夫稳定" class="headerlink" title="李雅普诺夫稳定"></a>李雅普诺夫稳定</h3><ul><li>如果平衡状态受到扰动之后，仍然停留在平衡状态点附近，即该平衡点在李雅普诺夫意义下是稳定的</li><li>如果平衡状态受到扰动之后，最终都会收敛到该平衡点处，即该平衡点在李雅普诺夫意义下是渐进稳定的</li><li>如果平衡状态受到任何扰动之后最终都会收敛到该平衡点处时，即该平衡点咋子李雅普诺夫意义下是大范围渐进稳定的</li><li><p>如果平衡状态受到某种扰动之后状态开始偏离平衡点，就称该点在李雅普诺夫意义下是不稳定的</p><p>  <img src="/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/v2-4ac6a500e089aab5a4eb6965938a62cf_720w.webp" alt="v2-4ac6a500e089aab5a4eb6965938a62cf_720w.webp"></p></li></ul><h3 id="李雅普诺夫第一法"><a href="#李雅普诺夫第一法" class="headerlink" title="李雅普诺夫第一法"></a>李雅普诺夫第一法</h3><p>需要将非线性系统在平衡态附近线性化，然后讨论线性化系统的特征值分布来研究原非线性系统的稳定性问题。称之为间接法</p><p>需要求解微分方程才能证明</p><h3 id="李雅普诺夫第二法"><a href="#李雅普诺夫第二法" class="headerlink" title="李雅普诺夫第二法"></a>李雅普诺夫第二法</h3><p>稳定的系统能量总是不断被耗散的，李雅普诺夫通过定义一个标量函数 $V(x)$（通常能代表广义能量）来分析稳定性。这种方法的避免了直接求解方程，也没有进行近似线性化，所以也一般称之为直接法。</p><p>如果该标量函数满足：</p><ul><li>$V(x)=0\ if\ and\ only\ if\ x=0$</li><li>$V(x)&gt;0\ if\ and\ only\ if\ x\neq 0$</li><li>$\dot{V(x)}=\frac{d}{dt}V(x)=\sum_{i=1}^{n}\frac{\partial V}{\partial x_i}f(x_i) \leq 0\ when\  x\neq 0$</li></ul><p>则该系统在李雅普诺夫意义下是稳定的，特别的，当 $\dot{V(x)}&lt;0$ 则该系统是渐进稳定的</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在判断一个系统稳定性方面很有用。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>很多时候李亚普诺夫函数是凭着经验的猜测。对于一个陌生的控制系统很难构建一个李亚普诺夫函数去证明这个系统的稳定性</p><p>对于一个线性时不变系统 LTI</p><div class="table-container"><table><thead><tr><th>稳定性</th><th>λ=a+bi</th></tr></thead><tbody><tr><td>李雅普诺夫稳定性</td><td>所有特征值只有非正的实部</td></tr><tr><td>渐进稳定性</td><td>所有特征值只有负的实部</td></tr><tr><td>不稳定</td><td>所有特征值有正的实部</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统稳定性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统的可控性</title>
      <link href="/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E6%8E%A7%E6%80%A7/"/>
      <url>/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E6%8E%A7%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>对于一个系统状态方程</p><script type="math/tex; mode=display">\dot{X}=AX+Bu</script><p>离散型与连续型是一样的</p><script type="math/tex; mode=display">X_{k+1}=AX_k+Bu_k</script><script type="math/tex; mode=display">X_{1}=AX_0+Bu_0\\\\X_2=AX_1+Bu_1=A^2X_0+ABu_0+Bu_1\\\\\dots\\\\X_n=AX_{n-1}+Bu_{n-1}=A^nX_0+A^{n-1}Bu_0+\dots+ABu_{n-2}+Bu_{n-1}</script><p>转化为矩阵形式</p><script type="math/tex; mode=display">X_n=\begin{bmatrix}B&AB&A^{n-1}B&A^n\end{bmatrix}\begin{bmatrix}u_{n-1}\\u_{n-2}\\\dots\\u_0\\X_0\end{bmatrix}</script><p>想要实现该方程中 $u$ 有解，需要保证系数矩阵行满秩，也就是可控，一般来说初始状态 $X_0=0$，所以上式可以写作</p><script type="math/tex; mode=display">X_n=\begin{bmatrix}B&AB&A^{n-1}B\end{bmatrix}\begin{bmatrix}u_{n-1}\\u_{n-2}\\\dots\\u_0\end{bmatrix}</script><p>但是这里所说的系统可控并不能使系统从一点直接到另一点，只能沿着特定的轨迹来运行到下一个点，并不能控制轨迹，这个系数矩阵可以定义为</p><script type="math/tex; mode=display">Co=\begin{bmatrix}B&AB&A^{n-1}B\end{bmatrix}</script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统可控性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hamilton Matrix and Equation</title>
      <link href="/Blog_ButterFly/2024/03/18/Hamilton-Matrix-and-Equation/"/>
      <url>/Blog_ButterFly/2024/03/18/Hamilton-Matrix-and-Equation/</url>
      
        <content type="html"><![CDATA[<p>最优化问题求解中的汉密尔顿方程是最优控制方法解决动态优化问题的一阶必要条件</p><p><a href="https://zhuanlan.zhihu.com/p/436150206">汉密尔顿方程（Hamilton Equation）</a></p><h3 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h3><p>首先看需要解决的问题</p><script type="math/tex; mode=display">max\int_{t_0}^{t_1}f(x,u)dt\\\\\dot{x}=g(x,u)\\\\x(t_0)=x_0\\\\x(t_1):free</script><p>引入一个函数 $\lambda (t)$ 表示一个定义在 $t_0\leq t\leq t_1$ 上的连续的可微函数，那么对于任何满足上述约束的 $x(t),u(t)$ 有</p><script type="math/tex; mode=display">\int_{t_0}^{t_1}f(x,u)dt=\int_{t_0}^{t_1}[f(x,u)+\lambda g(x,u)-\lambda \dot{x}]dt</script><p>对上式最右侧右侧部分进行分部积分可以得到</p><script type="math/tex; mode=display">-\int_{t_0}^{t_1}\lambda \dot{x}dt=-\lambda(t_1)x(t_1)+\lambda (t_0)x(t_0)+\int_{t_0}^{t_1}x\dot{\lambda}dt</script><p>将上式带回原来的方程</p><script type="math/tex; mode=display">\int_{t_0}^{t_1}f(x,u)dt=\int_{t_0}^{t_1}[f(x,u)+\lambda g(x,u)+\dot{\lambda} x]dt-\lambda(t_1)x(t_1)+\lambda (t_0)x(t_0)</script><p>在最优控制方法中，可以发现，只要确定了控制，系统状态自然就被确定了，这个是由函数 $g(x,u)$ 确定，所以问题变为求解最优的控制 $u^\star $</p><p>引入一个扰动项函数 $h(t)$ 是任意的但是人为给定，令</p><script type="math/tex; mode=display">u=u^\star +ah</script><p>并且定义函数 $y(t,a)$ 为关于 $u^\star +ah$ 的状态变量，并且满足</p><script type="math/tex; mode=display">y(t,0)=x^\star \\\\y(t_0,a)=x_0</script><p>之前的目标函数可以写作为</p><script type="math/tex; mode=display">\int_{t_0}^{t_1}f(y(t,a),u^\star +ah)dt</script><p>并且得到</p><script type="math/tex; mode=display">J(a)=\int_{t_0}^{t_1}f(y,u^\star +ah)dt=\int_{t_0}^{t_1}[f(y,u^\star +ah)+\lambda g(y,u^\star +ah)+\dot{\lambda} y]dt-\lambda(t_1)y(t_1,a)+\lambda (t_0)y(t_0,a)</script><p>由于 $u^\star $ 是最优控制变量，所以该函数在 $a=0$ 处取得最大值，也就是 $\dot{J}(0)=0$，也就是</p><script type="math/tex; mode=display">\dot{J}(0)=\int_{t_0}^{t_1}[(f_x+\lambda g_x+\dot{\lambda})y_a+(f_u+\lambda g_u)h]dt-\lambda (t_1)y_a(t_1,0)</script><p>由于 $y(t_0,a)$ 是常数，所以 $y_a(t_0,0)=0$</p><p>上式中难以确定的是 $y_a$ ，因为不知道 $y(t,a)$ 的具体形式，但是可以通过构造 $\lambda$ 来消去含有 $y$ 的项，定义</p><script type="math/tex; mode=display">\dot\lambda=-[f_x(x^\star ,u^\star )+\lambda g_x(x^\star ,u^\star )]\\\lambda(t_1)=0</script><p>所以因此可以得到</p><script type="math/tex; mode=display">\int_{t_0}^{t_1}-[f_u(x^\star ,u^\star )+\lambda g_u(x^\star ,u^\star )]hdt=0</script><p>并且对于任意连续的 $h$ 都成立，所以令</p><script type="math/tex; mode=display">h=f_u(x^\star ,u^\star )+\lambda g_u(x^\star ,u^\star )</script><p>得</p><script type="math/tex; mode=display">\int_{t_0}^{t_1}-[f_u(x^\star ,u^\star )+\lambda g_u(x^\star ,u^\star )]^2dt=0</script><p>即</p><script type="math/tex; mode=display">f_u(x^\star ,u^\star )+\lambda g_u(x^\star ,u^\star )=0~~t_0\leq t\leq t_1</script><p>也就是说，如果 $u^\star ,x^\star $ 是最优解，存在一个连续函数 $\lambda(t)$ ，他们同时满足</p><script type="math/tex; mode=display">State~Equation:\\\dot{x}=g(x,u)\\x(t_0)=x_0\\Multiplier~Equation:\\\dot\lambda=-[f_x(x^\star ,u^\star )+\lambda g_x(x^\star ,u^\star )]\\\lambda(t_1)=0\\Optimality~Equation:\\f_u(x^\star ,u^\star )+\lambda g_u(x^\star ,u^\star )=0</script><p>这就是汉密尔顿方程，普遍的表达形式为</p><script type="math/tex; mode=display">H(t,x(t),u(t),\lambda(t))=f(t,x,u)+\lambda g(t,x,u)</script><p>并且方程满足</p><script type="math/tex; mode=display">\frac{\partial H}{\partial u}=f_u+\lambda g_u=0\\\\-\frac{\partial H}{\partial x}=-(f_x+\lambda g_x)=\dot\lambda\\\\\frac{\partial H}{\partial \lambda}=g=\dot{x}</script><p>求解：</p><script type="math/tex; mode=display">State~Equation:\\\\\dot{x}=g(x,u)\\\\x(t_0)=x_0\\\\Multiplier~Equation:\\\\\dot\lambda=-[f_x(x^\star ,u^\star )+\lambda g_x(x^\star ,u^\star )]\\\\\lambda(t_1)=0\\\\Optimality~Equation:\\\\f_u(x^\star ,u^\star )+\lambda g_u(x^\star ,u^\star )=0</script><p>根据 $Optimality~Equation$ 可以得到 $u$ 关于 $x$ 和 $\lambda$ 的方程，然后带入 $Multiplier~Equation$ 和 $State~Equation$ 中可以得到两个微分方程，并且注意两个边界条件，这就可以解出两个微分方程，从而求解</p><p>对于方程最大值问题，还要求解 $H_{uu}(t,x^\star ,u^\star ,\lambda)\leq 0$，对于最小值，需要保证 $H_{uu}(t,x^\star,u^\star,\lambda)\geq 0$</p><p><strong>求解例子</strong></p><p>对于一个系统</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu\\y=Cx\\J=\frac{1}{2} x(t_f)^TSx(t_f)+\frac{1}{2}\int_{0}^{t_f}{[x^TQx+u^TRu]}dt</script><p>求解 $min~J$ 相当于求解 $min~\int_{0}^{t_f}{[x^TQx+u^TRu]}dt$</p><p>所以引入 $hamilton$ 函数</p><script type="math/tex; mode=display">H(t,x,u)=x^TQx+u^TRu+\lambda^T(Ax+Bu)</script><script type="math/tex; mode=display">\frac{\partial H}{\partial u}=(R+R^T)u+B^T\lambda=0\\\\\Downarrow\\\\u=-(R+R^T)^{-1}B^T\lambda</script><script type="math/tex; mode=display">-\frac{\partial H}{\partial x}=-(f_x+\lambda g_x)=-[(Q+Q^T)x+A^T\lambda]=\dot\lambda\\\\\frac{\partial H}{\partial \lambda}=g=Ax+Bu=Ax-B(R+R^T)^{-1}B^T\lambda=\dot{x}</script><p>由于我们设定 $u=-Kx$，所以可以知道 $\lambda=Px$，并且 $-(R+R^T)^{-1}B^TP=K$</p><p>带入上述的方程得到</p><script type="math/tex; mode=display">\dot\lambda=-[(Q+Q^T)x+A^T\lambda]=-(Q+Q^T+A^TP)x\\\\\dot{x}=Ax-B(R+R^T)^{-1}B^T\lambda=[A-B(R+R^T)^{-1}B^TP]x</script><p>联立得到</p><script type="math/tex; mode=display">\dot{\lambda}=\dot{P}x+P\dot{x}=[\dot{P}+P(A-B(R+R^T)^{-1}B^TP)]x=-(Q+Q^T+A^TP)x</script><p>所以得到</p><script type="math/tex; mode=display">\dot{P}+PA-PB(R+R^T)^{-1}B^TP+Q+Q^T+A^TP=0</script><p>令 $Q_1=Q+Q^T,Q_2=R+R^T$，得到</p><script type="math/tex; mode=display">\dot{P}+PA-PBQ_2^{-1}B^TP+Q_1+A^TP=0</script><p>最终得到一个 $Riccati$ 方程</p><h2 id="Hamiltonian-Matrix"><a href="#Hamiltonian-Matrix" class="headerlink" title="Hamiltonian Matrix"></a>Hamiltonian Matrix</h2><p>首先引入一种特殊的矩阵</p><script type="math/tex; mode=display">J=\begin{bmatrix}0&I\\-I&0\end{bmatrix}~~J\in R^{2n\times 2n}</script><p>这个矩阵具有如下性质</p><script type="math/tex; mode=display">J^T=-J\\J^{-1}=J^T\\J^TJ=I_{2n}\\J^TJ^T=-I_{2n}\\J^2=-I_{2n}\\detJ=\pm1</script><p>定义 $Hamiltonian~ matrix$</p><p>如果一个矩阵 $A=JS$，其中 $J$ 是上面的特殊矩阵， $S=S^T$，那么矩阵 $A$ 是一个 $Hamiltonian$ 矩阵</p><p>或者说，如果矩阵 $A$ 满足 $(JA)^T=JA$ ， $J$ 是上面的特殊矩阵，那么矩阵 $A$ 是一个 $Hamiltonian$ 矩阵</p><p><strong>性质</strong></p><ol><li>$A,B\in H^n ⇒ A+B\in H^n$</li><li>$A\in H^n ⇒ \alpha A\in H^n$</li><li>$\begin{bmatrix}A&amp;B\end{bmatrix}\in H^n⇒det\begin{bmatrix}A&amp;B\end{bmatrix}=AB-BA$</li><li>对于 $A\in H^n$，定义 $pA(x)$ 为矩阵 A 的特征多项式<ul><li>$pA(x)=pA(-x)$</li><li>$if~pA(c)=0,c\in R,then~pA(-c)=pA(\overline{c})=pA(-\overline{c})=0$</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Riccati方程</title>
      <link href="/Blog_ButterFly/2024/03/18/Riccati%E6%96%B9%E7%A8%8B/"/>
      <url>/Blog_ButterFly/2024/03/18/Riccati%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://zhuanlan.zhihu.com/p/33156814">第四讲：李群和李代数 - 知乎 (zhihu.com)</a></p><h3 id="辛矩阵"><a href="#辛矩阵" class="headerlink" title="辛矩阵"></a>辛矩阵</h3><p>数学中，辛矩阵是指存在一个 $2n\times 2n$ 的矩阵 M，使之满足</p><script type="math/tex; mode=display">M^T\Omega M=\Omega</script><p>其中 $M^T$ 为 M 的转置矩阵，而辛矩阵 $\Omega$ 是一个固定的可逆斜对称矩阵，这类矩阵在适当的变化后皆能表为</p><script type="math/tex; mode=display">\Omega=\begin{bmatrix}0&I\\-I&0\end{bmatrix}</script><p>或者</p><script type="math/tex; mode=display">\Omega=\begin{bmatrix}0&1\\-1&0\\&&...\\&&&0&1\\&&&-1&0\\\end{bmatrix}</script><p>两者的差异仅在于基的排列，其中 $I$ 是 $n\times n$ 的单位矩阵，此外 $\det\Omega=1$ 并且 $\Omega ^{-1}=-\Omega$</p><p><strong>性质</strong></p><ol><li>$\Omega^T=-\Omega=\Omega^{-1}$</li><li>$\Omega^T\Omega=\Omega\Omega^T=I$</li><li>$\Omega\Omega=-I$</li><li>$\det\Omega=1$</li></ol><h2 id="代数Riccati方程"><a href="#代数Riccati方程" class="headerlink" title="代数Riccati方程"></a>代数Riccati方程</h2><p>黎卡提方程是最简单的一类非线性方程。例如</p><script type="math/tex; mode=display">y' = P(x)y^2+Q(x)y+R(x)</script><p>是最优控制的非线性方程，和连续性时间或者是离散时间下无限时间的最优控制有关。</p><p>标准的Raccati方程分为两种：</p><ol><li><p>连续时间代数Riccati方程(CARE):</p><script type="math/tex; mode=display"> A^TP+PA-PBR^{-1}B^TP+Q=0</script></li><li><p>离散时间代数Riccati方程(DARE):</p><script type="math/tex; mode=display"> P=A^TPA-(A^TPB)(R+B^TPB)^{-1}(B^TPA)+Q</script></li></ol><p>在无限时间的最佳控制问题中，关注的是一些变数在相当时间之后的数值，因此需要在现在选定的控制变数的数值，让系统在之后的时间都在最佳的状态下运作，控制变数在任意时间下的最佳值可以使用 Riccati 方程的解以及状态变数当时的观测值求得，若观测变数及控制变数都不止一个，Riccati 方程就会是矩阵方程</p><p>其中P 是未知数的n x n对称矩阵，A，B，Q及 R  是已知实系数矩阵。一般而言此方程式有许多的解，不过若有存在稳定解的话，希望可以找到稳定解。</p><p>若代数 Riccati 方程存在稳定解，求解器一般会设法找到唯一的稳定解。稳定解的意思是指用此解控制相关的 LQR 系统，可以使闭回路的系统稳定。</p><h3 id="连续时间代数Riccati方程-CARE"><a href="#连续时间代数Riccati方程-CARE" class="headerlink" title="连续时间代数Riccati方程(CARE)"></a>连续时间代数Riccati方程(CARE)</h3><p>针对连续时间代数的Riccati方程(CARE)，控制规律为：</p><script type="math/tex; mode=display">K=R^{-1}B^TP</script><p>带入 Riccati 方程</p><script type="math/tex; mode=display">A^TP+PA-PBK+Q=0</script><p>闭回路递移矩阵为：</p><script type="math/tex; mode=display">A-BK=A-BR^{-1}B^TP</script><p>稳定的充分必要条件是所有的特征值都有负的实部</p><h3 id="离散时间代数Riccati方程-DARE"><a href="#离散时间代数Riccati方程-DARE" class="headerlink" title="离散时间代数Riccati方程(DARE)"></a>离散时间代数Riccati方程(DARE)</h3><p>针对离散时间代数的Riccati方程(DARE)</p><script type="math/tex; mode=display">K=-(R+B^TPB)^{-1}B^TPA</script><p>带入 Riccati 方程</p><script type="math/tex; mode=display">P=A^TPA+A^TPBK+Q</script><p>闭回路递移矩阵为：</p><script type="math/tex; mode=display">A-BK=A-B(R+B^TPB)^{-1}B^TPA</script><p>稳定的充要条件是所有的特征值在复数平面的单位圆内</p><p>代数 Riccati 方程的解可以用 Riccati 方程的的迭代或是矩阵因式分解求得。离散时间问题的一种迭代方式是由有限时间问题下的动态 Riccati 方程，每一次迭代时，矩阵中的值都是从最终时间往前一段有限时间内的最佳解，若进行无限长的迭代。就会分敛到特定矩阵，是无限时间内的最佳解。</p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p><strong>迭代法</strong></p><p>给定初始值 $K_0,P_0$ 使之满足上述 Riccati 方程，不断迭代，公式为</p><script type="math/tex; mode=display">CARE:A^TP_k+P_kA-P_kBK_k+Q=0\\DARE:P_k=A^TP_kA+A^TP_kBK_k+Q\\K_k=R^{-1}B^TP_{k-1}</script><p>当 $K$ 和 $P$ 收敛时，得到最优控制策略，迭代一定次数，使得本次迭代的结果与上次的结果的差值在某个范围之内认为是收敛了，就是最终的解</p><p><strong>不变子空间法</strong></p><p>持续更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵求导和迹运算</title>
      <link href="/Blog_ButterFly/2024/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%92%8C%E8%BF%B9%E8%BF%90%E7%AE%97/"/>
      <url>/Blog_ButterFly/2024/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%92%8C%E8%BF%B9%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h2><p>对与矩阵 $X$, $A$, $U$, $V$</p><script type="math/tex; mode=display">\frac{dX^T}{X}=I\\\\\frac{dX}{X^T}=I\\\\\frac{dX^TA}{X}=A\\\\\frac{dAX}{X^T}=A\\\\\frac{dAX}{X}=A^T\\\\\frac{dXA}{X}=A^T\\\\\frac{dX^TX}{X}=2X\\\\\frac{dX^TAX}{X}=(A+A^T)X\\\\\frac{dX^TAX}{XX^T}=\frac{d}{dX}(\frac{dX^TAX}{dX})=A^T+A\\\\\frac{\partial U}{\partial X^T}=(\frac{\partial U^T}{\partial X})^T\\\\\frac{\partial U^TV}{\partial X}=\frac{\partial U^T}{\partial X}V+\frac{\partial V^T}{\partial X}U^T\\\\\frac{\partial UV^T}{\partial X}=\frac{\partial U}{\partial X}V^T+U\frac{\partial V^T}{\partial X}\\\\\frac{\partial [(XU-V)^T(XU-V)]}{\partial X}=2(XU-V)U^T\\\frac{\partial U^TXV}{\partial X}=UV^T\\\\\frac{\partial U^TX^TXU}{\partial X}=2XUU^T</script><p>对于一个 n 维的方程组 $f(x_1,x_2,,x_n)$，求解它的最小值需要</p><script type="math/tex; mode=display">\frac{\partial f}{\partial x_1}=0\\\\\frac{\partial f}{\partial x_2}=0\\\\\\\\\frac{\partial f}{\partial x_n}=0</script><p>所以可以定义一个矩阵方程，并且 $y\in R^{n\times1}$</p><script type="math/tex; mode=display">f(y)\\\\y=\begin{bmatrix}x_1\\x_2\\\\y_n\end{bmatrix}</script><p>则求导为</p><script type="math/tex; mode=display">\frac{\partial f}{\partial y}=\begin{bmatrix}\frac{\partial f}{\partial x_1}\\\\\\\\\frac{\partial f}{\partial x_n}\end{bmatrix}</script><p>最终的结果的行数与分母一致，所以这种布局表达形式被称作 <strong>分母布局（Denominator Layout）</strong></p><script type="math/tex; mode=display">\frac{\partial f}{\partial y}=\begin{bmatrix}\frac{\partial f}{\partial x_1}&&\frac{\partial f}{\partial x_n}\end{bmatrix}</script><p>最终的结果的行数与分子一致，所以这种布局表达形式被称作 <strong>分子布局（Numerator Layout）</strong></p><p>上述所说的求导是函数是一个 $1\times1$ 的形式的，对于 $m\times 1$ 的函数来说，求导的结果为</p><script type="math/tex; mode=display">f(y)=\begin{bmatrix}f_1\\f_2\\\\f_m\end{bmatrix}\\y=\begin{bmatrix}x_1\\x_2\\\\y_n\end{bmatrix}</script><script type="math/tex; mode=display">\frac{\partial f}{\partial y}=\begin{bmatrix}\frac{\partial f_1}{\partial x_1}&&\frac{\partial f_m}{\partial x_1}\\&&\\\frac{\partial f_m}{\partial x_n}&&\frac{\partial f_m}{\partial x_n}\end{bmatrix}</script><p>最终的结果是一个 $n\times m$ 的矩阵，行数与分母一致，所以这种布局表达形式被称作 <strong>分母布局（Denominator Layout）</strong></p><script type="math/tex; mode=display">\frac{\partial f}{\partial y}=\begin{bmatrix}\frac{\partial f_1}{\partial x_1}&&\frac{\partial f_1}{\partial x_n}\\&&\\\frac{\partial f_m}{\partial x_1}&&\frac{\partial f_m}{\partial x_n}\end{bmatrix}</script><p>最终的结果是一个 $m\times n$ 的矩阵，行数与分子一致，所以这种布局表达形式被称作 <strong>分子布局（Numerator Layout）</strong></p><p><strong>不同的布局形式导致结果互为转置，计算中应当保持一种矩阵运算的形式</strong></p><p>对于上述中求解最小/大值需要求导为 0，但是有些情况不能够实现，所以使用梯度下降法</p><p>定义梯度</p><script type="math/tex; mode=display">\triangledown y = \frac{\partial f}{\partial y}</script><p>定义一个初始的 $y=y^*$，不断迭代，直到最终值满意</p><script type="math/tex; mode=display">y^*=y^*-\alpha \triangledown y</script><p>其中 $\alpha$ 是学习率，也就是不断接近目标值的步长，而且可以是矩阵，对于不同的数据可以有不同的步长</p><h3 id="矩阵的链式求导"><a href="#矩阵的链式求导" class="headerlink" title="矩阵的链式求导"></a>矩阵的链式求导</h3><script type="math/tex; mode=display">函数f(y(u))\\\\\frac{\partial f}{\partial u}=\frac{\partial y}{\partial u}\frac{\partial f}{\partial y}</script><h2 id="迹运算"><a href="#迹运算" class="headerlink" title="迹运算"></a>迹运算</h2><h3 id="矩阵迹运算"><a href="#矩阵迹运算" class="headerlink" title="矩阵迹运算"></a>矩阵迹运算</h3><script type="math/tex; mode=display">tr~ABC=trCAB=trBCA\\\\tr~A=trA^T\\\\tr~aA=a~trA</script><h3 id="矩阵的迹对矩阵求偏导"><a href="#矩阵的迹对矩阵求偏导" class="headerlink" title="矩阵的迹对矩阵求偏导"></a>矩阵的迹对矩阵求偏导</h3><script type="math/tex; mode=display">\nabla_AtrAB=B^T\\\\\nabla_{A^T}f(A)=(\nabla_{A}f(A))^T\\\\\nabla_AtrABA^TC=CAB+C^TAB^T\\\\\nabla_A|A|=|A|(A^{-1})^T\\\\\nabla_AtrA^TB=B\\\\\nabla_AtrA^TBA=(B+B^T)A\\\\\nabla_AtrABA^T=A(B+B^T)</script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统离散化</title>
      <link href="/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/Blog_ButterFly/2024/03/18/%E7%B3%BB%E7%BB%9F%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="连续时间系统"><a href="#连续时间系统" class="headerlink" title="连续时间系统"></a><strong>连续时间系统</strong></h3><p>一般来说系统的状态变化都是连续的</p><h3 id="离散时间系统"><a href="#离散时间系统" class="headerlink" title="离散时间系统"></a>离散时间系统</h3><p>数字控制器，有时候计算时需要将系统的状态离散化，控制器是离散的输出。这就需要将离散系统和连续系统结合起来，需要用到一些模块。首先是通过ADC将传感器信号采样并转化为离散输出，同时其他的参数都将是离散的形式。随后控制器的输出将会通过DAC转化为连续的系统输出，控制量的输出需要使用到保持器来保证在一个控制周期之内的控制量保持不变。</p><p>对于采样，采样频率太快会使数据堆积，需要大量的存储数据，采样频率太小，小于控制周期，会产生误差，采样频率一般采用被采样数据频率的2倍甚至是5-10倍，如果在中断中采样并且处理数据的话，采样周期一定要大于处理所用的时间，否则这段期间内的采样就没有了意义。</p><p>有时候会把连续系统近似为离散的系统之后设计算法来控制系统，连续系统与离散系统的转换</p><h3 id="采样周期的选取"><a href="#采样周期的选取" class="headerlink" title="采样周期的选取"></a>采样周期的选取</h3><ul><li>一般来说肯定是采样周期越小越好 $T→0 \Rightarrow y[k]\rightarrow y(t)$，需要存储大量数据，内存占用多</li><li>$T\uparrow$ 会导致产生混叠，根据采样定理，采样频率至少为信号最高频率的2倍，一般选择5~10倍</li></ul><p>对于实时控制器来说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[中断]--&gt;B[读取数据]--&gt;C[计算]--&gt;D[输出控制量]--&gt;A</span><br></pre></td></tr></table></figure><p>读取数据，计算和输出控制量需要在一个采样周期内完成</p><ul><li>测量频率太低，会忽略掉很多系统变化的数据，输出的控制量也就跟不上实际的情况</li><li>测量频率过高，会产生两个问题，可能会采集到大量的重复信息，无法实施计算好的控制量</li></ul><h3 id="控制器的设计"><a href="#控制器的设计" class="headerlink" title="控制器的设计"></a>控制器的设计</h3><p>将连续的系统近似转化成离散系统之后，直接使用离散系统中设计的控制器来进行分析，最后再运用到混合系统中</p><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>对于系统</p><script type="math/tex; mode=display">\dot{x(t)}=Ax(t)+Bu(t)</script><p>解为</p><script type="math/tex; mode=display">x(t)=e^{A(t-t_0)}x(t_0)+\int_{t_0}^te^{A(t-\tau)}Bu(\tau)d\tau</script><p>一般会使用零阶保持器，所以可以选取</p><script type="math/tex; mode=display">kT\leq t\leq (k+1)T\\u(\tau)=u(kT)</script><p>得</p><script type="math/tex; mode=display">x(t_{k+1})=e^{A(t_{k+1}-t_k)}x(t_k)+\int_{t_k}^{t_{k+1}}e^{A(t_{k+1}-\tau}Bu(\tau)d\tau</script><p>即</p><script type="math/tex; mode=display">x(t_{k+1})=e^{A(t_{k+1}-t_k)}x(t_k)+Bu(kT)\int_{t_k}^{t_{k+1}}e^{A(t_{k+1}-\tau}d\tau</script><p>可以写作</p><script type="math/tex; mode=display">x[k+1]=e^{AT}x[k]+Bu[k]\int_0^Te^{AT}d\tau</script><p>一般来说会对 $e^{AT}$ 进行泰勒展开</p><script type="math/tex; mode=display">e^{AT}=1+AT+\frac{A^2}{2!}T^2+...</script><p>相对来说会更精确一些</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传递函数和状态空间方程</title>
      <link href="/Blog_ButterFly/2024/03/18/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%92%8C%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E7%A8%8B/"/>
      <url>/Blog_ButterFly/2024/03/18/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%92%8C%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="状态空间"><a href="#状态空间" class="headerlink" title="状态空间"></a>状态空间</h2><p>对于一个系统的状态空间方程，可以使用 laplace 变换来得到系统的运行状态方程</p><p>状态空间方程——一个包含输入，输出，状态变量的集合的一阶微分方程，但是对于高阶的系统，可以选择合适的状态量来消除高阶的系数</p><p><strong>根据下式求出的状态空间方程中，对于矩阵 A 的特征值是决定系统极点的位置，可能会决定系统的稳定性</strong></p><h3 id="状态空间方程的解"><a href="#状态空间方程的解" class="headerlink" title="状态空间方程的解"></a>状态空间方程的解</h3><p>过程不再写了，直接结论</p><script type="math/tex; mode=display">X(t)=e^{A(t-t_0)}X(t_0)+\int_{t_0}^t{e^{A(t-\tau)}Bu(\tau)}d\tau</script><p>其中 $e^{A(t-t_0)}$ 是状态转移矩阵，表示系统状态转移变化的规律，是一个实时变化的矩阵，A 矩阵对其有着重要的作用，当 A 的特征值小于0时， $X(t)$ 是不断趋近于 0 的，是系统稳定性分析的一个重要方式，但是 A 矩阵的特征值中含有虚数就表示该系统是有震荡的（根据欧拉公式，引入虚数相当于是引入了 sint 和 cost，实际上是引入了震荡），要保证系统稳定，一定要保证特征值的实部小于零</p><p><img src="/Blog_ButterFly/2024/03/18/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%92%8C%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E7%A8%8B/1708342322241.png" alt="1708342322241.png"></p><p>第二项是一个卷积，表示输入与输出之间的动态变化的关系</p><h2 id="传递函数→状态空间方程"><a href="#传递函数→状态空间方程" class="headerlink" title="传递函数→状态空间方程"></a>传递函数→状态空间方程</h2><h3 id="一阶系统"><a href="#一阶系统" class="headerlink" title="一阶系统"></a>一阶系统</h3><p>假设传递函数为</p><script type="math/tex; mode=display">G(s)=\frac{Y(s)}{U(s)}=\frac{a_0}{b_0s+b_1}</script><p>可以写作</p><script type="math/tex; mode=display">Y(s)(b_0s+b_1)=a_0U(s)</script><p>即</p><script type="math/tex; mode=display">b_0\dot{y}+b_1y=a_0u</script><p>则可设</p><script type="math/tex; mode=display">x_1=y</script><p>则有</p><script type="math/tex; mode=display">\dot{x_1}=-\frac{b_1}{b_0}x_1+\frac{a_0}{b_0}u\\\\y=x_1</script><p>得到状态方程</p><script type="math/tex; mode=display">A=-\frac{b_1}{b_0}\\\\B=\frac{a_0}{b_0}\\\\C=1</script><h3 id="二阶系统"><a href="#二阶系统" class="headerlink" title="二阶系统"></a>二阶系统</h3><p>设传递函数为</p><script type="math/tex; mode=display">G(s)=\frac{Y(s)}{U(s)}=\frac{a_0s+a_1}{b_0s^2+b_1s+b_2}</script><p>写作</p><script type="math/tex; mode=display">Y(s)(b_0s^2+b_1s+b_2)=(a_0s+a_1)U(s)</script><script type="math/tex; mode=display">b_0\ddot{y}+b_1\dot{y}+b_2y=a_0\dot{x}+a_1{x}</script><p>令</p><script type="math/tex; mode=display">b_0\ddot{y_1}+b_1\dot{y_1}+b_2y_1=u\\\\y=a_0\dot{x_1}+a_1x_1</script><script type="math/tex; mode=display">\left\{\begin{aligned}&x_1=y_1\\&x_2=\dot{y_1}\end{aligned}\right.</script><script type="math/tex; mode=display">\left\{\begin{aligned}&\begin{bmatrix}\dot{x_1}\\\dot{x_2}\end{bmatrix}=\begin{bmatrix}0&1\\-\frac{b_2}{b_0}&-\frac{b_1}{b_0}\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\\\frac{1}{b_0}\end{bmatrix}u\\&y=\begin{bmatrix}a_1&a_0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}\end{aligned}\right.</script><p>则</p><script type="math/tex; mode=display">A=\begin{bmatrix}0&1\\-\frac{b_2}{b_0}&-\frac{b_1}{b_0}\end{bmatrix}\\\\B=\begin{bmatrix}0\\\frac{1}{b_0}\end{bmatrix}\\\\C=\begin{bmatrix}a_1&a_0\end{bmatrix}</script><h2 id="高阶系统"><a href="#高阶系统" class="headerlink" title="高阶系统"></a>高阶系统</h2><script type="math/tex; mode=display">G(s)=\frac{Y(s)}{X(s)}=\frac{\sum_{i=0}^{N-1}a_is^i}{\sum_{i=0}^{N}b_is^i}</script><p>则</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\dot{X}=AX+BU\\&Y=CX\end{aligned}\right.</script><p>其中</p><script type="math/tex; mode=display">A=\begin{bmatrix}0&1&0&&0\\0&0&1&&0\\\\0&0&0&&1\\-\frac{b_0}{b_N}&-\frac{b_1}{b_N}&-\frac{b_2}{b_N}&&-\frac{b_{N-1}}{b_N}\end{bmatrix}\\\\B=\begin{bmatrix}0\\0\\\\\frac{1}{b_N}\end{bmatrix}\\\\C=\begin{bmatrix}a_0&a_1&a_2&&a_{N-1}\end{bmatrix}</script><h2 id="状态空间方程→传递函数"><a href="#状态空间方程→传递函数" class="headerlink" title="状态空间方程→传递函数"></a>状态空间方程→传递函数</h2><p>对于一个状态空间方程</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\dot{X}=AX+BU\\&Y=CX+Du\end{aligned}\right.</script><p>对方程两侧进行 laplace 变换，得</p><script type="math/tex; mode=display">L(\dot{X})=L(AX+Bu)\\\\sX(s)=AX(s)+Bu(s)\\\\(sI-A)X(s)=Bu(s)</script><p>其中 $I$ 是单位对角阵，所以可以得出</p><script type="math/tex; mode=display">X(s)=(SI-A)^{-1}Bu(s)</script><p>对另一个式子进行 laplace 变换得到</p><script type="math/tex; mode=display">L(Y)=L(CX+Du)\\\\Y(s)=CX(s)+Du(s)</script><p>带入得</p><script type="math/tex; mode=display">Y(s)=(C(SI-A)^{-1}B+D)u(s)</script><p>所以得到传递函数</p><script type="math/tex; mode=display">G(s)=C(sI-A)^{-1}B+D</script><h2 id="连续系统离散化"><a href="#连续系统离散化" class="headerlink" title="连续系统离散化"></a>连续系统离散化</h2><p>对于传递函数</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu</script><p>该系统进行离散化之后可以得到</p><script type="math/tex; mode=display">x(k+1)=\overline Ax(k)+\overline{B}u(k)</script><p>其中</p><script type="math/tex; mode=display">\overline{A}=e^{AT}\\\\\overline{B}=\int</script><p>对 $e^{AT}$ 进行泰勒级数展开，得到</p><script type="math/tex; mode=display">e^{AT}=I+AT+\frac{1}{2!}A^2T^2+</script><p>一般来说可以只取前三项</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统</title>
      <link href="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><p>切换窗口：Alt+Tab<br>窗口移动：Win+↑/↓/←/→</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>保存：Ctrl+S<br>关闭文件：Ctrl+W<br>撤销：Ctrl+Z<br>恢复：Ctrl+Shift+Z<br>复制/粘贴：Ctrl+C/V<br>向上/向下翻页：PageUp/PageDown<br>切换到左/右边的文件：Ctrl+PageUp/PageDown</p><h3 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h3><p>全选：Ctrl+A<br>选中：Shift+各种移动/跳转</p><h3 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h3><p>上/下/左/右移动光标：↑/↓/←/→<br>向上/下插入光标：Ctrl+Alt+↑/↓<br>在下一个匹配项处插入光标：Ctrl+D<br>查找/替换匹配项：Ctrl+F/H<br>全局查找/替换匹配项：Ctrl+Shift+F/H</p><h3 id="更改操作"><a href="#更改操作" class="headerlink" title="更改操作"></a>更改操作</h3><p>行删除：Shift+Delete<br>行上/下交换：Alt+↑/↓</p><h3 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h3><p>跳转到上/下个光标位置：Alt+←/→<br>跳转到词首/尾：Ctrl+←/→<br>跳转到行首/尾：Home/End<br>跳转到列首/尾：Ctrl+Home/End<br>跳转到行：Ctrl+G<br>跳转到括号：Ctrl+Shift+\<br>跳到定义：F12<br>查看定义：Alt+F12</p><h3 id="VSCode-其他操作"><a href="#VSCode-其他操作" class="headerlink" title="VSCode 其他操作"></a>VSCode 其他操作</h3><p>向右拆分编辑器：Ctrl+\<br>行注释：Ctrl+/<br>命令面板：F1 或 ctrl+shift+p<br>打开文件：F1，然后 Backspace<br>打开/关闭活动栏：Ctrl+B<br>打开/关闭面板：Ctrl+J<br>打开/关闭终端：Ctrl+`<br>查找活动栏/面板：Ctrl+Q</p><ol><li>ALT+Esc 可以使当前窗口最小化。</li><li>Win+D 最小化所有窗口，再按一下就可以还原窗口。</li><li>Windows+M：最小化所有窗口 。</li><li>Windows+Shift+M：还原最小化的窗口。</li><li>Alt+空格+N 最小化当前窗口（和浏览器的最小化一样）</li><li>ALT+TAB 这个是切换窗口的按钮，切换到另外一个窗口，这个窗口自然也可以最小化</li><li>crtl+tab 软件内切换窗口</li><li>ctrl+shift+c 在当前文件夹打开终端</li></ol><hr><h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><h3 id="编译器的处理过程"><a href="#编译器的处理过程" class="headerlink" title="编译器的处理过程"></a>编译器的处理过程</h3><h3 id="1-预处理-cpp-Pre-processor"><a href="#1-预处理-cpp-Pre-processor" class="headerlink" title="1. 预处理 (cpp) Pre-processor"></a>1. 预处理 (cpp) Pre-processor</h3><p>预处理器根据 # 开头的代码处理源文件，处理后能把源文件中引用的 .h 头文件插入源文件中，得到一个以 .i 结尾的文件。</p><h3 id="2-编译-ccl-compiler"><a href="#2-编译-ccl-compiler" class="headerlink" title="2. 编译 (ccl) compiler"></a>2. 编译 (ccl) compiler</h3><p>编译器把 .i 文件翻译为 .s 文件<br>包括：词法分析，语法分析，语义分析，中间代码生成，优化等<br><!-- 编译原理 --></p><h3 id="3-汇编-as-Assembler"><a href="#3-汇编-as-Assembler" class="headerlink" title="3. 汇编 (as) Assembler"></a>3. 汇编 (as) Assembler</h3><p>汇编器根据指令集将会变程序 .s 翻译为机器指令，也就是机器语言，生成可重定位 .o 文件</p><h3 id="4-链接-Id-Linker"><a href="#4-链接-Id-Linker" class="headerlink" title="4. 链接 (Id) Linker"></a>4. 链接 (Id) Linker</h3><p>链接器把多个 .o 文件按照一定的规则进行调整,最后得到可执行的文件</p><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><h3 id="cpu-的结构"><a href="#cpu-的结构" class="headerlink" title="cpu 的结构"></a>cpu 的结构</h3><h3 id="programe-count-pc"><a href="#programe-count-pc" class="headerlink" title="programe count (pc)"></a>programe count (pc)</h3><p>真实含义是一个字大小的存储区域<br>32-bits 4 byte   64-bits 8 byte<br>存放的是某一条指令的地址，处理时cpu执行pc上的指令，并且更新pc使其指向下一条要执行的指令</p><h3 id="寄存器文件-register-file"><a href="#寄存器文件-register-file" class="headerlink" title="寄存器文件 register file"></a>寄存器文件 register file</h3><p>cpu内部的一个存储设备，是由一些单字长的寄存器构成，每一个都有自己唯一的名字，一个临时存放变量的空间</p><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>例如计算 a+b 的值，会先把a，b的值存入寄存器，这将会覆盖寄存器原来的数值，然后再传入 ALU 中计算，最后返回值存入寄存器中，并且会把原来的值覆盖</p><h3 id="主存-内存"><a href="#主存-内存" class="headerlink" title="主存 (内存)"></a>主存 (内存)</h3><p>主要存放程序指令以及数据，是由随机动态存储器的芯片组成，可以看成从 0 开始的大数组每个字节都有相应的地址</p><h3 id="总线-I-O"><a href="#总线-I-O" class="headerlink" title="总线 I/O"></a>总线 I/O</h3><p>内存和处理器之间通过总线来进行数据传输，总线贯穿了整个计算机系统，负责将信息从一个部件传到另一个部件，通常被设计成传送固定长度的字节块(word)<br>还包括键盘，磁盘，鼠标，每个输入输出设备都通过一个控制器或者适配器都与I/O总线相连，控制器与适配器的主要区别主要是在于它们的封装方式，但是都是在I/O的设备之间传输数据的</p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>一般来讲，内存大的存储器存取数据较慢</p><h3 id="存储数据数量"><a href="#存储数据数量" class="headerlink" title="存储数据数量"></a>存储数据数量</h3><p>寄存器文件 100～1000B<br>L1 cache L1与访问寄存器一样快<br>L2 cache L2访问时间是L1的5倍<br>L3 cache L3比L2还慢<br>内存      1～100GB<br>磁盘      1～1000TB</p><h3 id="在寄存器和内存之间引入了高速缓存，一般有三级"><a href="#在寄存器和内存之间引入了高速缓存，一般有三级" class="headerlink" title="在寄存器和内存之间引入了高速缓存，一般有三级"></a>在寄存器和内存之间引入了高速缓存，一般有三级</h3><p>L1 cache L1与访问寄存器一样快<br>L2 cache L2访问时间是L1的5倍<br>L3 cache L3比L2还慢</p><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统可操控硬件，操作系统是应用程序与硬件之间的中间层，所有应用程序必须通过操作系统来对硬件进行操纵<br>目的：1. 防止硬件被失控的应用程序滥用</p><ol><li><p>操作系统提供统一的机制来控制这些底层的硬件<br>引入了几种抽象：</p></li><li><p>文件是对I/O设备的抽象</p></li><li>虚拟内存是对内存和I/O设备的抽象</li><li>进程是对处理器，内存，I/O设备的抽象</li><li>虚拟机是对整个计算机系统的抽象，包括操作系统及以上</li></ol><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>操作系统跟踪进程运行中所需要的所有状态信息，例如当前PC和寄存器的值，以及内存中的内容等</p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>从底到高，堆，最顶部区域是为内核保留的区域，对应用程序代码不可见</p><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><h3 id="在远程主机上运行程序"><a href="#在远程主机上运行程序" class="headerlink" title="在远程主机上运行程序"></a>在远程主机上运行程序</h3><p>客户端的软件通过网络将字符串发送到ssh服务端，ssh服务端接受到之后传递给远程主机上的shell程序，在运行</p><h3 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h3><p>当我们对系统的某一部分进行加速时，倍加速部分的重要性，和加速成都是影响整体系统性能的关键因素，如果我们想把计算机程序提升2倍甚至更多的速度，需要优化大部分组件<br>三种途径提高速度：</p><ol><li>线程级并发</li><li>指令级并行</li><li>单指令多数据并行</li></ol><h3 id="cpu核心"><a href="#cpu核心" class="headerlink" title="cpu核心"></a>cpu核心</h3><p>处理器芯片中有多个CPU核心，每个CPU核心都有自己的L1 cache和L2 cache，所有的核心共享L3 cache，集成在同一芯片上<br>单颗芯片集成的CPU数量高达几十个，甚至上百个<br>通过增加CPU核心数可增加计算机性能</p><h3 id="超线程-同时多线程"><a href="#超线程-同时多线程" class="headerlink" title="超线程(同时多线程)"></a>超线程(同时多线程)</h3><p>如果每个CPU可以执行两个线程，那4个就可以执行8个线程，<br>在CPU内部，程序计数器和寄存器文件有多个备份，浮点运算部件只有一份<br>常规单线程处理器在做线程切换时，大概需要20000个时钟周期，超线程处理器可以在单周期的基础上决定执行哪一个线程，在一个线程等待时，进行另一个程序</p><h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><p>处理器可以同时执行多条指令的属性称为指令级并行，每条指令从开始到结束需要20个时钟周期或者更多，处理器可以从同时处理多达100条指令，可以保持每个周期2～4条指令的执行速率</p><h3 id="单指令多数据并行"><a href="#单指令多数据并行" class="headerlink" title="单指令多数据并行"></a>单指令多数据并行</h3><p>现代处理器允许一条指令产生多个并行的操作<br>SIMD的指令多是为了提高处理视频，以及声音这类数据的执行速度</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-信息的存贮"><a href="#2-1-信息的存贮" class="headerlink" title="2.1 信息的存贮"></a>2.1 信息的存贮</h3><h3 id="虚拟空间地址"><a href="#虚拟空间地址" class="headerlink" title="虚拟空间地址"></a>虚拟空间地址</h3><p>在计算机中所有的地址按从0开始从大到小依次排序，所有的地址总和成为虚拟空间地址</p><h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><p>字节，一个字节有8位，采取二进制计数方式，取值范围在0~255之间<br>用16进制数来表示位模式 0~9+A~F，以0x开头<br>A: 10, 1010<br>C: 12, 1100<br>F: 15, 1111<br>16进制转2进制只需要每位展开为四位的二进制数就可以<br>二进制转化为十六进制，位数不足的补零</p><h3 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h3><p>字长，w位字长的虚拟地址空间就是(2^w-1)，<br>K = 2^10<br>M = 2^20<br>G = 2^30<br>T = 2^40<br>P = 2^50<br>E = 2^60<br>32位机器，最大为4GB，使用4字节的地址<br>64位机器，最大为16EB，使用8字节的地址<br>64位机器上可以生成32位机器上运行的程序:linux&gt;gcc -m32 -o hello32/64 hello.c<br>64位的程序只能在64位机器上，两种程序主要区别是两种程序是如何编译的</p><div class="table-container"><table><thead><tr><th>Signed</th><th>Unsigned</th><th>32-bit</th><th>64-bit</th></tr></thead><tbody><tr><td>char</td><td>unsigned char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>int32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>int64_t</td><td>8</td><td>8</td></tr><tr><td>char*</td><td></td><td>4</td><td>8</td></tr><tr><td>float</td><td></td><td>4</td><td>4</td></tr><tr><td>double</td><td></td><td>8</td><td>8</td></tr></tbody></table></div><h3 id="字符串的存储"><a href="#字符串的存储" class="headerlink" title="字符串的存储"></a>字符串的存储</h3><p>字符串以 null 结尾<br>逻辑移动和移动运算：算数右移：当最右端为0，右移补0，为1，右移补1。</p><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><h3 id="NOT-非"><a href="#NOT-非" class="headerlink" title="NOT(非)"></a>NOT(非)</h3><p>取反，就是0变为1，1变为0</p><h3 id="AND-与"><a href="#AND-与" class="headerlink" title="AND(与)"></a>AND(与)</h3><p>两个参数只有两个都为1时，与的结果才是1</p><h3 id="OR-或"><a href="#OR-或" class="headerlink" title="OR(或)"></a>OR(或)</h3><p>只有当两个参数都为0时，结果才是0</p><h3 id="EXCLUSIZE-OR-异或"><a href="#EXCLUSIZE-OR-异或" class="headerlink" title="EXCLUSIZE-OR(异或)"></a>EXCLUSIZE-OR(异或)</h3><p>只有当两个参数不同时，运算的结果才是1</p><h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><ul><li>按位与<br>就是转化为二进制数，每一个对应的位上进行与运算，每一位上得到的结果就是与运算的结果</li><li>按位或<br>就是转化为二进制数，每一个对应的位上进行或运算，每一位上得到的结果就是或运算的结果</li></ul><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul><li>!(非)<br>1变为0，0变为1</li><li>!!(就是两次非运算)</li><li>&amp;&amp;(逻辑与)<br>就是逻辑运算并且</li><li>||(逻辑或)<br>逻辑运算或者</li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul><li>左移 <code>&lt;&lt;</code></li><li>右移 <code>&gt;&gt;</code></li></ul><p>左移和右移，一般对有符号数进行算数右移，无符号数一定进行逻辑右移</p><ul><li>左移( <code>SAL k,D D&lt;&lt; k SHL k,D D&lt;&lt; k</code> )<br>就是丢弃最左端的一位，然后右端补零</li><li>逻辑右移( <code>SHR k,D D&gt;&gt;k</code> )<br>就是丢弃最右端的一位，然后左端补零</li><li>算数右移( <code>SAR k,D D&gt;&gt;k</code> )</li></ul><p>当最高位为1时，算数右移后，左端补1，最高位为0，和逻辑右移一样，算数右移保持了数据的正负不变<br>无符号数一定进行逻辑右移，有符号数进行算术右移</p><h3 id="数据存储排布方式"><a href="#数据存储排布方式" class="headerlink" title="数据存储排布方式"></a>数据存储排布方式</h3><p>arm架构的系统，双端法，可以配置为大端法或者小端法<br>大端法，最高有效字节存储在低地址        intel兼容机<br>小端法，最高有效字节存储在高地址        windows,ios</p><h3 id="2-2-整数的表示"><a href="#2-2-整数的表示" class="headerlink" title="2.2 整数的表示"></a>2.2 整数的表示</h3><h3 id="整数的编码"><a href="#整数的编码" class="headerlink" title="整数的编码"></a>整数的编码</h3><h3 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h3><p>8位的无符号数编码范围是0~255<br>无符号数的最大值:<br>w位时，最大值为 2^w-1</p><h3 id="有符号数的编码"><a href="#有符号数的编码" class="headerlink" title="有符号数的编码"></a>有符号数的编码</h3><p>采用<strong>补码</strong>的形式<br>有符号数用最高位来表示正负，最高位是1表示负数，最高位为0表示正数，用补码来表示有符号数，例如-1：1111， -8：1000<br>例如-1:1111，其实就是(-1) <em>2^3 + 1</em> 2^2 + 1 <em>2^1 + 1</em> 2^0;<br>8位可以表示的无符号数的范围是-128~127<br>无符号数的范围:<br>w位时，最大 2^(w-1)-1，最小 2^(w-1)<br>16位数:<br>无符号12345:   0011000000111001<br>有符号-12345:  1100111111000111<br>无符号53191:   1100111111000111<br>其实就是 53191 + 12345 = 2^16</p><h3 id="有符号数与无符号数的转换"><a href="#有符号数与无符号数的转换" class="headerlink" title="有符号数与无符号数的转换"></a>有符号数与无符号数的转换</h3><p><strong>有符号数强制转换为无符号数</strong>:位模式不变，但是解释这些位的方式变了<br>有符号数—&gt;无符号数:(w位)<br>x &lt; 0 : 2^w+x<br>x &gt; 0 : x<br>无符号数-&gt;有符号数:<br>最高位 = 0 : x<br>最低位 = 1 : x-2^w<br>C语言执行运算时，两个数字一个是有符号数，另一个数是无符号数，C语言就会把两数都转化为无符号数，就有可能出现 —1&gt;0 的现象</p><h3 id="在不同字长的整数之间的转换"><a href="#在不同字长的整数之间的转换" class="headerlink" title="在不同字长的整数之间的转换"></a>在不同字长的整数之间的转换</h3><ul><li>较大的数据类型转换为较小的数据类型:<br>保持数值不变是不可能的，在转换时，只会保留低位的数字，所以可能会改变它原来的数值<br>例如将w位截断为k位时，将会丢弃最高的w-k位，可以通过取模运算，其实就是原数除以2^k取余<br>有符号数的转换，也是先截断最低的k位，然后再转化为无符号数</li><li>较小的数据类型转换为较大的数据类型:<br>保持数值不变是可以的，<br>当无符号数在转换时，就需要补高位零扩展，就是高位补零。<br>0123-&gt;0000 0123<br>当有符号数的转换时，就需要符号位扩展，如果符号位是0，那么就高位补零，如果符号位是1，那就高位补1<br>1123-&gt;1111 1123 0123-&gt;0000 0123</li></ul><h3 id="2-3-整数的运算"><a href="#2-3-整数的运算" class="headerlink" title="2.3 整数的运算"></a>2.3 整数的运算</h3><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h3 id="无符号数加法的原理"><a href="#无符号数加法的原理" class="headerlink" title="无符号数加法的原理"></a>无符号数加法的原理</h3><p>例如 无符号数x，无符号数y<br>x+y<max(这个数据类型的最大值) : x+y>max : x+y-2^w  (发生溢出)<br>例如:1111 + 0001 = 1 0000 -&gt; 结果: 0000 (去掉最高位)<br>判断是否溢出: return sum&gt;=x 如果发生溢出，那就返回0，为发生溢出，返回1.发生溢出时，得到的数小于两者任意一个数</max(这个数据类型的最大值)></p><h3 id="有符号数加法"><a href="#有符号数加法" class="headerlink" title="有符号数加法"></a>有符号数加法</h3><p>例如 w位的x，y<br>x+y &gt; 2^(w-1)(正溢出) : x+y-2^w<br>-2^(w-1) &lt; x+y &lt; 2^(w-1) : x+y<br>x+y &lt; -2^(w-1) : x+y+2^w<br>例如: 0111 1111 + 0000 0001 = 1111 1111 (-128)<br>判断是否发生溢出:<br>x&gt;0,y&gt;0  x+y<0 (正溢出) x<0,y<0 x+y>0 (负溢出)</0></p><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>实际上就是加上相反数</p><h3 id="加法逆元"><a href="#加法逆元" class="headerlink" title="加法逆元"></a>加法逆元</h3><p>对于x，存在x1，使得 x+x1 = 0，x1为x的加法逆元，实际上x与x1互为相反数<br>对于无符号数x来说: x = 0, x1 = 0;  x&gt;0, x1 = 2^w-x  (实际上就是x+x1溢出)<br>对于有符号数x来说: x&gt;min, x1 =-x;  x =min, x1 = x<br>例如:1000 0000 + 1000 0000 = 1 0000 0000 (截取低八位为0)</p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h3 id="无符号数的乘法"><a href="#无符号数的乘法" class="headerlink" title="无符号数的乘法"></a>无符号数的乘法</h3><p>例如 w位的x，y<br>x<em>y可能会超出w位，那么结果就是取截低w位<br>x</em> y = x * y mode 2^w (取模)</p><h3 id="有符号数的乘法"><a href="#有符号数的乘法" class="headerlink" title="有符号数的乘法"></a>有符号数的乘法</h3><p>无论是无符号数的乘法，还是有符号数的乘法，运算结果的位级表示都是一样的<br>x <em>y = U-&gt;T(x</em> y mode 2^w) (取模之后再转化为有符号数)<br>对于位模式相同的数相乘，乘积结果的位级表示可能不同，但是最后截断的结果的位级表示是相同的<br>例如 101(5) <em>011(3)  = 001 111 -&gt; 111(7)<br>101(-3)</em> 011(3) = 110 111 -&gt; 111(-1)<br><strong>对于C语言来说，乘法可以转化为移位运算</strong><br>乘以2的幂: 111 <em>2^2 = 11100 相当于左移了两位, x</em>2^k =&gt; x &lt;&lt; k<br>乘以14: 14(0000 1110) <em>x = (2^3 +2^2 +2^1)</em> x =&gt; (x&lt;<3) + (x<<2) (x<<1) 或者>(16-2)*x = (x&lt;&lt;4)-(x&lt;&lt;1)</3)></p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>无符号数除法就是对应的右移操作，对于有符号数采用算数右移，无符号数采用逻辑右移，除法得到的结果总是向0舍入<br>有符号数(补码)的除法,当补码的最高位为1时，右移结果就和无符号数一样的，对于负数来讲:<br>例如:-12340 右移不同位数:</p><div class="table-container"><table><thead><tr><th>k位</th><th>-12340</th><th>浮点数结果</th><th>整数jieguo</th></tr></thead><tbody><tr><td>0位</td><td>1100 1111 1100 1100</td><td>-12340.0</td><td>-12340</td></tr><tr><td>1位</td><td>1110 0111 1110 0110</td><td>-6170.0</td><td>-6170</td></tr><tr><td>4位</td><td>1111 1100 1111 1100</td><td>-771.25</td><td>-772(向下舍入)/-771(期望)</td></tr><tr><td>8位</td><td>1111 1111 1100 1111</td><td>-48.203125</td><td>-49(向下舍入)/-48(期望)</td></tr><tr><td>需要加入偏置来修正不合适舍入</td><td></td><td></td><td></td></tr><tr><td>偏置(2^k-1)，只有负数有偏置</td><td></td><td></td><td></td></tr><tr><td>对于x/2^k:</td><td></td><td></td><td></td></tr><tr><td>x &lt; 0 : x = x + 2^k - 1, x &gt;&gt; k</td><td></td><td></td><td></td></tr><tr><td>x &gt; 0 : x &gt;&gt; k</td><td></td><td></td></tr></tbody></table></div><h3 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h3><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Screenshot_2023_1031_234028.png" alt="float"></p><p>总的浮点数表示方法是</p><p>$float=(1+\frac{M}{2^{23}}）2^{E-127}$</p><p>$double=(1+\frac{M}{2^{52}}）2^{E-1023}$</p><h3 id="含有小数值的二进制数"><a href="#含有小数值的二进制数" class="headerlink" title="含有小数值的二进制数"></a>含有小数值的二进制数</h3><p>小数点左边的是2的正幂，右边是2的负幂<br>$2^{-1}, 2^{-2}……$<br>单精度float 一般是32位:最高一位s表示符号，23~30位这八个二进制位与阶码的值是相关的，剩下0~22位与尾数m是相关的<br>双精度double 64位: 最高位表是符号，52~62位是阶码，阶码共有11位，剩下的0~51位为小数字段</p><h3 id="浮点数的数值"><a href="#浮点数的数值" class="headerlink" title="浮点数的数值"></a>浮点数的数值</h3><p>可分为三类，阶码的值决定了这个数属于哪一类</p><h3 id="规格化的值：当阶码的值不全为0也不全为1"><a href="#规格化的值：当阶码的值不全为0也不全为1" class="headerlink" title="规格化的值：当阶码的值不全为0也不全为1"></a>规格化的值：当阶码的值不全为0也不全为1</h3><ul><li><em>阶码部分</em><br>最小值为1，最大值为254，用e来表示阶码的这几个二进制数，E表示阶码的值<br>但是阶码的值不等于e的值，而是e的值减去一个偏置量，偏置量的值与阶码的位数相关 <strong>E =</strong> $e - bias$<br>$bias(float) = 2^{8-1}-1$<br>$bias(double) = 2^{11-1}-1$<br>$-126 &lt; E(float) &lt; 127$<br>$-1022 &lt; E(double) &lt; 1023$</li><li><em>小数部分</em><br>小数部分的值用f表示(小数值)<br>整个数字的值就是: M*2^E</li></ul><div class="table-container"><table><thead><tr><th></th><th>符号</th><th>阶码</th><th>小数</th><th>e</th><th>bias</th><th>E</th><th>2^E</th><th>f</th><th>M</th><th>Value</th></tr></thead><tbody><tr><td>最小</td><td>0</td><td>0001</td><td>000</td><td>1</td><td>127</td><td>-6</td><td>1/64</td><td>0</td><td>8/8</td><td>8/512</td></tr><tr><td></td><td>0</td><td>0001</td><td>001</td><td>1</td><td>127</td><td>-6</td><td>1/64</td><td>1/8</td><td>9/8</td><td>9/512</td></tr><tr><td>1</td><td>0</td><td>0111</td><td>000</td><td>7</td><td>127</td><td>0</td><td>1</td><td>0/8</td><td>8/8</td><td>1</td></tr><tr><td>最大</td><td>0</td><td>1110</td><td>111</td><td>14</td><td>127</td><td>7</td><td>128</td><td>7/8</td><td>15/8</td><td>240</td></tr><tr><td>尾数M被定义为(1+f)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h3 id="非规格化的值：当阶码全为0时为非规格化"><a href="#非规格化的值：当阶码全为0时为非规格化" class="headerlink" title="非规格化的值：当阶码全为0时为非规格化"></a>非规格化的值：当阶码全为0时为非规格化</h3><ul><li><em>提供了表示0的方法</em><br>当符号位为0，阶码字段，小数字段全为0时，此时表示正0<br>当符号位为1，阶码字段，小数字断全为0时，此时表示负0</li><li><em>可以表示非常接近0的数</em><br>当阶码字段全为0时，阶码<strong>E = 1-bias(偏置)</strong>，<strong>尾数 M = f</strong><br>整个数字的值就是:  $M * 2^E$</li></ul><div class="table-container"><table><thead><tr><th></th><th>符号</th><th>阶码</th><th>小数</th><th>e</th><th>bias</th><th>E</th><th>2^E</th><th>f</th><th>M</th><th>Value</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0000</td><td>000</td><td>0</td><td>127</td><td>-6</td><td>1/64</td><td>0</td><td>0</td><td>0</td></tr><tr><td>最小</td><td>0</td><td>0000</td><td>001</td><td>0</td><td>127</td><td>-6</td><td>1/64</td><td>1/8</td><td>1/8</td><td>1/512</td></tr><tr><td></td><td>0</td><td>0000</td><td>011</td><td>0</td><td>127</td><td>-6</td><td>1/64</td><td>3/8</td><td>3/8</td><td>3/512</td></tr><tr><td>最大</td><td>0</td><td>0000</td><td>111</td><td>0</td><td>127</td><td>-6</td><td>1/64</td><td>7/8</td><td>7/8</td><td>7/512</td></tr></tbody></table></div><h3 id="特殊值：当阶码全为1时，可分为两类：一类表示无穷大或者无穷小，另一类表示不是一个数"><a href="#特殊值：当阶码全为1时，可分为两类：一类表示无穷大或者无穷小，另一类表示不是一个数" class="headerlink" title="特殊值：当阶码全为1时，可分为两类：一类表示无穷大或者无穷小，另一类表示不是一个数"></a>特殊值：当阶码全为1时，可分为两类：一类表示无穷大或者无穷小，另一类表示不是一个数</h3><p>阶码字段全为1，小数字段为0时，是无穷大，符号位为1时为正无穷大，符号为0时为负无穷大<br>阶码全为1，小数字段不为0时，不是一个数(非实数)</p><p>int       12345    0x00003039     0000 0000 0000 0000 001<strong>1 0000 0011 1001</strong><br>float     12345.0  0x00e44046     0100 0110 0<strong>100 0000 1110 01</strong>00 0000 0000<br>两者有一段是相同的<br><strong>整形转化为浮点型</strong></p><p><code>int 12345 =  1100 0000 0011 1001 = 1.1 0000 0011 1001 * 2^&#123;13&#125;</code></p><p>则小数部分f为 1 0000 0011 1001</p><p>位数不够右端补零得到 1 0000 0011 1001 0000 0000 00  (float 23位，double 52位)</p><p>E = e - bias = 13 得 e = 140 = 1000 1100</p><p>浮点数为: 0100 0110 1000 0000 1110 0100 0000 0000<br>由于表示方法的原因，限制了浮点数的范围和精度，浮点运算只能近似的表示实数运算<br>对于一个浮点数，无法完全表示其精度，只能舍入到最接近的那一个<br>四种舍入方式:</p><ul><li>向偶数舍入: 总是朝向最接近的方向舍入，对于1.5和2.5这样的，就是朝向偶数，所以结果是2。还有就是看最低有效位，如果最低有效位为偶数，则向下舍入，如果最低有效位是基数，则向上计数。</li><li>向0舍入: 总是朝向0的方向</li><li>向下舍入: 总是朝向小的方向</li><li>向上舍入: 总是朝向大的方向<br><strong>浮点数的加法是不具有结合性的</strong><br>例: (3.14 + 1e10) - 1e10 = 0.0 再加上1e10时对结果舍入，3.14丢失<br>3.14 + (1e10 - 1e10) = 3.14<br><strong>浮点数的乘法也不具有结合性</strong><br>由于计算结果的溢出，会导致失去精度<br><strong>浮点数乘法也不具有分配律</strong><br>由于计算结果溢出</li></ul><h3 id="浮点数与整形之间的转换"><a href="#浮点数与整形之间的转换" class="headerlink" title="浮点数与整形之间的转换"></a>浮点数与整形之间的转换</h3><ol><li>int -&gt; float 数字不会发生溢出，但是可能会被舍入，由于float小数字段为23位，可能出现无法保留精度</li><li>int/float -&gt; double 由于double范围大，可以保留数值</li><li>double -&gt; float (1)发生数字溢出 (2)而且float的精度较小，可能会被舍入</li><li>float/double -&gt; int (1)值会向零舍入 (2)发生溢出</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-1-程序的机器级表示"><a href="#3-1-程序的机器级表示" class="headerlink" title="3.1 程序的机器级表示"></a>3.1 程序的机器级表示</h3><p><strong>gcc -Og -o prog main.c mstore.c</strong></p><ul><li>gcc是linux上的默认的编译器</li><li>Og就是告诉编译器生成符合原始c代码整体结构的机器代码,有时侯为了获取更高的性能，会使用-O1或者-O2，甚至更高的编译优化项，但是高级别优化产生的代码会严重变形</li><li>o后面的参数prog表示可以生成的可执行文件的文件名<br>在Intel x86-64的处理器中包含了16个通用目的寄存器，用于存放整数数据和指针<br>%rax %rbx %rcx %rdx %rsi %rdi %rbp %rsp %r8 %r9 %r10 %r11 %r12 %r13 %r14 %r16</li></ul><h3 id="Callee-saved-register-被调用者保存寄存器-amp-Caller-saved-register-调用者保存寄存器"><a href="#Callee-saved-register-被调用者保存寄存器-amp-Caller-saved-register-调用者保存寄存器" class="headerlink" title="Callee-saved register (被调用者保存寄存器) &amp; Caller-saved register (调用者保存寄存器)"></a>Callee-saved register (被调用者保存寄存器) &amp; Caller-saved register (调用者保存寄存器)</h3><p>例如，在程序A中调用了B，B被称为被调用者，A为调用者，逻辑上寄存器上的值在调用B前后应该保持一致</p><ul><li>有两个策略:</li></ul><ol><li>调用者保存，寄存器的值在调用函数中提前先保留原值，执行完函数B后，在恢复到原值</li><li>被调用者保存，寄存器的值在被调用函数中先保留原值，运行程序到结束时再恢复到原值<br>Callee saved: %rbx %rbp %rb12 %rb13 %rb14 %rb15<br>Caller saved: %rax %r10 %r11 %rsi %rdi %rdx %rcx %r8 %r9<br>这些策略都是为了提高性能</li></ol><h3 id="汇编后缀"><a href="#汇编后缀" class="headerlink" title="汇编后缀"></a>汇编后缀</h3><p>表示操作数的大小</p><div class="table-container"><table><thead><tr><th>类型</th><th>汇编后缀</th><th>大小</th></tr></thead><tbody><tr><td>char:</td><td>b</td><td>1</td></tr><tr><td>short:</td><td>w</td><td>2</td></tr><tr><td>int:</td><td>l</td><td>4</td></tr><tr><td>long:</td><td>q</td><td>8</td></tr><tr><td>char*:</td><td>q</td><td>8</td></tr><tr><td>float:</td><td>s</td><td>4</td></tr><tr><td>double:</td><td>l</td><td>8</td></tr></tbody></table></div><ul><li>数据传送指令<br>movb: move byte<br>movw: move word<br>movl: move double word<br>movq: move quaty word<br><strong>gcc -Og -c prog main.c mstore.c</strong><br>编译生成机器代码 (.o文件)<br><strong>objdump -d xx.o</strong><br>反汇编代码，通过命令可以查看xx.o中的相关信息，反汇编代码省略了汇编后缀，但在有些指令后面添加了汇编后缀</li></ul><h3 id="3-2-寄存器与数据传送指令"><a href="#3-2-寄存器与数据传送指令" class="headerlink" title="3.2 寄存器与数据传送指令"></a>3.2 寄存器与数据传送指令</h3><p>一般的程序中，不同的寄存器扮演着不同的角色<br>大部分代码包含两个部分，操作码(决定CPU执行的操做类型)和操作数(大多数指令都具有一个或者多个操作数)</p><h3 id="符号扩展位传送指令"><a href="#符号扩展位传送指令" class="headerlink" title="符号扩展位传送指令"></a>符号扩展位传送指令</h3><p>s是sign的缩写,最后两个字符也是大小指示符<br>movsbw   movsbl   movswl   movsbq   movswq   movslq   cltq = moveslq<br>一般的内存引用包括 4 个部分</p><ol><li>立即数</li><li>基址寄存器</li><li>变址寄存器</li><li>比例因子，也就是申请的数组的元素大小</li></ol><p>有效地址就是  $立即数 + 基址寄存器 + 变址寄存器 * 比例因子$</p><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p>%rax 64<br>%eax 32<br>%ax  16<br>%al  8<br>其实是同一寄存器对不同数位的元素处理的操作</p><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p><strong>一元操作指令</strong><br>只有一个操作数，既是源操作数，也是目的操作数<br>inc D D+1 increment(加1)<br>dec D D-1 decrement(减1)<br>neg D -D  Negate(取负)<br>not D ~D  Complement(取补)</p><p><strong>二元操作指令</strong><br>第一个操作数是源操作数，可以是立即数，寄存器，内存地址<br>第二个操作数既是源操作数，也是目的操作数，可以是寄存器，内存地址<br>ADD S,D D+S 加<br>SUB S,D D-S 减<br>IMUL S,D D*S 乘<br>XOR S,D D^S 异或<br>OR S,D D|S 或<br>AND S,D S&amp;D 与</p><p><strong>其他操作指令</strong><br>imulq s 有符号全乘法<br>mulq s 无符号全乘法<br>cqto 转换为八字<br>idivq s 有符号除法<br>divq s 无符号除法</p><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><p><strong>条件码寄存器</strong><br>条件码寄存器是由CPU来维护的，长度是 单个比特位，描述了最近执行操作的结果的属性，会被下一条指令覆盖<br>常用的条件码<br>CF Carry Flag (进位标志) 可以检查无符号数操作的溢出<br>ZF Zero Flag (零标志) 当最近操作结果为0时，会被置1<br>SF Sign Flag (符号标志) 当最近操作结果小于零时，会被置1<br>OF Overflow Flag (溢出标志) 针对有符号数，出现正溢出和负溢出都会被置1</p><p>条件码寄存器的值是由<em>ALU</em>在执行算数和运算指令时写入的，上面操作指令都会改变条件码寄存器的值，ALU运算结束后会改变目的寄存器的值<br><em>cmp 和 test</em> 指令都会设置条件码寄存器<br>cmp 根据两个操作数的差来设置条件码寄存器，但是只能设置条件码寄存器，不会更改目的寄存器的值<br>test 和 and 指令类似，只设置条件码寄存器，不改变目的寄存器的值<br><strong>条件码的使用</strong><br>例如:<br>判断 a &lt; b -条件&gt; SF ^ OF (异或)<br>case a &lt; b   t &lt; 0   SF = 1   SF ^ OF = 1<br>case a &gt; b   t &gt; 0   SF = 0   SF ^ OF = 0<br>case a &lt; b   t &lt; 0   a = -2   b = 127   SF = 0   OF = 1   SF ^ OF = 1<br>case a &gt; b   t &gt; 0   a = 1   b = -128   SF = 1   OF = 1   SF ^ OF = 0</p><p>其他比较运算也能通过条件码表示</p><script type="math/tex; mode=display">> D <- ~(SF^OF)&~ZF=   D <- ~(SF^OF)<   D <- SF^OF<=   D <- (SF^OF)|ZF></script><h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>在执行 if-else 和 while ,for ,switch 语句时，都会执行跳转，跳转指令比传送指令要快一点<br>while 和 for 循环语句只是在跳转指令不同，其他地方都一致<br>switch 跳转时，会生成一个链表，会把多种跳转形成一个表，把跳转表声明为长度为情况数量的数组，而且执行时间与 case 的数量无关</p><h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3><p>例如，函数P调用函数Q，函数Q执行完之后返回函数P<br>当函数Q正在执行时，函数P以及相关调用链上的函数都会被暂时挂起<br><strong>栈帧</strong><br>当函数执行所需要的存储空间超出寄存器所能存放的大小时，就会借助栈上的存储空间，这部分空间就是 栈帧，<br>当函数P调用函数Q时，会把返回地址压入栈中，该地址就是当函数P执行完之后，返回P函数该从那个位置开始执行，<br>这个操作不是由 push 执行的，而是函数调用指令 call 来执行的<br><em>参数传递</em> : 当一个函数的参数 (形参) 数量大于 6 时，超出的部分就要通过栈来传递，前 6 个参数的传递可以使用对应的寄存器来传递<br>当n非常大时，不建议使用递归调用函数</p><h3 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h3><p>指针就是地址的抽象表述<br>不同类型的指针在进行加法运算时，运动的内存字节数也是不同的，运算时，会对指针相应的类型进行伸缩<br><strong>嵌套数组</strong><br>对于二维数组，在内存中存放是按照行优先的规则的<br>$\&amp;D[i][j] = D + L(c*i+j)$<br>L 就是数组元素类型的大小<br>可以申请变长度数组:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">var_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n],<span class="type">long</span> i,<span class="type">long</span> j )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h3><p><strong>结构体</strong>中的元素的存储顺序是从上到下的，按声明的顺序<br>为了提高内存系统的性能，系统对于数据存储的合法地址做出了一些限制，例如 int 类型是4个字节，那么它的起始地址必须为4的整数倍，会对之前空缺的进行补齐<br>数据存储的原则: 对于任何 k 字节的数据，它的存储起始地址必须是 k 的倍数<br>结构体中的对齐要求: 结构体需要补充为字节数最多的元素类型的整数倍<br>在结构体的末端也可能需要对齐操作来填充</p><p><strong>联合体</strong><br>两个字段的使用是互斥的，就可以把这两个字段声明为一个联合体<br>联合体的大小就是联合体中最大元素的大小</p><p>在声明二叉树的时候，可以使用联合体，因为不会同时使用两个树叶，可以节省一半的空间，把同一树枝上的树叶声明为一个联合体<br>但是不能分清楚一个结点时叶子结点还是内部节点，<br>解决: 引入一个枚举类型，然后创建一个结构体，结构体包含一个标签和一个联合体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> enmu&#123;N_LEAF, N_INTERNAL&#125; <span class="type">nodetype_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">nodetype_t</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">left</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">right</span>;</span></span><br><span class="line">        &#125;internal;</span><br><span class="line">        <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">    &#125;info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h3><p>缓冲区溢出，就是后面输入的元素数量太多而把栈中后面的数据覆盖，导致程序运行错误，甚至会把 return 函数的返回内容覆盖<br><strong>应对缓冲区溢出的方法</strong></p><ol><li>栈随机化<br>栈的位置在程序每次运行时都会有变化，地址空间分布随机化， ASLR<br>每次运行时，程序的不同部分会被加载到不同的区域</li><li>栈破坏检测<br>编译器会在产生的汇编代码中加入一个栈保护者的机制来检测缓冲区越界，就是在缓冲区与栈保存的状态值之间存储一个特殊值，这个特殊值是程序运行时随机产生的，在函数返回之前检测特殊值是否被修改来判断是否遭受攻击，而且特殊值声明的时候被定义为只读</li><li>限制可执行代码区域<br>可以把栈标记为 可读可写但是不可执行 来防止外来插入的代码执行</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>指令系统结构<br>是计算机软件和硬件的交互接口<br>一个简单的指令系统 Y86</p><ul><li>各种状态单元</li><li>指令集及它们的编码</li><li>编程规范</li><li>异常事件处理</li></ul><p><strong>程序员的可见状态</strong><br>这里的程序员不仅包括写程序的人，也包括编译器，可见状态就是指每条指令都会区读取或者修改处理器的某些部分<br>寄存器 %rsp 定义为栈指针，其他的寄存器没有固定的含义<br>程序计数器 PC 就是用来存放当前正在执行指令的地址<br>状态码 stat 程序的执行状态</p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p><strong>硬件描述语言</strong></p><ul><li><a href="https://baike.baidu.com/item/Verilog%20HDL/596353?fromtitle=Verilog&amp;fromid=524752&amp;fr=aladdin">Verilog</a><br>Verilog 语言是并行执行的<br>C语言程序是串行执行的</li></ul><ol><li>assign 用于描述组合逻辑</li><li>always @(posedge clock) 用于描述时序逻辑， posedge clock 表示在始终上升沿的时候变化</li><li>模块调用语句</li></ol><ul><li><a href="https://baike.baidu.com/item/vhdl/105618?fr=aladdin">VHDL</a><br>VHDL主要用于描述数字系统的结构，行为，功能和接口。</li></ul><h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><p>实现所有 Y86-64 指令所需要的计算可以被组织为 6 个基本阶段</p><ol><li>取指阶段</li><li>译码阶段</li><li>执行阶段</li><li>访存阶段</li><li>写回阶段</li><li>更新PC</li></ol><h3 id="4-5-流水线"><a href="#4-5-流水线" class="headerlink" title="4.5 流水线"></a>4.5 流水线</h3><p>延迟就是一条指令从开始执行到结束所需要的时间，通常单位是 ps(皮秒)<br>单位时间内执行的指令数目被称为吞吐量<br>在使用流水线之前，程序是按照一条接着一条执行的<br>使用流水线之后可以使程序在执行某一条指令的中途执行下一条指令，原理是调用多个寄存器共同工作，会提高系统的吞吐量，但是会轻微增加延迟<br>把计算过程分成更多的阶段时，系统的吞吐量也就提高了，但是会导致系统性能的下降</p><h3 id="4-6-流水线的硬件结构"><a href="#4-6-流水线的硬件结构" class="headerlink" title="4.6 流水线的硬件结构"></a>4.6 流水线的硬件结构</h3><ol><li>取指阶段，将程序计数器PC的值作为地址，从指令内存中读取指令字节，第一个字节分成两部分，分别是指令代码icode和指令功能ifun，指明一个或者两个寄存器指示符(rA,rB)，还可能含有一个8字节的常数valc，pc增加器用来计算下一条指令的地址valp</li><li>译码阶段，一次译码可以同时读出两个寄存器的值，寄存器文件的读出端口与算术逻辑单元ALU的输入相连接</li><li>执行阶段，ALU会根据指令功能来执行指定的运算，从而得到运算结果valE，同时设置条件码寄存器CC，对于跳转指令，在执行阶段会根据条件码和跳转条件来产生信号Cnd<br>在这些阶段中，ALU不仅要实行算数逻辑指令，还要计算访存的有效地址以及针对栈指针的运算(加8和减8操作)，因此ALU的输出端口会与数据内存的地址逻辑单元相连</li><li>对于访存阶段，可以将数据写入内存或者从内存中读取数据，写入的数据可以是寄存器文件，也可以是指令中的常数字段</li><li>写回阶段，ALU的计算结果可以通过E端口写回到寄存器文件，端口M与数据内存的输入端相连，从内存中读取的数据可以从M端口写回到寄存器文件</li><li><p>更新PC的值，需要根据当前执行的指令和执行的状态来判断，如果是跳转指令，需要根据条件判断是否跳转，还有返回指令，是否产生异常信号</p><p> <img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1696224556821.png" alt="1696224556821.png"></p></li></ol><p>电路重定时改造，只改变系统的状态表示，并没有改变系统的逻辑行为</p><p><strong>电路重定时retiming：</strong>一种时序优化技术，用在不影响电路输入/输出行为的情况下跨组合逻辑寄存器从而提高设计性能。</p><p><strong>目的：</strong>Retiming就是重新调整时序，例如电路中遇到复杂的组合逻辑，延迟过大，电路时序不满足，这个时候采用流水线技术，在组合逻辑中插入寄存器加流水线，进行操作，面积换速度思想。</p><p><strong>原理：</strong>任何的数字电路都可以等效成组合逻辑加D触发器打拍，两个D触发器之间的组合逻辑路径决定了，系统的工作频率，决定芯片的性能。所以为了提高芯片的工作频率，使用流水线技术在组合逻辑中插入寄存器。插入寄存器的位置需要慎重选择，不同的位置数据的打拍所消耗的寄存器的数量也不同</p><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1696224765282.png" alt="1696224765282.png"></p><p>改造步骤，只需要在顺序阶段中的各个阶段之间插入流水线寄存器，然后对信号进行重新排列，就可以得到流水结构</p><h3 id="4-7-数据冒险"><a href="#4-7-数据冒险" class="headerlink" title="4.7 数据冒险"></a>4.7 数据冒险</h3><p>对于流水线中，比如下面的栗子，流水线中的指令执行顺序必须按照FDEMW顺序执行，所以会出现数据冒险和控制冒险等问题</p><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1696226674582.png" alt="1696226674582.png"></p><p>对于这些指令不具有相干性的，可以按照这样的顺寻执行</p><p>但是对于指令存在相关性的，按照这样的顺序执行的话，就会出现错误，原因是，寄存器内的数值改变在写回阶段才会赋值，而提前取指的话，就会得到寄存器的默认值0，出现错误的计算结果，这被称为冒险/冲突</p><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1696226745274.png" alt="1696226745274.png"></p><p>为了解决这种问题，就需要比较后面指令的源寄存器ID与先前指令的目的寄存器ID是否匹配，不匹配的话就可以继续执行，否则需要执行以下方法</p><ol><li>解决数据冲突的方法就是在addq的指令执行阶段延迟，可以在decode译码阶段插入几段气泡来延迟后面的执行，一直到irmovq指令完成写回操作。但是这种暂停会导致流水线的执行效率降低。频繁暂停指令的执行会降低流水线的吞吐量</li><li>数据转发/旁路，例如上面的例子，可以把movq的执行结果直接转发到addq的译码阶段，需要在计算机的硬件部分增加一些额外的数据连接和控制逻辑，只能在译码阶段读取到转发的数据</li></ol><p>但是对于内存的操作，需要从内存中读取数据，就是在memory（访存阶段）的时候才能把数据转发到下一条指令中，所以下一条指令就必须暂停一下，来获得转发的数据</p><h3 id="4-8-控制冒险"><a href="#4-8-控制冒险" class="headerlink" title="4.8 控制冒险"></a>4.8 控制冒险</h3><p><strong>出现原因</strong></p><ol><li>对于流水线，每一个时钟周期内，都要保证每一个阶段都有指令执行，所以就必须在下一条指令执行之前找到该指令的地址，一般来说都是满足情况的，但是对于 ret 指令，必须在访存操作结束之后才能确定下一条指令的地址</li><li>当取到的条件是分支条件指令的时候，流水线无法立即判断是否要进行跳转操作，需要经过执行阶段之后才能够确定是否跳转</li></ol><p><strong>解决</strong></p><ol><li>对于ret导致的数据冒险，可以在执行过程中插入气泡，暂停程序的执行，一直到执行完访存操作才能确定下一条指令的地址，继续执行</li><li>对于分支条件指令，可以分支跳转预测，在一开始就规定是否跳转，但是分支预测的准确性对程序的性能有很大的影响，主要是出现预测错误需要采取相应的措施来处理</li></ol><p><strong>分支预测</strong></p><p>PC预测逻辑单元，预设分支总是跳转的或者总是不跳转的，但是分支预测的准确性对程序的性能有很大的影响，主要是出现预测错误需要采取相应的措施来处理。插入气泡，但是这个里的插入气泡相当于是把这两条指令剔除了，会造成时钟周期的浪费</p><p>PC选择逻辑单元指令纠错单元，如果PC预测逻辑单元出错了，PC选择逻辑单元会根据实际的执行情况来改正预测错误。</p><p><strong>暂停和插入气泡的实现</strong></p><p>操作系统中有流水线寄存器，并且每次在时钟周期的上升沿都将输入作为输出输出出来，并且引入了两个信号量，暂停信号和气泡信号，并且初始值都为0</p><p>当执行暂停操作时，流水线寄存器中的暂停信号置位1，流水线寄存器保留数值不变，流水线运行阻塞</p><p>当执行气泡操作时，流水线寄存器中的气泡信号置位1，流水线寄存器数值保持为某个复位配置相当于nop</p><h3 id="4-9-Y86-64流水线的实现"><a href="#4-9-Y86-64流水线的实现" class="headerlink" title="4.9 Y86-64流水线的实现"></a>4.9 Y86-64流水线的实现</h3><ol><li><p>取指阶段</p><p> 最复杂的地方就是下一条指令的地址：一般是顺序执行和跳转执行</p><ul><li>顺序执行：根据当前指令地址和当前指令的大小来预测下一条指令的位置</li><li>跳转执行：做出一个假定的预测——分支预测策略</li><li>ret：返回指令的下一条指令地址从栈中取出，不会对返回地址做预测，采用和顺序执行一样的逻辑来处理执行</li></ul></li><li><p>译码阶段</p><p> 根据寄存器的ID从寄存器文件中读取地址，寄存器ID由字段 rA，rB 提供，通过srcA和srcB 输入到寄存器文件，最终译码出来可以用valA和valB来表示。可以用数据转发，就是不必等待寄存器写回到寄存器文件中再从中读取，而是可以直接使用寄存器的数值</p><p> 需要判断是直接采用转发的数据还是从寄存器文件中读取数据，依据是当前需要读取寄存器的ID值与转发的目的寄存器是否相等，转发源：</p><ol><li>ALU产生的输出结果，正常流程是再访存和写回之后才能完成寄存器的更新，采用数据转发，ALU的输出结果可以马上作为译码阶段的结果</li><li>内存的输出数据</li><li>是写入阶段时，对寄存器端口E还没有进行写入的数据</li><li>写回阶段时，对寄存器写入端口M还没有进行写入的数据</li><li><p>写回阶段时对寄存器写入端口E还没有进行写入的数据</p><p>每个转发源有两个部分，一部分是寄存器的ID值，另一部分是转发数据。转发源是存在优先级的，执行→访存→写回</p></li></ol></li></ol><h3 id="4-10-流水线的控制逻辑"><a href="#4-10-流水线的控制逻辑" class="headerlink" title="4.10 流水线的控制逻辑"></a>4.10 流水线的控制逻辑</h3><p>为了避免冒险，需要在设计中添加控制逻辑单元</p><p>指令执行中出现的特殊情况</p><ol><li>加载/使用冒险 就是数据/控制冒险</li><li>分支预测错误</li><li>返回指令的处理</li><li>对异常的处理</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-1-优化程序性能"><a href="#5-1-优化程序性能" class="headerlink" title="5.1 优化程序性能"></a>5.1 优化程序性能</h3><p>编写高效的程序：</p><ol><li>选择适当的算法和数据结构</li><li>理解器的能力和局限性</li><li>探索并行化</li></ol><p>妨碍优化的因素：</p><ol><li>不确定的指针</li><li>函数调用</li></ol><h3 id="5-2-优化程序性能"><a href="#5-2-优化程序性能" class="headerlink" title="5.2 优化程序性能"></a>5.2 优化程序性能</h3><p>减少函数的调用可以提升程序的性能</p><p>降低函数调用的开销</p><p>消除不必要的内存引用</p><h3 id="5-3-现代处理器"><a href="#5-3-现代处理器" class="headerlink" title="5.3 现代处理器"></a>5.3 现代处理器</h3><p>指令级并行的实现</p><p>整体设计分为两部分</p><ol><li>指令控制单元 ICU</li><li>执行单元 EU</li></ol><p>从内存中读取指令序列，然后对指令进行译码</p><p>现代处理器可以把一条指令中的多个操作分别给不同的元件取执行，节约运行时间。现代处理器每个时钟周期可以执行多个操作，而且可以是乱序执行的</p><p>现代处理器采取的分支预测技术来预测分支并且可以预测分支的目标地址，甚至在不确定分支结果的时候就可以提前运行选择的分支，如果发现分支预测错误，就会将状态重置到分支点之前的状态，开始执行另外一个方向上的指令——投机执行。执行结果暂时不会放到寄存器文件或者内存中，直到确认应该执行这些指令时再把结果写回到寄存器或者内存中。预测错误执行单元会丢弃分支点之后计算出来的结果，执行单元还会告诉分支单元，并且指出正确的分支，此时分支逻辑单元开始在新的位置取指</p><p>在指令执行单元中，退役单元，包含寄存器文件，同时控制寄存器的更新，指令在译码时，指令的相关信息被放置在一个先进先出的队列中，这些信息会一直保存在队列中，直到</p><ol><li>当一条指令完成了，并且所有引起这条指令得到分支点也都被确认预测正确，指令就可以退役了，可以更新寄存器</li><li>引起该指令的某个分支点预测错误，指令会被清空，丢弃所有计算出来的结果</li></ol><p>通过这种处理方式，即便是预测错误也不会对计算机造成影响</p><h3 id="5-4-数据流图"><a href="#5-4-数据流图" class="headerlink" title="5.4 数据流图"></a>5.4 数据流图</h3><ul><li>延迟界限：在下一条指令开始之前，这条指令必须结束</li><li>吞吐量界限：处理器功能单元的原始计算能力</li></ul><p>存在四种类型的寄存器</p><ol><li>read-only 只读寄存器</li><li>write-only 只写寄存器</li><li>local 局部寄存器</li><li>loop 循环寄存器</li></ol><p>一个循环程序在不断运行的过程中，会不断的对数据进行读取和写入操作，导致程序运行速率降低</p><h3 id="5-5-循环展开"><a href="#5-5-循环展开" class="headerlink" title="5.5 循环展开"></a>5.5 循环展开</h3><p>可以减少一些与程序结果无关的操作，能够减少整个计算中关键路径的操作数量，减少一写延迟等待，在循环展开之后，运算过程可以调用多个寄存器来实现运算，减少延迟等待</p><p>但是当循环展开到一定的极限的时候就会受到吞吐量界限的限制从而程序的性能下降</p><h3 id="5-6-理解内存性能"><a href="#5-6-理解内存性能" class="headerlink" title="5.6 理解内存性能"></a>5.6 理解内存性能</h3><p>现代处理器中有16个寄存器用来保存浮点数，一旦在一次使用中超出了这个界限，就会分配一些栈空间用来存储存储数据，就会带来内存读写的开销</p><ul><li>加载操作：将数据从内存中读取到寄存器中</li><li>存储操作：将数据从寄存器保存到到内存中，不会影响任何寄存器的值，存储操作不会产生数据相关</li></ul><p>写读相关会导致处理速度下降，因为如果写入和读出的地址是同一个，读取数据依赖于写入数据之后，就会产生延迟</p><p>对于寄存器的操作，在指令被译码成具体的操作的时候，处理器就已经能判断哪些寄存器出现了相关操作，但是对于内存操作，只有把具体的地址计算出来才能判断是否出现了相关操作</p><p><strong>提高程序运行性能的方式</strong></p><ol><li>针对具体的问题选择合适的算法和数据结构</li><li>遵循一些基本的编码原则，比如消除连续的调用和消除不必要的内存引用</li><li>根据硬件的设计，利用循环展开等技术来提高指令级并行</li></ol><h2 id="第六章-存储技术"><a href="#第六章-存储技术" class="headerlink" title="第六章 存储技术"></a>第六章 存储技术</h2><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698317977365.png" alt="1698317977365.png"></p><div class="table-container"><table><thead><tr><th>存储类型</th><th>速度</th></tr></thead><tbody><tr><td>寄存器</td><td>立即使用</td></tr><tr><td>chche 告诉缓存</td><td>4~75时钟周期</td></tr><tr><td>内存</td><td>几百个时钟周期</td></tr><tr><td>磁盘</td><td>几千万个时钟周期</td></tr></tbody></table></div><h3 id="RAM-随机访问存储器"><a href="#RAM-随机访问存储器" class="headerlink" title="RAM 随机访问存储器"></a><strong>RAM 随机访问存储器</strong></h3><p>需要在有电的情况下才能保存数据</p><ul><li><p>static RAM 静态</p><p>  将每个bit位的信息存储在一个双稳态的存储器单元内，每个存储器单元需要6个晶体管来实现，只要有电就能一直存储原来的数据</p></li><li><p>dynamic RAM 动态</p><p>  存储的原理是电容充电，每个bit位存储对应一个电容和一个晶体管，这个电容很小，对干扰十分敏感，并且电容电压受到干扰之后无法回到之前</p><p>  会有很多原因导致漏电，使得DRAM会在10~100ms内失去电荷，因此内存系统需要不断地读出数据然后重写来刷新内存中地每一位</p><p>  同步DRAM比异步DRAM更快</p></li></ul><p>两种结构不同，导致速度存在差异，SRAM速度要快于DRAM，但是价格更贵</p><p>处理器芯片中的cache采用的是SRAM，内存采用的是DRAM</p><p>一个用DRAM封装成地内存模块的基本组成是由 8 个DRAM芯片组成的，每个DRAM中有8M的内存，每个超单元可以存储8位的数据，每个 64 位的数据使用 8 个超单元来存储，但是这8个超单元并不存在于同一个DRAM芯片上，其中最低8位存储在DRAM0，以此类推直到DRAM7存储最高8位数据，当处理器向内存控制器发起读取数据的请求时，内存控制器将地址转换成超单元地址（i， j），然后发送到内存模块，然后内存模块将超单元地址广播到所有的DRAM中，然后每个DRAM会输出它对应的超单元的数据，最后内存模块将所有的超单元合并为1个64位的数据输出到内存控制器</p><h3 id="机械磁盘"><a href="#机械磁盘" class="headerlink" title="机械磁盘"></a><strong>机械磁盘</strong></h3><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698330160836.png" alt="1698330160836.png"></p><p>依靠盘片来存储数据，盘片表面涂有磁性的记录材料，主轴带动盘片高速旋转</p><p>对于SRAM和DRAM之类的</p><p>$K=2^{10}$ $M = 2^{20}$ $G = 2^{30}$ $T = 2^{40}$</p><p>对于磁盘之类的IO设备</p><p>$K=2^{10}$ $M = 10^{6}$ $G = 10^{9}$ $T = 10^{12}$</p><p>对于磁盘扇区的访问的时间 = 寻道时间 + 旋转时间 + 传送时间</p><ul><li><p>寻道时间</p><p>  传动臂将读写头移动到目标扇区所在的磁道所用的时间，取决于当前位置与目标位置的距离</p><p>  通常时间 3~9ms 左右</p></li><li><p>旋转时间</p><p>  决定因素：</p><ul><li>当前读写头所在的扇区位置与目标扇区位置</li><li>盘片的速度</li></ul></li><li><p>传送时间</p><p>  传送数据的时间</p></li></ul><p>对于操作系统来说，整块磁盘被抽象成一个个逻辑块序列，与磁盘上的块区都是512字节，磁盘内有一个小块的磁盘控制器，它维护着逻辑块号与实际磁盘扇区之间的映射关系，当操作系统需要从磁盘中读取数据时，就会发送一个命令到磁盘控制器，就是让磁盘控制器读取特定逻辑块号的数据，用（盘面，磁道，扇区）的三元组来表示一个唯一的物理扇区，然后读写头把读到的数据放入一个缓冲区中，最后将目标数据复制到内存里</p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>是由一个或者多个闪存芯片组成的，还包含一个闪存转换层，功能与磁盘控制器类似，都是将操作系统对逻辑块的请求翻译成对底层物理设备的访问</p><p>固态硬盘内存操作包括 读写和擦除</p><p><strong>闪存芯片</strong>是基于 nand flash 实现的</p><p>每个闪存芯片是由一个或者多个 die 组成的，每个 die 可以分为多个 plane ，每个 plane 包含多个 block ，但是这个 block 与逻辑块是没有关系的，其中又被分为了多个 page，固态硬盘就是以 page 为单位读写的，对于不同规格的闪存芯片，其中 page 的大小可能并不相同。</p><p>由于闪存芯片的写入原则，导致每次写入只能从 1 变为 0，所以page在读写之前存储位为1，写入相当于是将某些存储位从1写为0，并且在写入之前，page 必须擦除，不能直接覆盖，写入操作的基本单位是 page，但是擦除操作的基本单位是 block，本质就是将所有的存储位都变为1，经过多次擦除操作之后，block就会磨损，直到block发生损坏之后就不能再使用了，所以对于闪存翻译层会使用磨损平均算法，将擦除平均到所有的块上来最大化每个块的寿命</p><p><strong>应用程序的局部性</strong></p><ul><li><p>时间局部性</p><p>  对于一个内存被引用了一次，程序很可能在不远的将来再次引用这个内存</p></li><li><p>空间局部性</p><p>  对于一个内存被引用了一次，程序很可能在不远的将来再次引用这个内存附近的内存</p></li></ul><p>对于一个二维数组，内存中的存储是按照行优先的顺序来存储的，如果代码中引用顺序一致的话速率就会比较高（空间局部性）</p><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p>中心思想是，速度更小，容量更小的存储设备作为速度更慢，容量更大的存储设备的缓存</p><p>在层次结构中，数据总是以块为单元在相邻的块之间复制，对于相邻层块的大小是固定的，但是对于不相邻层块的大小是不固定的，一般来说距离CPU越远得到设备访问时间就越长</p><p>随着CPU与内存之间的性能的差距加大，在内存和寄存器之间又插入了一些缓存</p><p><strong>缓存命中</strong></p><p>对于读取第 K+1 层中的数据，会先查看第 K 层中是否有该数据的缓存，如果有就是缓存命中，如果没有目标数据就是缓存不命中，那么第K层就会读取第K+1层中包含目标数据的块，如果第K层已经满了，这个块就会覆盖现存的一个块，这个过程被称为替换，被替换的块成为牺牲快，常用替换方式有随机替换和LRU（淘汰最少使用的存储块）</p><p>整个cache被划分为一个或者多个 set ，每个set包含一个或者多个cache line（高速缓存行），每个cache line由3部分组成，分别是有效位，标记，数据块，有效位来标记数据是否有效，cache的大小是所有数据块的和，不包括有效位和标记。</p><p>当从cache中读取数据时，CPU将地址发送到 cache中，如果cache中保存着目标数据的副本，就立即将目标数据发回CPU</p><p>对于cache中如果每个set中只有一个cacheline的话，就将这种结构的cache成为<strong>直接映射</strong></p><p><strong>判断是否缓存命中的步骤</strong></p><ol><li><p>组选择</p><p> 根据组索引值来确定目标数据属于哪一个set的</p></li><li><p>行匹配</p><p> 先查看有效位是否置1，再对比cacheline中的标记与地址中的标记位是否一致，如果一致就是在当前的cacheline中，如果不一致或者cache时无效的表示数据不存在于cacheline中</p></li><li><p>字抽取</p><p> 行匹配如果命中就可以进行，可以通过目标偏移量来确定数据的位置，以字为单位的偏移</p></li></ol><p>如果没有命中就需要读取下一层的内存了，对于直接映射的 cache 来说，直接将当前的cacheline的行替换掉就可以了</p><p><strong>冲突不命中</strong></p><p>对于不同的块有可能对应着同一个set，所以在交替引用之下会产生数据不命中的结果</p><p><strong>组相联 全相连 cacheline</strong></p><p>组相连 每个set中的cacheline数量&gt;1</p><ol><li><p>组选择</p><p> 根据组索引值来确定目标数据属于哪一个set的</p></li><li><p>行匹配</p><p> 遍历每一行cacheline，寻找有效位为并且标签匹配的cacheline</p></li><li><p>字抽取</p><p> 行匹配如果命中就可以进行，可以通过目标偏移量来确定数据的位置，以字为单位的偏移</p></li></ol><p>如果没有命中就需要读取下一层的内存了，必须在组中选择一行来覆盖，如果有空行就填入空行中，否则就需要覆盖掉一行，可以使用LFU策略，LRU策略或者随机替换</p><ul><li>LFU 最不常使用的行</li><li>LRU 最后一次访问时间最久远的行</li></ul><p>全相联 只有一个set，所有的cache都包含在内</p><p>不需要组索引来进行组选择了，地址只需要为标记和块偏移就可以</p><p>只适合做容量较小的高速缓存</p><p><strong>写入</strong></p><p>当向cache中写入数据的时候需要考虑写命中和写不命中的情况</p><ul><li><p>写命中 找到了对应的cacheline</p><ul><li><p>写穿透</p><pre><code>CPU在写cache的同时写内存，保证数据永远是新的，cache替换时直接扔掉旧数据</code></pre></li><li><p>写回</p><pre><code>只写cache，不写内存，比较省事，当更新算法要驱逐这一块内存的时候再写入内存中但是会增加cache的复杂性，cache需要有一个标志位来记录是否被修改过</code></pre></li></ul></li><li><p>写不命中 没有找到对应的cacheline</p><ul><li><p>写分配</p><pre><code>就是先把目标数据所在的块从内存加载到cache中，再往cache中写，通常与写回搭配</code></pre></li><li><p>写不分配</p><pre><code>绕开cache，直接把要写的内容写到内存里，通常与写穿透搭配</code></pre></li></ul></li></ul><p>容量较大的cache可能会提高命中率，但是运行后速率慢，较大的cache可能会增加命中的时间</p><p>数据块较大能利用程序中可能存在的空间局部性，帮助提高命中率，但是相应的cache的行数就少，会导致一些时间局部性较好的代码命中率下降，而且块越大，导致的不命中处罚也就越严重，对于数据传送时间会比较长</p><h2 id="第七章-编译器"><a href="#第七章-编译器" class="headerlink" title="第七章 编译器"></a>第七章 编译器</h2><h3 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h3><p><strong>链接</strong></p><p>是将各种代码和数据收集并组合成一个文件的过程，最终得到的文件可以被加载到内存中执行，早期链接是手动执行的，现在链接是由链接器自动完成的</p><p>编译的流程</p><p>预处理→编译→汇编→链接</p><p>加载→执行</p><h3 id="7-2-可重定位目标文件"><a href="#7-2-可重定位目标文件" class="headerlink" title="7.2 可重定位目标文件"></a>7.2 可重定位目标文件</h3><p>查看操作系统的笔记</p><h3 id="7-3-符号和符号表"><a href="#7-3-符号和符号表" class="headerlink" title="7.3 符号和符号表"></a>7.3 符号和符号表</h3><h3 id="7-4-符号解析与静态库"><a href="#7-4-符号解析与静态库" class="headerlink" title="7.4 符号解析与静态库"></a>7.4 符号解析与静态库</h3><p>在linux系统种，静态库以一种成为archive的特殊文件格式存放在磁盘上，以.a 结尾，是一组可重定位的目标文件的集合，可以通过 <code>objdump -t libc.a</code> 来查看这个静态库包含哪些目标文件，也可以使用 <code>ar</code> 指令解压该静态库</p><p><strong>ar指令的使用：</strong></p><ul><li>-r 将objfile文件插入静态库尾或者替换静态库中同名文件</li><li>-x 从静态库文件种抽取目标文件</li><li>-t 打印静态库的成员文件列表</li><li>-d 从静态库种删除目标文件</li><li>-s 重置静态库文件索引</li><li>-v 显示详细信息</li><li>-c 创建静态库文件</li></ul><h3 id="7-5-静态库的解析过程"><a href="#7-5-静态库的解析过程" class="headerlink" title="7.5 静态库的解析过程"></a>7.5 静态库的解析过程</h3><p>在符号解析阶段，链接器从左到右按照命令行种出现的顺序来扫描可重定位文件和静态库文件</p><p>其中由于编译器驱动程序总是会把libc.a传给链接器，所以不必显式声明</p><p>链接器会维护三个集合</p><ol><li>集合E 在链接器扫描的过程中发现了可重定位目标文件就会放到这个集合中，链接即将完成之时，这个集合中的文件最终会被合并起来行程可执行文件</li><li>集合U 用来存放未定义的符号</li><li>集合D 它是用来存放输入文件中已经定义的符号</li></ol><p>链接开始时，三个集合都为空，对于命令行上每一个文件，链接器会判断，如果文件是一个目标文件，那么链接器就会把文件添加进集合E中，同时修改集合U和D来反映文件中的符号定义和引用，如果文件是静态库文件，链接器就会尝试在这个静态库文件中寻找集合U中未解析的符号，如果找到了就将该.o文件放入集合E中，并且从集合U中移除，如果其中还定义了其他符号，就添加到集合D中，直到EUD不再发生变化，最后不在E中的目标文件将会被丢弃。操作完成之后，如果集合U是空的，链接器会合并集合E中的文件来生成可执行文件，如果U是非空的，链接器就会输出一个错误并且终止。但是这会导致一些链接错误，因为目标文件和库文件的输入顺序就很重要。如果把一些静态链接库放在前面，U中一开始是空的，就不会对任何符号引用解析，所以直到结束之后会发现有一些符号未定义。并且如果库不是独立的，那就必须对它们进行排序（调用者放前面），也可以重复库，也可以把它们合并成一个静态库文件</p><h3 id="7-6-重定位"><a href="#7-6-重定位" class="headerlink" title="7.6 重定位"></a>7.6 重定位</h3><p>分为两步</p><ol><li><p>重定位节和符号定义</p><p> 链接器将可重定位目标文件中的 <code>text section</code> 合成为一个新的 <code>text section</code> ，合成之后的 <code>text section</code> 就是可执行目标文件的 <code>text section</code>，完成之后程序中的每条指令和全局变量都有了唯一的运行时内存地址</p></li><li><p>重定位符号引用</p><p> 对于函数调用，会有call指令，一开始指令的最终地址是不确定的会先填充0，链接器需要修改对函数符号的引用，使它指向正确的运行地址，链接器还依赖于可重定位条目的数据结构</p></li></ol><p><strong>重定位条目</strong></p><p>可重定位目标文件是由汇编器产生的，当汇编器在生成可重定位目标文件时，并不知道数据和代码最终放在内存的那个位置，也不清楚全局变量和外部函数的位置，对于最终位置不确定的符号就会产生一个重定位条目，用来告诉链接器在合成可执行文件时应该如何修改这个引用，代码的重定位条目放在 <code>.rel.text</code> 中。对于已初始化的重定位条目放在 <code>.rel.data</code> 中</p><p>重定位条目的结构体定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="type">long</span> offset; <span class="comment">// 表示被修改的引用的节偏移量</span></span><br><span class="line"> <span class="type">long</span> type:<span class="number">32</span>, <span class="comment">// 链接器会根据type来修改新的引用</span></span><br><span class="line">    symbol:<span class="number">32</span>;<span class="comment">// 表示被修改的引用是哪一个符号</span></span><br><span class="line"> <span class="type">long</span> addend; <span class="comment">// 一个常数，一些类型的重定位要使用它对被修改应用的值做偏移调整</span></span><br><span class="line">&#125;ELF64_Rela;</span><br></pre></td></tr></table></figure><p>定义了32中重定位类型，一般只关心PC相对地址重定位(R_X86_64_PC32)和绝对地址重定位(R_X86_64_32)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ref_addr = ADDR(main) + r.offset <span class="comment">// 重定位的绝对地址，引用时地址</span></span><br><span class="line">*ref_ptr = ADDR(func) - ref_addr + r.addend <span class="comment">// 更新符号引用，使得运行时指向对应的函数</span></span><br><span class="line"><span class="comment">// addend 字段默认为 -4 其实是执行到跳转指令的时候，PC已经到达下一条指令的位置了，所以需要用到算数回调</span></span><br></pre></td></tr></table></figure><ul><li><p>重定位相对引用</p><p>  其中的偏移调整值 <code>addend</code> 是默认为-4的，因为当执行当前指令时，PC的实际地址是指向了下一条指令</p><p>  执行call指令可以分为两步</p><ol><li>将PC值压入栈中</li><li>修改PC数值，在PC数值上加上偏移量</li></ol></li><li><p>重定位绝对引用</p><p>  对于绝对地址引用的计算比较简单， <code>addend</code> 默认为0</p></li></ul><p>重定位之后，对应的符号重定位地址都会被更新，执行完重定位之后，可以确定目标文件的 <code>text section</code> 和 <code>data section</code> 的内容，当程序执行加载的时候，会把这些 <code>section</code> 中的字节都复制到内存里，不用修改就可以执行</p><h3 id="7-7-可执行目标文件"><a href="#7-7-可执行目标文件" class="headerlink" title="7.7 可执行目标文件"></a>7.7 可执行目标文件</h3><h2 id="第八章-异常"><a href="#第八章-异常" class="headerlink" title="第八章 异常"></a>第八章 异常</h2><h3 id="8-1-异常控制流"><a href="#8-1-异常控制流" class="headerlink" title="8.1 异常控制流"></a>8.1 异常控制流</h3><p><strong>控制流</strong></p><p>是一个PC的运行序列</p><p>平滑控制流是指运行的地址都是连续的，如果其中产生了突变，也就是程序的运行地址不相邻了，通常是由跳转，函数调用和返回这类指令造成的。这种突变属于是必要的机制，但是系统在运行的过程中需要对系统状态的变化做出反应，这种就是异常控制流</p><p>软件异常允许程序进行非本地跳转来响应错误。非本地跳转指的是违反通常的调用/返回栈规则的跳转，是一种应用层的异常控制流，可以通过函数 <code>setjmp</code> 和 <code>longjmp</code> 来实现</p><p><strong>异常</strong></p><p>当处理器正在执行应用程序中的某一条指令的时候，系统发生一个事件，可能与当前程序的执行相关（程序错误），也可能不相关（IO请求），然后处理器从执行应用程序切换到异常处理程序，异常完成之后，根据引起的异常的类型选择是否返回。处理异常需要软硬件的配合</p><p>系统为每种类型的异常都分配了唯一的异常编号，有些是由处理器的设计者分配的，其他的是由操作系统内核的设计者分配的。处理器在得到异常编号的时候，会在异常表中查找到异常处理程序的入口来处理异常。<strong>异常表</strong>是在系统启动时分配和初始化的一个跳转表，<strong>异常号</strong>就是这个跳转表的索引号。异常表的起始地址是保存在CPU的一个特殊的寄存器（异常表基址寄存器）中。异常的处理类似一个间接的函数调用。</p><p>函数调用时，在跳转到目的函数之前，处理器首先将返回地址压入栈中。根据异常的类型，返回地址要么是当前指令要么是下一条指令。当处理异常时，会把处理器额外的一些状态压入到栈中，当重新开始这段程序时需要这些状态。控制从用户态转向内核态时，所有的内容都要被压入到内核栈中而不是用户栈中。异常处理程序是运行在内核态的，对所有的系统资源都有访问权限</p><p>根据异常的事件类型，发生3种情况</p><ul><li>异常处理程序将控制返回到之前正在执行的指令</li><li>异常处理程序将控制返回到没有发生异常将要执行的下一条指令</li><li>异常处理程序终止之前CPU正在执行的程序</li></ul><h3 id="8-2-异常（Linux异常表）"><a href="#8-2-异常（Linux异常表）" class="headerlink" title="8.2 异常（Linux异常表）"></a>8.2 异常（<a href="https://blog.csdn.net/weifenghai/article/details/52833372">Linux异常表</a>）</h3><ol><li><p>中断</p><p> 异步⇒ 由处理器CPU外部的IO设备产生的</p><p> <img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698456735283.png" alt="1698456735283.png"></p></li><li><p>陷阱</p><p> 同步⇒ CPU执行当前指令产生的结果</p><p> 故意触发，是执行一条指令的结果，为用户程序和操作系统内核之间提供一个类似函数的接口。陷阱就是由 <code>syscall</code> 产生的</p><p> <img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698456876607.png" alt="1698456876607.png"></p></li><li><p>故障</p><p> 同步⇒ CPU执行当前指令产生的结果</p><p> 是由错误情况引起的，有可能被故障处理程序修复</p><p> 如果修复，就返回引起故障的指令重新执行，否则终止运行</p><p> <img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698456997355.png" alt="1698456997355.png"></p></li><li><p>终止</p><p> 同步⇒ CPU执行当前指令产生的结果</p><p> 是由一些不可恢复的错误导致的，通常是硬件错误</p><p> <img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698457356120.png" alt="1698457356120.png"></p></li></ol><h3 id="8-3-进程与上下文"><a href="#8-3-进程与上下文" class="headerlink" title="8.3 进程与上下文"></a>8.3 进程与上下文</h3><p><strong>逻辑控制流</strong></p><p>PC在程序运行时有一系列的程序计数器的数值，与可执行程序中的指令是一一对应的，把这个PC值的序列叫做逻辑控制流。一个处理器上可以有多个进程，时间片轮转→每个进程轮流占用CPU。把两个在时间上重叠的情况称为并发流，两个流的执行被成为并发运行。</p><p>并发是交替运行</p><p>并行是同时运行</p><p>为了限制应用程序执行某些特殊指令以及限制可以访问的地址空间范围，通常处理器通过控制寄存器的模式位来实现这些限制功能。该寄存器描述了当前进程的权限，设置控制寄存器的模式位之后，进程就运行在<strong>内核模式</strong>。运行在内核模式的进程可以执行指令集中的任何指令，访问系统中任意内存位置。否则就运行在<strong>用户模式</strong>，不允许执行特权指令。特权指令可以停止处理器，改变模式位以及发起一个IO操作。用户模式的进程也不能直接引用内核区域的代码和数据，入如果试图访问内核区域会导致保护故障然后终止运行，但是可以通过系统调用间接的访问内核的代码和数据。</p><p>一般来说，应用程序一开始运行在用户模式下的，进程从用户模式切换到内核模式需要通过中断，故障或者系统调用，当这类异常发生时，执行异常处理程序处理异常，处理器的模式会从用户模式，当返回应用程序继续执行时，会从内核模式返回到用户模式</p><p><strong>上下文</strong></p><p>上下文就是内容重新启动一个被抢占的进程所需的状态</p><p>组成：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：描述地址空间的页表，有关当前进程信息的进程表，进程已打开文件的信息表</li></ul><p>进程调度：进程执行的某些时刻，内核可以决定抢占当前的进程，然后重新开始执行先前被抢占的进程，由内核中的调度器来执行。当内核调度了一个新的进程运行后，它就抢占当前进程，并使用上下文切换的机制来将控制转到新的进程</p><p>上下文切换</p><ol><li>保存当前进程上下文</li><li>恢复某个先前被抢占的进程的上下文</li><li>将控制传递给这个新恢复的进程</li></ol><p><strong>系统调用</strong>和<strong>中断</strong>会引发上下文切换</p><h3 id="8-4-进程的创建"><a href="#8-4-进程的创建" class="headerlink" title="8.4 进程的创建"></a>8.4 进程的创建</h3><p><strong>程序</strong>：一段代码和数据，执行之前以文件得到形式存储在磁盘上，运行时，程序以段的形式存储在内存的地址空间中</p><p><strong>进程：</strong>正在执行中程序的一个具体的实例</p><p>从程序员角度来看，状态</p><ol><li>运行 要么在CPU上运行，要么等待被执行，最终会被内核调度执行</li><li><p>暂停 进程被挂起，不会被调度执行</p><p> <code>SIGSTOP</code> <code>SIGTSTP</code> <code>SIGTTIN</code> <code>SIGTTOU</code> 会使程序进入暂停状态，并且一直保持该状态</p><p> 直到收到 <code>SIGCONT</code> 信号，进程继续运行</p></li><li><p>终止</p><ul><li>进程收到一个信号，该信号默认行为就是终止进程</li><li>进程从主程序返回</li><li>调用 <code>exit()</code> 函数</li></ul></li></ol><p><code>void fork(void)</code></p><p>调用一次，返回两次，一次返回到父进程，返回值为子进程的进程号pid，另外一次返回到新创建的子进程，返回值为0。二者具有完全相同的内容但是不同的地址空间，共享文件描述符，二者是独立并发运行的，父进程会先开始执行，然后是子进程开始执行</p><p><strong>标准输入输出</strong></p><p>用C去写文件时的操作， <code>File *fp=fopen()</code>这个fp就是向系统申请的，相当于一通往文件的通道。文件描述符</p><p>其实， <code>stdin,stdout,stderr</code>就是一个文件描述符，不过他是随着计算机系统的开启默认打开的，其中0就是 <code>stdin</code>，表示输入流，指从键盘输入，1代表 <code>stdout</code>，2代表 <code>stderr</code>，1,2默认是显示器。 <code>printf()</code>其实就是向 <code>stdout</code>中输出，等同于 <code>fprintf(stdout，“****”)</code>， <code>perror()</code>其实就是向 <code>stderr</code>中输出，相当于 <code>fprintf(stderr，“***”)</code></p><p><code>stderr</code>，和 <code>stdout</code>还有重要一点区别， <code>stderr</code>是没有缓冲的，它立即输出，而 <code>stdout</code>默认是行缓冲，也就是它遇到 <code>‘\n’</code>，才向外输出内容，如果你想 <code>stdout</code>也实时输出内容，那就在输出语句后加上 <code>fflush(stdout)</code>，这样就能达到实时输出的效果</p><h3 id="8-5-execve和waitpid函数"><a href="#8-5-execve和waitpid函数" class="headerlink" title="8.5 execve和waitpid函数"></a>8.5 execve和waitpid函数</h3><p>具体内容看操作系统笔记</p><h3 id="8-6-信号"><a href="#8-6-信号" class="headerlink" title="8.6 信号"></a>8.6 信号</h3><p>是一种更高层次的软件形式的异常，允许内核和进程中断其他的进程</p><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698488158889.png" alt="1698488158889.png"></p><p><strong>发送信号的几种方式</strong></p><ol><li><p>用 <code>/bin/kill</code> 程序发送信号</p><p> 例如：</p><ul><li><code>/bin/kill -9 1</code> 表示向进程1发送终止信号</li><li><code>/bin/kill -9 -1</code> 表示向进程组1发送终止信号，将会发送到进程组的每一个进程中，进程组中所有进程都将终止</li></ul></li><li><p>从键盘发送信号</p><p> 键盘输入 <code>ctrl-c</code> 键系统会发送一个中断信号到前台进程组中的所有进程中</p><p> 键盘输入 <code>ctrl-z</code> 系统会挂起前台进程组的所有进程</p></li><li><p>用 <code>kill</code> 函数发送信号</p><p> <code>int kill(pid_t pid, int sig);</code></p><p> 可以向进程发送终止信号</p><p> 如果 pid&gt;0，函数kill发送信号sig给进程pid</p><p> 如果 pid=0，函数kill发送信号sig给调用进程所在的进程组中的所有进程包括自己</p><p> 如果 pid&lt;0，函数kill发送信号sig给对应进程组(id=abs(pid))的所有进程</p></li><li><p>用 <code>alarm</code> 函数发送信号</p><p> <code>unsigned int alarm(unsigned int secs);</code> 可以向自己发送信号</p><p> secs表示函数alarm安排内核在secs秒之后发送一个SIGALRM信号给调用进程，如果为0直接发送信号</p></li></ol><p><strong>进程组</strong></p><p>每个进程都只属于一个进程组，每个进程组都有自己的ID值来唯一标识，这个ID是一个正整数</p><p><code>pid_t getpgrp(void);</code> 获取当前进程所属的进程组ID值</p><p>默认情况下一个子进程和它的父进程属于同一个进程组</p><p><code>pid_t setpgrp(pid_t pid, pid_t pgid);</code> 进程可以调用该函数来改变自己或其他进程的进程组，pid表示原来进程组的id值，pgid表示更改后进程组的id。如果参数pid为0，那就使用当前进程的PID值。如果pgid为0，那就用pid指定的进程的PID值作为进程组的ID值。</p><p><strong>接收信号</strong></p><p>当内核把进程从内核模式切换到用户模式时，会检查进程未阻塞的待处理的信号集合，如果集合为空，内核将控制传递到进程的逻辑控制流中的下一条指令。如果集合非空，那么内核选择集合中的一个信号，强制进程接收该信号。接收信号会触发控制转移到信号处理程序，完成处理之后，将控制返回给被中断的程序。每一个信号都有被预定义的默认行为</p><ol><li>进程终止 SIGKILL</li><li>进程终止并转储内存 dumping core 转储内存就是把代码和数据的内存镜像都写在磁盘上</li><li>进程挂起直到被SIGCONT信号重启</li><li>进程可以直接忽略的信号</li></ol><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698491260653.png" alt="1698491260653.png"></p><p>待处理信号：只被接收未被处理的信号，一种类型的信号最多有一个待处理信号，之后接收到的该类型的信号只会被简单的丢弃。</p><p>信号处理程序可以被其他信号处理程序中断</p><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698491445240.png" alt="1698491445240.png"></p><h2 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h2><h3 id="9-1-虚拟内存"><a href="#9-1-虚拟内存" class="headerlink" title="9.1 虚拟内存"></a>9.1 虚拟内存</h3><p>计算机系统中，多个进程之间共享CPU和内存，如果进程太多会因为无法获得足够的内存空间而无法运行，并且，如果某个进程不小心把数据写入到另外一个进程的内存空间中就会发生一些奇怪的错误。</p><p>现代计算机系统提供了一种对内存的抽象概念，虚拟内存，可以自动完成内存管理的相关工作，并不需要外部干预</p><ol><li>虚拟内存遍布计算机系统的各个层面，在硬件异常，汇编器，链接器，加载器，文件以及进程的设计中都扮演了重要角色</li><li>虚拟内存为应用程序提供强大的能力，可以创建和释放内存空间，将内存空间映射到磁盘文件的某个部分，与其他进程共享内存等</li><li>如果虚拟内存使用不当，程序会产生很复杂的错误。每次引用一个变量，间接引用一个指针或者调用一个malloc函数时会与虚拟内存产生交互</li></ol><p><strong>物理地址</strong></p><p>CPU通过物理地址访问内存，物理地址通过内存总线传递给内存控制器</p><p><strong>虚拟寻址</strong></p><p>CPU通过虚拟地址访问内存，要先转化为响应的物理地址，这个任务叫做地址翻译，由内存管理单元来实现该功能。</p><p><strong>地址空间</strong></p><p>一个非负整数的有序集合，如果地址空间中的整数是连续的，就是一个线性地址空间</p><p><strong>物理地址空间</strong></p><p>对应系统中的物理内存</p><p><strong>虚拟内存（</strong><a href="https://blog.csdn.net/fwb330198372/article/details/107343468">虚拟内存</a><strong>）</strong></p><p>虚拟内存可以看成一个由磁盘上N个连续的字节组成的数组，其中每个字节都有一个唯一的虚拟地址，这个虚拟地址就是数组得到索引值。虚拟内存中被分割成块，就是虚拟页，每个虚拟页大小为P个字节。并且物理内存也被分割为物理页，大小是一样的。虚拟页面分为3类</p><ol><li>未分配的——虚拟内存系统还没有创建的页，没有任何数据与之相关联，不占用任何磁盘空间，没有映射物理空间</li><li>已缓存的——当前已经缓存在物理内存页中</li><li>未缓存的——已经被分配，但是没缓存在物理内存页中</li></ol><p>把进程整个复制到内存空间中去，可能会由于数据太多导致内存不够用，并且这种复制内存可能会花费相当多的时间。可以把它切碎，分成一个个小单元，每个单元可以是4kb大小，称为1页或者页面，其中只有一部分页面会在内存中。当CPU需要访问的地址不在内存中的页面中时，可以从磁盘中加载对应的部分到内存中，同时内存不够时，也可以把长期不访问的页面保存到磁盘中，然后删除内存中的部分——虚拟内存</p><p><strong>虚拟内存的使用流程</strong></p><p>先把虚拟内存地址发送给内存管理单元MMU，把虚拟地址转换为物理地址后，通过总线访问内存，内存从总线中获得物理地址。</p><p>其中MMU转换地址需要一个用来记录虚拟地址到物理地址页框的映射关系，成为页表。进程的虚拟地址空间可以比实际内存空间大。把内存中对应的框叫做页框，用于加载一个页面，并且页面的映射没有顺序。</p><p><img src="/Blog_ButterFly/2024/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1698499204357.png" alt="1698499204357.png"></p><p>最终转化为2进制之后，偏移地址量都是一致的，只是页面所对应的页框号是不同的，这个是根据页表的映射关系来确定的</p><p>页面号中间可能有二级页面号，这种称为多级页表。好处是可以只让部分页表保存在内存中，页表的加载也可以同虚拟内存的使用类似</p><p>记录映射关系的页表，其中每一项叫做页表项，包含</p><ul><li>页框号</li><li>一位表示该页面是否在内存中</li><li>保护位，记录读写执行的权限</li><li>修改位，访问位，高速缓存禁止位</li></ul><p>页表通常是保存在内存中，那转换器MMU每次转换都需要从内存中读取就会很慢，所以需要硬件加速。MMU中有暂时存储最近使用的部分页表项，这称为转换检测缓冲区TLB或者相联存储器</p><h3 id="1-什么是虚拟内存？解决了什么问题？"><a href="#1-什么是虚拟内存？解决了什么问题？" class="headerlink" title="1. 什么是虚拟内存？解决了什么问题？"></a><strong>1. 什么是虚拟内存？解决了什么问题？</strong></h3><p>虚拟内存是操作系统内存管理的一种技术，每个进程启动时，操作系统会提供一个独立的虚拟地址空间，这个地址空间是连续的，进程可以很方便的访问内存，这里的内存指的是访问虚拟内存。<strong>虚拟内存的目的，一是方便进程进行内存的访问，二是可以使有限的物理内存运行一个比它大很多的程序。</strong></p><p>虚拟内存的基本思想：每个程序拥有自己的地址空间，这个空间被分割成很多块，每块称为一页，每一页地址都是连续的地址范围。这些页被映射到物理内存，但不要求是连续的物理内存，也不需要所有的页都映射到物理内存，而是按需分配，在程序片段需要分配内存时由硬件执行映射(通常是 MMU)，调入内存中执行。</p><h3 id="2-说说分页和分段的机制？"><a href="#2-说说分页和分段的机制？" class="headerlink" title="2. 说说分页和分段的机制？"></a><strong>2. 说说分页和分段的机制？</strong></h3><p>分页是实现虚拟内存的技术，虚拟内存按照固定的大小分为页面，物理内存也会按照固定的大小分成页框，页面和页框大小通常是一样的，一般是 4KB，页面和页框可以实现一对一的映射。<strong>分页是一维的，主要是为了获得更大的线性地址空间。</strong>但是一个地址空间可能存在很多个表，表的数据大小是动态增长的，由于多个表都在一维空间中，有可能导致一个表的数据覆盖了另一个表。</p><p>分段是把虚拟内存划分为多个独立的地址空间，每个地址空间可以动态增长，互不影响。每个段可以单独进行控制，有助于保护和共享。</p><h3 id="3-页表的作用？为什么引入多级页表？"><a href="#3-页表的作用？为什么引入多级页表？" class="headerlink" title="3. 页表的作用？为什么引入多级页表？"></a><strong>3. 页表的作用？为什么引入多级页表？</strong></h3><p>页表实现了虚拟内存到物理内存的映射，当访问一个虚拟内存页面时，页面的虚拟地址将作为一个索引指向页表，如果页表中存在对应物理内存的映射，则直接返回物理内存的地址，否则将引发一个缺页异常，从而陷入到内核中分配物理内存，返回对应的物理地址，然后更新页表。</p><p>为了加快虚拟地址到物理地址的转换，多数系统会引入一个转换检测缓冲区（TLB）的设备，通常又称为<strong>快表</strong>，当请求访问一个虚拟地址时，处理器检查是否缓存了该虚拟地址的映射，如果命中则直接返回物理地址，否则就通过页表搜索对应的物理地址。</p><p>由于虚拟内存通常比较大(32 位系统通常是 4G)，要实现整个地址空间的映射，需要非常大的页表。解决的办法是引入多级页表，只将那些用到的页面装载进来，因此，多级页表可以大大节约地址转换所需要的的空间。</p><h3 id="4-页面置换算法有哪几种？"><a href="#4-页面置换算法有哪几种？" class="headerlink" title="4. 页面置换算法有哪几种？"></a><strong>4. 页面置换算法有哪几种？</strong></h3><p>当访问的页面不在内存中时，会发生一个缺页异常，操作系统必须将该页换出内存，如果此时内存已满，则操作系统必须将其中一个页面换出，放到 swap 交换区中，为当前访问的页面腾出空间，这个过程称为页面置换。操作系统提供了多种页面置换算法：</p><p><strong>最优页面置换算法</strong></p><p>选择一个将来最长时间不会被访问的页面换出。这样可以保证将来最低的缺页率。这是一种理论上的算法，因为无法知道哪个页面是将来最长时间都不会被访问的。</p><p><strong>最近未使用页面置换算法 (NRU)</strong></p><p>为每个页面设两个状态位：被访问时设置为 R=1 位，页面被修改时，设置为 M=1 位。当启动一个进程时，所有页面都被初始化为 R=0，M=0。其中 R 位会被定时的清 0，以此区分最近被访问的页面和没有被访问的页面。</p><p>于是所有页面可以分为以下 4 类：</p><p>0 类：R=0，M=0；</p><p>1 类：R=0，M=1；</p><p>2 类：R=1，M=0；</p><p>3 类：R=1，M=1；</p><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出（挑选优先级：1 类 &gt; 2 类 &gt; 3 类）。</p><p><strong>最近最少未使用（LRU）页面置换算法</strong></p><p>在内存中维护一个所有页面的单链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><p><strong>先进先出（FIFO）页面置换算法</strong></p><p>维护一个链表，最先进入的页面放在表头，最后进入的页面放在表尾，当缺页中断发生时，直接淘汰表头的页面，并把新的页面放在表尾。</p><p>这种算法有可能置换掉经常访问的页面，导致缺页率升高。</p><p><strong>第二次机会页面置换算法</strong></p><p>对 FIFO 算法做一个修改：取出表头的页面时，检查该页面的 R 位，如果是 1 表示是最近有访问的，将其清 0，然后放入表尾，然后继续检查下一个表头的页面，直到遇到一个 R 位为 0 的页面，将其换出。</p><p><strong>时钟页面置换算法</strong></p><p>与上一个算法类似，只不过单链表改成了环形链表，形成一个时钟，移动的也不是页面，而是中间的表针。检查页面逻辑类似，如果该页面 R 为 0，则直接置换该页面，否则将该 R 位清 0，然后表针向前移动。</p><h3 id="5-内存是如何分配的"><a href="#5-内存是如何分配的" class="headerlink" title="5. 内存是如何分配的"></a><strong>5. 内存是如何分配的</strong></h3><p>Linux 分配物理内存的主要机制是页面分配机制（页分配器），使用了著名的伙伴算法，主要用来分配页大小的整数倍的内存(4n KB)。如果是小于页大小的内存分配，通常使用 slab 管理器。通过 slab 分配的内存通常会缓存起来，方便下次使用。</p><h3 id="6-内存是如何回收的？"><a href="#6-内存是如何回收的？" class="headerlink" title="6. 内存是如何回收的？"></a><strong>6. 内存是如何回收的？</strong></h3><p>应用程序用完内存后，可以调用 free() 释放内存，或调用 unmap() 取消内存映射，归还系统。</p><p>在内存紧张时，会通过一系列机制来回收内存，如以下三种方式：</p><ul><li>回收缓存。主要是页缓存。</li><li>回收不常访问的页面。使用页面置换算法，把不常用的页面放到交换区中。</li><li>通过 OOM 杀死占用大量内存的进程，释放内存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码整洁之道</title>
      <link href="/Blog_ButterFly/2024/03/18/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
      <url>/Blog_ButterFly/2024/03/18/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>时刻保持初心，保持代码整洁</p><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><ol><li>名副其实，见名知意</li><li>避免误导</li><li>做有意义的区分</li><li>使用读的出来的名称</li><li>使用可以搜索的名称</li><li>避免使用编码<ol><li>成员前缀</li><li>匈牙利语标记法</li></ol></li><li>避免思维映射</li><li>类名<ol><li>类名和对象名应该是名词或名词短语</li><li>类名不应当是动词</li></ol></li><li>方法名<ol><li>方法名应当是动词或动词短语</li></ol></li><li>别扮可爱</li><li>每个概念对应一个词</li><li>别用双关语</li><li>使用解决方案领域的名称<ol><li>给这些事取个技术性的名称，通常是最靠谱的做法。</li></ol></li><li>使用源自所涉问题领域的名称</li><li>添加有意义的语境，不要添加没用的语境</li></ol><h2 id="函数的定义规则"><a href="#函数的定义规则" class="headerlink" title="函数的定义规则"></a>函数的定义规则</h2><ol><li>短小 函数的第一规则是要短小。第二条规则是还要更短小。</li><li>只做一件事</li><li>每个函数一个抽象层级</li><li>switch语句</li><li>使用描述性的名称</li><li>函数参数<ol><li>最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数）—所以无论如何也不要这么做。</li><li>标识参数丑陋不堪。向函数传入布尔值简直就是骇人听闻的做法。这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事。如果标识为 true 将会这样做，标识为 false 则会那样做！</li></ol></li><li>无副作用<ol><li>输出参数</li></ol></li><li>分隔指令与询问</li><li>使用异常替代返回错误码<ol><li>抽离 Try/Catch 代码块</li><li>错误处理就是一件事</li><li>Error 依赖 enum</li></ol></li><li>别重复自己</li><li>结构化编程</li></ol><h2 id="代码命名规范"><a href="#代码命名规范" class="headerlink" title="代码命名规范"></a>代码命名规范</h2><p>这是自己定义的一个代码书写规范，可以用作参考</p><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>文件命名</td><td>全小写，可以包含下划线 <code>_</code> 或者连字符 <code>-</code> ，尽量使用 <code>_</code></td></tr><tr><td>类型命名</td><td>类或结构体命名使用驼峰式，每个单词首字母均大写</td></tr><tr><td>变量命名</td><td>一律小写，单词之间使用下划线连接</td></tr><tr><td>类/结构数据成员命名</td><td>一律小写，单词之间使用下划线连接，但是需要名称末尾接下划线</td></tr><tr><td>常量命名</td><td>对于 <code>const</code> 变量，或者在程序运行期间值不变的，命名以 <code>k</code> 开头，每个单词首字母大写</td></tr><tr><td>函数命名</td><td>使用大驼峰式，每个单词首字母均大写</td></tr><tr><td>类/结构方法命名</td><td>使用小驼峰式，除了首字母以外每个单词首字母均大写</td></tr><tr><td>枚举命名</td><td>使用全大写，单词之间使用下划线连接</td></tr><tr><td>宏命名</td><td>使用全大写，单词之间使用下划线连接</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 程序员的自我涵养 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/Blog_ButterFly/2024/03/18/git/"/>
      <url>/Blog_ButterFly/2024/03/18/git/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>git 是一个十分强大的远程项目管理的系统，对于开发者来说十分重要，它的版本管理功能也十分强大，而且存储空间也有 1GB，还算挺大的。</p><p>本人曾在一次事故中磁盘损坏导致丢失了自己做的项目，熬夜半年多完成的心血，很心痛。。。</p><p>所以在这里告诫大家， <strong>一定要做好备份</strong></p><h3 id="SSH与github"><a href="#SSH与github" class="headerlink" title="SSH与github"></a>SSH与github</h3><p>SSH（安全外壳协议，Secure Shell 的缩写）是建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。简单来说，SSH就是保障你的账户安全，将你的数据加密压缩，不仅防止其他人截获你的数据，还能加快传输速度。</p><p>一般来说，安装 git bash 之后实际上是自带 SSH 的，所以可以检验一下，在终端输入指令 <code>ssh</code> 会显示出 <code>usage</code> 的内容，那就是装好了，有问题的话，可以自行百度一下。</p><p>没问题了就可以输入指令 <code>ssh-keygen -t rsa</code> ，使用 RSA 算法生成密钥，然后，如下</p><p><img src="/Blog_ButterFly/2024/03/18/git/IMG_20240320_093427.png" alt="IMG_20240320_093427.png"></p><p>其中 红色圈里面是输入保存的地址，蓝色圈里输入的是 passphrase，可以不输入，直接回车就行。最终去你保存的地址找到它</p><p>接下来我们要做的事情就是把公钥 id.pub  的内容添加到 GitHub。复制公钥 id.pub 文件里的内容，你可以通过目录找到 id.pub 文件的位置，打开复制里面的内容。（文件名是与上述操作中文件名称有关，我的设置的路径是 E:\id，所以相应的文件名就是 id）</p><p>之后进入github的主页，进入设置（settings），然后找到 SSH and GPG keys，点击 New SSH key，创建一个新的 SSH</p><p><img src="/Blog_ButterFly/2024/03/18/git/1710899281606.png" alt="1710899281606.png"></p><p>将在文件 id.pub 中复制的内容，粘贴到图下的 key 中，然后点击 Add SSH key，就好了</p><p><img src="/Blog_ButterFly/2024/03/18/git/1710899471693.png" alt="1710899471693.png"></p><p>之后，在终端中输入 <code>ssh -T [git@github.com](mailto:git@github.com)</code> 进行检验，第一次会有一个询问，只要回答 <code>yes</code> 就可以了，出现提示 <code>successfully authenticated</code> 就表示绑定成功。</p><h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><p><img src="/Blog_ButterFly/2024/03/18/git/image.png" alt="image"></p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>指的就是 <code>.git/HEAD</code> 文件，存储着当前工作空间所处的某次 <code>commit</code></p><p><code>HEAD</code> 是当前分支引用的指针，它总是指向某次 commit，默认是上一次的 commit。 这表示 <code>HEAD</code> 将是下一次提交的父结点。 通常，可以把 <code>HEAD</code> 看做你的上一次提交的快照。当然 <code>HEAD</code> 的指向是可以改变的，比如你提交了 commit，切换了仓库，分支，或者回滚了版本，切换了 tag 等</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><code>git config --global item val</code> 设置全局参数，其中 <code>item</code> 就是需要设置的项， <code>val</code> 就是设置的值</li><li><code>git config --list</code> 查看环境参数列表，包括全局参数列表</li><li><code>git config --global --list</code> 查看全局参数列表</li><li><code>git config item</code> 查看对应 <code>item</code> 的值</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><code>git init</code> 初始化仓库</li></ul><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li><code>git status</code> 查看工作区和暂存区的状态</li><li><code>git status -s</code> 输出更加简洁</li></ul><h3 id="下载仓库"><a href="#下载仓库" class="headerlink" title="下载仓库"></a>下载仓库</h3><ul><li><code>git clone [-b branch_name] https/ssh</code> 下载代码，可以指定该仓库的分支，默认为主分支</li><li><code>git pull</code> 从远程仓库更新到本地仓库</li><li><code>git fetch</code> 从远程仓库获取最新修改，用户在检查了以后决定是否合并到工作本机分支中</li></ul><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ul><li><code>git add [file1] [file2] ...</code> 将对应文件添加到暂存区</li><li><code>git add [dir]</code> 将对应目录添加到暂存区</li><li><code>git add .</code> 将当前目录下所有文件添加到暂存区，实际上就是目录 <code>.</code></li><li><code>git commit -m &quot;message&quot;</code> 将暂存区的文件提交到本地仓库中，需要注意的是，一定要写 <code>message</code> ，不然提交会失败</li><li><code>git commit -a</code> 不需要执行 <code>git add</code> 指令，直接将所有更改提交到本地仓库</li><li><code>git commit -am &quot;message&quot;</code> 不需要执行 <code>git add</code> 指令，直接将所有更改提交到本地仓库</li><li><code>git push</code> 推送，将本地仓库推送到远程仓库，会进行对比操作，默认会推送到当前的分支</li><li><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code> 将本地的分支版本上传到远程仓库并且合并，将本地分支推送到对应主机的远程分支处</li><li><code>git push --force</code> 当本地版本与远程版本有差异，但又需要强制推送，可以使用 <code>--force</code> 参数</li></ul><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li><code>git branch</code> 查看本地分支</li><li><code>git branch -v</code> 查看本地分支和上次提交的信息</li><li><code>git branch -vv</code> 查看本地分支和上次提交的信息以及本地和远程分支的关系</li><li><code>git branch -vv -a</code> 查看本地分支和上次提交的信息以及本地和远程分支的关系和远程分支</li><li><code>git branch -r</code> 查看远程分支</li><li><code>git branch -a</code> 查看所有分支</li><li><code>git branch branch_name</code> 创建本地分支</li><li><code>git checkout -b branch_name</code> 创建本地分支并且切换到该分支</li><li><code>git branch -d branch_name</code> 删除本地分支</li><li><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code> 创建远程分支</li><li><code>git push &lt;主机名&gt; --delete &lt;分支名&gt;</code> 删除远程分支</li><li><code>git push &lt;主机名&gt; -d &lt;分支名&gt;</code> 删除远程分支</li><li><code>git push &lt;主机名&gt;:&lt;分支名&gt;</code> 删除远程分支</li><li><code>git merge &lt;branch&gt;</code> 合并指定分支到当前分支中</li><li><code>git rebase &lt;base&gt; &lt;topic&gt;</code> 将主题分支 <code>topic</code> 变基到目标分支 <code>base</code> 上</li><li><code>git switch &lt;branch&gt;</code> 用于更清晰地切换分支。与 <code>git checkout</code> 类似，但提供了更清晰的语义和错误检查</li><li><code>git switch -c/--create &lt;new_branch&gt;</code> 用于创建一个新分支 <code>new_branch</code> 并且立即切换到新创建的分支</li><li><code>git switch -</code> 快速切换回前一个分支，无需记住分支名称</li><li><code>git switch &lt;option&gt; &lt;commit_hash&gt;</code> 将工作目录切换到指定提交 <code>commit_hash</code> 的状态，处于分离 <code>HEAD</code> 的状态<ul><li><code>-d/--detach</code> 选项可以使切换到某个提交的操作更明确，即使存在同名分支也不会切换到分支上</li><li><code>-c</code> 选项创建新分支并立即切换到该分支</li><li><code>-f/--force</code> 选项可以强制执行切换操作，即使存在未提交的更改</li></ul></li></ul><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><ul><li><code>git remote</code> 列出当前仓库中已经配置的远程仓库</li><li><code>git remote -v</code> 列出当前仓库配置的远程仓库，并且显示出其 url</li><li><code>git remote add &lt;remote_name&gt; &lt;remote_url&gt;</code> 添加一个新的远程仓库，指定一个远程仓库的名称和 url，并将其添加到当前仓库中</li><li><code>git remote rename &lt;old_name&gt; &lt;new_name&gt;</code> 将已经配置的远程仓库重命名</li><li><code>git remote remove/rm &lt;remote_name&gt;</code> 从当前仓库中删除指定的远程仓库</li><li><code>git remote set-url &lt;remote_name&gt; &lt;new_url&gt;</code> 修改指定远程仓库的 url</li><li><code>git remote show &lt;remote_name&gt;</code> 显示指定的远程仓库的详细信息，包括 url 和跟踪分支</li></ul><h3 id="恢复版本操作"><a href="#恢复版本操作" class="headerlink" title="恢复版本操作"></a>恢复版本操作</h3><ul><li><code>git reset [--soft | --mixed | --hard] [HEAD]</code> 用于回退版本，可以指定回退某一次提交的版本，回退之后，最新版本就被删除了<ul><li><code>HEAD</code> 当前版本</li><li><code>HEAD^</code> 上个版本</li><li><code>HEAD^^</code> 上上个版本</li><li><code>HEAD...</code> 以此类推</li><li><code>HEAD~0</code> 当前版本</li><li><code>HEAD~1</code> 上个版本</li><li><code>HEAD~2</code> 上上个版本</li><li><code>HEAD...</code> 以此类推</li><li><code>--soft</code> 用于回退到某个版本</li><li><code>--hard</code> 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交</li><li><code>--mixed</code> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变</li></ul></li><li><code>git revert &lt;commit_id&gt;</code> 用于撤消版本，将指定的 <code>commit_id</code> 的提交的内容从当前分支上撤除</li><li><code>git revert HEAD</code> 撤销对应的版本<ul><li><code>HEAD</code> 撤销前一次 <code>commit</code></li><li><code>HEAD^</code> 撤销前前一次 <code>commit</code></li></ul></li></ul><p><strong>区别</strong></p><ol><li><code>git revert</code> 是用一次新的 <code>commit</code> 来回滚之前的 <code>commit</code> ， <code>git reset</code> 是直接删除指定的 <code>commit</code></li><li>在回滚这一操作上看，效果差不多。但是在日后继续 <code>merge</code> 以前的老版本时有区别。因为 <code>git revert</code> 是用一次逆向的 <code>commit</code> 抵消之前的提交，因此日后合并老的 <code>branch</code> 时，导致这部分改变不会再次出现，但是 <code>git reset</code> 是之间把某些 <code>commit</code> 在某个 <code>branch</code> 上删除，因而和老的 <code>branch</code> 再次 <code>merge</code> 时，这些被回滚的 <code>commit</code> 应该还会被引入</li><li><code>git reset</code> 是把HEAD向后移动了一下，而 <code>git revert</code> 是 <code>HEAD</code> 继续前进，只是新的 <code>commit</code> 的内容和要 <code>revert</code> 的内容正好相反，能够抵消要被 <code>revert</code> 的内容</li></ol><h3 id="追溯文件修改记录"><a href="#追溯文件修改记录" class="headerlink" title="追溯文件修改记录"></a>追溯文件修改记录</h3><ul><li><code>git blame filename</code> 追溯一个指定文件的历史修改记录，能显示任何文件中每一行最后一次修改的提交记录</li><li><code>git blame -L n1,n2 filename</code> 使用 <code>-L</code> 参数来指定追溯文件的行数范围</li><li><code>git show [options] &lt;object&gt;</code> 用于显示各种类型的对象，对于提交，它显示日志消息和文本差异，对于标签，它显示标签消息和引用对象</li><li><code>git show commit_id</code> 用于查看某次提交的详情，使用 <code>git log</code> 指令查看提交日志，可以看到对应的 <code>commit_id</code></li><li><code>git show tag</code> 显示对应标签的详情，使用 <code>git tag</code> 来获得对应的 <code>tag</code></li><li><code>git show commit_id filename</code> 查看某次提交中某个文件的详情</li><li><code>git diff [file]</code> 比较文件在暂存区和工作区的差异</li><li><code>git diff --cached/--staged [file]</code> 显示暂存区和上一次提交的差异</li><li><code>git diff [first-branch]...[second-branch]</code> 显示两次提交之间的差异</li></ul><h3 id="stash-操作"><a href="#stash-操作" class="headerlink" title="stash 操作"></a>stash 操作</h3><ul><li><code>git stash</code> 会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录，stash 是本地的，不会通过 <code>git push</code> 命令上传</li><li><code>git stash pop</code> 命令恢复之前缓存的工作目录，将缓存堆栈中的第一个 stash 删除，并将对应修改应用到当前的工作目录下</li><li><code>git stash apply</code> 将缓存堆栈中的 stash 多次应用到工作目录中，但并不删除 stash 拷贝</li><li><code>git stash list</code> 查看现有的 stash</li><li><code>git stash drop [stash_name]</code> 移除对应的 stash</li><li><code>git stash clear</code> 删除所有缓存的 stash</li><li><code>git stash show [stash_name]</code> 查看指定的 stash 的 diff</li><li><code>git stash show [stash_name] -p/--patch</code> 查看指定的 stash 的全部 diff</li><li><code>git stash branch branch_name</code> 从存储的工作中创建一个分支</li><li><code>git stash -u</code> 可以缓存 untracked 文件</li><li><code>git stash -a</code> 可以缓存当前目录下的所有修改</li></ul><p><strong>注意</strong></p><p>默认情况下，git stash会缓存下列文件：</p><ol><li>添加到暂存区的修改（staged changes）</li><li>git 跟踪的但并未添加到暂存区的修改（unstaged changes）</li></ol><p>但不会缓存一下文件：</p><ol><li>在工作目录中新的文件（untracked files）</li><li>被忽略的文件（ignored files）</li></ol><p>但是可以使用</p><h3 id="其它一些操作"><a href="#其它一些操作" class="headerlink" title="其它一些操作"></a>其它一些操作</h3><ul><li><code>git remove/rm --cached xxx</code> 从远程版本库中删除文件，但是不删除本地系统和工作目录中的文件</li><li><code>git mv</code> 令用于移动或重命名一个文件、目录、软连接，使用与 Linux 中的 <code>mv</code> 指令类似</li><li><code>git clean options &lt;path&gt;</code> 从工作目录中/指定路径下删除所有没有 <code>tracked</code> ，没有被管理的文件<ul><li><code>-n</code> 显示将要被删除的文件</li><li><code>-f</code> 强制运行</li><li><code>-d</code> 删除未被添加到 git 路径中的文件（将 .gitignore 文件标记的文件全部删除）</li><li><code>-x</code> 删除没有被 track 的文件</li></ul></li><li><code>git log [&lt;options&gt;] [&lt;since&gt;..&lt;until&gt;] [[--] &lt;path&gt;...]</code> 主要用于查看 git 版本演变历史（也就是提交历史），同时根据追加的参数和选项不同，也会有不同的展示效果，太过于复杂了，可以看看 <a href="https://blog.csdn.net/hlsxjh/article/details/135532818">git log</a></li></ul><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><code>.gitignore</code> 文件位于工作区的根目录中，用来指定忽略的文件，从而实现忽略一些不重要的文件，从而减少整个项目占用的空间（毕竟 <code>github</code> 仓库最大 1GB）</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>在任何当前工作的 git 仓库中，每个文件都被做上了标记：</p><ul><li>追踪的（tracked）- 这些是 git 所知道的所有文件或目录。这些是新添加（用 git add 添加）和提交（用 git commit 提交）到主仓库的文件和目录</li><li>未被追踪的（untracked） - 这些是在工作目录中创建的，但还没有被暂存（或用 git add 命令添加）的任何新文件或目录</li><li>被忽略的（ignored） - 这些是 git 知道的要全部排除、忽略或在 git 仓库中不需要注意的所有文件或目录。本质上，这是一种告诉 git 哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法</li></ul><p>所有被忽略的文件都会被保存在 <code>.gitignore</code> 文件中，它是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 git 忽略的</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>直接在工作区的根目录中创建文件即可</p><h3 id="书写"><a href="#书写" class="headerlink" title="书写"></a>书写</h3><ul><li><code>filename</code> 直接忽略工作空间内所有名为 <code>filename</code> 的文件/文件夹</li><li><code>dir/filename</code> 忽略 <code>dir</code> 目录下的名为 <code>filename</code> 的文件/文件夹。这个 <code>dir</code> 一般为相对路径，相对于 <code>.gitignore</code> 的路径</li><li><code>dir/</code> 忽略 <code>dir</code> 目录下的所有文件/文件夹</li><li>正则表达式，所有符合正则表达式的匹配都会被忽略<ul><li><code>xx*</code> 以 <code>xx</code> 开头的文件/文件夹</li><li><code>xx.*</code> 所有带有后缀的文件/文件夹</li><li><code>*.xx</code> 所有以 <code>.xx</code> 文件扩展名结尾的文件</li></ul></li><li><code>!filename</code> 当这个文件名匹配到其它的忽略项时，可以使用该语句来取消忽略</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>.gitignore</code> 只能忽略没有提交或者上传的文件，当已经提交/上传了的话，只是不会再更新对应的文件了，已经提交/上传的依旧会保存，这个需要注意</p><h2 id="一些其它注意事项"><a href="#一些其它注意事项" class="headerlink" title="一些其它注意事项"></a>一些其它注意事项</h2><h3 id="创建一个新仓库"><a href="#创建一个新仓库" class="headerlink" title="创建一个新仓库"></a>创建一个新仓库</h3><ol><li><p><strong>方法1</strong><br> 直接在本地创建，然后发布到远程端，比较方便</p></li><li><p><strong>方法2</strong><br> 在远程端创建好，然后在本地端与之绑定</p></li><li><p><strong>方法3</strong><br> 在远程端创建好，然后直接下载到本地端使用</p></li></ol><h3 id="遇到的一些奇怪的问题"><a href="#遇到的一些奇怪的问题" class="headerlink" title="遇到的一些奇怪的问题"></a>遇到的一些奇怪的问题</h3><ol><li><code>can’t push refs to remote</code> 重新建立一个分支之后就可以向那个分支提交，之后有需要可以合并分支，但是好像有其它方法，忘记了。。。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双轮足式机器人控制器设计</title>
      <link href="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/wheelfoot">github开源仓库</a></p><p><strong>注意方向问题！意方向问题！方向问题！向问题！问题！题！</strong></p><p>机体解算时所用到的角度力矩方向都是顺时针为正（从右侧看），但是在 VMC 和腿部五连杆解算中，几乎都是逆时针为正，但是有一点，关节电机的转矩为顺时针为正，所以读者一定要注意这一点</p><h1 id="单侧系统状态方程求解"><a href="#单侧系统状态方程求解" class="headerlink" title="单侧系统状态方程求解"></a>单侧系统状态方程求解</h1><p>首先双轮足式机器人可以将模型化简为一个倒立摆模型，如下</p><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709187889300.png" alt="1709187889300.png"></p><p>分块开始分析</p><h2 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a><strong>轮子</strong></h2><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709189277698.png" alt="1709189277698.png"></p><p>水平方向上</p><script type="math/tex; mode=display">m_w\ddot{x}=f-N_w</script><p>竖直方向上</p><script type="math/tex; mode=display">F_N=P_w+G</script><p>转矩</p><script type="math/tex; mode=display">I_w\frac{\ddot{x}}{r}=T_w-fr</script><p>联立消去 $f$ 得到</p><script type="math/tex; mode=display">\ddot{x}=\frac{T_wr-N_wr^2}{I_w+m_wr^2}~~~~{1}</script><h2 id="摆杆"><a href="#摆杆" class="headerlink" title="摆杆"></a><strong>摆杆</strong></h2><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709190884792.png" alt="1709190884792.png"></p><p>水平方向上</p><script type="math/tex; mode=display">m_l(\ddot{x}+\frac{\partial^2}{\partial t^2}L_w\sin\theta)=N_w-N_b~~~~{2}</script><p>竖直方向上</p><script type="math/tex; mode=display">m_l\frac{\partial^2}{\partial t^2}L_w\cos\theta=P_w-P_b-m_lg~~~~{3}</script><p>转矩</p><script type="math/tex; mode=display">I_l\ddot{\theta}=T_b-T_w+(P_bL_b+P_wL_w)\sin\theta-(N_bL_b+N_wL_w)\cos\theta~~~~{4}</script><h2 id="机体"><a href="#机体" class="headerlink" title="机体"></a><strong>机体</strong></h2><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709204006116.png" alt="1709204006116.png"></p><p>水平方向上</p><script type="math/tex; mode=display">m_b(\ddot{x}+\frac{\partial^2}{\partial t^2}L\sin\theta-\frac{\partial^2}{\partial t^2}l\sin\varphi)=N_b~~~~{5}</script><p>竖直方向上</p><script type="math/tex; mode=display">m_b(\frac{\partial^2}{\partial t^2}L\cos\theta+\frac{\partial^2}{\partial t^2}l\cos\varphi)=P_b-m_bg~~~~{6}</script><p>转矩</p><script type="math/tex; mode=display">I_b\ddot{\varphi}=T_b+N_bl\cos\varphi+P_bl\sin\varphi~~~~{7}</script><p>根据上述得到的 ${2},{3},{5},{6}$ 联立，得到中间变量 $P_w,N_w,P_b,N_b$ 的表达式，得</p><script type="math/tex; mode=display">\left\{\begin{aligned}&P_w=m_b(\frac{\partial^2}{\partial t^2}L\cos\theta+\frac{\partial^2}{\partial t^2}l\cos\varphi)+m_bg+m_l\frac{\partial^2}{\partial t^2}L_w\cos\theta+m_lg\\&N_w=m_l(\ddot{x}+\frac{\partial^2}{\partial t^2}L_w\sin\theta)+m_b(\ddot{x}+\frac{\partial^2}{\partial t^2}L\sin\theta-\frac{\partial^2}{\partial t^2}l\sin\varphi)\\&P_b=m_b(\frac{\partial^2}{\partial t^2}L\cos\theta+\frac{\partial^2}{\partial t^2}l\cos\varphi)+m_bg\\&N_b=m_b(\ddot{x}+\frac{\partial^2}{\partial t^2}L\sin\theta-\frac{\partial^2}{\partial t^2}l\sin\varphi)\end{aligned}\right.</script><p>带入 ${1},{4},{7}$ 中，并且利用 matlab 的符号求解工具解。</p><p>设定</p><script type="math/tex; mode=display">X=\begin{bmatrix}\theta\\\dot{\theta}\\x\\\dot{x}\\\varphi\\\dot\varphi\end{bmatrix}\\U=\begin{bmatrix}T_w\\T_b\end{bmatrix}</script><p>最终求解对应的雅各比矩阵，就是 A 和 B</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">syms x(t) theta(t) phi(t)</span><br><span class="line">syms Tw Tb Pw Pb Nw Nb</span><br><span class="line">syms x_ddot theta_ddot phi_ddot x_dot theta_dot phi_dot</span><br><span class="line">syms mw R Iw mb Ib_y g Ic_z R_l l ml</span><br><span class="line">syms L Il Lw Lb</span><br><span class="line"><span class="comment">% 这里的 mw, Iw, ml, Il 都是指的是两侧的总的参数 </span></span><br><span class="line"></span><br><span class="line">func1 = [ml * diff(diff(x + Lw * <span class="built_in">sin</span>(theta), t), t) == Nw - Nb;</span><br><span class="line">    ml * diff(diff(Lw * <span class="built_in">cos</span>(theta), t), t) == Pw - Pb - ml * g;</span><br><span class="line">    mb * diff(diff(x + L * <span class="built_in">sin</span>(theta) - l * <span class="built_in">sin</span>(phi), t), t) == Nb;</span><br><span class="line">    mb * diff(diff(L * <span class="built_in">cos</span>(theta) + l * <span class="built_in">cos</span>(phi), t), t) == Pb - mb * g;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">[Pw, Pb, Nw, Nb] = solve(func1, [Pw, Pb, Nw, Nb]);</span><br><span class="line"></span><br><span class="line">func2 = [diff(diff(x, t), t) == (Tw * R - Nw * R * R) / (Iw + mw * R * R);</span><br><span class="line">    Il * diff(diff(theta, t), t) == Tb - Tw + (Pb * Lb + Pw * Lw) * <span class="built_in">sin</span>(theta) - (Nb * Lb + Nw * Lw) * <span class="built_in">cos</span>(theta);</span><br><span class="line">    Ib_y * diff(diff(phi, t), t) == Tb + Nb * l * <span class="built_in">cos</span>(phi) + Pb * l * <span class="built_in">sin</span>(phi);];</span><br><span class="line"></span><br><span class="line">func2 = subs(func2, ...</span><br><span class="line">    [diff(diff(x, t), t), diff(diff(theta, t), t), diff(diff(phi, t), t), diff(x, t), diff(theta, t), diff(phi, t)], ...</span><br><span class="line">    [x_ddot, theta_ddot, phi_ddot, x_dot, theta_dot, phi_dot]);</span><br><span class="line"></span><br><span class="line">[x_ddot, theta_ddot, phi_ddot] = solve(func2, [x_ddot theta_ddot phi_ddot]);</span><br><span class="line"></span><br><span class="line">X = [theta(t); theta_dot; x(t); x_dot; phi(t); phi_dot];</span><br><span class="line">u = [Tw; Tb];</span><br><span class="line">X_dot = [theta_dot; theta_ddot; x_dot; x_ddot; phi_dot; phi_ddot];</span><br><span class="line">A = jacobian(X_dot, X);</span><br><span class="line">B = jacobian(X_dot, u);</span><br><span class="line">A = subs(A, [x_dot, theta(t), theta_dot, phi(t), phi_dot, Tw, Tb], <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">7</span>))</span><br><span class="line">B = subs(B, [x_dot, theta(t), theta_dot, phi(t), phi_dot, Tw, Tb], <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">7</span>))</span><br></pre></td></tr></table></figure><p>最终得到结果，有点复杂，之前那个是解算出错了 T_T</p><p>这就是系统状态空间方程</p><h1 id="控制器设计"><a href="#控制器设计" class="headerlink" title="控制器设计"></a>控制器设计</h1><h2 id="LQR-控制器"><a href="#LQR-控制器" class="headerlink" title="LQR 控制器"></a>LQR 控制器</h2><p>首先是 LQR 控制器。是一个比较常用的控制器，设计起来也比较简单。</p><p>推导过程与一般的 LQR 无异，所以直接调用 matlab 函数来求得对应的 K，最终需要拟合出一个 K 关于杆长的函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 设置</span></span><br><span class="line">C = <span class="built_in">eye</span>(<span class="number">6</span>);</span><br><span class="line">D = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">Q = <span class="built_in">diag</span>([<span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">10</span> <span class="number">5000</span> <span class="number">1</span>]);</span><br><span class="line">R = <span class="built_in">diag</span>([<span class="number">1</span> <span class="number">0.25</span>]);</span><br><span class="line">sys = ss(A, B, C, D);</span><br><span class="line">KLQR = lqr(sys, Q, R);<span class="comment">%得到反馈增益矩阵</span></span><br></pre></td></tr></table></figure><p>其中的 Q 和 R 就是系统状态与系统输入的权重，越大表示越在意</p><p>最终需要将控制器反馈增益矩阵拟合为关于杆长的一元三次方程，具体的拟合代码为</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"><span class="comment">%% 拟合质心位置，转动惯量和杆长的函数</span></span><br><span class="line">I = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">116</span>);</span><br><span class="line">L = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">116</span>);</span><br><span class="line">Lw = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">116</span>);</span><br><span class="line">Lb = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">116</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> angle4 = <span class="number">-15</span> : <span class="number">1</span> : <span class="number">100</span></span><br><span class="line">    [ml, Il, L_, Lw_, Lb_] = GetLegBaryCenter(<span class="number">180</span> - angle4, angle4, <span class="number">0</span>);</span><br><span class="line">    I(angle4 + <span class="number">16</span>) = Il;</span><br><span class="line">    L(angle4 + <span class="number">16</span>) = L_;</span><br><span class="line">    Lw(angle4 + <span class="number">16</span>) = Lw_;</span><br><span class="line">    Lb(angle4 + <span class="number">16</span>) = Lb_;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">KI = polyfit(L, I, <span class="number">1</span>);</span><br><span class="line">valKI = polyval(KI,L);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);<span class="built_in">hold</span> on;<span class="built_in">plot</span>(L,I,<span class="string">&#x27;r*&#x27;</span>,L,valKI,<span class="string">&#x27;b-.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">KLw = polyfit(L, Lw, <span class="number">1</span>);</span><br><span class="line">valKLw = polyval(KLw,L);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);<span class="built_in">hold</span> on;<span class="built_in">plot</span>(L,Lw,<span class="string">&#x27;r*&#x27;</span>,L,valKLw,<span class="string">&#x27;b-.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">KLb = polyfit(L, Lb, <span class="number">1</span>);</span><br><span class="line">valKLb = polyval(KLb,L);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);<span class="built_in">hold</span> on;<span class="built_in">plot</span>(L,Lb,<span class="string">&#x27;r*&#x27;</span>,L,valKLb,<span class="string">&#x27;b-.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 开始解算</span></span><br><span class="line">syms x(t) theta(t) phi(t)</span><br><span class="line">syms Tw Tb Pw Pb Nw Nb</span><br><span class="line">syms x_ddot theta_ddot phi_ddot x_dot theta_dot phi_dot</span><br><span class="line">syms L</span><br><span class="line">mw = <span class="number">1.267245</span> * <span class="number">2</span>;</span><br><span class="line">R = <span class="number">0.2</span>;</span><br><span class="line">Iw = <span class="number">0.00379267</span> * <span class="number">2</span>;</span><br><span class="line">mb = <span class="number">5.4940204</span>;</span><br><span class="line">Ib_y = <span class="number">0.05026821</span>;</span><br><span class="line">g = <span class="number">9.81</span>;</span><br><span class="line">Ic_z = <span class="number">0.37248874</span>;</span><br><span class="line">R_l = <span class="number">0.482000001</span>;</span><br><span class="line">l = <span class="number">-0.01994485</span>;</span><br><span class="line">Il = (KI(<span class="number">1</span>, <span class="number">1</span>) * L + KI(<span class="number">1</span>, <span class="number">2</span>)) * <span class="number">2</span>;</span><br><span class="line">Lw = KLw(<span class="number">1</span>, <span class="number">1</span>) * L + KLw(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Lb = KLb(<span class="number">1</span>, <span class="number">1</span>) * L + KLb(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ml = ml * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">func1 = [ml * diff(diff(x + Lw * <span class="built_in">sin</span>(theta), t), t) == Nw - Nb;</span><br><span class="line">    ml * diff(diff(Lw * <span class="built_in">cos</span>(theta), t), t) == Pw - Pb - ml * g;</span><br><span class="line">    mb * diff(diff(x + L * <span class="built_in">sin</span>(theta) - l * <span class="built_in">sin</span>(phi), t), t) == Nb;</span><br><span class="line">    mb * diff(diff(L * <span class="built_in">cos</span>(theta) + l * <span class="built_in">cos</span>(phi), t), t) == Pb - mb * g;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">[Pw, Pb, Nw, Nb] = solve(func1, [Pw, Pb, Nw, Nb]);</span><br><span class="line"></span><br><span class="line">func2 = [diff(diff(x, t), t) == (Tw * R - Nw * R * R) / (Iw + mw * R * R);</span><br><span class="line">    Il * diff(diff(theta, t), t) == Tb - Tw + (Pb * Lb + Pw * Lw) * <span class="built_in">sin</span>(theta) - (Nb * Lb + Nw * Lw) * <span class="built_in">cos</span>(theta);</span><br><span class="line">    Ib_y * diff(diff(phi, t), t) == Tb + Nb * l * <span class="built_in">cos</span>(phi) + Pb * l * <span class="built_in">sin</span>(phi);];</span><br><span class="line"></span><br><span class="line">func2 = subs(func2, ...</span><br><span class="line">    [diff(diff(x, t), t), diff(diff(theta, t), t), diff(diff(phi, t), t), diff(x, t), diff(theta, t), diff(phi, t)], ...</span><br><span class="line">    [x_ddot, theta_ddot, phi_ddot, x_dot, theta_dot, phi_dot]);</span><br><span class="line"></span><br><span class="line">[x_ddot, theta_ddot, phi_ddot] = solve(func2, [x_ddot theta_ddot phi_ddot]);</span><br><span class="line"></span><br><span class="line">X = [theta(t); theta_dot; x(t); x_dot; phi(t); phi_dot];</span><br><span class="line">u = [Tw; Tb];</span><br><span class="line">X_dot = [theta_dot; theta_ddot; x_dot; x_ddot; phi_dot; phi_ddot];</span><br><span class="line">A = jacobian(X_dot, X);</span><br><span class="line">B = jacobian(X_dot, u);</span><br><span class="line">A = subs(A, [x_dot, theta(t), theta_dot, phi(t), phi_dot, Tw, Tb], <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">7</span>));</span><br><span class="line">B = subs(B, [x_dot, theta(t), theta_dot, phi(t), phi_dot, Tw, Tb], <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置拟合次数和腿长，开始拟合</span></span><br><span class="line">numsize = <span class="number">29</span>;</span><br><span class="line">minleglen = <span class="number">0.120</span>;</span><br><span class="line">maxleglen = <span class="number">0.400</span>;</span><br><span class="line"></span><br><span class="line">K_vals = <span class="built_in">zeros</span>(numsize, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">A_vals = <span class="built_in">zeros</span>(numsize, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">B_vals = <span class="built_in">zeros</span>(numsize, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">L_ranges = <span class="built_in">linspace</span>(minleglen, maxleglen, numsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">1</span> : numsize</span><br><span class="line">valL = L_ranges(<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line">valA = subs(A, L, valL);</span><br><span class="line">valB = subs(B, L, valL);</span><br><span class="line">valA = double(valA);</span><br><span class="line">valB = double(valB);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rank(ctrb(valA, valB)) == <span class="built_in">size</span>(valA, <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;系统可控&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;系统不可控&#x27;</span>)</span><br><span class="line">    K = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">i</span>)</span><br><span class="line"></span><br><span class="line">C = <span class="built_in">eye</span>(<span class="number">6</span>);</span><br><span class="line">D = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">Q = <span class="built_in">diag</span>([<span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">10</span> <span class="number">5000</span> <span class="number">1</span>]);</span><br><span class="line">R = <span class="built_in">diag</span>([<span class="number">1</span> <span class="number">0.25</span>]);</span><br><span class="line">sys = ss(valA, valB, C, D);</span><br><span class="line">KLQR = lqr(sys, Q, R);<span class="comment">%得到反馈增益矩阵</span></span><br><span class="line">K_vals(<span class="built_in">i</span>, :, :) = KLQR;</span><br><span class="line">A_vals(<span class="built_in">i</span>, :, :) = valA;</span><br><span class="line">B_vals(<span class="built_in">i</span>, :, :) = valB;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% LQR 拟合:比较倾向于使用Curve Fitting Toolbox，简单好用</span></span><br><span class="line">K11 = K_vals(:, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">K12 = K_vals(:, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">K13 = K_vals(:, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">K14 = K_vals(:, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">K15 = K_vals(:, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">K16 = K_vals(:, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">K21 = K_vals(:, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">K22 = K_vals(:, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">K23 = K_vals(:, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">K24 = K_vals(:, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">K25 = K_vals(:, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">K26 = K_vals(:, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A11 = A_vals(:, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">A12 = A_vals(:, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">A13 = A_vals(:, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">A14 = A_vals(:, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">A15 = A_vals(:, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">A16 = A_vals(:, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A21 = A_vals(:, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">A22 = A_vals(:, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">A23 = A_vals(:, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">A24 = A_vals(:, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">A25 = A_vals(:, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">A26 = A_vals(:, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A31 = A_vals(:, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">A32 = A_vals(:, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">A33 = A_vals(:, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">A34 = A_vals(:, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">A35 = A_vals(:, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">A36 = A_vals(:, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A41 = A_vals(:, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">A42 = A_vals(:, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">A43 = A_vals(:, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">A44 = A_vals(:, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">A45 = A_vals(:, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">A46 = A_vals(:, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A51 = A_vals(:, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">A52 = A_vals(:, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">A53 = A_vals(:, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">A54 = A_vals(:, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">A55 = A_vals(:, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">A56 = A_vals(:, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A61 = A_vals(:, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">A62 = A_vals(:, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">A63 = A_vals(:, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">A64 = A_vals(:, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">A65 = A_vals(:, <span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">A66 = A_vals(:, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">B11 = B_vals(:, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">B12 = B_vals(:, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B21 = B_vals(:, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">B22 = B_vals(:, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B31 = B_vals(:, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">B32 = B_vals(:, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B41 = B_vals(:, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">B42 = B_vals(:, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B51 = B_vals(:, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">B52 = B_vals(:, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B61 = B_vals(:, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">B62 = B_vals(:, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不知道为啥，喜欢上使用 Curve Fitting Toolbox 了，不想自己写代码了</p><h2 id="Hinfinty-控制器"><a href="#Hinfinty-控制器" class="headerlink" title="Hinfinty 控制器"></a>Hinfinty 控制器</h2><p>由于默认系统的传感器读取是没有噪声的，所以就把噪声的增益都设置为 0</p><p>推导过程与一般的 Hinfinty 控制器无异，所以直接放出 matlab 中的代码，可调试不同的 $\gamma$ 值来使系统有不同的表现。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">B_1 = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">B_2 = B;</span><br><span class="line">C_1 = <span class="built_in">diag</span>([<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">D_11 = <span class="number">0</span>;</span><br><span class="line">D_12 = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">C_2 = <span class="built_in">diag</span>([<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">D_21 = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">D_22 = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">syssize = <span class="built_in">size</span>(A, <span class="number">1</span>);</span><br><span class="line">inputsize = <span class="built_in">size</span>(B, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">gamma</span> = <span class="number">3.1</span>;</span><br><span class="line"></span><br><span class="line">setlmis([]);</span><br><span class="line">Xh = lmivar(<span class="number">1</span>, [syssize <span class="number">1</span>]);</span><br><span class="line">Wh = lmivar(<span class="number">2</span>, [inputsize syssize]);</span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> Xh], A, <span class="number">1</span>, <span class="string">&#x27;s&#x27;</span>); <span class="comment">% AX+(AX)&#x27;</span></span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> Wh], B_2, <span class="number">1</span>, <span class="string">&#x27;s&#x27;</span>); <span class="comment">%B_2W+(B_2W)&#x27;</span></span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span>], B_1&#x27;); <span class="comment">% B1&#x27;</span></span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span>], <span class="number">-1</span>); <span class="comment">% -I</span></span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">3</span> <span class="number">1</span> Xh], C_1, <span class="number">1</span>); <span class="comment">% C1X</span></span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">3</span> <span class="number">1</span> Wh], D_12, <span class="number">1</span>); <span class="comment">% D12W</span></span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">0</span>], D_11); <span class="comment">% D11</span></span><br><span class="line">lmiterm([<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span>], <span class="number">-1</span> * <span class="built_in">gamma</span> ^ <span class="number">2</span>); <span class="comment">% -γ^2I</span></span><br><span class="line">lmiterm([<span class="number">-2</span> <span class="number">1</span> <span class="number">1</span> Xh], <span class="number">1</span>, <span class="number">1</span>); <span class="comment">% X&gt;0 特别注意不能漏掉</span></span><br><span class="line"></span><br><span class="line">lmisys = getlmis;</span><br><span class="line">[tmin, xfeas] = feasp(lmisys);</span><br><span class="line">XX2 = dec2mat(lmisys, xfeas, Xh);</span><br><span class="line">WW2 = dec2mat(lmisys, xfeas, Wh);</span><br><span class="line">KHinfinty = WW2 * inv(XX2);</span><br></pre></td></tr></table></figure><h2 id="二阶-LADRC"><a href="#二阶-LADRC" class="headerlink" title="二阶 LADRC"></a>二阶 LADRC</h2><h3 id="LTD"><a href="#LTD" class="headerlink" title="LTD"></a>LTD</h3><p>这是由二阶低通滤波器来得到的，只需要更改 r 值， $r$ 值越大到达设定值 $v$ 的时间就越短</p><script type="math/tex; mode=display">X=\begin{bmatrix}x_r\\\dot{x_r}\\\theta_r\\\dot{\theta_r}\\\varphi_r\\\dot\varphi_r\end{bmatrix}\\U=\begin{bmatrix}Tw\\Tb\end{bmatrix}</script><p>由于系统中状态有 6 个，所以需要 3 个低通滤波器，这里的 R 表示输入的期望值</p><script type="math/tex; mode=display">\dot{X}=AX+BR=\begin{bmatrix}0&1\\-r^2_1&-2r_1\\0&1\\-r^2_2&-2r_2\\0&1\\-r^2_3&-2r_3\end{bmatrix}X+\begin{bmatrix}0\\r_1^2\\0\\r_2^2\\0\\r_3^2\end{bmatrix}R</script><p>所以得到离散型的系统状态方程</p><script type="math/tex; mode=display">x_r(k+1)=h\dot{x}_r(k)+x_r(k)\\\\\dot{x}_r(k+1)=h(-r_1^2x_r(k)-2r_1\dot{x_r}(k)+r_1^2R_{\dot x})+\dot{x_r}(k)\\\\\theta_r(k+1)=h\dot{\theta}_r(k)+\theta_r(k)\\\\\dot{\theta}_r(k+1)=h(-r_2^2\theta_r(k)-2r_2\dot{\theta_r}(k)+r_2^2R_{\dot\theta})+\dot{\theta_r}(k)\\\\\varphi_r(k+1)=h\dot{\varphi}_r(k)+\varphi_r(k)\\\\\dot{\varphi}_r(k+1)=h(-r_3^2\varphi_r(k)-2r_3\dot{\varphi_r}(k)+r_3^2R_{\dot{\varphi}})+\dot{\varphi_r}(k)</script><h3 id="LESO"><a href="#LESO" class="headerlink" title="LESO"></a>LESO</h3><p>对于每一对系统状态（$x,\dot{x}$）都需要设计一个扩张状态观测器，所以令</p><script type="math/tex; mode=display">S_1=\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}\\\\S_2=\begin{bmatrix}\theta_1\\\theta_2\\\theta_3\end{bmatrix}\\\\S_3=\begin{bmatrix}\varphi_1\\\varphi_2\\\varphi_3\end{bmatrix}</script><p>并且有</p><script type="math/tex; mode=display">x_1\rightarrow x\\\\x_2\rightarrow \dot{x}\\\\x_3\rightarrow f_x\\\\\theta_1\rightarrow \theta\\\\\theta_2\rightarrow \dot\theta\\\\\theta_3\rightarrow f_{\theta}\\\\\varphi_1\rightarrow \varphi\\\\\varphi_2\rightarrow \dot{\varphi}\\\\\varphi_3\rightarrow f_{\varphi}</script><p>可以得到</p><script type="math/tex; mode=display">\dot{Z}=AZ+Bu+L(x_1-z_1)\\\hat{y}=CZ</script><p>并且有</p><script type="math/tex; mode=display">L_1=\begin{bmatrix}\beta_{11}\\\beta_{12}\\\beta_{13}\end{bmatrix}\\\\L_2=\begin{bmatrix}\beta_{21}\\\beta_{22}\\\beta_{23}\end{bmatrix}\\\\L_3=\begin{bmatrix}\beta_{31}\\\beta_{32}\\\beta_{33}\end{bmatrix}</script><p>带入可以得到</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x_1}\\\dot{x_2}\\\dot{x_3}\end{bmatrix}=\begin{bmatrix}-\beta_{11}&1&0\\-\beta_{12}&0&1\\-\beta_{13}&0&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}+\begin{bmatrix}0&\beta_{11}\\b_1&\beta_{12}\\0&\beta_{13}\end{bmatrix}\begin{bmatrix}u\\y\end{bmatrix}\\\\\begin{bmatrix}\dot{\theta_1}\\\dot{\theta_2}\\\dot{\theta_3}\end{bmatrix}=\begin{bmatrix}-\beta_{21}&1&0\\-\beta_{22}&0&1\\-\beta_{23}&0&0\end{bmatrix}\begin{bmatrix}\theta_1\\\theta_2\\\theta_3\end{bmatrix}+\begin{bmatrix}0&\beta_{21}\\b_2&\beta_{22}\\0&\beta_{23}\end{bmatrix}\begin{bmatrix}u\\y\end{bmatrix}\\\\\begin{bmatrix}\dot{\varphi_1}\\\dot{\varphi_2}\\\dot{\varphi_3}\end{bmatrix}=\begin{bmatrix}-\beta_{31}&1&0\\-\beta_{32}&0&1\\-\beta_{33}&0&0\end{bmatrix}\begin{bmatrix}\varphi_1\\\varphi_2\\\varphi_3\end{bmatrix}+\begin{bmatrix}0&\beta_{31}\\b_3&\beta_{32}\\0&\beta_{33}\end{bmatrix}\begin{bmatrix}u\\y\end{bmatrix}</script><p>其中的 $\beta$ 都是存在于特征方程中</p><script type="math/tex; mode=display">L_{ESO}(s)=s^{n+1}+\beta_1 s^n + \beta_2 s^{n-1}+…+\beta_{n-1}</script><p>并且可以将调节参数缩减为</p><script type="math/tex; mode=display">L_{ESO1}=(s+w_{o1})^{n+1}\\\\L_{ESO2}=(s+w_{o2})^{n+1}\\\\L_{ESO3}=(s+w_{o3})^{n+1}</script><p>其中 $w_o$ 表示扩张观测器的带宽</p><p>所以上述可以写为公式，其中 $b_1,b_2, b_3\in R^{1\times2}$</p><script type="math/tex; mode=display">x_1(k+1)=x_1(k)+h(-\beta_{11}x_1(k)+x_2(k)+\beta_{11}y_x)\\\\x_2(k+1)=x_2(k)+h(-\beta_{12}x_1(k)+x_3(k)+b_1u+\beta_{12}y_x)\\\\x_3(k+1)=x_3(k)+h(-\beta_{13}x_1(k)+\beta_{13}y_x)</script><script type="math/tex; mode=display">\theta_1(k+1)=\theta_1(k)+h(-\beta_{21}\theta_1(k)+\theta_2(k)+\beta_{21}y_\theta)\\\\\theta_2(k+1)=\theta_2(k)+h(-\beta_{22}\theta_1(k)+\theta_3(k)+b_2u+\beta_{22}y_\theta)\\\\\theta_3(k+1)=\theta_3(k)+h(-\beta_{23}\theta_1(k)+\beta_{23}y_\theta)</script><script type="math/tex; mode=display">\varphi_1(k+1)=\varphi_1(k)+h(-\beta_{31}\varphi_1(k)+\varphi_2(k)+\beta_{31}y_\varphi)\\\\\varphi_2(k+1)=\varphi_2(k)+h(-\beta_{32}\varphi_1(k)+\varphi_3(k)+b_3u+\beta_{32}y_\varphi)\\\\\varphi_3(k+1)=\varphi_3(k)+h(-\beta_{33}\varphi_1(k)+\beta_{33}y_\varphi)</script><h3 id="LSEF"><a href="#LSEF" class="headerlink" title="LSEF"></a>LSEF</h3><p>设</p><script type="math/tex; mode=display">e_{11}=x_{r}-x_1\\\\e_{12}=\dot{x}_r-x_2\\\\e_{21}=\theta_{r}-\theta_1\\\\e_{22}=\dot{\theta}_r-\theta_2\\\\e_{31}=\varphi_{r}-\varphi_1\\\\e_{32}=\dot{\varphi}_r-\varphi_2</script><script type="math/tex; mode=display">T_w=\frac{a_{111}e_{11}+a_{112}e_{12}-x_3}{b_{11}}+\frac{a_{121}e_{21}+a_{122}e_{22}-\theta_3}{b_{12}}+\frac{a_{131}e_{31}+a_{132}e_{32}-\varphi_3}{b_{13}}\\\\T_b=\frac{a_{211}e_{11}+a_{212}e_{12}-x_3}{b_{21}}+\frac{a_{221}e_{21}+a_{222}e_{22}-\theta_3}{b_{22}}+\frac{a_{231}e_{31}+a_{232}e_{32}-\varphi_3}{b_{23}}</script><p>其中 $a$ 存在于 SEF 特征方程中</p><script type="math/tex; mode=display">L_{SEF}(s)=s^n+a_ns^{n-1}+…+a_2s+a_1</script><p>将特征值统一配置在左半实轴同一位置，得到</p><script type="math/tex; mode=display">L_{SEF11}(s)=(s+w_{c11})^{n}\\\\L_{SEF12}(s)=(s+w_{c12})^{n}\\\\L_{SEF13}(s)=(s+w_{c13})^{n}\\\\L_{SEF21}(s)=(s+w_{c21})^{n}\\\\L_{SEF22}(s)=(s+w_{c22})^{n}\\\\L_{SEF23}(s)=(s+w_{c23})^{n}</script><p>其中 $w_c$ 是 LSEF 的带宽</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要调试的参数</p><script type="math/tex; mode=display">w_{o1}\\\\w_{o2}\\\\w_{o3}\\\\w_{c11}\\\\w_{c12}\\\\w_{c13}\\\\w_{c21}\\\\w_{c22}\\\\w_{c23}\\\\b_1\\\\b_2\\\\b_3</script><p>一共是 12 个参数 T_T，但是在很多系统中 $b=1$</p><h2 id="三阶-LADRC"><a href="#三阶-LADRC" class="headerlink" title="三阶 LADRC"></a>三阶 LADRC</h2><p>与二阶 LADRC 过程一致，所以直接得到结果</p><h3 id="LTD-1"><a href="#LTD-1" class="headerlink" title="LTD"></a>LTD</h3><script type="math/tex; mode=display">x_r(k+1)=h\dot{x}_r(k)+x_r(k)\\\\\dot{x}_r(k+1)=h\ddot{x}_r(k)+\dot{x_r}(k)\\\\\ddot{x}_r(k+1)=h(-r_1^3x_r(k)-3r_1^2\dot{x}_r(k)-3r\ddot{x}_r(k)+r^3R_{\ddot{x}})+\dot{x_r}(k)</script><p>其它两个形式与之一致</p><h3 id="LESO-1"><a href="#LESO-1" class="headerlink" title="LESO"></a>LESO</h3><script type="math/tex; mode=display">x_1(k+1)=x_1(k)+h(-\beta_{11}x_1(k)+x_2(k)+\beta_{11}y_x)\\\\x_2(k+1)=x_2(k)+h(-\beta_{12}x_1(k)+x_3(k)+\beta_{12}y_x)\\\\x_3(k+1)=x_3(k)+h(-\beta_{13}x_1(k)+x_4(k)+b_1u+\beta_{13}y_x)\\\\x_4(k+1)=x_4(k)+h(-\beta_{14}x_1(k)+\beta_{14}y_x)</script><p>其它两个与之一致</p><h3 id="LSEF-1"><a href="#LSEF-1" class="headerlink" title="LSEF"></a>LSEF</h3><script type="math/tex; mode=display">e_{11}=x_{r}-x_1\\\\e_{12}=\dot{x}_r-x_2\\\\e_{13}=\ddot{x}_r-x_3\\\\e_{21}=\theta_{r}-\theta_1\\\\e_{22}=\dot{\theta}_r-\theta_2\\\\e_{23}=\ddot{\theta}_r-\theta_3\\\\e_{31}=\varphi_{r}-\varphi_1\\\\e_{32}=\dot{\varphi}_r-\varphi_2\\\\e_{33}=\ddot{\varphi}_r-\varphi_3</script><script type="math/tex; mode=display">T_w=\frac{a_{111}e_{11}+a_{112}e_{12}+a_{113}e_{13}-x_4}{b_1}+\frac{a_{121}e_{21}+a_{122}e_{22}+a_{123}e_{23}-\theta_4}{b_2}+\frac{a_{131}e_{31}+a_{132}e_{32}+a_{133}e_{33}-\varphi_4}{b_3}\\\\T_b=\frac{a_{211}e_{11}+a_{212}e_{12}+a_{213}e_{13}-x_4}{b_1}+\frac{a_{221}e_{21}+a_{222}e_{22}+a_{223}e_{23}-\theta_4}{b_2}+\frac{a_{231}e_{31}+a_{232}e_{32}+a_{233}e_{33}-\varphi_4}{b_3}</script><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所需要调节的参数为</p><script type="math/tex; mode=display">w_{o1}\\\\w_{o2}\\\\w_{o3}\\\\w_{c11}\\\\w_{c12}\\\\w_{c13}\\\\w_{c21}\\\\w_{c22}\\\\w_{c23}\\\\b_1\\\\b_2\\\\b_3</script><p>参数的数量只与系统的输入输出数量有关，与系统的实际阶数无关</p><h1 id="整体状态空间方程"><a href="#整体状态空间方程" class="headerlink" title="整体状态空间方程"></a>整体状态空间方程</h1><p>与单侧的平衡状态空间方程的建立基本上是一致的，但是需要同时注意左右两侧，并且还有一些整体机器人的分析。</p><h2 id="轮子-1"><a href="#轮子-1" class="headerlink" title="轮子"></a><strong>轮子</strong></h2><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709189277698.png" alt="1709189277698.png"></p><p><strong>左侧</strong></p><p>水平方向上</p><script type="math/tex; mode=display">m_{w,l}\ddot{x}_l=f_l-N_{w,l}~~~~{1}</script><p>竖直方向上</p><script type="math/tex; mode=display">F_{N,l}=P_{w,l}+G~~~~{2}</script><p>转矩</p><script type="math/tex; mode=display">I_{w,l}\frac{\ddot{x}_l}{R}=T_{w,l}-f_lR~~~~{3}</script><p><strong>右侧</strong></p><p>水平方向上</p><script type="math/tex; mode=display">m_{w,r}\ddot{x}_r=f_r-N_{w,r}~~~~{4}</script><p>竖直方向上</p><script type="math/tex; mode=display">F_{N,r}=P_{w,r}+G~~~~{5}</script><p>转矩</p><script type="math/tex; mode=display">I_{w,r}\frac{\ddot{x}_r}{R}=T_{w,r}-f_rR~~~~{6}</script><h2 id="摆杆-1"><a href="#摆杆-1" class="headerlink" title="摆杆"></a><strong>摆杆</strong></h2><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709190884792.png" alt="1709190884792.png"></p><p><strong>左侧</strong></p><p>水平方向上</p><script type="math/tex; mode=display">m_{l,l}(\ddot{x}_l+\frac{\partial^2}{\partial t^2}L_{w,l}\sin\theta_l)=N_{w,l}-N_{b,l}~~~~{7}</script><p>竖直方向上</p><script type="math/tex; mode=display">m_{l,l}\frac{\partial^2}{\partial t^2}L_{w,l}\cos\theta_l=P_{w,l}-P_{b,l}-m_{l,l}g~~~~{8}</script><p>转矩</p><script type="math/tex; mode=display">I_{l,l}\ddot{\theta_l}=T_{b,l}-T_{w,l}+(P_{b,l}L_{b,l}+P_{w,l}L_{w,l})\sin\theta_l-(N_{b,l}L_{b,l}+N_{w,l}L_{w,l})\cos\theta_l~~~~{9}</script><p><strong>右侧</strong></p><p>水平方向上</p><script type="math/tex; mode=display">m_{l,r}(\ddot{x}_r+\frac{\partial^2}{\partial t^2}L_{w,r}\sin\theta_r)=N_{w,r}-N_{b,r}~~~~{10}</script><p>竖直方向上</p><script type="math/tex; mode=display">m_{l,r}\frac{\partial^2}{\partial t^2}L_{w,r}\cos\theta_r=P_{w,r}-P_{b,r}-m_{l,r}g~~~~{11}</script><p>转矩</p><script type="math/tex; mode=display">I_{l,r}\ddot{\theta_r}=T_{b,r}-T_{w,r}+(P_{b,r}L_{b,r}+P_{w,r}L_{w,r})\sin\theta_r-(N_{b,r}L_{b,r}+N_{w,r}L_{w,r})\cos\theta_r~~~~{12}</script><h2 id="机体-1"><a href="#机体-1" class="headerlink" title="机体"></a><strong>机体</strong></h2><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709204006116.png" alt="1709204006116.png"></p><p>水平方向上</p><script type="math/tex; mode=display">m_b\frac{\partial^2}{\partial t^2}[\frac{1}{2}({x}_l+L_l\sin\theta_l+{x}_r+L_r\sin\theta_r)-l\sin\varphi]=N_{b,l}+N_{b,r}~~~~{13}</script><p>竖直方向上</p><script type="math/tex; mode=display">m_b\frac{\partial^2}{\partial t^2}[\frac{1}{2}(L_l\cos\theta_l+L_r\cos\theta_r)+l\cos\varphi]=P_{b,l}+P_{b,r}-m_bg~~~~{14}</script><p>转矩</p><script type="math/tex; mode=display">I_b\ddot{\varphi}=T_{b,l}+T_{b,r}+(N_{b,l}+N_{b,r})l\cos\varphi+(P_{b,l}+P_{b,r})l\sin\varphi~~~~{15}</script><p>假设机体两侧支持力大小一致</p><script type="math/tex; mode=display">P_{b,l}=P_{b,r}~~~~{16}</script><h2 id="整车的航向角"><a href="#整车的航向角" class="headerlink" title="整车的航向角"></a>整车的航向角</h2><script type="math/tex; mode=display">I_{c,z}\ddot{\psi}=(f_r-f_l)R_l~~~~{17}\\\\\ddot{\psi}=\frac{\partial^2}{\partial t^2}\frac{(x_r+L_r\sin\theta_r-x_l-L_l\sin\theta_l)}{2R_l}~~~~{18}</script><p>对上述中所有式子进行机体倾角进行小角度近似，然后利用其中的 ${1},{4},{7},{8},{10},{11},{13},{14},{16},{17}$ 式求解出中间变量 $P_{w,l},N_{w,l},P_{b,l},N_{b,l},P_{w,r},N_{w,r},P_{b,r},N_{b,r},f_l,f_r$ 的表达式，并且进行小角度近似（令 $\theta_l, \theta_r, \phi$ 均为 0 ）。</p><p>然后利用其中的 ${3},{6},{9},{12},{15}$ 来求解 $\ddot{x}_l, \ddot{x}_r, \ddot{\theta}_l,\ddot{\theta}_r,\ddot{\varphi}$ 的表达式，然后根据 ${18}$ 可以得到 $\ddot{\psi}$ 的表达式。</p><p>定义车子移动距离的表达式</p><script type="math/tex; mode=display">s=\frac{x_l+x_r}{2}\\\\\Downarrow\\\\\ddot{s}=\frac{\ddot{x}_l+\ddot{x}_r}{2}</script><p>可以得到 $\ddot{s}$ 的表达式</p><p>定义</p><script type="math/tex; mode=display">X=\begin{bmatrix}s\\\dot{s}\\\psi\\\dot{\psi}\\\theta_l\\\dot{\theta}_l\\\theta_r\\\dot{\theta}_r\\\varphi\\\dot{\varphi}\end{bmatrix}\\\\U=\begin{bmatrix}T_{w,l}\\T_{w,r}\\T_{b,l}\\T_{b,r}\end{bmatrix}</script><p>其中 $\psi$ 为整车的航向角， $\varphi$ 为机体的俯仰角</p><p>最终可以得到系统状态方程的表达式。这里就不列出来了，太复杂了。直接上代码</p><p><strong>电脑毁灭者——未进行小角度近似</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment">% 一些变量</span></span><br><span class="line">syms theta_l(t) theta_r(t) phi(t) s(t) <span class="built_in">psi</span>(t) x_l(t) x_r(t)</span><br><span class="line"><span class="comment">% 轮子参数</span></span><br><span class="line">syms mw_l mw_r f_l f_r Nw_l Nw_r Pw_l Pw_r Iw_l Iw_r R Tw_l Tw_r</span><br><span class="line"><span class="comment">% 腿部参数</span></span><br><span class="line">syms ml_l ml_r Il_l Il_r Lw_l Lw_r Lb_l Lb_r L_l L_r</span><br><span class="line"><span class="comment">% 机体参数</span></span><br><span class="line">syms mb Ib_x Ib_y Ib_z l Tb_l Tb_r Nb_l Nb_r Pb_l Pb_r</span><br><span class="line"><span class="comment">% 基本参数</span></span><br><span class="line">syms g</span><br><span class="line"><span class="comment">% 整车参数</span></span><br><span class="line">syms wb_z R_l</span><br><span class="line"><span class="comment">% 求解需要用到的</span></span><br><span class="line">syms x_l_dot x_r_dot theta_l_dot theta_r_dot phi_dot s_dot psi_dot</span><br><span class="line">syms x_l_ddot x_r_ddot theta_l_ddot theta_r_ddot phi_ddot s_ddot psi_ddot</span><br><span class="line"></span><br><span class="line"><span class="comment">% s = 0.5 * (x_l + x_r);</span></span><br><span class="line"><span class="comment">% s_dot = 0.5 * (x_l_dot + x_r_dot);</span></span><br><span class="line"><span class="comment">% s_ddot = 0.5 * (x_l_ddot + x_r_ddot);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 轮子分析</span></span><br><span class="line">xw_l = x_l;</span><br><span class="line">xw_r = x_r;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 左侧 水平</span></span><br><span class="line">FrontW_l = mw_l * diff(diff(xw_l, t), t) == f_l - Nw_l;</span><br><span class="line"><span class="comment">% 左侧 转矩</span></span><br><span class="line">TorqueW_l = Iw_l * diff(diff(xw_l, t), t) / R == Tw_l - f_l * R; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 右侧 水平</span></span><br><span class="line">FrontW_r = mw_r * diff(diff(xw_r, t), t) == f_r - Nw_r;</span><br><span class="line"><span class="comment">% 右侧 转矩</span></span><br><span class="line">TorqueW_r = Iw_r * diff(diff(xw_r, t), t) / R == Tw_r - f_r * R; </span><br><span class="line"></span><br><span class="line"><span class="comment">%% 腿部分析</span></span><br><span class="line">xl_l = x_l + Lw_l * <span class="built_in">sin</span>(theta_l);</span><br><span class="line">xl_r = x_r + Lw_r * <span class="built_in">sin</span>(theta_r);</span><br><span class="line">yl_l = Lw_l * <span class="built_in">cos</span>(theta_l);</span><br><span class="line">yl_r = Lw_r * <span class="built_in">cos</span>(theta_r);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 左侧 水平</span></span><br><span class="line">FrontL_l = ml_l * diff(diff(xl_l, t), t) == Nw_l - Nb_l;</span><br><span class="line"><span class="comment">% 左侧 竖直</span></span><br><span class="line">UpL_l = ml_l * diff(diff(yl_l, t), t) == Pw_l - Pb_l - ml_l * g;</span><br><span class="line"><span class="comment">% 左侧 转矩</span></span><br><span class="line">TorqueL_l = Il_l * diff(diff(theta_l, t), t) == Tb_l - Tw_l + (Pb_l * Lb_l + Pw_l * Lw_l) * <span class="built_in">sin</span>(theta_l) - (Nb_l * Lb_l + Nw_l * Lw_l) * <span class="built_in">cos</span>(theta_l);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 右侧 水平</span></span><br><span class="line">FrontL_r = ml_r * diff(diff(xl_r, t), t) == Nw_r - Nb_r;</span><br><span class="line"><span class="comment">% 右侧 竖直</span></span><br><span class="line">UpL_r = ml_r * diff(diff(yl_r, t), t) == Pw_r - Pb_r - ml_r * g;</span><br><span class="line"><span class="comment">% 右侧 转矩</span></span><br><span class="line">TorqueL_r = Il_r * diff(diff(theta_r, t), t) == Tb_r - Tw_r + (Pb_r * Lb_r + Pw_r * Lw_r) * <span class="built_in">sin</span>(theta_r) - (Nb_r * Lb_r + Nw_r * Lw_r) * <span class="built_in">cos</span>(theta_r);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 机体分析</span></span><br><span class="line">xb = <span class="number">0.5</span> * (x_l + L_l * <span class="built_in">sin</span>(theta_l) + x_r + L_r * <span class="built_in">sin</span>(theta_r)) - l * <span class="built_in">sin</span>(phi);</span><br><span class="line">yb = <span class="number">0.5</span> * (L_l * <span class="built_in">cos</span>(theta_l) + L_r * <span class="built_in">cos</span>(theta_r)) + l * <span class="built_in">cos</span>(phi);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 水平</span></span><br><span class="line">FrontB = mb * diff(diff(xb, t), t) == Nb_l + Nb_r;</span><br><span class="line"><span class="comment">% 竖直</span></span><br><span class="line">UpB = mb * diff(diff(yb, t), t) == Pb_l + Pb_r - mb * g;</span><br><span class="line"><span class="comment">% 转矩</span></span><br><span class="line">TorqueB = Ib_y * diff(diff(phi, t), t) == (Tb_l + Tb_r) + (Nb_l + Nb_r) * l * <span class="built_in">cos</span>(phi) + (Pb_l + Pb_r) * l * <span class="built_in">sin</span>(phi);</span><br><span class="line"><span class="comment">% 假设机体两侧支持力一致</span></span><br><span class="line">ForceEqual = Pw_l == Pw_r;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 整车分析</span></span><br><span class="line">psi_ = (x_r - x_l + L_r * <span class="built_in">sin</span>(theta_r) - L_l * <span class="built_in">sin</span>(theta_l)) / <span class="number">2</span> / R_l;</span><br><span class="line">WholeTurn = wb_z * diff(diff(psi_, t), t) == (f_r - f_l) * R_l;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求解中间变量 Pw Pb Nw Nb f</span></span><br><span class="line">func1 = [FrontW_l; FrontW_r; FrontL_l; FrontL_r; UpL_l; UpL_r; FrontB; UpB; ForceEqual; WholeTurn];</span><br><span class="line">[valPw_l, valPw_r, valNw_l, valNw_r, valPb_l, valPb_r, valNb_l, valNb_r, valf_l, valf_r] = solve(func1, [Pw_l, Pw_r, Nw_l, Nw_r, Pb_l, Pb_r, Nb_l, Nb_r, f_l, f_r]);</span><br><span class="line"></span><br><span class="line">func2 = [TorqueW_l; TorqueW_r; TorqueL_l; TorqueL_r; TorqueB];</span><br><span class="line">func2 = subs(func2, ...</span><br><span class="line">    [Pw_l, Pw_r, Nw_l, Nw_r, Pb_l, Pb_r, Nb_l, Nb_r, f_l, f_r], ...</span><br><span class="line">    [valPw_l, valPw_r, valNw_l, valNw_r, valPb_l, valPb_r, valNb_l, valNb_r, valf_l, valf_r]);</span><br><span class="line"></span><br><span class="line">func2 = subs(func2, ...</span><br><span class="line">    [diff(diff(x_l, t), t), diff(diff(x_r, t), t), diff(diff(theta_l, t), t), diff(diff(theta_r, t), t), diff(diff(phi, t), t), diff(x_l, t), diff(x_r, t), diff(theta_l, t), diff(theta_r, t), diff(phi, t)], ...</span><br><span class="line">    [x_l_ddot, x_r_ddot, theta_l_ddot, theta_r_ddot, phi_ddot, x_l_dot, x_r_dot, theta_l_dot, theta_r_dot, phi_dot]);</span><br><span class="line"></span><br><span class="line">[x_l_ddot, x_r_ddot, theta_l_ddot, theta_r_ddot, phi_ddot] = vpasolve(func2, [x_l_ddot, x_r_ddot, theta_l_ddot, theta_r_ddot, phi_ddot]);</span><br><span class="line"></span><br><span class="line">X_dot = [x_l_dot, x_l_ddot, x_r_dot, x_r_ddot, theta_l_dot, theta_l_ddot, theta_r_dot, theta_r_ddot, phi_dot, phi_ddot];</span><br><span class="line">X = [x_l, x_l_dot, x_r, x_r_dot, theta_l, theta_l_dot, theta_r, theta_r_dot, phi, phi_dot];</span><br><span class="line">U = [Tw_r, Tw_r, Tb_l, Tb_r];</span><br><span class="line"></span><br><span class="line">a_25 = <span class="number">1</span> / <span class="number">2</span> * (diff(x_l_ddot, thetal_l) + diff(x_r_ddot, thetal_l));</span><br><span class="line">a_27 = <span class="number">1</span> / <span class="number">2</span> * (diff(x_l_ddot, thetal_r) + diff(x_r_ddot, thetal_r));</span><br><span class="line">a_29 = <span class="number">1</span> / <span class="number">2</span> * (diff(x_l_ddot, phi) + diff(x_r_ddot, phi));</span><br><span class="line"></span><br><span class="line">a_45 = <span class="number">1</span> / (<span class="number">2</span> * R_l) * (-diff(x_l_ddot, thetal_l) + diff(x_r_ddot, thetal_l)) - L_l / (<span class="number">2</span> * R_l) * diff(thetal_l_ddot, thetal_l) + L_r / (<span class="number">2</span> * R_l) * diff(thetal_r_ddot, thetal_l);</span><br><span class="line">a_47 = <span class="number">1</span> / (<span class="number">2</span> * R_l) * (-diff(x_l_ddot, thetal_r) + diff(x_r_ddot, thetal_r)) - L_l / (<span class="number">2</span> * R_l) * diff(thetal_l_ddot, thetal_r) + L_r / (<span class="number">2</span> * R_l) * diff(thetal_r_ddot, thetal_r);</span><br><span class="line">a_49 = <span class="number">1</span> / (<span class="number">2</span> * R_l) * (-diff(x_l_ddot, phi) + diff(x_r_ddot, phi)) - L_l / (<span class="number">2</span> * R_l) * diff(thetal_l_ddot, phi) + L_r / (<span class="number">2</span> * R_l) * diff(thetal_r_ddot, phi);</span><br><span class="line"></span><br><span class="line">a_65 = diff(thetal_l_ddot, thetal_l);</span><br><span class="line">a_67 = diff(thetal_l_ddot, thetal_r);</span><br><span class="line">a_69 = diff(thetal_l_ddot, phi);</span><br><span class="line"></span><br><span class="line">a_85 = diff(thetal_r_ddot, thetal_l);</span><br><span class="line">a_87 = diff(thetal_r_ddot, thetal_r);</span><br><span class="line">a_89 = diff(thetal_r_ddot, phi);</span><br><span class="line"></span><br><span class="line">a_x5 = diff(phi_ddot, thetal_l);</span><br><span class="line">a_x7 = diff(phi_ddot, thetal_r);</span><br><span class="line">a_x9 = diff(phi_ddot, phi);</span><br><span class="line"></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> a_25 <span class="number">0</span> a_27 <span class="number">0</span> a_29 <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> a_45 <span class="number">0</span> a_47 <span class="number">0</span> a_49 <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> a_65 <span class="number">0</span> a_67 <span class="number">0</span> a_69 <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> a_85 <span class="number">0</span> a_87 <span class="number">0</span> a_89 <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> a_x5 <span class="number">0</span> a_x7 <span class="number">0</span> a_x9 <span class="number">0</span>;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">b_21 = <span class="number">1</span> / <span class="number">2</span> * (diff(x_l_ddot, Tw_l) + diff(x_r_ddot, Tw_l));</span><br><span class="line">b_22 = <span class="number">1</span> / <span class="number">2</span> * (diff(x_l_ddot, Tw_r) + diff(x_r_ddot, Tw_r));</span><br><span class="line">b_23 = <span class="number">1</span> / <span class="number">2</span> * (diff(x_l_ddot, Tb_l) + diff(x_r_ddot, Tb_l));</span><br><span class="line">b_24 = <span class="number">1</span> / <span class="number">2</span> * (diff(x_l_ddot, Tb_r) + diff(x_r_ddot, Tb_r));</span><br><span class="line"></span><br><span class="line">b_41 = <span class="number">1</span> / (<span class="number">2</span> * R_l) * (-diff(x_l_ddot, Tw_l) + diff(x_r_ddot, Tw_l)) - L_l / (<span class="number">2</span> * R_l) * diff(thetal_l_ddot, Tw_l) + L_r / (<span class="number">2</span> * R_l) * diff(thetal_r_ddot, Tw_l);</span><br><span class="line">b_42 = <span class="number">1</span> / (<span class="number">2</span> * R_l) * (-diff(x_l_ddot, Tw_r) + diff(x_r_ddot, Tw_r)) - L_l / (<span class="number">2</span> * R_l) * diff(thetal_l_ddot, Tw_r) + L_r / (<span class="number">2</span> * R_l) * diff(thetal_r_ddot, Tw_r);</span><br><span class="line">b_43 = <span class="number">1</span> / (<span class="number">2</span> * R_l) * (-diff(x_l_ddot, Tb_l) + diff(x_r_ddot, Tb_l)) - L_l / (<span class="number">2</span> * R_l) * diff(thetal_l_ddot, Tb_l) + L_r / (<span class="number">2</span> * R_l) * diff(thetal_r_ddot, Tb_l);</span><br><span class="line">b_44 = <span class="number">1</span> / (<span class="number">2</span> * R_l) * (-diff(x_l_ddot, Tb_r) + diff(x_r_ddot, Tb_r)) - L_l / (<span class="number">2</span> * R_l) * diff(thetal_l_ddot, Tb_r) + L_r / (<span class="number">2</span> * R_l) * diff(thetal_r_ddot, Tb_r);</span><br><span class="line"></span><br><span class="line">b_61 = diff(thetal_l_ddot, Tw_l);</span><br><span class="line">b_62 = diff(thetal_l_ddot, Tw_r);</span><br><span class="line">b_63 = diff(thetal_l_ddot, Tb_l);</span><br><span class="line">b_64 = diff(thetal_l_ddot, Tb_r);</span><br><span class="line"></span><br><span class="line">b_81 = diff(thetal_r_ddot, Tw_l);</span><br><span class="line">b_82 = diff(thetal_r_ddot, Tw_r);</span><br><span class="line">b_83 = diff(thetal_r_ddot, Tb_l);</span><br><span class="line">b_84 = diff(thetal_r_ddot, Tb_r);</span><br><span class="line"></span><br><span class="line">b_x1 = diff(phi_ddot, Tw_l);</span><br><span class="line">b_x2 = diff(phi_ddot, Tw_r);</span><br><span class="line">b_x3 = diff(phi_ddot, Tb_l);</span><br><span class="line">b_x4 = diff(phi_ddot, Tb_r);</span><br><span class="line"></span><br><span class="line">B = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    b_21 b_22 b_23 b_24;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    b_41 b_42 b_43 b_44;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    b_61 b_62 b_63 b_64;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    b_81 b_82 b_83 b_84;</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    b_x1 b_x2 b_x3 b_x4;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">A = subs(A, [x_l_dot, x_r_dot, thetal_l(t), thetal_l_dot, thetal_r(t), thetal_r_dot, phi(t), phi_dot, Tw_l, Tw_r, Tb_l, Tb_r], <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">12</span>))</span><br><span class="line">A = double(A);</span><br><span class="line">B = subs(B, [x_l_dot, x_r_dot, thetal_l(t), thetal_l_dot, thetal_r(t), thetal_r_dot, phi(t), phi_dot, Tw_l, Tw_r, Tb_l, Tb_r], <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">12</span>))</span><br><span class="line">B = double(B);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rank(ctrb(A, B)) == <span class="built_in">size</span>(A, <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;系统可控&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;系统不可控&#x27;</span>)</span><br><span class="line">    K = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上式中的符号方程不容易解，但是带入数据之后就容易解出来了。下面的解法是直接进行机体倾角小角度近似，并且提前算好中间变量</p><p>实际上，上述代码是根据上海交通大学所分享的开源系统设计中所得到的，主要是因为自己算出来的直接求解对应的 $jacobian$ 矩阵所得到的系统状态空间方程是不可控的，我也不知道为啥（这个解算研究两天了），验证之后发现，并不是不可控的，可能是 $jacobian$ 求解时所用的矩阵的布局不一致？把状态空间方程的最后求解的部分给改掉就好了。需要注意，上海交通大学的开源系统设计中，所用到的机体的俯仰角是右视图中是顺时针为正，与我的分析中向上抬头为正好相反。</p><h1 id="控制器设计-1"><a href="#控制器设计-1" class="headerlink" title="控制器设计"></a>控制器设计</h1><h2 id="LQR-控制器设计"><a href="#LQR-控制器设计" class="headerlink" title="LQR 控制器设计"></a>LQR 控制器设计</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C = <span class="built_in">eye</span>(<span class="number">10</span>);</span><br><span class="line">D = <span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">4</span>);</span><br><span class="line">Q = <span class="built_in">diag</span>([<span class="number">10</span> <span class="number">1</span> <span class="number">10</span> <span class="number">1</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">100</span> <span class="number">1</span>]);</span><br><span class="line">R = <span class="built_in">diag</span>([<span class="number">1</span> <span class="number">1</span> <span class="number">0.25</span> <span class="number">0.25</span>]);</span><br><span class="line">sys = ss(A, B, C, D);</span><br><span class="line">K = lqr(sys, Q, R);</span><br><span class="line">K_vals(a, : , :) = K;</span><br></pre></td></tr></table></figure><p>其中的 Q 和 R 就是系统状态与系统输入的权重，越大表示越在意</p><p>最终需要将状态反馈增益系数拟合为左右杆长的二元二次函数，下面是拟合分析的总体代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"><span class="comment">%% 开始解算</span></span><br><span class="line">syms x(t) theta(t) phi(t)</span><br><span class="line">syms Tw Tb Pw Pb Nw Nb</span><br><span class="line">syms x_ddot theta_ddot phi_ddot x_dot theta_dot phi_dot</span><br><span class="line">syms L Il Lw Lb ml</span><br><span class="line">mw = <span class="number">1.267245</span> * <span class="number">2</span>;</span><br><span class="line">R = <span class="number">0.1</span>;</span><br><span class="line">Iw = <span class="number">0.00379267</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mb = <span class="number">5.4940204</span>;</span><br><span class="line">Ib_y = <span class="number">0.05019911</span>;</span><br><span class="line">g = <span class="number">9.81</span>;</span><br><span class="line">Ic_z = <span class="number">0.37248874</span>;</span><br><span class="line">R_l = <span class="number">0.482000001</span>;</span><br><span class="line">l = <span class="number">-0.02011323</span>;</span><br><span class="line"></span><br><span class="line">func1 = [ml * diff(diff(x + Lw * <span class="built_in">sin</span>(theta), t), t) == Nw - Nb;</span><br><span class="line">    ml * diff(diff(Lw * <span class="built_in">cos</span>(theta), t), t) == Pw - Pb - ml * g;</span><br><span class="line">    mb * diff(diff(x + L * <span class="built_in">sin</span>(theta) - l * <span class="built_in">sin</span>(phi), t), t) == Nb;</span><br><span class="line">    mb * diff(diff(L * <span class="built_in">cos</span>(theta) + l * <span class="built_in">cos</span>(phi), t), t) == Pb - mb * g;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">[Pw, Pb, Nw, Nb] = solve(func1, [Pw, Pb, Nw, Nb]);</span><br><span class="line"></span><br><span class="line">func2 = [diff(diff(x, t), t) == (Tw * R - Nw * R * R) / (Iw + mw * R * R);</span><br><span class="line">    Il * diff(diff(theta, t), t) == Tb - Tw + (Pb * Lb + Pw * Lw) * <span class="built_in">sin</span>(theta) - (Nb * Lb + Nw * Lw) * <span class="built_in">cos</span>(theta);</span><br><span class="line">    Ib_y * diff(diff(phi, t), t) == Tb + Nb * l * <span class="built_in">cos</span>(phi) + Pb * l * <span class="built_in">sin</span>(phi);];</span><br><span class="line"></span><br><span class="line">func2 = subs(func2, ...</span><br><span class="line">    [diff(diff(x, t), t), diff(diff(theta, t), t), diff(diff(phi, t), t), diff(x, t), diff(theta, t), diff(phi, t)], ...</span><br><span class="line">    [x_ddot, theta_ddot, phi_ddot, x_dot, theta_dot, phi_dot]);</span><br><span class="line"></span><br><span class="line">[x_ddot, theta_ddot, phi_ddot] = solve(func2, [x_ddot theta_ddot phi_ddot]);</span><br><span class="line"></span><br><span class="line">X = [theta(t); theta_dot; x(t); x_dot; phi(t); phi_dot];</span><br><span class="line">u = [Tw; Tb];</span><br><span class="line">X_dot = [theta_dot; theta_ddot; x_dot; x_ddot; phi_dot; phi_ddot];</span><br><span class="line">A = jacobian(X_dot, X);</span><br><span class="line">B = jacobian(X_dot, u);</span><br><span class="line">A = subs(A, [x_dot, theta(t), theta_dot, phi(t), phi_dot, Tw, Tb], <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">7</span>));</span><br><span class="line">B = subs(B, [x_dot, theta(t), theta_dot, phi(t), phi_dot, Tw, Tb], <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置拟合次数和腿长，开始拟合</span></span><br><span class="line">minangle4 = <span class="number">-15</span>;</span><br><span class="line">maxangle4 = <span class="number">79</span>;</span><br><span class="line">steps = <span class="number">0.2</span>;</span><br><span class="line">numsize = (maxangle4 - minangle4) / steps + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">K_vals = <span class="built_in">zeros</span>(numsize, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">A_vals = <span class="built_in">zeros</span>(numsize, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">B_vals = <span class="built_in">zeros</span>(numsize, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">L_vals = <span class="built_in">zeros</span>(numsize, <span class="number">1</span>);</span><br><span class="line">I_vals = <span class="built_in">zeros</span>(numsize, <span class="number">1</span>);</span><br><span class="line">Lw_vals = <span class="built_in">zeros</span>(numsize, <span class="number">1</span>);</span><br><span class="line">Lb_vals = <span class="built_in">zeros</span>(numsize, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">angle1_vals = <span class="built_in">zeros</span>(numsize, <span class="number">1</span>);</span><br><span class="line">angle4_vals = <span class="built_in">zeros</span>(numsize, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> angle4 = minangle4 : steps : maxangle4</span><br><span class="line">    angle1 = <span class="number">180</span> - angle4;</span><br><span class="line">    [valml, valIl, valL, valLw, valLb] = GetLegBaryCenter(angle1, angle4, <span class="number">0</span>);</span><br><span class="line">    valA = subs(A, [ml, Il, L, Lw, Lb], [<span class="number">2</span> * valml, <span class="number">2</span> * valIl, valL, valLw, valLb]);</span><br><span class="line">    valB = subs(B, [ml, Il, L, Lw, Lb], [<span class="number">2</span> * valml, <span class="number">2</span> * valIl, valL, valLw, valLb]);</span><br><span class="line">    valA = double(valA);</span><br><span class="line">    valB = double(valB);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(rank(ctrb(valA, valB)) == <span class="built_in">size</span>(valA, <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;系统可控&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;系统不可控&#x27;</span>)</span><br><span class="line">        K = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    C = <span class="built_in">eye</span>(<span class="number">6</span>);</span><br><span class="line">    D = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">    Q = <span class="built_in">diag</span>([<span class="number">10</span> <span class="number">1</span> <span class="number">40</span> <span class="number">30</span> <span class="number">100</span> <span class="number">1</span>]);</span><br><span class="line">    R = <span class="built_in">diag</span>([<span class="number">1</span> <span class="number">0.25</span>]);</span><br><span class="line">    sys = ss(valA, valB, C, D);</span><br><span class="line">    KLQR = lqr(sys, Q, R);<span class="comment">%得到反馈增益矩阵</span></span><br><span class="line">    K_vals(a, :, :) = KLQR;</span><br><span class="line">    A_vals(a, :, :) = valA;</span><br><span class="line">    B_vals(a, :, :) = valB;</span><br><span class="line">    L_vals(a) = valL;</span><br><span class="line">    I_vals(a) = valIl;    </span><br><span class="line">    Lb_vals(a) = valLw;</span><br><span class="line">    Lw_vals(a) = valLb;</span><br><span class="line">    </span><br><span class="line">    angle1_vals(a) = angle1;</span><br><span class="line">    angle4_vals(a) = angle4;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% LQR 拟合:比较倾向于使用Curve Fitting Toolbox，简单好用</span></span><br><span class="line">K11 = K_vals(:, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">K12 = K_vals(:, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">K13 = K_vals(:, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">K14 = K_vals(:, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">K15 = K_vals(:, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">K16 = K_vals(:, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">K21 = K_vals(:, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">K22 = K_vals(:, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">K23 = K_vals(:, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">K24 = K_vals(:, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">K25 = K_vals(:, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">K26 = K_vals(:, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A11 = A_vals(:, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">A12 = A_vals(:, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">A13 = A_vals(:, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">A14 = A_vals(:, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">A15 = A_vals(:, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">A16 = A_vals(:, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A21 = A_vals(:, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">A22 = A_vals(:, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">A23 = A_vals(:, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">A24 = A_vals(:, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">A25 = A_vals(:, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">A26 = A_vals(:, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A31 = A_vals(:, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">A32 = A_vals(:, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">A33 = A_vals(:, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">A34 = A_vals(:, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">A35 = A_vals(:, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">A36 = A_vals(:, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A41 = A_vals(:, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">A42 = A_vals(:, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">A43 = A_vals(:, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">A44 = A_vals(:, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">A45 = A_vals(:, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">A46 = A_vals(:, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A51 = A_vals(:, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">A52 = A_vals(:, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">A53 = A_vals(:, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">A54 = A_vals(:, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">A55 = A_vals(:, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">A56 = A_vals(:, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">A61 = A_vals(:, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">A62 = A_vals(:, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">A63 = A_vals(:, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">A64 = A_vals(:, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">A65 = A_vals(:, <span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">A66 = A_vals(:, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">B11 = B_vals(:, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">B12 = B_vals(:, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B21 = B_vals(:, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">B22 = B_vals(:, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B31 = B_vals(:, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">B32 = B_vals(:, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B41 = B_vals(:, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">B42 = B_vals(:, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B51 = B_vals(:, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">B52 = B_vals(:, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">B61 = B_vals(:, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">B62 = B_vals(:, <span class="number">6</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>获得腿部转动惯量与腿长的函数如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ml, Il, L, Lw, Lb]</span> = <span class="title">GetLegBaryCenter</span><span class="params">(angle1, angle4, pitch)</span></span></span><br><span class="line"></span><br><span class="line">angle1 = angle1 / <span class="number">180</span> * <span class="built_in">pi</span>;</span><br><span class="line">angle4 = angle4 / <span class="number">180</span> * <span class="built_in">pi</span>;</span><br><span class="line"></span><br><span class="line">l1 = <span class="number">0.15</span>;</span><br><span class="line">l2 = <span class="number">0.27</span>;</span><br><span class="line">l3 = <span class="number">0.27</span>;</span><br><span class="line">l4 = <span class="number">0.15</span>;</span><br><span class="line">l5 = <span class="number">0.15</span>;</span><br><span class="line"></span><br><span class="line">ml1 = <span class="number">0.1399</span>;</span><br><span class="line">ml2 = <span class="number">0.14175</span>;</span><br><span class="line">ml3 = <span class="number">0.1779</span>;</span><br><span class="line">ml4 = <span class="number">0.10615</span>;</span><br><span class="line"></span><br><span class="line">Il1 = <span class="number">0.00057637</span>;</span><br><span class="line">Il2 = <span class="number">0.00161803</span>;</span><br><span class="line">Il3 = <span class="number">0.00204813</span>;</span><br><span class="line">Il4 = <span class="number">0.00047237</span>;</span><br><span class="line"></span><br><span class="line">scale1 = <span class="number">0.683717133</span>;</span><br><span class="line">scale2 = <span class="number">0.44485837</span>;</span><br><span class="line">scale3 = <span class="number">0.362538407</span>;</span><br><span class="line">scale4 = <span class="number">0.582931467</span>;</span><br><span class="line"></span><br><span class="line">ml = ml1 + ml2 + ml3 + ml4;</span><br><span class="line"></span><br><span class="line">xa = -l5 / <span class="number">2</span>;</span><br><span class="line">ya = <span class="number">0</span>;</span><br><span class="line">xe = l5 / <span class="number">2</span>;</span><br><span class="line">ye = <span class="number">0</span>;</span><br><span class="line">xb = l1 * <span class="built_in">cos</span>(angle1) - l5/<span class="number">2</span>;</span><br><span class="line">yb = l1 * <span class="built_in">sin</span>(angle1);</span><br><span class="line">xd = l5/<span class="number">2</span> + l4 * <span class="built_in">cos</span>(angle4);</span><br><span class="line">yd = l4 * <span class="built_in">sin</span>(angle4);</span><br><span class="line">lbd = <span class="built_in">sqrt</span>((xd - xb).^<span class="number">2</span> + (yd - yb).^<span class="number">2</span>);</span><br><span class="line">A0 = <span class="number">2</span> * l2 * (xd - xb);</span><br><span class="line">B0 = <span class="number">2</span> * l2 * (yd - yb);</span><br><span class="line">C0 = l2.^<span class="number">2</span> + lbd.^<span class="number">2</span> - l3.^<span class="number">2</span>;</span><br><span class="line">D0 = l3.^<span class="number">2</span> + lbd.^<span class="number">2</span> - l2.^<span class="number">2</span>;</span><br><span class="line">u2 = <span class="number">2</span> * <span class="built_in">atan</span>((B0 + <span class="built_in">sqrt</span>(A0.^<span class="number">2</span> + B0.^<span class="number">2</span> - C0.^<span class="number">2</span>))/(A0 + C0));</span><br><span class="line">u3 = <span class="built_in">pi</span> - <span class="number">2</span> * <span class="built_in">atan</span>((-B0 + <span class="built_in">sqrt</span>(A0.^<span class="number">2</span> + B0.^<span class="number">2</span> - D0.^<span class="number">2</span>))/(A0 + D0));</span><br><span class="line">xc = xb + l2 * <span class="built_in">cos</span>(u2);</span><br><span class="line">yc = yb + l2 * <span class="built_in">sin</span>(u2);</span><br><span class="line">R = [<span class="built_in">cos</span>(pitch), -<span class="built_in">sin</span>(pitch);</span><br><span class="line">    <span class="built_in">sin</span>(pitch), <span class="built_in">cos</span>(pitch)];</span><br><span class="line">v = R*[xc;yc];</span><br><span class="line">xc = v(<span class="number">1</span>);</span><br><span class="line">yc = v(<span class="number">2</span>);</span><br><span class="line">L = <span class="built_in">sqrt</span>(xc ^ <span class="number">2</span> + yc ^ <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">mx_l1 = scale1*(xb-xa)+xa;</span><br><span class="line">my_l1 = scale1*(yb-ya)+ya;</span><br><span class="line">mx_l2 = scale2*(xc-xb)+xb;</span><br><span class="line">my_l2 = scale2*(yc-yb)+yb;</span><br><span class="line">mx_l3 = scale3*(xc-xd)+xd;</span><br><span class="line">my_l3 = scale3*(yc-yd)+yd;</span><br><span class="line">mx_l4 = scale4*(xd-xe)+xe;</span><br><span class="line">my_l4 = scale4*(yd-ye)+ye;</span><br><span class="line"></span><br><span class="line">x = (mx_l1*ml1 + mx_l2*ml2 + mx_l3*ml3 + mx_l4*ml4)/(ml1+ml2+ml3+ml4);</span><br><span class="line">y = (my_l1*ml1 + my_l2*ml2 + my_l3*ml3 + my_l4*ml4)/(ml1+ml2+ml3+ml4);</span><br><span class="line"></span><br><span class="line">Lw = <span class="built_in">sqrt</span>((xc - x)^<span class="number">2</span> + (yc - y)^<span class="number">2</span>);</span><br><span class="line">Lb = <span class="built_in">sqrt</span>((xc)^<span class="number">2</span> + (yc)^<span class="number">2</span>);</span><br><span class="line">Lsum = Lw + Lb;</span><br><span class="line"></span><br><span class="line">Lw = Lw / Lsum * L;</span><br><span class="line">Lb = Lb / Lsum * L;</span><br><span class="line"></span><br><span class="line">x = Lb / L * xc;</span><br><span class="line">y = Lb / L * yc;</span><br><span class="line"></span><br><span class="line">d1 = <span class="built_in">sqrt</span>((x - mx_l1)^<span class="number">2</span> + (y - my_l1)^<span class="number">2</span>);</span><br><span class="line">d2 = <span class="built_in">sqrt</span>((x - mx_l2)^<span class="number">2</span> + (y - my_l2)^<span class="number">2</span>);</span><br><span class="line">d3 = <span class="built_in">sqrt</span>((x - mx_l3)^<span class="number">2</span> + (y - my_l3)^<span class="number">2</span>);</span><br><span class="line">d4 = <span class="built_in">sqrt</span>((x - mx_l4)^<span class="number">2</span> + (y - my_l4)^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Il = (Il1 + ml1 *d1^<span class="number">2</span>) + (Il2 + ml2 * d2^<span class="number">2</span>) + (Il3 + ml3 * d3^<span class="number">2</span>) + (Il4 + ml4 * d4^<span class="number">2</span>);<span class="comment">%平行轴定理</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>代码介绍</strong></p><p>最上面一部分是对腿部质心，转动惯量等与腿长关系所拟合出的直线（一元一次方程），后面的 K 的拟合是利用 matlab 工具集 Curve Fitting Box 来做的。但是这个好像不能引用矩阵里面的某一块，只能直接引用一整个矩阵，所以才有了后面的一大段冗长的代码。</p><ol><li><p>在 <strong>主页-附加功能</strong> 搜索这个工具集并且下载，然后在 <strong>APP</strong> 这个界面就会有这个曲线拟合器</p><p> <img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709468855166.png" alt="1709468855166.png"></p></li><li><p>加载数据，并且选择对应的数据，这里的话，如果只有两个变量，y 是因变量，而三个变量的话 z 就是因变量，x 和 y 就是自变量，权重不需选择</p><p> <img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709469021142.png" alt="1709469021142.png"></p></li><li><p>选择自定义方程，最后拟合得到的参数就是函数的系数（右下角）</p><p> <img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1709472773921.png" alt="1709472773921.png"></p></li></ol><p>有一点不太好的是，一次只能拟合一个 K 的系数，但是还是挺简单的，而且很直观。</p><p>最后将这些数据写入代码中就可以了，需要注意的是 $u=-Kx$</p><h1 id="控制器小结"><a href="#控制器小结" class="headerlink" title="控制器小结"></a>控制器小结</h1><h2 id="半身控制器"><a href="#半身控制器" class="headerlink" title="半身控制器"></a>半身控制器</h2><p>比较简单，参数也比较少，但是需要将机体两半部分联动起来，必须要写 PID 来实现对机体整体的控制。需要额外的 PID</p><ul><li>腿部控制腿长 PID：输入当前腿长，目标腿长。输出为虚拟力。注意需要加一个前馈力，用以补偿重力和侧向惯性力矩</li><li>两腿夹角 PID：由于在 LQR的实际使用中，对于腿部的参数是直接使用两腿的均值，所以就会导致劈腿。所以这里需要一个防止劈腿的 PID，输入就是两腿之间的夹脚，目标为 0 ，输出就是 Tb 的增益，注意方向。</li><li>转向 PID：对于上述所得到的 LQR 控制器，发现并没有关于转向的 PID，所以需要自己写一个，输入就是当前转角，目标为目标角度，输出就是 Tw 的增益。注意方向</li><li>翻滚角 PID：用于控制机体的翻滚角，输入系统当前翻滚角，目标翻滚角，输出就是虚拟力 F 的增益。注意方向</li></ul><h2 id="全身控制器"><a href="#全身控制器" class="headerlink" title="全身控制器"></a>全身控制器</h2><p>比较复杂，系统状态空间方程会很难解算，只能说自己解了好久（2天，对应上面的半身控制器只用了一个小时），参数巨多，最终拟合出来的 K 的函数至少有 240 个参数，我只能说太魔鬼了。但是实际控制效果还是很不错的，需要的额外 PID 并不是很多，其实也不少</p><ul><li>腿部控制腿长 PID：输入当前腿长，目标腿长。输出为虚拟力。注意需要加一个前馈力，用以补偿重力和侧向惯性力矩</li><li>翻滚角 PID：用于控制机体的翻滚角，输入系统当前翻滚角，目标翻滚角，输出就是虚拟力 F 的增益。注意方向</li><li>两腿夹角 PID：由于在 LQR的实际使用中，对于腿部的参数是直接使用两腿的均值，所以就会导致劈腿。所以这里需要一个防止劈腿的 PID，输入就是两腿之间的夹脚，目标为 0 ，输出就是 Tb 的增益，注意方向。</li></ul><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>全身控制器相比半身控制器会更复杂，但是对系统的控制效果说实话还是很不错的，感觉控制的很细腻（不知道是不是好不容易解出来之后对自己的安慰）。可以都试试。</p><p>对于 ADRC 和 Hinfinty 控制器，并不是很好用，ADRC 来说，需要调试的参数太多，而且系统耦合性太强了，很不好调，而且也很复杂，主要是编程要写的太多了（doge）。Hinfinty 来说，也不需要调节参数，实际上只有一个 $\gamma$ 需要调节，但是最终的效果不尽人意啊，抖动太大，而且对于干扰的抗性并不是很好（也许是自己做的问题）。</p><p>但是不管怎么说，LQR 还算是一个不错的控制器的</p><p>在仿真中测试，WBC 是比单边控制要有更高的上限，并且对机体的控制确实更好。但是也需要控制腿部夹角</p><h1 id="五连杆正运动学解算"><a href="#五连杆正运动学解算" class="headerlink" title="五连杆正运动学解算"></a>五连杆正运动学解算</h1><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1710491620264.png" alt="1710491620264.png"></p><p>以杆 $L_5$ 的中心为原点，可以得到</p><script type="math/tex; mode=display">A=(-\frac{L_5}{2}, 0)\\\\B=(-\frac{L_5}{2}+L_1\cos\varphi_1,L_1\sin\varphi_1)\\\\D=(\frac{L_5}{2}+L_4\cos\varphi_4,L_4\sin\varphi_4)\\\\E=(\frac{L_5}{2},0)</script><p>通过五连杆左右两部分列写 C 点坐标，可以得到下列等式</p><script type="math/tex; mode=display">\left\{\begin{aligned}&x_B+L_2\cos\varphi_2=x_D+L_3\cos\varphi_3\\&y_B+L_2\sin\varphi_2=y_D+L_3\sin\varphi_3\end{aligned}\right.</script><p>求解得到</p><script type="math/tex; mode=display">\varphi_2=2\arctan(\frac{B+\sqrt{A^2+B^2-C^2}}{A+C})\\\\\varphi_3=\pi-2\arctan(\frac{-B+\sqrt{A^2+B^2-D^2}}{A+D})</script><p>其中</p><script type="math/tex; mode=display">A=2L_2(x_D-x_B)\\\\B=2L_2(y_D-y_B)\\\\C=L_2^2+L_{BD}^2-L_3^2\\\\D=L_3^2+L_{BD}^2-L_2^2\\\\L_{BD}=\sqrt{(x_D-x_B)^2+(y_D-y_B)^2}</script><p>可以得到 C 点坐标</p><script type="math/tex; mode=display">x_C=-\frac{L_5}{2}+L_1\cos(\varphi_1)+L_2\cos(\varphi_2)\\\\y_C=L_1\sin(\varphi_1)+L_2\sin(\varphi_2)</script><p>则</p><script type="math/tex; mode=display">L_0=\sqrt{x_c^2+y_c^2}\\\\\varphi_0=\arctan{\frac{y_c}{x_c}}</script><h1 id="VMC"><a href="#VMC" class="headerlink" title="VMC"></a>VMC</h1><p>关键是在每个需要控制的自由度上构造合适的虚拟构件来产生合适的虚拟力。虚拟力不是实际执行机构的作用力或力矩，而是通过执行机构的作用经过机构转换而成。对于一些控制问题，我们可能需要将工作空间 (Task Space) 的力或力矩映射成关节空间 (Joint Space) 的关节力矩。</p><p>在五连杆中，需要获得机构末端沿腿的推力 $F$ 与沿中心轴的力矩 $T_b$，对应极坐标 $L_0,\varphi_0$ 与 $A,E$ 两个关节转动副力矩 $T_A,T_E$ 的关系。所以定义</p><script type="math/tex; mode=display">x=\begin{bmatrix}L_0\\\varphi_0\end{bmatrix}\\\\q=\begin{bmatrix}\varphi_1\\\varphi_4\end{bmatrix}</script><p>对正运动学模型 $x=f(q)$ 做微分得</p><script type="math/tex; mode=display">f'=\begin{bmatrix}\frac{\partial L_0}{\partial \varphi_1}&\frac{\partial L_0}{\partial \varphi_4}\\\frac{\partial \varphi_0}{\partial \varphi_1}&\frac{\partial \varphi_0}{\partial \varphi_4}\end{bmatrix}</script><p>这就是 x 对 q 的雅各比矩阵，记作 $J$。得到对应的全微分方程为</p><script type="math/tex; mode=display">\Delta x=J\Delta q</script><p>通过雅各比矩阵 $J$ 将关节速度 $\dot{q}$ 映射为五连杆姿态变化率 $\dot{x}$。根据虚功原理，可以得到</p><script type="math/tex; mode=display">T^T\Delta q+(-F)^T\Delta x=0\\\\\Downarrow\\\\T=\begin{bmatrix}T_A\\T_E\end{bmatrix}\\F_{pole}=\begin{bmatrix}F\\T_b\end{bmatrix}</script><p>将全微分方程带入之后可得</p><script type="math/tex; mode=display">T=J^TF_{pole}</script><p>但是上述推导中的正运动学模型直接求雅各比矩阵比较困难，因为模型中有大量的平方与三角函数的运算，结果比较复杂。所以进行下列改进</p><p>由于雅各比矩阵实际上描述的是两坐标微分的线性映射关系，所以可以计算速度映射来得到雅各比矩阵。由于 $L_0,\varphi_0$ 实际上就是 $C$ 点的极坐标，所以首先求出 $C$ 点直角坐标速度</p><script type="math/tex; mode=display">\dot{x}_C=-L_1\dot{\varphi}_1\sin\varphi_1-L_2\dot{\varphi}_2\sin\varphi_2\\\\\dot{y}_C=L_1\dot{\varphi}_1\cos\varphi_1+L_2\dot{\varphi}_2\cos\varphi_2</script><p>通过五连杆左右两部分列写 C 点坐标求导可以得到 $\dot\varphi_2$</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\dot x_B-L_2\dot\varphi_2\sin\varphi_2=\dot x_D-L_3\dot\varphi_3\sin\varphi_3\\&y_B+L_2\sin\varphi_2=y_D+L_3\sin\varphi_3\end{aligned}\right.</script><p>消去 $\dot\varphi_3$ 得到 $\dot\varphi_2$</p><script type="math/tex; mode=display">\dot\varphi_2=\frac{(\dot x_D-\dot x_B)\cos\varphi_3+(\dot y_D-\dot y_B)\sin\varphi_3}{L_2\sin(\varphi_3-\varphi_2)}</script><p>其中</p><script type="math/tex; mode=display">\dot x_B=-L_2\dot\varphi_1\sin\varphi_1\\\\\dot y_B=L_2\dot\varphi_1\cos\varphi_1\\\\\dot x_D=-L_4\dot\varphi_4\sin\varphi_4\\\\\dot y_D=L_4\dot\varphi_4\sin\varphi_4</script><p>并且其中的 $\dot\varphi_1,\dot\varphi_4$ 都是直接测出来的，带入之后得到</p><script type="math/tex; mode=display">\dot{x}_C=-L_1\dot{\varphi}_1\sin\varphi_1-L_2\frac{(\dot x_D-\dot x_B)\cos\varphi_3+(\dot y_D-\dot y_B)\sin\varphi_3}{L_2\sin(\varphi_3-\varphi_2)}\sin\varphi_2\\\\\dot{y}_C=L_1\dot{\varphi}_1\cos\varphi_1+L_2\frac{(\dot x_D-\dot x_B)\cos\varphi_3+(\dot y_D-\dot y_B)\sin\varphi_3}{L_2\sin(\varphi_3-\varphi_2)}\cos\varphi_2</script><p>化简之后得到</p><script type="math/tex; mode=display">\begin{bmatrix}\dot x_C\\\dot y_C\end{bmatrix}=\begin{bmatrix}\frac{L_1\sin(\varphi_1-\varphi_2)\sin\varphi_3}{\sin(\varphi_2-\varphi_3)}&\frac{L_4\sin(\varphi_3-\varphi_4)\sin\varphi_2}{\sin(\varphi_2-\varphi_3)}\\-\frac{L_1\sin(\varphi_1-\varphi_2)\cos\varphi_3}{\sin(\varphi_2-\varphi_3)}&-\frac{L_4\sin(\varphi_3-\varphi_4)\cos\varphi_2}{\sin(\varphi_2-\varphi_3)}\end{bmatrix}\begin{bmatrix}\dot \varphi_1\\\dot \varphi_4\end{bmatrix}</script><p>记作</p><script type="math/tex; mode=display">\begin{bmatrix}\dot x_C\\\dot y_C\end{bmatrix}=J\begin{bmatrix}\dot \varphi_1\\\dot \varphi_4\end{bmatrix}</script><p>根据上式可以得到关节力矩 $T$ 与虚拟力 $F_{rect}$ 的关系</p><script type="math/tex; mode=display">T=J^TF_{rect}\\F_{rect}=\begin{bmatrix}F_x\\F_y\end{bmatrix}</script><p>利用旋转矩阵将 $F_{rect}$ 旋转到杆的方向，旋转矩阵记作 $R$</p><script type="math/tex; mode=display">\begin{bmatrix}F_x\\F_y\end{bmatrix}=\begin{bmatrix}\cos\theta&\sin\theta\\-\sin\theta&\cos\theta\end{bmatrix}\begin{bmatrix}F_c\\F_t\end{bmatrix}</script><p>将杆的方向里转到极坐标方向的力 $F_{pole}$，旋转矩阵记作 $M$</p><script type="math/tex; mode=display">\begin{bmatrix}F_c\\F_t\end{bmatrix}=\begin{bmatrix}0&\frac{1}{L_0}\\1&0\end{bmatrix}\begin{bmatrix}F\\T_b\end{bmatrix}</script><p>依次带入得到最终的关节力矩与虚拟力之间的映射关系</p><script type="math/tex; mode=display">T=J^TRMF_{pole}</script><p>令</p><script type="math/tex; mode=display">A=\frac{L_1\sin(\varphi_1-\varphi_2)}{\sin(\varphi_2-\varphi_3)}\\B=\frac{L_4\sin(\varphi_3-\varphi_4)}{\sin(\varphi_2-\varphi_3)}</script><p>最终带入得到</p><script type="math/tex; mode=display">T=\begin{bmatrix}-A\cos(\theta+\varphi_3)&\frac{A\sin(\theta+\varphi_3)}{L_0}\\-B\cos(\theta+\varphi_2)&\frac{B\sin(\theta+\varphi_2)}{L_0}\end{bmatrix}F_{pole}</script><p>但是在这里解算中的 $\varphi_0,\varphi_1,\varphi_2,\varphi_3, \varphi_4$ 都是逆时针为正的，所以最终得到的 $T$ 也是逆时针的，要施加到电机上需要取负值，因此最终结果为</p><script type="math/tex; mode=display">T=\begin{bmatrix}A\cos(\theta+\varphi_3)&-\frac{A\sin(\theta+\varphi_3)}{L_0}\\B\cos(\theta+\varphi_2)&-\frac{B\sin(\theta+\varphi_2)}{L_0}\end{bmatrix}F_{pole}</script><p>注意，这里的·解算中，对于每个关节电机转矩的方向是顺时针为正，其他都是按照图上的方向的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">2</span>, <span class="number">2</span>&gt; trans;</span><br><span class="line"><span class="type">float</span>                      A = l1 * <span class="built_in">sin</span>(angle1 - angle2) / <span class="built_in">sin</span>(angle2 - angle3);</span><br><span class="line"><span class="type">float</span>                      B = l4 * <span class="built_in">sin</span>(angle3 - angle4) / <span class="built_in">sin</span>(angle2 - angle3);</span><br><span class="line">trans &lt;&lt; -A * <span class="title function_">cos</span><span class="params">(theta.now + angle3)</span>, </span><br><span class="line">    A * <span class="title function_">sin</span><span class="params">(theta.now + angle3)</span> / L0.now, </span><br><span class="line">         -B * <span class="title function_">cos</span><span class="params">(theta.now + angle2)</span>, </span><br><span class="line">         B * <span class="title function_">sin</span><span class="params">(theta.now + angle2)</span> / L0.now;</span><br><span class="line"></span><br><span class="line">this-&gt;jointF-&gt;setTorque(-trans(<span class="number">0</span>, <span class="number">0</span>) * this-&gt;Fset - trans(<span class="number">0</span>, <span class="number">1</span>) * this-&gt;Tbset);</span><br><span class="line">this-&gt;jointB-&gt;setTorque(-trans(<span class="number">1</span>, <span class="number">0</span>) * this-&gt;Fset - trans(<span class="number">1</span>, <span class="number">1</span>) * this-&gt;Tbset);</span><br><span class="line">this-&gt;wheel-&gt;setTorque(this-&gt;Twset);</span><br></pre></td></tr></table></figure><h1 id="腿长控制"><a href="#腿长控制" class="headerlink" title="腿长控制"></a>腿长控制</h1><p>腿长控制是直接使用 PID 进行控制，但是一定要将控制腿长的 PID 调节的软一点，P 要小一点，D 要尽量小，I 尽量不给。</p><p>腿长 PID 较大会造成很大的影响，PID 过大导致系统的控制腿长的输出太大，相对应的控制整个系统的平衡的输出就很小，从而导致系统稳定性不够</p><p>例如：电机的输出的力矩是有限的，当把 LQR + VMC 解算出来的力矩同腿长控制 PID 的输出相结合之后，就会比较大，那么进行力矩限制时，会导致限制之后的力矩不能保证机体平衡或者腿长的控制，最终控制效果不好</p><h1 id="离地检测"><a href="#离地检测" class="headerlink" title="离地检测"></a>离地检测</h1><p><img src="/Blog_ButterFly/2024/03/18/%E5%8F%8C%E8%BD%AE%E8%B6%B3%E5%BC%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/1710325439567.png" alt="1710325439567.png"></p><p>根据图中可以得到</p><script type="math/tex; mode=display">m_w\ddot{z}_w=F_N-F\cos\theta+\frac{T_b\sin\theta}{L_0}</script><p>其中</p><script type="math/tex; mode=display">z_w=z_b-L_0\cos\theta\\\\\Downarrow\\\\\ddot{z}_w=\ddot{z}_b-\ddot{L}_0\cos\theta+2\dot{L}_0\dot{\theta}\sin\theta+L_0\ddot{\theta}\sin\theta+L_0\dot{\theta}^2\cos\theta</script><p>并且其中的 $\ddot{z}_b$ 是机体重力加速度，可以通过机体上的传感器测得，但是需要结合机体姿态并且消去重力加速度得到</p><script type="math/tex; mode=display">\ddot{z}_b=(a_z\cos\varphi+a_x\sin\varphi)\cos{\gamma}+a_y\sin\gamma</script><p>并且 $F$ 与 $T_b$ 都是根据关节电机反解出来的</p><script type="math/tex; mode=display">(J^TRM)^{-1}T=F_{pole}</script><p>得到</p><script type="math/tex; mode=display">F_N=m_w(\ddot{z}_b-\ddot{L}_0\cos\theta+2\dot{L}_0\dot{\theta}\sin\theta+L_0\ddot{\theta}\sin\theta+L_0\dot{\theta}^2\cos\theta)+F\cos\theta-\frac{T_b\sin\theta}{L_0}</script><p>可以判断，当 $F_N$ 小于某个阈值，就认为地面给的摩擦力不足以支持机体平衡，也就是处于腾空状态，此时，就只保持腿部姿态角即可，也就是除了 $\theta,\dot\theta$ 之外的数据的系数均为 0 即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> A = l1 * <span class="built_in">sin</span>(angle1 - angle2) / <span class="built_in">sin</span>(angle2 - angle3);</span><br><span class="line"><span class="type">float</span> B = l4 * <span class="built_in">sin</span>(angle3 - angle4) / <span class="built_in">sin</span>(angle2 - angle3);</span><br><span class="line">A       = A * <span class="built_in">cos</span>(angle2 + theta.now) * <span class="built_in">sin</span>(angle3 + theta.now) - A * <span class="built_in">cos</span>(angle3 + theta.now) * <span class="built_in">sin</span>(angle2 + theta.now);</span><br><span class="line">B       = B * <span class="built_in">cos</span>(angle2 + theta.now) * <span class="built_in">sin</span>(angle3 + theta.now) - B * <span class="built_in">cos</span>(angle3 + theta.now) * <span class="built_in">sin</span>(angle2 + theta.now);</span><br><span class="line"></span><br><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">2</span>, <span class="number">2</span>&gt; trans;</span><br><span class="line">trans &lt;&lt; <span class="built_in">sin</span>(angle2 + theta.now) / A, -<span class="built_in">sin</span>(angle3 + theta.now) / B, L0.now * <span class="title function_">cos</span><span class="params">(angle2 + theta.now)</span> / B, -L0.now * <span class="title function_">cos</span><span class="params">(angle3 + theta.now)</span> / B;</span><br><span class="line"></span><br><span class="line">Fnow  = -trans(<span class="number">0</span>, <span class="number">0</span>) * jointF-&gt;torqueRead - trans(<span class="number">0</span>, <span class="number">1</span>) * jointB-&gt;torqueRead;</span><br><span class="line">Tbnow = -trans(<span class="number">1</span>, <span class="number">0</span>) * jointF-&gt;torqueRead - trans(<span class="number">1</span>, <span class="number">1</span>) * jointB-&gt;torqueRead;</span><br></pre></td></tr></table></figure><p>最终得到</p><script type="math/tex; mode=display">F_N = \frac{F_{l,now} + F_{r,now}}{2}</script><h1 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h1><p>有些轮腿的控制中，是直接给一个比较大的力矩来使得机体跳跃，但是这样的话感觉并不是很好。所以有另一种方法：通过设定腿部杆长伸腿和蹬腿来实现跳跃</p><p>具体的腿部运动流程就是：收腿 <script type="math/tex">\rightarrow</script> 蹬腿 <script type="math/tex">\rightarrow</script></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(jump_process) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">        leg_len_l_set = min_leg_len;</span><br><span class="line">        leg_len_r_set = min_leg_len;</span><br><span class="line">        <span class="keyword">if</span>(fabsf(leg_len_l_set - min_leg_len) &lt; <span class="number">0.01f</span> &amp;&amp; fabsf(leg_len_r_set - min_leg_len) &lt; <span class="number">0.01f</span>)</span><br><span class="line">            ++jump_process;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        leg_len_l_set = max_leg_len;</span><br><span class="line">        leg_len_r_set = max_leg_len;</span><br><span class="line">        <span class="keyword">if</span>(fabsf(leg_len_l_set - max_leg_len) &lt; <span class="number">0.01f</span> &amp;&amp; fabsf(leg_len_r_set - max_leg_len) &lt; <span class="number">0.01f</span>)</span><br><span class="line">            ++jump_process;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        leg_len_l_set = min_leg_len;</span><br><span class="line">        leg_len_r_set = min_leg_len;</span><br><span class="line">        <span class="keyword">if</span>(fabsf(leg_len_l_set - min_leg_len) &lt; <span class="number">0.01f</span> &amp;&amp; fabsf(leg_len_r_set - min_leg_len) &lt; <span class="number">0.01f</span>)</span><br><span class="line">            ++jump_process;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        leg_len_l_set = buffer_leg_len;</span><br><span class="line">        leg_len_r_set = buffer_leg_len;</span><br><span class="line">        <span class="keyword">if</span>(fabsf(leg_len_l_set - buffer_leg_len) &lt; <span class="number">0.01f</span> &amp;&amp; fabsf(leg_len_r_set - buffer_leg_len) &lt; <span class="number">0.01f</span>)</span><br><span class="line">            ++jump_process;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// nothing</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转角控制"><a href="#转角控制" class="headerlink" title="转角控制"></a>转角控制</h1><p>转角可以直接利用 PID 进行控制，可以实现比较准确的控制，但是一般来说，这个 PID 的参数应当是一个 PD 控制器，这会保证系统不会因为卡住而出现大电流</p><h1 id="横滚角控制"><a href="#横滚角控制" class="headerlink" title="横滚角控制"></a>横滚角控制</h1><p>直接根据当前的横滚角，计算当机体保持平衡的时候两条腿的长度之差，然后叠加在当前腿长上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> leg_dif = <span class="built_in">sin</span>(roll) * l_body;</span><br><span class="line">leg_len_l_set -= leg_dir / <span class="number">2</span>;</span><br><span class="line">leg_len_r_set += leg_dir / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>整个控制系统是断断续续的研究了很久才能实现，这个机器人的控制确实很难，对于菜鸟的我来说确实很痛苦，但是研究出来之后会发现，原来当时困扰自己的东西只是一些小问题</p><p>实际上是做了两代轮腿，第一代死于经验不足，调试了差不多一个月然后被去安排做其他事情了。然后第二代轮腿实际上只在 4 天就成功了（喜极而泣），其实就是因为对其原理的理解不够清晰（一直觉得是机械结构设计不好，其实应该是我的问题）</p><p>再者即使调不出来也别放弃，重新整理一下思路，总会发现不一样的东西的</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LQR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPC模型预测控制</title>
      <link href="/Blog_ButterFly/2024/03/18/MPC%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/Blog_ButterFly/2024/03/18/MPC%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Luo25177/modelControl">github仓库</a></p><h3 id="最优化控制"><a href="#最优化控制" class="headerlink" title="最优化控制"></a>最优化控制</h3><p><strong>研究动机</strong></p><p>在一定的约束条件下达到最优的系统表现，最优是综合分析的最优</p><p><strong>代价函数与评判标准</strong></p><ul><li><p>对于单输入单输出系统控制，e(t)为误差， u(t)为输入</p><p>  当 $\int_0^te^2dt$ 最小时，就可以保证系统的追踪性很好</p><p>  当 $\int_1^tu^2dt$ 最小时，可以保证系统的输入最小，能耗最低</p><p>  控制过程的代价函数 </p><script type="math/tex; mode=display">  J = \int_1^t(qe^2+ru^2)dt</script><p>  目的就是设计一个u使J达到最小值</p><p>  q和r就是我们可以调节的参数，如果 $q&gt;&gt;r$ 那么就是设计过程更加注重误差，如果 $r&gt;&gt;q$的话，就是设计过程更加注重能耗最低</p></li><li><p>对于多输入多输出的系统控制中</p><p>  $\frac{dx}{dt} = Ax +Bu$     x是系统的状态变量</p><p>  $Y=Cx$       Y就是系统的输出</p><p>  代价方程就是</p><script type="math/tex; mode=display">  J = \int_0^t(E^TQE + u^TRu)dt</script><p>  一个栗子：</p><p>  $\begin{bmatrix} y_1 \\ y_2\\ \end{bmatrix} = \begin{bmatrix} x_1 \\ x_2 \\ \end{bmatrix}$</p><p>  $R = \begin{bmatrix}r_1\\r_2\\ \end{bmatrix} = \begin{bmatrix}0\\0\\ \end{bmatrix}$</p><p>  $⇒E = \begin{bmatrix}e_1\\e_2\\\end{bmatrix} = \begin{bmatrix}y_1-r_1\\y_2-r_2\\\end{bmatrix} = \begin{bmatrix}x_1\\x_2\\\end{bmatrix}$</p><p>  $⇒E^TQE=\begin{bmatrix}x_1&amp;x_2\\\end{bmatrix}\begin{bmatrix}q_1&amp;0\\0&amp;q_2\\\end{bmatrix}\begin{bmatrix}x_1\\x_2\\\end{bmatrix} = q_1x_1^2+q_2x_2^2$</p><p>  $⇒u^TRu = r_1u_1^2+r_2u_2^2$</p><p>  Q和R都是调节矩阵， $q_1,q_2,r_1,r_2$都是权重系数，如果过多的关注 $x_1$的话，可以适当的将 $q_1,r_1$加大，加重权重系数</p></li></ul><h3 id="MPC"><a href="#MPC" class="headerlink" title="MPC"></a>MPC</h3><p>通过模型来预测系统在某一时间段内的表现来进行最优化控制，多用于数位控制，多采用离散型状态空间的表达形式  $X_{k+1} = AX_k+Bu_k$</p><p><strong>分析步骤</strong></p><p>在当前时刻，即k时刻</p><ol><li>测量/估计当前状态，输出为 $Y_k$</li><li><p>基于 $u_k,u_{k+1},….u_{k+N}$ 来进行最优化， N为预测出空间，N-1为控制范围</p><p> 代价函数 </p><script type="math/tex; mode=display"> X_k=\begin{bmatrix}x(k+1|k)\\x(k+2|k)\\\dots\\x(k+N|k)\end{bmatrix}\\U_k=\begin{bmatrix}u(k|k)\\u(k+1|k)\\\dots\\u(k+N-1|k)\end{bmatrix}\\output:Y=X\\reference:R\\E=Y-R=X-R</script><script type="math/tex; mode=display"> J = ∑_k^{N-1}E_k^TQE_k+U_k^TRU_k+E_N^TFE_N</script><p> 其中 $E_N^TFE_N$ 代表了最终的结果，就是期望值，也就是最末一点，终端误差，预测区间最后时刻的误差的代价函数，目的就是找到 $J$ 的最小值</p><p> 并且 Q 与 R 都是对角矩阵</p></li><li><p>需要找到 $u_k,u_{k+1},….u_{k+N}$ 并非要使用所有的 $u_k$，只实施第一个也就是 $u_k$，当时间到达k+1的时候，就要把窗口，也就是预测区间向右移动，每一步都需要去求解一个最优化问题——滚动优化问题</p></li></ol><p>mpc在预测的过程中会考虑到系统的约束</p><h3 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h3><p><strong>一般形式</strong></p><script type="math/tex; mode=display">min\ Z^TQZ+C^TZ</script><p>当Q为对角矩阵时，这个式子为</p><script type="math/tex; mode=display">\sum_{i=1}^n q_iz_i^2</script><p>就变成了一个最小二乘的形式</p><p>对于一个系统状态方程</p><script type="math/tex; mode=display">x(k+1)=Ax(k)+Bu(k)\\state:x=\begin{bmatrix}x_1\\x_2\\\dots\\x_n\end{bmatrix}\\input:u=\begin{bmatrix}u_1\\u_2\\\dots\\u_n\end{bmatrix}</script><p>利用增广矩阵来表示k时刻的预测的结果</p><script type="math/tex; mode=display">x(k+1|k)~~~u(k|k)\\x(k+2|k)~~~u(k+1|k)\\\dots\\x(k+N|k)~~~u(k+N-1|k)</script><p>其中 N 表示预测的区间</p><p>定义</p><script type="math/tex; mode=display">X_k=\begin{bmatrix}x(k|k)\\x(k+1|k)\\\dots\\x(k+N|k)\end{bmatrix}\\U_k=\begin{bmatrix}u(k|k)\\u(k+1|k)\\\dots\\u(k+N-1|k)\end{bmatrix}\\output:Y=X\\reference:R=0\\E=Y-R=X-0=X</script><p>代价函数为</p><script type="math/tex; mode=display">J_{k\rightarrow k+N}=∑_{i=0}^{N-1} \{x(k+i|k)^TQx(k+i|k)+u(k+i|k)^TRu(k+i|k)\} + x(k+N)^TFx(k+N)</script><p>其中</p><ul><li>$X(k+i|k)^TQX(k+i|k)$ 误差加权和</li><li>$u(k+i|k)^TRu(k+i|k)$ 输入加权和</li><li>$x(k+N)^TFx(k+N)$ 终端误差</li></ul><p>在k时刻时</p><script type="math/tex; mode=display">x(k|k)=x_k~~~该时刻的初始条件\\x(k+1|k)=Ax(k|k)+Bu(k|k)=Ax_k+Bu(k|k)\\x(k+2|k)=Ax(k+1|k)+Bu(k+1|k)=A^2x(k|k)+ABu(k|k)+Bu(k+1|k)\\x(k+N|k)=A^Nx_k+\sum_{i=0}^{N-1}{A^{N-1-i}Bu(k+i|k)}</script><p>根据之前定义简化方程</p><script type="math/tex; mode=display">X_k=\begin{bmatrix}I\\A\\A^2\\\dots\\A^N\end{bmatrix}x_k+\begin{bmatrix}0&0&...&0\\B&0&...&0\\AB&B&...&0\\\dots\\A^{N-1}B&A^{N-2}B&...&B\end{bmatrix}U_k</script><p>可令</p><script type="math/tex; mode=display">M=\begin{bmatrix}I\\A\\A^2\\\dots\\A^N\end{bmatrix}\\C=\begin{bmatrix}0&0&...&0\\B&0&...&0\\AB&B&...&0\\\dots\\A^{N-1}B&A^{N-2}B&...&B\end{bmatrix}</script><p>其中 $M$ 为 $(N+1)\times 1$， $C$ 为 $(N+1)\times N$ 矩阵</p><p>则简化为</p><script type="math/tex; mode=display">X_k=Mx_k+CU_k</script><p>代价函数为</p><script type="math/tex; mode=display">J_{k\rightarrow k+N}=∑_{i=0}^{N-1} \{x(k+i|k)^TQx(k+i|k)+u(k+i|k)^TRu(k+i|k)\} + x(k+N)^TFx(k+N)</script><p>其中第一项与最后一项为</p><script type="math/tex; mode=display">x(k|k)^TQx(k|k)+...+x(k+N-1|k)^TQx(k+N-1|k)+x(k+N|k)^TQx(k+N|k)\\\Rightarrow \begin{bmatrix}x(k|k)\\x(k+1|k)\\\dots\\x(k+N|k)\end{bmatrix}^T\begin{bmatrix}Q&0&...&0\\0&Q&...&0\\\dots\\0&0&...&F\end{bmatrix}\begin{bmatrix}x(k|k)\\x(k+1|k)\\\dots\\x(k+N|k)\end{bmatrix}</script><p>令</p><script type="math/tex; mode=display">\overline{Q}=\begin{bmatrix}Q&0&...&0\\0&Q&...&0\\\dots\\0&0&...&F\end{bmatrix}</script><p>则上式为</p><script type="math/tex; mode=display">X_k^T\overline{Q}X_k</script><p>中间一项为</p><script type="math/tex; mode=display">u(k|k)^TRu(k|k)+...+u(k+N-1|k)^TRu(k+N-1|k)\\\Rightarrow \begin{bmatrix}u(k|k)\\u(k+1|k)\\\dots\\u(k+N-1|k)\end{bmatrix}^T\begin{bmatrix}R&0&...&0\\0&R&...&0\\\dots\\0&0&...&R\end{bmatrix}\begin{bmatrix}u(k|k)\\u(k+1|k)\\\dots\\u(k+N-1|k)\end{bmatrix}</script><p>令</p><script type="math/tex; mode=display">\overline{R}=\begin{bmatrix}R&0&...&0\\0&R&...&0\\\dots\\0&0&...&R\end{bmatrix}</script><p>上式化简为</p><script type="math/tex; mode=display">U_k^T\overline{R}U_k</script><p>故而代价函数为</p><script type="math/tex; mode=display">J_{k\rightarrow k+N}=X_k^T\overline{Q}X_k+U_k^T\overline{R}U_k</script><p>由于</p><script type="math/tex; mode=display">X_k=Mx_k+CU_k</script><p>则</p><script type="math/tex; mode=display">J_{k\rightarrow k+N}=(Mx_k+CU_k)^T\overline{Q}(Mx_k+CU_k)+U_k^T\overline{R}U_k</script><p>分开之后为</p><script type="math/tex; mode=display">J_{k\rightarrow k+N}=x_k^TM^T\overline{Q}Mx_k+x_k^TM^T\overline{Q}CU_k+U_k^TC^T\overline{Q}Mx_k+U_k^TC^T\overline{Q}CU_k+U_k^T\overline{R}U_k</script><p>对于第2项和第3项，它们互为转置，并且 $\overline{Q}$ 是对称的，所以可以简化合并为</p><script type="math/tex; mode=display">2x_k^TM^T\overline{Q}CU_k</script><p>对于第4项和第5项，也可以化简为</p><script type="math/tex; mode=display">U_k^T(C^T\overline{Q}C+\overline{R})U_k</script><p>可令</p><script type="math/tex; mode=display">G=M^T\overline{Q}M\\E=M^T\overline{Q}C\\H=C^T\overline{Q}C+\overline{R}</script><p>最终，代价函数写作</p><script type="math/tex; mode=display">J_{k\rightarrow k+N}=x_k^TGx_k+2x_k^TEU_k+U_k^THU_k</script><p>求解最优解，先求导数为0处，即</p><script type="math/tex; mode=display">\frac{\partial J}{\partial U_k}=0</script><script type="math/tex; mode=display">first~part:0\\second~part:2E^Tx_k\\second~part:(H+H^T)U_k</script><p>即</p><script type="math/tex; mode=display">\frac{\partial J_{k\rightarrow k+N}}{\partial U_k}=2E^Tx_k+(H+H^T)U_k=0</script><p>求得</p><script type="math/tex; mode=display">U_k=-2(H+H^T)^{-1}E^Tx_k</script><p>验证是否为极小值</p><script type="math/tex; mode=display">\frac{\partial^2 J_{k\rightarrow k+N}}{\partial U_k^2}=(H+H^T)^T=H^T+H</script><p>由于H中的 $\overline{Q}$, $C$, $\overline{R}$ 都为正定阵，所以结果一定是正定的，故得证</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 这是一个通用的 MPC 模型预测算法的代码</span></span><br><span class="line">clear;</span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%系统矩阵</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">0.1</span>; <span class="number">0</span> <span class="number">2</span>];</span><br><span class="line">n = <span class="built_in">size</span>(A, <span class="number">1</span>);</span><br><span class="line">B = [<span class="number">0.2</span> <span class="number">1</span>; <span class="number">0.5</span> <span class="number">2</span>]; <span class="comment">% 大小取决于输入量的数目</span></span><br><span class="line">p = <span class="built_in">size</span>(B, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%% 权重矩阵</span></span><br><span class="line">Q = [<span class="number">100</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">F = [<span class="number">100</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">R = [<span class="number">1</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0.1</span>]; <span class="comment">% 大小取决于输入量</span></span><br><span class="line">k_step = <span class="number">100</span>; <span class="comment">% 走100步</span></span><br><span class="line"></span><br><span class="line">x_k = <span class="built_in">zeros</span>(n, k_step);</span><br><span class="line">x_k(:, <span class="number">1</span>) = [<span class="number">20</span>; <span class="number">-20</span>];</span><br><span class="line">u_k = <span class="built_in">zeros</span>(p, k_step);</span><br><span class="line"></span><br><span class="line">N = <span class="number">5</span>; <span class="comment">% 预测区间</span></span><br><span class="line">[E, H] = MPC_Matrices(A, B,Q, R, F, N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>: k_step</span><br><span class="line">    u_k(:, k) = Prediction(x_k(:, k), E, H, N, p);</span><br><span class="line">    x_k(:, k+<span class="number">1</span>) = (A * x_k(:, k) + B * u_k(:, k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(x_k, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(x_k(<span class="number">1</span>, :));</span><br><span class="line">    <span class="built_in">plot</span>(x_k(<span class="number">2</span>, :));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>, <span class="string">&quot;x2&quot;</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(x_k, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(u_k(<span class="number">1</span>, :));    </span><br><span class="line">    <span class="built_in">plot</span>(u_k(<span class="number">2</span>, :));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u2&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="params">[E , H]</span>=<span class="title">MPC_Matrices</span><span class="params">(A,B,Q,R,F,N)</span></span></span><br><span class="line">    n=<span class="built_in">size</span>(A,<span class="number">1</span>);   <span class="comment">% A 是 n x n 矩阵, 得到 n</span></span><br><span class="line">    p=<span class="built_in">size</span>(B,<span class="number">2</span>);   <span class="comment">% B 是 n x p 矩阵, 得到 p</span></span><br><span class="line">    <span class="comment">%%%%%%%%%%%%</span></span><br><span class="line">    M=[<span class="built_in">eye</span>(n);<span class="built_in">zeros</span>(N*n,n)]; <span class="comment">% 初始化 M 矩阵. M 矩阵是 (N+1)n x n的， </span></span><br><span class="line">                             <span class="comment">% 它上面是 n x n 个 &quot;I&quot;, 这一步先把下半部</span></span><br><span class="line">                             <span class="comment">% 分写成 0 </span></span><br><span class="line">    C=<span class="built_in">zeros</span>((N+<span class="number">1</span>)*n,N*p); <span class="comment">% 初始化 C 矩阵, 这一步令它有 (N+1)n x NP 个 0</span></span><br><span class="line">    <span class="comment">% 定义M 和 C </span></span><br><span class="line">    tmp=<span class="built_in">eye</span>(n);  <span class="comment">%定义一个n x n 的 I 矩阵</span></span><br><span class="line">    <span class="comment">%　更新Ｍ和C</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N <span class="comment">% 循环，i 从 1到 N</span></span><br><span class="line">        rows =<span class="built_in">i</span>*n+(<span class="number">1</span>:n); <span class="comment">%定义当前行数，从i x n开始，共n行 </span></span><br><span class="line">        C(rows,:)=[tmp*B,C(rows-n, <span class="number">1</span>:<span class="keyword">end</span>-p)]; <span class="comment">%将c矩阵填满</span></span><br><span class="line">        tmp= A*tmp; <span class="comment">%每一次将tmp左乘一次A</span></span><br><span class="line">        M(rows,:)=tmp; <span class="comment">%将M矩阵写满</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 定义Q_bar和R_bar</span></span><br><span class="line">    Q_bar = kron(<span class="built_in">eye</span>(N),Q);</span><br><span class="line">    Q_bar = <span class="built_in">blkdiag</span>(Q_bar,F);</span><br><span class="line">    R_bar = kron(<span class="built_in">eye</span>(N),R);</span><br><span class="line">    <span class="comment">% 计算G, E, H</span></span><br><span class="line">    G=M&#x27;*Q_bar*M; <span class="comment">% G: n x n</span></span><br><span class="line">    E=C&#x27;*Q_bar*M; <span class="comment">% E: NP x n</span></span><br><span class="line">    H=C&#x27;*Q_bar*C+R_bar; <span class="comment">% NP x NP</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u_k</span>= <span class="title">Prediction</span><span class="params">(x_k,E,H,N,p)</span></span></span><br><span class="line">    U_k = <span class="built_in">zeros</span>(N*p,<span class="number">1</span>); <span class="comment">% NP x 1</span></span><br><span class="line">    U_k = quadprog(H,E*x_k); <span class="comment">% MPC预测控制函数</span></span><br><span class="line">    u_k = U_k(<span class="number">1</span>:p,<span class="number">1</span>); <span class="comment">% 取第一个结果</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
